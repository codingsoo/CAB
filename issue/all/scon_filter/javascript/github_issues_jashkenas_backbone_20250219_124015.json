[
  {
    "number": 3557,
    "title": "Router.execute doesn't return anything",
    "created_at": "2015-04-04T17:49:38Z",
    "closed_at": "2015-04-05T16:36:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/3557",
    "body": "If the route callback returns false, a route event is not supposed to be fired. i.e.\n`if (router.execute(callback, args, name) !== false) {//trigger 'route' event...}`\n\nHowever, execute() doesn't actually return the callback functions return value:\n`if (callback) callback.apply(this, args);`\n\nShouldn't this be:\n`if (callback) return callback.apply(this, args);`\n\nIs this by design, or am I missing something?\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/3557/comments",
    "author": "emersonyu",
    "comments": [
      {
        "user": "akre54",
        "created_at": "2015-04-05T16:36:40Z",
        "body": "Nope, this is in place so folks can override `execute` in their apps to act as a `beforeAction`-like method (see #3016). We don't want the route handler's return value to affect the transition. \n"
      },
      {
        "user": "emersonyu",
        "created_at": "2015-04-05T17:04:04Z",
        "body": "Thanks, makes sense. Didn't read the comments closely enough :)\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of the design rationale behind Router.execute's return value behavior",
      "Clarification of how Router.execute supports extensibility patterns",
      "Confirmation that the observed behavior is intentional rather than a bug"
    ]
  },
  {
    "number": 3370,
    "title": "Incoherence: different sort behaviour when setting models and collections",
    "created_at": "2014-11-05T13:11:43Z",
    "closed_at": "2014-11-05T19:37:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/3370",
    "body": "Let's assume a collection is sorted by an attribute called `name`. In other words, its `comparator` is `'name'`. \n\n_Model behaviour_: If we take one of the collection's models and `set` the `name` attribute, the collection will not be re-sorted and no `sort` event will be triggered. This is well explained in the documentation.\n\n_Collection behaviour_: Now, if we take the collection as a whole and call `set` on it, passing it the existing model but with a modified `name`, it will indeed re-sort the collection and trigger a `sort` event; refer to the following line:\n\n``` javascript\nif (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;\n```\n\nIs this intended? IMHO, it would be better if either both of them caused a re-sort, or none of them.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/3370/comments",
    "author": "guigrpa",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2014-11-05T19:37:29Z",
        "body": "Yes, this is intended.\n"
      },
      {
        "user": "guigrpa",
        "created_at": "2014-11-06T15:03:00Z",
        "body": "@jashkenas And why, may I ask?\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2014-11-06T16:32:09Z",
        "body": "Because models entering and exiting a collection are supposed to be sorted into their proper place. `Collection.set` adds and removes models from a collection.\n\nHowever, once inside a collection, the collection can't know \u2014 in the general case \u2014 when a model has changed properties that need to be resorted. `comparator` can be an arbitrary function. So if your application is the type where a particular models sort properties _can_ change, then you'll want to tell their collection to re-sort itself at the appropriate time.\n"
      },
      {
        "user": "guigrpa",
        "created_at": "2015-01-26T07:47:59Z",
        "body": "Thanks @jashkenas! It's all clear now\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of the design rationale behind the differing sort behaviors",
      "Clarification of when automatic sorting should vs. shouldn't occur",
      "Guidance on handling comparator-dependent resorting requirements",
      "Differentiation between collection membership changes vs. model property changes"
    ]
  },
  {
    "number": 3230,
    "title": "events selector by name or complex id names",
    "created_at": "2014-07-21T10:36:07Z",
    "closed_at": "2014-07-21T10:41:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/3230",
    "body": "I have an input with this complex name:\n\n``` html\n<input ... name=\"bic_voucher_entitybundle_company[name]\" id=\"bic_voucher_entitybundle_company[name]\" >\n```\n\nThe problem comes when I want to assign this name or id to an event:\n\n``` js\n        events: {\n            'click #bic_voucher_entitybundle_company[name]': 'limitLength',\n            'click [name=\"bic_voucher_entitybundle_company[name]\"]': 'limitLength',\n```\n\nBoth do not work.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/3230/comments",
    "author": "bichotll",
    "comments": [
      {
        "user": "braddunbar",
        "created_at": "2014-07-21T10:41:47Z",
        "body": "Hi @bichotll!  I believe you'll need to escape the inner brackets with slashes.\n\n``` js\nevents: {\n  'click #bic_voucher_entitybundle_company\\\\[name\\\\]': 'limitLength',\n  'click [name=\"bic_voucher_entitybundle_company\\\\[name\\\\]\"]': 'limitLength'\n}\n```\n"
      }
    ],
    "satisfaction_conditions": [
      "Proper handling of special characters in CSS/jQuery selectors",
      "Working event binding using both ID and name attribute selectors",
      "Clear escaping mechanism for complex attribute values"
    ]
  },
  {
    "number": 3166,
    "title": "Backbone's View constructor is adding a call to this.delegateEvents in the min version and the dev version is not",
    "created_at": "2014-05-28T03:34:11Z",
    "closed_at": "2014-05-28T13:43:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/3166",
    "body": "```\nvar View = Backbone.View = function(options) {\n        this.cid = _.uniqueId('view');\n        options || (options = {});\n        _.extend(this, _.pick(options, viewOptions));\n        this._ensureElement();\n        this.initialize.apply(this, arguments);\n};\n\nvar w = e.View = function (t) {\n        this.cid = i.uniqueId(\"view\");\n        t || (t = {});\n        i.extend(this, i.pick(t, E));\n        this._ensureElement();\n        this.initialize.apply(this, arguments);\n        this.delegateEvents()\n};\n```\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/3166/comments",
    "author": "markwise",
    "comments": [
      {
        "user": "tgriesser",
        "created_at": "2014-05-28T03:45:41Z",
        "body": "Yes, this change was added in #3060 in master but is not yet on the current release (and therefore not in the minified version). Are there any  issues you see with this change in behavior?\n"
      },
      {
        "user": "markwise",
        "created_at": "2014-05-28T04:03:56Z",
        "body": "I recently inherited a codebase that is using views as abstract classes.\n\nFor example:\n\n``` js\nvar AbstractView = Backbone.View.extend({\n    initialize: function () {\n        _.extend(self.events || (self.events = {}), {\n            'click .element': 'handler'\n        }\n    }\n});\n\nvar MyView = AbstractView.extend({\n    initialize: function () {\n        AbstractView.prototype.initialize.apply(this);    \n    }\n});\n```\n\nThe AbstractView events get attached with the min version, but not the dev version.\n"
      },
      {
        "user": "akre54",
        "created_at": "2014-05-28T05:03:14Z",
        "body": "Better to set those in an `events` method on the AbstractView:\n\n``` js\nvar AbstractView = Backbone.View.extend({\n    events: function() {\n        return {\n            'click .element': 'handler'\n        };\n    }\n});\n\nvar MyView = AbstractView.extend({\n    events: function() {\n      return _.extend(AbstractView.prototype.events.call(this), {\n        ...\n      });\n    }\n});\n```\n\nLooks even nicer in CoffeeScript:\n\n``` coffeescript\nclass AbstractView extends Backbone.View\n  events: ->\n    'click .element': 'handler'\n\nclass MyView extends AbstractView\n  events: ->\n    _.extend super, \n      'click .otherelement': 'other handler'\n```\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2014-05-28T13:43:17Z",
        "body": "Yep, @akre54's example above is a good strategy.\n"
      },
      {
        "user": "markwise",
        "created_at": "2014-05-28T15:43:41Z",
        "body": "I agree that the above solution is a better way to handle attaching events in an abstract view. However, I think you guys are missing the point here. The dev and min version should be the same and they are not. This begs the question of how many other things are different between the two. This is indeed a bug and can result in different behavior based on my example above despite the suggested work around.\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2014-05-28T15:45:07Z",
        "body": "> The dev and min version should be the same and they are not.\n\nThe minified file is only updated for releases to keep commit noise to a minimum.\n"
      },
      {
        "user": "markwise",
        "created_at": "2014-05-28T16:10:37Z",
        "body": "Can I assume the dev version is correct and this.delegateEvents was removed from the  Backbone.View constructor?\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2014-05-28T16:30:43Z",
        "body": "@markwise That's right.  `#delegateEvents` is already called in `#setElement` so we found it redundant to call it twice.  Sorry about the breakage.\n\nIf you need to call it anyway you can always add it in an override of the constructor while you migrate.\n"
      },
      {
        "user": "markwise",
        "created_at": "2014-05-28T17:14:28Z",
        "body": "Right on, thanks.\n"
      }
    ],
    "satisfaction_conditions": [
      "Clarification of intended behavior between development and minified versions",
      "Explanation of version synchronization strategy",
      "Resolution of unexpected inheritance behavior differences",
      "Confirmation of intentional constructor changes",
      "Guidance on future-proofing view implementations"
    ]
  },
  {
    "number": 3059,
    "title": "listenTo",
    "created_at": "2014-03-13T03:20:54Z",
    "closed_at": "2014-03-13T03:26:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/3059",
    "body": "Could listenTo be applied to window.location.pathname?\n\nI know it can be applied to a model and other objects.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/3059/comments",
    "author": "MarcusSorealheis",
    "comments": [
      {
        "user": "caseywebdev",
        "created_at": "2014-03-13T03:26:56Z",
        "body": "The `Events` object can be extended onto any JavaScript object. It doesn't not do dirty checking for changes as I suspect you're looking for, but merely provide the facilities to trigger and listen for events on that object. It would be up to you to establish your own \"has changed\" event in this case.\n"
      },
      {
        "user": "MarcusSorealheis",
        "created_at": "2014-03-13T04:58:16Z",
        "body": "Thanks for the swift response Casey! I thought it should work but I was running into a few problems earlier. Our error was probably not Backbone related then.\n"
      }
    ],
    "satisfaction_conditions": [
      "Confirmation that `listenTo` can be used with `window.location.pathname` when properly configured",
      "Clarification that manual event triggering is required for pathname changes",
      "Explanation of Backbone's event system extensibility to arbitrary objects"
    ]
  },
  {
    "number": 3050,
    "title": "Control over PUT vs POST for models with supplied IDs",
    "created_at": "2014-03-07T14:51:55Z",
    "closed_at": "2014-03-07T15:37:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/3050",
    "body": "``` javascript\n\nvar UserModel = Backbone.Model.extend({\n    idAttribute: \"username\",\n    urlRoot: \"/userapi\"\n});\n\nvar newUser = new UserModel();\nnewUser.set('username','v0idnull');\nnewUser.save();\n```\n\nI can not create a new user with this code.\n\nBackbone makes the assumption that whatever API you are calling, the unique identifier for resource you're manipulating is generated on creation. But this is not always the case. In this above example, the unique identifier is the username, and so the ID is provided.\n\nBut that code will always try to do a PUT request on /userapi/v0idnull and it will always fail with a 404.\n\nI think there are many different ways of solving this, from providing create() and update() methods on the model (that save() can use), to changing\n\n``` javascript\nmethod = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');\n```\n\nto exposing the method through the options hash of the save() method:\n\n``` javascript\nmethod = options.method ? options.method : (this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');\n```\n\nWith a change like this, I can do one of two things:\n\nMy application is aware of when I'm creating a user and when I'm updating a user and call the appropriate method / set the appropriate option\n\nOR\n\nI call save normally which tries a PUT, gets a 404, and an error handler tries save again, forcing a POST.\n\nThoughts?\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/3050/comments",
    "author": "alex-dow",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2014-03-07T15:37:51Z",
        "body": "> But that code will always try to do a PUT request on /userapi/v0idnull\n\nThat's correct. PUT vs POST isn't about create vs update. If you know the URL where your resource should belong, it's as simple as PUT-ing a representation of it there.\n\nFeel free to override sync if you'd like to do something different.\n"
      },
      {
        "user": "magalhas",
        "created_at": "2014-03-07T15:57:12Z",
        "body": "Or just override the isNew method if needed.\n"
      }
    ],
    "satisfaction_conditions": [
      "Solution must allow explicit control over HTTP method (POST/PUT) when saving models with client-provided IDs",
      "Must handle server-side resource creation without requiring error-driven retries",
      "Solution should integrate with Backbone's existing save() workflow",
      "Must respect Backbone's architectural patterns while extending functionality",
      "Should avoid requiring external state tracking for create/update status"
    ]
  },
  {
    "number": 3033,
    "title": "Accessing view options during `el` construction",
    "created_at": "2014-03-03T14:07:02Z",
    "closed_at": "2014-03-03T14:25:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/3033",
    "body": "Hi,\n\n`View#options` has been removed since Backbone 1.1.0, and the usual recommandation is to set it ourselves if we need to inside the initialize constructor. That's what we're doing currently.\n\nHowever, we have a few views with this kind of pattern :\n\n``` js\nPopupView.extend( {\n\n    el : function ( ) {\n        return Templates.get( 'popups/upload/settings', {\n            filename : this.options.filename\n        } );\n    }\n\n} );\n```\n\nAs you can see, the root element constructor is currently requiring the options to be functional. Since the initialize constructor is only called after creating the node, it fails.\n\nFor what it worth, this error can be somewhat fixed by overloading the entire `View` constructor :\n\n``` js\nvar View = ( function ( ) {\n\n    var View = function ( options ) {\n        this.options = options;\n        Backbone.View.apply( this, arguments );\n    };\n\n    var F = function ( ) { };\n    F.prototype = Backbone.View.prototype;\n    View.prototype = new F( );\n\n    return View;\n\n} ( ) );\n```\n\nBut I think we agree to say that it's not the best code snippet ever :)\n\nWhat do you think of this issue ? Should it be solved ?\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/3033/comments",
    "author": "arcanis",
    "comments": [
      {
        "user": "wyuenho",
        "created_at": "2014-03-03T14:13:30Z",
        "body": "Can you do this?\n\n``` javascript\nvar MyView = Backbone.View.extend({\n  initialize: function(options) {\n    this.setElement(Templates.get('popups/upload/settings', {\n      filename: options.filename\n    }));\n  }\n});\n```\n"
      },
      {
        "user": "arcanis",
        "created_at": "2014-03-03T14:25:42Z",
        "body": "Hm, it is indeed possible. It does introduce a little delta between the elements which need the options and those which don't, but nothing really serious. I haven't thought of using setElement myself, thanks : )\n\nI'm closing my issue since I don't see immediate use case where your snippet wouldn't work\n"
      },
      {
        "user": "cobbweb",
        "created_at": "2014-03-04T01:18:01Z",
        "body": "If it makes it any easier for you @arcanis you can override the constructor like this:\n\n``` js\nvar MyView = Backbone.View.extend({\n  constructor: function() {\n    console.log('test');  \n    Backbone.View.prototype.constructor.apply(this, arguments);\n  }\n});\n```\n"
      },
      {
        "user": "mllocs",
        "created_at": "2014-03-21T10:37:11Z",
        "body": "I'm having the same issue defining `className`, `attributes`, `id` or `tagName` as a function. It's specially handy to use the passed `options` to customise the class or attributes of the element. The workaround is to set the classes or attributes in the `onRender` method... :disappointed: \n"
      },
      {
        "user": "wyuenho",
        "created_at": "2014-03-21T11:08:16Z",
        "body": "@mllocs You can still pass the functions as options to the constructor.\n\n``` javascript\nnew View({id: function () { return 'foo'; }});\n```\n"
      },
      {
        "user": "mllocs",
        "created_at": "2014-03-21T11:17:32Z",
        "body": "I meant using the passed `options` in those functions. After the 1.1.0 update you no longer have `options` automatically attached to the context before calling those methods. \n"
      },
      {
        "user": "wyuenho",
        "created_at": "2014-03-21T11:21:57Z",
        "body": "Save `options` in your overridden initialize method or the constructor.\n"
      },
      {
        "user": "mllocs",
        "created_at": "2014-03-21T11:32:48Z",
        "body": "Initialize is called afterwards...\n\n``` javascript\n  var View = Backbone.View = function(options) {\n    this.cid = _.uniqueId('view');\n    options || (options = {});\n    _.extend(this, _.pick(options, viewOptions));\n    this._ensureElement(); // here we resolve className, id, attributes and tagName\n    this.initialize.apply(this, arguments);  // initialize... \n    this.delegateEvents();\n  };\n```\n\nand overriding the constructor looks too much for what I need to accomplish... \n"
      },
      {
        "user": "braddunbar",
        "created_at": "2014-03-21T11:36:15Z",
        "body": "Nah, overriding the constructor is a good plan.  It's pretty common and should be moreso.  :+1:\n"
      },
      {
        "user": "mllocs",
        "created_at": "2014-03-21T13:02:53Z",
        "body": "Overriding the constructor in every view declaration seems too much boilerplate to me... there was any reason to remove `options` from the context or to not pass it to the `ensureElement` methods? I would like to understand this change... for me this was a pretty common pattern:\n\n``` javascript\nvar MyView = Backbone.View.extend({\n  attributes: function() {\n    return {'tabindex': this.options.tabindex};\n  }\n});\n```\n\nany 'bad practice' in this pattern?\n"
      },
      {
        "user": "arcanis",
        "created_at": "2014-03-21T13:14:32Z",
        "body": "For my use case, every view in my application comes from a Backbone indirection. Something like this :\n\n``` js\nvar View = Backbone.View.extend( {\n    constructor : function ( options ) {\n        this.options = options;\n        Backbone.View.apply( this, arguments );\n    }\n} );\n\nvar UserView = View.extend( {\n} );\n\nvar CommentView = View.extend( {\n} );\n\n...\n```\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2014-03-21T13:49:12Z",
        "body": "@mllocs Yes, I would say accessing `this.options.foo` is an anti-pattern.  Instead, use `options` as a vehicle and attach properties directly as follows.\n\n``` js\nvar MyView = Backbone.View.extend({\n  constructor: function(options) {\n    _.extend(this, _.pick(options, 'tabindex', 'foo', 'bar', 'baz'));\n    Backbone.View.apply(this, arguments);\n  }\n  attributes: function() {\n    return {'tabindex': this.tabindex};\n  }\n});\n```\n\nThere's a great deal more detail in #2458 if you're interested.\n"
      },
      {
        "user": "mllocs",
        "created_at": "2014-03-21T14:07:36Z",
        "body": "Thanks @braddunbar, that options whitelisting is interesting... I'll investigate how to apply that idea when using Backbone.Marionette... \n"
      }
    ],
    "satisfaction_conditions": [
      "Solution must allow view element configuration (el/className/attributes) to access initialization options before element creation",
      "Approach must work with Backbone's view lifecycle without requiring deep framework modifications",
      "Solution should preserve Backbone's intended options handling patterns",
      "Must support dynamic element properties (tagName/className/etc) that depend on initialization parameters",
      "Implementation should minimize boilerplate when extending multiple views"
    ]
  },
  {
    "number": 2809,
    "title": "collection's 'create' method seems to need 'index' option.",
    "created_at": "2013-10-15T05:16:22Z",
    "closed_at": "2013-10-15T11:53:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/2809",
    "body": "While collection's 'add' method supports 'index' option,\nbut 'create' method doesn't seem to support it. \nIs there any way to set the index position when creating a model in collection?\nIf no, it seems to need 'index' option.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/2809/comments",
    "author": "oigil",
    "comments": [
      {
        "user": "akre54",
        "created_at": "2013-10-15T05:42:40Z",
        "body": "There's no `index` option, but there's an `at` option which you can pass in through options (`Collection#create` uses `add` under the hood.) Give it a try.\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2013-10-15T11:54:46Z",
        "body": "Hey @akre54 -- would you be interested in \"Collaborator\" status on the Backbone repo, so that you can tag and close questions as you see fit?\n"
      },
      {
        "user": "akre54",
        "created_at": "2013-10-15T14:38:57Z",
        "body": "sure. thanks!\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2013-10-15T14:40:41Z",
        "body": "Done. Enjoy. And welcome.\n"
      },
      {
        "user": "oigil",
        "created_at": "2013-10-16T05:38:56Z",
        "body": "wow! 'at' option works nicely.\n@akre54 Thanks!!\n"
      }
    ],
    "satisfaction_conditions": [
      "A way to specify insertion position when creating a model in a collection",
      "Integration with the existing Collection#create method workflow"
    ]
  },
  {
    "number": 2754,
    "title": "collection.on(\"myevent\") original model?",
    "created_at": "2013-09-10T15:21:14Z",
    "closed_at": "2013-09-10T15:42:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/2754",
    "body": "Hi guys,\n\nIs there any way I can get the original model who trigger an event inside a collection without having to passing it ?\n\n``` javascript\nvar collection = new Backbone.Collection();\nvar myModel = new Backbone.Model({});\ncollection.add(myModel);\nmyModel.trigger(\"foo\", 42);\n// ...\ncollection.on(\"foo\", function (number) {\n  // how can I get the original model object here?\n});\n```\n\nThis is a limitation I experiment on different projects, Is there an existing way to get that model without having to pass it at the trigger time?\n\nThe workaround of this I found is quite boring:\nsomething like:\n\n``` javascript\nfunction bindModel (model) {\n  model.on(\"foo\", function (number) {\n    // model in the scope\n  });\n}\nfunction unbindModel (model) {} // erf need to keep somewhere the original reference of the bound function...\ncollection.each(bindModel);\ncollection.on(\"add\", bindModel);\ncollection.on(\"remove\", unbindModel);\n```\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/2754/comments",
    "author": "gre",
    "comments": [
      {
        "user": "caseywebdev",
        "created_at": "2013-09-10T15:32:05Z",
        "body": "What's the problem with simply passing the model as the first arg? It's the convention Backbone uses everywhere in core.\n\n``` js\ncollection.add(model).on('foo', function (model, n) { ... });\nmodel.trigger('foo', model, 42);\n```\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2013-09-10T15:42:30Z",
        "body": "Yep yep, passing the model as the first argument is the preferred way to do this.  I think you'll find it works rather well.\n"
      },
      {
        "user": "gre",
        "created_at": "2013-09-10T15:47:18Z",
        "body": "That just looks not so DRY. I would prefer the trigger method to do that for me. \nBut anyway, that's fine!\nThanks.\n"
      }
    ],
    "satisfaction_conditions": [
      "Solution must avoid manual model passing during event triggering",
      "Must provide access to originating model in collection event handlers",
      "Solution should integrate with Backbone's event system patterns",
      "Avoids manual binding/unbinding per model"
    ]
  },
  {
    "number": 2739,
    "title": "Problem with parse and create",
    "created_at": "2013-08-30T06:24:22Z",
    "closed_at": "2013-09-11T17:16:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/2739",
    "body": "I want to add a model to a collection and immediately trigger the 'add' event so that a view is instantly rendered.\n\nHowever, I also want it to be persisted and saved as well.\n\nI do not want to wait for save to return before add is triggered.\n\nAll of this should be fine, except that I have data in the model that needs to be created on parse.  An example is a url to a map whose value is dependent on the client's browser type.\n\nIf I call `collection.create(model)`, the model will be added to the collection, parsed, then saved.\n\nThe problem is that I want that parsing to be done, but I don't want that parsed data to be saved to the server.\n\nI can fix this by doing `collection.create(model, {wait: true})`, but then there is a delay from when the model is created until the view is rendered.\n\nAny ideas on this?  Essentially I want the data created in `parse` in the model to never be persisted to the server, just accessed locally.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/2739/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "j03w",
        "created_at": "2013-08-30T11:38:24Z",
        "body": "How about override `model.toJSON()`?\n"
      },
      {
        "user": "tgriesser",
        "created_at": "2013-08-30T13:38:26Z",
        "body": "@blairvanderhoof - might be easier if you just saved & added...\n\n``` js\nvar model = new collection.model(data)\nmodel.save(data);\ncollection.add(model.parse());\n```\n\nor if you just set the attributes you don't want saved as properties on the model rather than in the model's attributes hash.\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2013-09-11T17:16:08Z",
        "body": "That works. It's also a not-very-great way to create a client-side-only view onto your data. Simply having a method on the model that generates the URL for you is _way_ nicer than having to keep data in sync.\n\n```\nmodel.urlForBrowser()\n```\n"
      },
      {
        "user": "ghost",
        "created_at": "2013-09-11T18:03:37Z",
        "body": "Thanks Jeremy, looks like staying away from setting properties on the attributes is the way to go and instead use instance/generated variables.\n"
      }
    ],
    "satisfaction_conditions": [
      "Immediate view rendering upon model addition without waiting for server persistence",
      "Client-side generated data (like browser-dependent URLs) must not be persisted to server",
      "Separation of transient client-specific data from persisted model attributes",
      "Maintain Backbone.js event flow integrity during model creation"
    ]
  },
  {
    "number": 2722,
    "title": "couldn't pass string as an argument to Backbone View",
    "created_at": "2013-08-14T13:47:09Z",
    "closed_at": "2013-08-14T13:52:26Z",
    "labels": [
      "wontfix",
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/2722",
    "body": "e.g. new MyView(\"Hello\");\nTypeError: invalid 'in' operand n\nBackbone version: 1.0.0\n\nThrows the above javascript error from Underscore.js, on passing string as an argument to backbone view. Accepts only object. Worked for Version 0.9.2, but not 1.0.0.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/2722/comments",
    "author": "shanvel26",
    "comments": [
      {
        "user": "braddunbar",
        "created_at": "2013-08-14T13:52:26Z",
        "body": "Hi @shanvel26!  That's correct, `Backbone.View` accepts an object as an argument.  The fact that it previously allowed a string is just coincidence.  I'd recommend using `new View({key: 'value'})` instead.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why Backbone 1.0.0 enforces object arguments for Views",
      "Clear migration path for code using primitive values as View arguments",
      "Best practices for View initialization in modern Backbone"
    ]
  },
  {
    "number": 2563,
    "title": "\" this.$el.height() \" always return 0. why ? ",
    "created_at": "2013-05-27T14:33:03Z",
    "closed_at": "2013-05-27T14:56:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/2563",
    "body": "Hi,\nI have a Backbone view and I try to retrieve the height of the el element after applying the view template like this \n\n``` javascript\nrender: function () {\n  this.$el.html(this.template);\n  console.log(this.$el.height());\n  // It always returns 0 \n}\n```\n\nWhy the result is always 0 ? \n\nThanks in advance\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/2563/comments",
    "author": "first-developer",
    "comments": [
      {
        "user": "lfac-pt",
        "created_at": "2013-05-27T14:51:00Z",
        "body": "Templates are usually functions, shouldn't `this.template` be `this.template()`?\n"
      },
      {
        "user": "tgriesser",
        "created_at": "2013-05-27T14:56:11Z",
        "body": "It doesn't have a height until the element is inserted in the DOM... try this:\n\n``` js\nrender: function () {\n  this.$el.html(this.template);\n  _.defer(function() { console.log(this.$el.height()); });\n}\n```\n"
      },
      {
        "user": "tbranyen",
        "created_at": "2013-05-27T16:34:05Z",
        "body": "His code is in the DOM as soon as it hits the `html` method.  The problem is that his View is not _inserted_ into the Document where it will have its height calculated.\n\nBasically `_.defer` may work, or it may have unintended side consequences depending on what is happening above-the-hood.  We're not getting a full scope of what @first-developer's code looks like.\n\nThis is why we have `afterRender` hooks in LM.   You can simulate your own by defining an `afterRender` method on your View, and triggering it after your code inserts the View into the Document.\n\n``` javascript\nafterRender: function() {\n  console.log(this.$el.height());\n}\n```\n\nand then later on:\n\n``` javascript\nmyView.$el.appendTo(\"body\");\nmyView.afterRender();\n```\n"
      },
      {
        "user": "first-developer",
        "created_at": "2013-05-29T06:33:29Z",
        "body": "@tgriesser You were right! I try this and it works fine for my case. However, what's @tbranyen said is also interesting and I think I will change my previous implementation to what he'was mentioning above. :+1: Guys you rock.\n"
      }
    ],
    "satisfaction_conditions": [
      "Ensures element measurement occurs after DOM insertion",
      "Explains why height measurement fails before DOM attachment",
      "Provides a reliable method to access rendered dimensions"
    ]
  },
  {
    "number": 2510,
    "title": "Model.save() with options and no key/val",
    "created_at": "2013-05-01T19:49:21Z",
    "closed_at": "2013-05-01T20:03:14Z",
    "labels": [
      "invalid",
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/2510",
    "body": "Using backbone 1.0.0.\n\nI have not been able to figure out how to call Model.save and pass options (success, error) and have it skip the key/val logic.\n\nWhat I've done for now is override Model.save changing the following line (50) in from:\n      if (key == null || typeof key === 'object') {\nTo:\n      if (key === null || typeof key === 'object') {\n\nThis allows me to call save as Model.save(undefined, undefined, {succes: mySuccess, error: myError}); and not have the options wiped out in the parameter logic of save.\n\nMaybe there is another way around this but I was unable to find it.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/2510/comments",
    "author": "cfator",
    "comments": [
      {
        "user": "tgriesser",
        "created_at": "2013-05-01T19:56:39Z",
        "body": "@cfator is there a reason you're saving as `Model.save(undefined, undefined, opts)` rather than `Model.save(undefined, opts)`? The latter should work just fine.\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2013-05-01T19:57:57Z",
        "body": "Or `model.save(null, {...})`, which is a bit shorter.  :)\n"
      },
      {
        "user": "cfator",
        "created_at": "2013-05-01T20:08:26Z",
        "body": "Yup that's the magic I was looking for.  I do find the parameters of Model.save() and the parameter switching behavior a bit cryptic but now that I know I can get back to business.  Thanks guys.\n"
      },
      {
        "user": "tgriesser",
        "created_at": "2013-05-01T20:09:22Z",
        "body": "@braddunbar right, of course :)\n"
      }
    ],
    "satisfaction_conditions": [
      "Clarify how to pass options to Model.save() without triggering key/value parameter handling",
      "Provide a method to use save() with options while omitting attributes/values",
      "Explain Backbone's parameter handling logic for Model.save()"
    ]
  },
  {
    "number": 2474,
    "title": "Pass all $.ajax options for fetch, save, and destroy",
    "created_at": "2013-04-11T19:24:28Z",
    "closed_at": "2013-04-11T19:26:41Z",
    "labels": [
      "invalid",
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/2474",
    "body": "It seems like success and error callbacks are the only options passed to $.ajax. What is the benefit of this? I'm finding it very hard to add a custom header to a single API call because the only thing that has worked so far is $.ajaxSetup, but then the custom header is added to every subsequent API call. Is there an easier way to add a custom header for a single ajax call?\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/2474/comments",
    "author": "briansorahan",
    "comments": [
      {
        "user": "braddunbar",
        "created_at": "2013-04-11T19:26:41Z",
        "body": "Hi @briansorahan!  Actually, all options passed to `fetch`/`save`/`destroy` are already passed through to `$.ajax`.  Enjoy!\n\n``` js\nmodel.fetch({complete: function(){ ... }});\n```\n"
      }
    ],
    "satisfaction_conditions": [
      "Demonstrates how to pass custom headers/options to a single Backbone.js AJAX request without affecting global settings",
      "Confirms that all $.ajax options (not just success/error callbacks) can be passed through Backbone's fetch/save/destroy methods",
      "Provides a method to avoid persistent global configuration changes"
    ]
  },
  {
    "number": 2229,
    "title": "sync event firing",
    "created_at": "2013-01-31T21:33:18Z",
    "closed_at": "2013-02-01T17:14:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/2229",
    "body": "I want an event like 'sync' to be triggered before the success function so that I can bind the event in the success function without it being executed right away\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/2229/comments",
    "author": "jkbailey",
    "comments": [
      {
        "user": "jkbailey",
        "created_at": "2013-01-31T21:39:07Z",
        "body": "maybe something like a 'response' event\n\n``` javascript\n...\n    var success = options.success;\n    options.success = function(resp) {\n++      model.trigger('response', model, resp, options);\n      if (success) success(model, resp, options);\n      model.trigger('sync', model, resp, options);\n    };\n...\n```\n"
      },
      {
        "user": "tgriesser",
        "created_at": "2013-01-31T21:52:23Z",
        "body": "Would the `request` event work? This is called by `Backbone.sync` before every request regardless of success/error.\n\n> \"request\" (model, xhr, options) \u2014 when a model (or collection) has started a request to the server.\n\nOtherwise, you could just trigger an event in your success handler:\n\n``` js\nmodel.fetch({\n  success: function (model, resp, options) {\n    model.trigger('response', model, resp, options);\n    //... rest of your success handler here\n  }\n});\n```\n"
      },
      {
        "user": "jkbailey",
        "created_at": "2013-01-31T22:13:06Z",
        "body": "Well, the request event won't work because i don't it to trigger if there is an error.\n\nHere is my dilemma, I have a collection of messages. I initially fetch the messages and in the success of that fetch I create a new view to display those messages. On the init of that view I want to attach a trigger so that whenever a new messages is added to the collection and successfully saved to the DB it updates my list of messages. So I could use the add event, but that is triggered before the data is saved to the DB. That is why I chose to use the 'sync' event, but then realized that right after the view is initialized (from the success function of fetch) the sync event is firing. Does that make sense?\n"
      },
      {
        "user": "tgriesser",
        "created_at": "2013-01-31T22:27:08Z",
        "body": "It sounds like what you probably want to do is add `wait:true` in the options when you're creating the new model, so the add event isn't fired until it syncs with the database.\n\n> Pass {wait: true} if you'd like to wait for the server before adding the new model to the collection.\n"
      },
      {
        "user": "jkbailey",
        "created_at": "2013-01-31T22:42:04Z",
        "body": "from my experience the `add` event doesn't fire a database sync, does it?\n"
      },
      {
        "user": "tgriesser",
        "created_at": "2013-01-31T23:13:54Z",
        "body": "The `create` method on the collection does an `add` and `save` at the same time, I assumed that's what you'd be using, then you would just listen on add rather than `sync`.\n"
      },
      {
        "user": "jkbailey",
        "created_at": "2013-02-01T17:11:27Z",
        "body": "wow... don't I feel dumb...\n\n\n---\n\nfor some reason i never knew the create method existed :(\n\n\n---\n\nI had this in the init of my collection...\n\n```\n        t.on('add',function(msg,opt) {\n\n            msg.save(msg.attributes,{\n                success: function(m,r,x) {\n                    m.trigger('response', m, r, x);\n                    console.log('message sent successfully');\n                },error: function() {\n                    console.log('error saving message');\n                }\n            });\n\n        });\n```\n"
      },
      {
        "user": "tgriesser",
        "created_at": "2013-02-01T17:14:27Z",
        "body": "Glad you got it sorted out!\n"
      }
    ],
    "satisfaction_conditions": [
      "Event triggering must occur after successful server synchronization",
      "Solution must allow event binding without immediate execution during initialization",
      "Must handle model addition in a way that ties to server confirmation",
      "Should leverage framework capabilities for atomic create-sync operations"
    ]
  },
  {
    "number": 2225,
    "title": "'Fetch' can't be bound to a 'change' event",
    "created_at": "2013-01-31T10:38:01Z",
    "closed_at": "2013-01-31T13:19:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/2225",
    "body": "Hi,\n\nI have a collection that listens to changes in a model to then update itself, like this:\n\n```\nthis.listenTo(this.user, \"change:addresses\", this.fetch);\n```\n\nAnd it was getting back the user's own data, instead of the expected. After some probing I figured that `change` events pass `(model, value, options)` to the callbacks, which in this case meant `sync` was eventually getting the user model as it's `option` param.\n\nThe user model has its own url, and 8478567 means it is then overriding the collection's url for the request.\n\nI understand this is an edge case, and can be easily circumvented by using `function(){ this.fetch(); }` instead, but maybe it deserves some looking into. Specially since I believe this also means `fetch` can't be bound to any event.\n\nRight now I can't think of a good way to solve it that won't break 8478567, though. Maybe needing to explicitly state you want to override the request settings in `sync`?\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/2225/comments",
    "author": "Dhekke",
    "comments": [
      {
        "user": "braddunbar",
        "created_at": "2013-01-31T13:19:26Z",
        "body": "Mornin' @Dhekke!  Thanks for pointing this out.  I don't think there's any action Backbone should take here though.  You'll have to deal with function arguments in any case and the extra wrapper function is a pretty standard pattern.  I often create a separate handler, which I think is cleaner sometimes, but it's really just adding a bit of indirection.\n\n``` js\ninitialize: function() {\n  this.listenTo(this.user, 'change:addresses', this.changed);\n},\nchanged: function() {\n  this.fetch();\n}\n```\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why parameter binding occurs when using methods directly as event handlers",
      "Pattern for safely binding collection fetch operations to model change events",
      "Clarification on Backbone.js's intended behavior for event parameter propagation"
    ]
  },
  {
    "number": 2160,
    "title": "Weird behavior when model.save if option.validate is not set",
    "created_at": "2013-01-18T19:45:06Z",
    "closed_at": "2013-01-18T20:34:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/2160",
    "body": "When validate is not set when calling model.save, it will call 'model.set' in 'model.save' with option passed in, so no validation. Later, option will be extended with {validate : true}, which makes 'model.save' fail. However, since the 'model.set' is done, the data presented wrongly in the view.\n\nI think the behaviors should be consistent, maybe. If no validate: true in option, it doesn't extend the option and check when save.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/2160/comments",
    "author": "LLLLKKKK",
    "comments": [
      {
        "user": "tgriesser",
        "created_at": "2013-01-18T20:22:46Z",
        "body": "@LLLLKKKK - I believe the best way to go about this would be to pass `wait:true` into the `model.save` so that the `set` call isn't applied until the model is both validated and a success is returned by the server. The other option, if you don't want to wait on the server call, would be to get a copy of the attributes, and if the `model.save` returns false, reset the model to those attributes.\n\n``` js\nvar currentAttr = _.clone(model.attributes);\nif (!model.save(attr)) {\n  model.clear({silent:true}).set(currentAttr);\n}\n```\n"
      }
    ],
    "satisfaction_conditions": [
      "Ensures model state consistency between set/save operations when validation is involved",
      "Provides predictable validation behavior when options.validate is unspecified",
      "Prevents view layer from displaying invalid data after failed validation",
      "Avoids requiring manual attribute state management by developers"
    ]
  },
  {
    "number": 2087,
    "title": "`route` event now fired by router and history",
    "created_at": "2013-01-08T02:38:54Z",
    "closed_at": "2013-01-08T13:18:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/2087",
    "body": "Since PR #2062 got merged into master there are now two places that `route` is triggered:\n1.  On the router \n2.  On BB.History\n\nIt seems odd to me that there is an identical event name being triggered in two different locations.\n\nIs there a particular reason why this behavior is desired?\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/2087/comments",
    "author": "hswolff",
    "comments": [
      {
        "user": "tgriesser",
        "created_at": "2013-01-08T03:35:30Z",
        "body": "It feels similar to how the `change` or `remove` events are fired on both the model and the collection containing the model - but @braddunbar might have a better idea.\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2013-01-08T12:26:14Z",
        "body": "Hi @hswolff!  `Backbone.history` triggers `route` for all routes on all routers.  Triggering the event on the route itself is just a shortcut for filtering out route events by router.\n\n``` js\n// This...\nBackbone.history.on('route', function(router, name, args) {\n  if (router === myRouter) {\n    // ...\n  }\n});\n// is more easily written as...\nmyRouter.on('route', function(name, args) {\n  // ...\n});\n```\n\n@hswolff It's mostly sugar, but I think it's a nice addition for folks that use multiple routers in a page.\n"
      },
      {
        "user": "hswolff",
        "created_at": "2013-01-08T13:18:53Z",
        "body": "Fair enough.  Seemed redundant to me at first glance but that makes sense.  Thanks for the explanation @braddunbar \n"
      }
    ],
    "satisfaction_conditions": [
      "Explains the design rationale for having two identical event names in different locations",
      "Demonstrates how the redundancy provides value to developers",
      "Clarifies the relationship between global history events and router-specific events",
      "Addresses use cases for multiple routers in a single page application"
    ]
  },
  {
    "number": 2078,
    "title": "Collection fetch does not render on \"add\" event",
    "created_at": "2013-01-06T14:43:46Z",
    "closed_at": "2013-01-12T18:24:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/2078",
    "body": "I've set up this AppView that triggers the overall Backbone's application!\nI want to fetch my collection and dynamically add items when the \"add\" event is thrown!\n\n```\nvar AppView = Backbone.View.extend({\n    el: $('#pics'),\n\n    initialize: function () {\n\n        // Fetch contents\n        this.collection = new PLibrary;\n        this.collection.on(\"add\", this.renderMessage, this);\n\n        $.ajaxSetup({async: false});\n        this.collection.fetch({update: true});  // fires an \"add\" event for every new model\n        $.ajaxSetup({async: true});\n\n        _.bindAll(this, 'render');\n    },\n\n    renderMessage: function(p){\n        var mV = new PRow({model: p});\n        this.$el.append(mV.render().el);\n    }\n\n});\n```\n\nThe code above sends the Ajax request to the server, but nothing gets displayed.\nInstead... If I make use of render() like this... the application works.\n\n```\nvar AppView = Backbone.View.extend({\n    el: $('#pics'),\n\n    initialize: function () {\n\n        // Fetch contents\n        this.collection = new PLibrary;\n        this.collection.on(\"add\", this.renderMessage, this);\n\n        $.ajaxSetup({async: false});\n        this.collection.fetch();\n        $.ajaxSetup({async: true});\n\n        _.bindAll(this, 'render');\n        this.render();\n    },\n\n    renderMessage: function(p){\n        var mV = new PRow({model: p});\n        this.$el.append(mV.render().el);\n    },\n\n    render: function() {\n        var self = this;\n        _.each(this.collection.models, function (item) {\n            self.renderMessage(item);\n        }, this);\n    }\n\n});\n```\n\nIt seems that the \"add\" event doesn't get thrown!\nHelp me please\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/2078/comments",
    "author": "omsoft",
    "comments": [
      {
        "user": "yuku",
        "created_at": "2013-01-06T16:14:17Z",
        "body": "`Collection#fetch` uses `Collection#reset` internally by default and it triggers `\"reset\"` event on the collection instance but doesn't tigger `\"add\"` event.\nIf `{update: true}` is given to `Collection#fetch` then `Collection#update` is executed and it may trigger `\"add\"`, `\"remove\"` and `\"change\"` events.\nSo, there are two solutions.\n1. Set `render` as callback of collection's `\"reset\"` event\n2. Give `{update: true}` to `Collection#fetch`\n\nI like 1. Because it is easy to implement and `update` is a little heavier than `reset`.\n"
      },
      {
        "user": "omsoft",
        "created_at": "2013-01-06T17:14:04Z",
        "body": "If you take a closer look at my first code snippet, you'll see the call fetch({update: true}).\nMy question is, infact, why it doesn't work?\n"
      },
      {
        "user": "yuku",
        "created_at": "2013-01-06T18:50:54Z",
        "body": "Oh, excuse me. The first code looks correct. ummm\nCould you show me the console string of following code?\n\n``` javascript\nconsole.log(Backbone.VERSION);\nvar collection = new PLibrary();\ncollection.on('all', function () { console.log(arguments); }); \ncollection.fetch({update: true, async: false});\ncollection.fetch();\n```\n\nExpect:\n\n```\n0.9.9\n['add', ModelObject, CollectionObject, OptionObject]\n['add', ModelObject, CollectionObject, OptionObject]\n...\n['reset', CollectionObject, OptionObject]\n```\n\n`Model#update`was added at 0.9.9.\n"
      },
      {
        "user": "omsoft",
        "created_at": "2013-01-12T15:08:17Z",
        "body": "Thank you very much! I was working with an old version of Backbone. Updated to 0.9.9 and now it works as expected!\n"
      }
    ],
    "satisfaction_conditions": [
      "Identifies why the 'add' event isn't triggered during collection fetch with {update: true}",
      "Addresses version compatibility of Backbone.js collection update functionality",
      "Explains conditions when fetch() triggers 'add' vs 'reset' events",
      "Ensures collection modifications are observable by views",
      "Clarifies proper event binding for collection changes"
    ]
  },
  {
    "number": 2070,
    "title": "When upgrade to 0.99, the console report an error: \"_.pick is not a function\"  ",
    "created_at": "2013-01-04T16:18:36Z",
    "closed_at": "2013-01-04T18:00:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/2070",
    "body": "Hello.\nWhen upgrade to 0.99, the console report an error: \"_.pick is not a function\"  . Why?\nPrevious version: 0.9.1\n\nRegards\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/2070/comments",
    "author": "vicenrele",
    "comments": [
      {
        "user": "braddunbar",
        "created_at": "2013-01-04T16:21:14Z",
        "body": "Hi @vicenrele!  Have you updated your copy of underscore as well?  Backbone 0.9.9 requires underscore 1.4.3 or higher.\n"
      },
      {
        "user": "vicenrele",
        "created_at": "2013-01-04T17:38:44Z",
        "body": "Thanks for help @braddunbar! That was the problem. \n"
      }
    ],
    "satisfaction_conditions": [
      "Identifies the root cause of the '_.pick is not a function' error after upgrading to Backbone 0.9.9",
      "Explains dependency version requirements between Backbone and Underscore",
      "Addresses compatibility checks between related library versions"
    ]
  },
  {
    "number": 1883,
    "title": "Problem with IE8 and sorted models in collection detected in Version 0.9.2",
    "created_at": "2012-12-09T12:43:03Z",
    "closed_at": "2012-12-09T17:04:59Z",
    "labels": [
      "invalid",
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/1883",
    "body": "IE8 displays: error on page\n\nNumber expected\nbackbone.js  Line: 724 (it's the \"sort\" function)\nCode: 0   Char: 9\nif I use a sorted collection with:\n\n```\ncomparator: function() {\n    return this.get('pageNo');\n},\n```\n## \n\npageNo is an integer in the model\n\nthis error doesn't occur in IE9 or Firefox but every time in IE8\nmy workaround was to throw out the comparator function and use the where clauses to find the correct model\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/1883/comments",
    "author": "lka",
    "comments": [
      {
        "user": "caseywebdev",
        "created_at": "2012-12-09T17:02:19Z",
        "body": "What you want is\n\n``` js\ncomparator: function(model) {\n    return model.get('pageNo');\n},\n```\n\nThe comparator function isn't called with the model context, it's called with the collection context. It is passed the model as the first argument, however, which is what you want.\n"
      },
      {
        "user": "lka",
        "created_at": "2012-12-09T18:19:45Z",
        "body": "works well\nthank you for advise\n"
      },
      {
        "user": "caseywebdev",
        "created_at": "2012-12-09T18:21:36Z",
        "body": "And actually on `master` (not 0.9.2) you can do this\n\n``` js\ncomparator: 'pageNo',\n```\n\nwhich is some pretty sweet sugar if you ask me :+1:\n"
      }
    ],
    "satisfaction_conditions": [
      "Solution must explain how to properly access model attributes in Backbone.js comparator functions",
      "Resolution must address IE8's strict type expectations in JavaScript sort operations",
      "Answer must maintain collection sorting functionality while avoiding workarounds like manual filtering",
      "Explanation should clarify Backbone.js version differences in comparator syntax"
    ]
  },
  {
    "number": 1728,
    "title": "Question - Assign index to models on instantiation",
    "created_at": "2012-10-12T09:39:41Z",
    "closed_at": "2012-10-12T09:49:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/1728",
    "body": "Is there anyway to let the newly instantiated model know of its 0-based index inside its collection, and assign it? Something like:\n\n``` javascript\n    var m = Backbone.Model.extend({\n        initialize: function() {\n            this.set('index', '// 0-based index inside the parent collection//');\n        }\n    });\n```\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/1728/comments",
    "author": "gsklee",
    "comments": [
      {
        "user": "vincentbriglia",
        "created_at": "2012-10-12T09:44:45Z",
        "body": "You can get the index of a model on a collection by using indexOf\n\n``` javascript\ncollection.indexOf(model)\n```\n\nor if you don't have access to the collection in your view but you know the model is inside a particular collection, you can always get the collection like this:\n\n``` javascript\nmodel.collection.indexOf(model)\n```\n\nI wouldn't recommend storing the index on a model, because then each time you add an additional model you will have to update the index values for each model on a collection.\n"
      },
      {
        "user": "gsklee",
        "created_at": "2012-10-12T09:50:55Z",
        "body": "Feeling stupid, thanks =D\n"
      }
    ],
    "satisfaction_conditions": [
      "Provides a way to dynamically determine a model's position in its collection without manual index storage",
      "Maintains index accuracy during collection modifications",
      "Works with Backbone.js collection/model architecture"
    ]
  },
  {
    "number": 1721,
    "title": ".fetch({add: true}) attaching phantom object into collection",
    "created_at": "2012-10-10T11:11:14Z",
    "closed_at": "2012-10-10T16:00:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/1721",
    "body": "`collection.fetch({add: true})` currently adds an empty object `{}` into the original collection even if the fetched response is `undefined` or `null`:\n\n``` javascript\n[..., {\"id\" : 39, attr: \"whatever\"}, {}]\n```\n\nThis can lead to unexpected errors when processing the collection data. Is this intended?\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/1721/comments",
    "author": "gsklee",
    "comments": [
      {
        "user": "caseywebdev",
        "created_at": "2012-10-10T15:54:24Z",
        "body": "It's because `Collection#add(undefined | null | false | 0 | '' | {})` all add an empty model to the collection. What you want is `Collection#add([])` which means you have an array of models, but it's empty, so nothing is added. The question is why isn't your fetched JSON returning `[]`?\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2012-10-10T16:00:30Z",
        "body": "Quite right.  You can use `Collection#parse` to ensure that undefined results return an empty array.  Thanks @caseywebdev!\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of whether empty model addition is intentional behavior",
      "Method to prevent empty model creation on invalid server responses",
      "Clear handling strategy for undefined/null API responses",
      "Solution that maintains collection integrity during incremental adds"
    ]
  },
  {
    "number": 1715,
    "title": "By reference inheritance",
    "created_at": "2012-10-05T23:05:36Z",
    "closed_at": "2012-10-05T23:08:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/1715",
    "body": "Have a question, potentially a bug - hopefully just a question.\n\nTrying to create a slightly enhanced view, and then create instances of that view as below.\n\n// enhanced view\nvar Enhanced = Backbone.View.extend({\nfoo: [],\ntest: function () {\nthis.foo.push(Math.random());\n}\n});\n\n// couple of new objects\nvar Foo = Enhanced.extend({});\nvar Bar = Enhanced.extend({});\n\n// instantiating\nvar foo = new Foo();\nvar bar = new Bar();\n\n// trying to push a random number into foo\nfoo.test();\nbar.test();\n\n// expecting to see something like [0.11767047128388153][0.8575983647365905]\nconsole.log(foo.foo, bar.foo);\n\nOne would expect to see 2 different values for the output above, however one gets the same array of length 2 with identical values in both instances.\n\nLooking @ the code around line 1400, one can see the following:\n\nctor.prototype = parent.prototype;\n\nIn order to create a truly new instance wouldn't:\n\nctor.prototype = $.extend(true,{},parent.prototype);\n\nbe suited better?\n\nThat would solve the problem I described above. As is, array foo feels like a static, not instance variables.\n\nI know that the prescribed version is to use \"initialize\" for instance variables, but why would the above suggested \"fix\" be wrong?\n\nThanks!\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/1715/comments",
    "author": "ndanson",
    "comments": [
      {
        "user": "braddunbar",
        "created_at": "2012-10-05T23:08:40Z",
        "body": "Hi @ndanson!  Give this a try instead:\n\n``` js\nvar View = Backbone.View.extend({\n  initialize: function() {\n    this.foo = [Math.random()];\n  }\n});\n```\n\nPrototype properties are indeed shared between javascript instances.  For a unique value on each instance, you'll need to set it explicitly as above.\n"
      },
      {
        "user": "ndanson",
        "created_at": "2012-10-05T23:25:10Z",
        "body": "Suppose we have the following:\n\nvar Foo = View.extend({\n    initialize: function () {\n        console.log('toast is yummy!');\n    }\n});\n\nvar foo = new Foo();\n\nView's initialize will be overwritten by Foo's initialize, thereby variable foo won't be available in Foo anymore. Is that by design?\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2012-10-05T23:27:04Z",
        "body": "It is, but you can always call the method on the prototype like so:\n\n``` js\nvar Sub = View.extend({\n  initialize: function() {\n    View.prototype.initialize.apply(this, arguments);\n    // \u2026\n  }\n});\n```\n"
      },
      {
        "user": "ndanson",
        "created_at": "2012-10-05T23:32:12Z",
        "body": "Thank you for your prompt replies. Indeed, the above does solve the issue.\nMy question is, why not provide a deep copy option, rather than keep writing the same boilerplate code over and over again - assuming that our project will likely have hundreds if not more views?\n\nThanks!\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2012-10-05T23:36:06Z",
        "body": "Glad to help.  :)\n\nI'm not sure what boilerplate you're talking about.  If you're referring to the super call, that's just the reality of inheritance in javascript.  Calling super methods is rather verbose.\n"
      },
      {
        "user": "ndanson",
        "created_at": "2012-10-05T23:43:35Z",
        "body": "Thank you for your patience! Much appreciated.\n\nI do understand inheritance in JS. That's a fact. My question would rather be: why not provide the option of deep copying within the Backbone framework? My example when describing the problem included a potential solution for such functionality.\n\nTo rephrase even more, what would be the real world scenario where objects X and Y that extend Foo would share the same instance variables (within Backbone views for example) - not JavaScript in general.\n\nThanks!\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2012-10-05T23:47:40Z",
        "body": "> To rephrase even more, what would be the real world scenario where objects X and Y that extend Foo would share the same instance variables (within Backbone views for example) - not JavaScript in general.\n\nIn all the examples above, each instance shares prototype variables for `initialize`, so functions are one example.  Also, default values such as `disabled` or `hidden` are good examples, assuming you need them.\n"
      },
      {
        "user": "ndanson",
        "created_at": "2012-10-05T23:54:23Z",
        "body": "Last question: why isn't there an option for deep copying?\n"
      },
      {
        "user": "tgriesser",
        "created_at": "2012-10-06T00:00:22Z",
        "body": "@ndanson - only objects and arrays are passed by reference when they are object properties (as they are on the prototype), so those are the only items that you'll need to set explicitly per instance. Deep copying is very costly from a performance standpoint (and in almost every case a different solution would be better suited) - if it's something you still want to do, you'll have to find something other than backbone to do it with.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why Backbone's inheritance model shares prototype properties by default",
      "Clarification of trade-offs between prototype sharing vs. instance-specific properties",
      "Examples of valid use cases for shared prototype properties in Backbone"
    ]
  },
  {
    "number": 1703,
    "title": "Can't Pass \"data-\" attributes within View's Attributes method",
    "created_at": "2012-10-03T21:07:26Z",
    "closed_at": "2012-10-03T21:08:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/1703",
    "body": "I am a fan of setting attributes within a view as such...\n\n<pre>Backbone.View.extend({\n    attributes: {\n        data-attr: 'mydata'\n    }\n});\n</pre>\n\n\n... however, this throws an error due to the hyphen in the key \"data-attr\".\n\n<pre>Uncaught SyntaxError: Unexpected token -</pre>\n\n\nI realize this is an illegal token in a JavaScript key-value object, however I was hoping Backbone offered some work around for this, given the fact that passing data attributes is one of the most likely scenarios.\n\nI have been working around it by setting the attribute within the render function using jQuery:\n\n<pre>render: function () {\n    this.$el.attr( 'data-attr', 'mydata\"');\n}\n</pre>\n\n\nThis works, but I thought to ask if there is another option.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/1703/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2012-10-03T21:08:35Z",
        "body": "Yep -- it's just a JavaScript object. Use quoted keys.\n\n```\nattributes: {\n    \"data-attr\": \"mydata\"\n}\n```\n"
      },
      {
        "user": "ghost",
        "created_at": "2012-10-03T21:15:45Z",
        "body": "Ahh, I thought I tried that! Thanks!\n\n\n---\n\nWhat do you suggest for passing a data attribute to the View's DOM element from the attributes within the View's Model? As such...\n\n<pre>\nattributes: {\n    \"data-attr\": this.model.foo\n}\n</pre>\n\nI am losing scope for reference to \"this\".\n\n<pre>\nUncaught TypeError: Cannot read property 'model' of undefined \n</pre>\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2012-10-03T21:16:49Z",
        "body": "You can use a function like so:\n\n``` js\nattributes: function() {\n  return {\n    'data-attr': this.model.foo\n  };\n}\n```\n"
      },
      {
        "user": "ghost",
        "created_at": "2012-10-03T21:22:23Z",
        "body": "Awesome. That works perfectly. Thank you for the prompt responses!\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2012-10-03T21:27:05Z",
        "body": "You're welcome, but in the future, please don't use the bug tickets for tech support like this -- try the IRC channel or the mailing list first.\n"
      },
      {
        "user": "ghost",
        "created_at": "2012-10-03T21:42:38Z",
        "body": "Happy to. I tried that first, but there is only one other user in DocumentCloud IRC, Turjakas who was not responding.\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2012-10-03T22:01:12Z",
        "body": "Must've mistyped -- there are 242 folks in #documentcloud on freenode right now.\n"
      }
    ],
    "satisfaction_conditions": [
      "Proper syntax for defining hyphenated data attributes in Backbone View's attributes object",
      "Access to view/model context when setting dynamic attribute values",
      "Native Backbone pattern for setting element attributes without jQuery DOM manipulation"
    ]
  },
  {
    "number": 1702,
    "title": "Alternative to events: { \"trigger select\" : \"functor\" }?",
    "created_at": "2012-10-03T18:31:37Z",
    "closed_at": "2012-10-03T18:45:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/1702",
    "body": "Hi,\n\nI was wondering if there was an alternative to the standard Backbone.View.extend({ events: { \"trigger selector\" : \"functor\", ...} ... }).\n\nIs there a special alternative function that gets called that lets you bind events for that specific view without having to mix the trigger and CSS selector into a string, and without having to pass the callback as a string rather than as a reference?\n\nThe latter's less important than the former: if there's a way to at least do even binding in a way that keeps the trigger and the view selector separate, that would be awesome. Is there such an alternative?\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/1702/comments",
    "author": "Pomax",
    "comments": [
      {
        "user": "braddunbar",
        "created_at": "2012-10-03T18:39:57Z",
        "body": "> Is there a special alternative function that gets called that lets you bind events for that specific view without having to mix the trigger and CSS selector into a string\n\nI'm afraid not.  Is there a reason you would rather not concatenate the event and the selector?  I've found that the object syntax is rather succinct.\n\n> and without having to pass the callback as a string rather than as a reference?\n\nYou can pass a function instead of a string as the callback.\n\n``` js\nvar View = Backbone.View.extend({\n  events: {\n    click: function(e) {\n      e.preventDefault();\n      // ...\n    }\n  }\n});\n```\n\nThis will also work when calling `delegateEvents` directly.\n\n``` js\nview.delegateEvents({click: function(){...}});\n```\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2012-10-03T18:45:43Z",
        "body": "Just use jQuery?\n\n```\n$(view.el).on('click', '.target', function(){ ... })\n```\n"
      },
      {
        "user": "Pomax",
        "created_at": "2012-10-03T19:13:24Z",
        "body": "the syntax is succinct, but it puts two completely different things in the same string, effectively making it a mystery string (the first word is a trigger, then there's whitespace, then there's a selector, but how do you get the trigger back out? split on whitespace? is that always going to be true? maybe, maybe not).\n\nUsing jQuery for the el is a good suggestion, thank you!\n"
      }
    ],
    "satisfaction_conditions": [
      "Allows binding view events without combining event triggers and CSS selectors into a single string",
      "Provides programmatic access to event binding mechanism",
      "Maintains view encapsulation boundaries"
    ]
  },
  {
    "number": 1552,
    "title": "Delegate event in View does not return original event",
    "created_at": "2012-08-15T10:48:20Z",
    "closed_at": "2012-08-15T12:08:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/1552",
    "body": "To process some attributes i need access to $(this) in event callback, but receive only event object. This event object contain target (child html element) but does not contain the original event.\n\nFor example\n\n```\n<div class=\"test\"><div class=\"sub\">TEXT</div></div>\n\nevents: {\n    \"click .test\": \"func\"\n}\n```\n\nThis backbone uses \n\n```\nvar eventName = match[1], selector = match[2];\nmethod = _.bind(method, this);\n```\n\nyes, it is okay. But maybe the original \"this\" should returned too as 2d argument?\n\nit can be dome for example as $.delegate eventData\n\nps of course i can get access to parent by jquery parents() but it adds some complexity\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/1552/comments",
    "author": "artyomtrityak",
    "comments": [
      {
        "user": "braddunbar",
        "created_at": "2012-08-15T12:01:44Z",
        "body": "Mornin' @artyomtrityak, thanks for opening an issue!  I'm not sure which element you're trying to get to, but I'm fairly certain that you can grab a reference to it using one of the following:\n- event.target\n- event.currentTarget\n- event.delegateTarget\n\nCould you be a bit more specific?  Maybe some extra context in the code would help me understand the issue.\n"
      },
      {
        "user": "artyomtrityak",
        "created_at": "2012-08-15T12:08:39Z",
        "body": "oh,, sry, i have missed event.currentTarget, sorry \n"
      }
    ],
    "satisfaction_conditions": [
      "Access to the delegate target element (where the handler was attached) through the event object",
      "Clarification of standard event properties available in Backbone's delegated events"
    ]
  },
  {
    "number": 1376,
    "title": "general collection event",
    "created_at": "2012-06-04T07:29:19Z",
    "closed_at": "2012-06-04T11:42:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/1376",
    "body": "Hello!\nFor my HTML/JavaScript table I have my own slider. Everytime the number of entries in the Backbone Collection changes, I have to adjust the size of this slider. So I have to \"listen\" to 3 Events (reset, add and remove) in the slider widget. If there would be a general \"lengthchange\"?! event, I would only have to listen to this one event.\nMaybe some other developers would also benefit from this change?\nThanks a lot\nWolfgang\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/1376/comments",
    "author": "wolfgang-adamec",
    "comments": [
      {
        "user": "braddunbar",
        "created_at": "2012-06-04T11:42:54Z",
        "body": "Hi @wolfgang-adamec.  I don't know if you're aware of this, but it's fairly easy to use space separated events to listen to the collection changes.\n\n``` js\n// this\ncollection.on('add remove reset', ...);\n\n// instead of this\ncollection.on('add', ...);\ncollection.on('remove', ...);\ncollection.on('reset', ...);\n```\n\nIn this way, you can just proxy those events through a custom collection class like so:\n\n``` js\nvar Collection = Backbone.Collection.extend({\n\n  initialize: function() {\n    this.on('add remove reset', function() {\n      this.trigger('change:length', this, this.length);\n    }, this);\n  }\n\n});\n```\n\nSince this is rather easy to do, I think we should probably leave it up to the user as to how it's implemented.  Hope it helps!\n"
      },
      {
        "user": "wolfgang-adamec",
        "created_at": "2012-06-04T11:54:34Z",
        "body": "Thank you!\n"
      }
    ],
    "satisfaction_conditions": [
      "Provides a way to listen to collection length changes through a single unified event",
      "Demonstrates how to propagate collection length changes without requiring manual event binding for each mutation type",
      "Maintains compatibility with Backbone.js event patterns",
      "Does not require modifying Backbone core library"
    ]
  },
  {
    "number": 1198,
    "title": "collection.sortedIndex does not use collection.comparator",
    "created_at": "2012-04-06T01:37:17Z",
    "closed_at": "2012-04-06T14:15:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/1198",
    "body": "`collection.sortedIndex` does not use `collection.comparator`, so it always returns 0\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/1198/comments",
    "author": "mikepb",
    "comments": [
      {
        "user": "aterris",
        "created_at": "2012-04-06T03:15:24Z",
        "body": "I hadn't actually had a use for sortedIndex yet and I don't use the comparators all that often, so I just spent the last few minutes playing around in the console.\n\nsince sortedIndex is just a proxied underscore method writing `collection.sortedIndex` is essentially just syntax sugar for `_.sortedIndex(collection.models, ...`\n\nIt looks like you are actually expecting it to automatically pass the comparator on to sortedIndex, but these methods are simply proxied with the models being passed as the first argument.  You will need to just pass it yourself.\n\nHere is the final code that I ran in the backbone docs site console that I feels recreates your issue and shows how to get the correct result.\n\n```\nc = new Backbone.Collection();\nc.comparator = function(model){ return model.get('score')}\n\nc.add(new Backbone.Model({score: 3}));\nc.add(new Backbone.Model({score: 0}));\nc.add(new Backbone.Model({score: 9}));\nc.add(new Backbone.Model({score: 6}));\n\nc.pluck('score');\n# [0,3,6,9]\n\nc.sortedIndex(new Backbone.Model({score: 7}));\n# 0 \n\nc.sortedIndex(new Backbone.Model({score: 7}), c.comparator);\n# 3\n\n```\n\nBecause the underscore method are passed models, it will never be able to figure out the order (will always return 0) unless a comparator of some kind is passed, so it knows what \"sorting the models\" even means.  This is actually the correct behavior, and I think it makes sense to keep it the same as every other proxy method.\n\nI am pretty sure that should addresses your issue, but if I missed something or I am way off base with what you are talking about just lemme know :+1:\n"
      },
      {
        "user": "mikepb",
        "created_at": "2012-04-06T03:18:35Z",
        "body": "What you say is true! I was thinking about having collections default to using its own comparator, but since I am not using the method anymore, and not many people actually use it, it's probably fine to just leave it as is.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why sortedIndex doesn't automatically use the collection's comparator",
      "Validation that current behavior aligns with Backbone's design patterns",
      "Demonstration of correct sortedIndex usage with comparator parameter"
    ]
  },
  {
    "number": 962,
    "title": "Models not available in Collection.initialize()",
    "created_at": "2012-02-06T12:28:24Z",
    "closed_at": "2012-02-06T15:00:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/962",
    "body": "In 0.5.3, the Collection's constructor used to set the models before calling `initialize()`. However, with 0.9, the models get set only after `initialize()`. \n\nOur existing `initialize()` code relies on models existing in order to run some aggregate calculations. Now, all that is broken. Why the change?\n\nAdditionally, when `reset()` is called to set the models, it is done silently, so we can't even listen to the \"reset\" event to perform the calculations.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/962/comments",
    "author": "anush",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2012-02-06T15:00:45Z",
        "body": "The change was made so that the collection can dynamically set it's `model` attribute and others during initialization, before any models have been created.\n\nAlthough there are use cases for doing it both ways, the change was deemed to be correct, because a collection should be fully initialized before it receives its first model.\n\nHopefully, you can fix your code by writing:\n\n```\nvar collection = new Collection(models);\ncollection.performCalculations();\n```\n"
      },
      {
        "user": "anush",
        "created_at": "2012-02-06T15:42:03Z",
        "body": "Would you be open to adding a new \"ready\" event, once the collection is fully initialized... models and all?\n\nDoing the calculations outside the collection's initialize is quirky because then the collection is no longer self-sufficient.\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2012-02-06T15:46:34Z",
        "body": "> Would you be open to adding a new \"ready\" event, once the \n> collection is fully initialized... models and all?\n\nNo. Firstly because it's not an evented thing -- you're in control of when you create a collection. If the two-liner doesn't float your boat, why not just create your own method?\n\n```\nCollection.create = function(models, options) {\n  var col = new Collection(models, options);\n  col.trigger(\"ready\"); // or whatever...\n  return col;\n};\n```\n"
      },
      {
        "user": "anush",
        "created_at": "2012-02-06T19:50:06Z",
        "body": "Yeah, you're right, thinking more on it, it's not an event-worthy situation. Ugh, ok, I suppose I'll write a whole extra line of code to trigger the calculations :)\n\nThanks for the quick response.\n"
      }
    ],
    "satisfaction_conditions": [
      "A mechanism to trigger calculations after models are fully set in the collection",
      "Avoid reliance on internal event timing (e.g., silent 'reset' event)",
      "Control over execution timing without introducing new framework events"
    ]
  },
  {
    "number": 855,
    "title": "model.destroy don't send id in request header",
    "created_at": "2012-01-12T12:46:13Z",
    "closed_at": "2012-01-12T17:21:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/855",
    "body": "I use default behavior (REST) with PHP server\n\nI defined url for my model and everything is right with create and update.\n\nBut with delete method, ID is not send in the header like for others methods\n\nIn the source code, I find : \n\n```\nif (!params.data && model && (method == 'create' || method == 'update')) {\n  params.contentType = 'application/json';\n  params.data = JSON.stringify(model.toJSON());\n}\n```\n\nWhy dont include delete method ?\n\n```\nif (!params.data && model && (method == 'create' || method == 'update' || method == 'delete' )) {\n```\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/855/comments",
    "author": "dcz-switcher",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2012-01-12T17:21:09Z",
        "body": "Yes, delete requests have no body -- the URL itself should contain the ID of the model being deleted.\n"
      },
      {
        "user": "dcz-switcher",
        "created_at": "2012-01-13T10:41:33Z",
        "body": "Thanks for your reply,\n\nI understand now, but it works only with urlRoot, not with url ?!?\n\nso, I can't call destroy() method from a model in a collection\n\nmyCollection.get( id ).destroy() ; //don't work (the ID is not in the URL\n\nBut ...\nmyCollection.get(id).save({name : 'newName' }) ; //works\n\nThanks again\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2012-01-13T15:37:09Z",
        "body": "The ID should be in the URL -- unless you've overridden the `url()` function to prevent it from being there.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how model IDs are included in DELETE request URLs",
      "Clarification on URL construction differences between models in collections vs standalone",
      "Guidance on proper Backbone URL configuration for RESTful endpoints",
      "Explanation of HTTP method semantics in REST APIs"
    ]
  },
  {
    "number": 832,
    "title": "Weird behaviour of Collection.without",
    "created_at": "2011-12-30T16:26:38Z",
    "closed_at": "2011-12-30T21:28:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/832",
    "body": "Hi,\n\nI noticed a weird behaviour for `without` method on collections with the following code.\n\n``` coffee\nremainingTerritories = allTerritories.without(territoriesToReject)\n```\n\nBoth `allTerritories` and `territoriesToReject` are `Territories` collections containing Territory objects, and some of these territories to reject come from the pool of territories, matching with `===`).\n`remainingTerritories` contains a regular Array containing all the Territory objects  no one is filtered out.\nI would expect to get all the territories minus the ones to reject.\n\nTo achieve my goal, I had to write:\n\n``` coffee\nremainingTerritories = new Territories(allTerritories.reject (t)-> territoriesToReject.include(t))\n```\n\nIt's not a big deal but I would be glad to know why, and if I can help fixing that if it's not the expected behaviour.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/832/comments",
    "author": "Sephi-Chan",
    "comments": [
      {
        "user": "nordyke",
        "created_at": "2011-12-30T20:50:14Z",
        "body": "@Sephi-Chan  `allTerritories.without` expects `territoriesToReject` to be an array.  Have you tried \n\n`remainingTerritories = allTerritories.without(territoriesToReject.models)`?\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2011-12-30T21:28:31Z",
        "body": "Yep -- you have to pass an array to `without`.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why Collection.without() fails to filter objects when given another collection",
      "Clarification of Collection.without()'s expected input requirements",
      "Comparison between Collection.without() and Collection.reject() behavior",
      "Guidance on proper usage for filtering collections based on object identity",
      "Confirmation whether this is intended API behavior or a bug"
    ]
  },
  {
    "number": 830,
    "title": "Callback vs event handler priority",
    "created_at": "2011-12-30T02:11:23Z",
    "closed_at": "2011-12-30T14:04:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/830",
    "body": "What's the reasoning for event handlers getting priority over the passed in callback?\n\n```\n# taken from destroy method\n...\noptions.success = function(resp) {\n   model.trigger('destroy', model, model.collection, options);\n   if (success) success(model, resp);\n};\n...\n```\n\nThe callback is provided by the object making the call in the first place, so it seems natural that it would get first rights to act on the result and then any event handlers would be handled second.  No?\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/830/comments",
    "author": "rymohr",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2011-12-30T14:04:31Z",
        "body": "I'm afraid not. The `destroy` event and the `success` callback aren't quite the same thing. The former notifies listeners that the model has been destroyed, the latter is a callback that indicates that the operation (including the `destroy` handlers) have finished successfully. You certainly wouldn't want the `success` callback to fire if one of the `destroy` handlers raised an exception. \n"
      },
      {
        "user": "rymohr",
        "created_at": "2011-12-30T19:49:31Z",
        "body": "Oh, ok.  I misunderstood the intent of the `success` and `error` callbacks then.  I thought their purpose was to abstract the sync call, not wrap the entire life of the operation.\n\nMight be good to clarify this in the docs.  Thanks for the quick answer.\n"
      }
    ],
    "satisfaction_conditions": [
      "Clarify the distinct purposes of event handlers vs success/error callbacks",
      "Explain why operation completion must follow event handling",
      "Address error handling implications between events and callbacks",
      "Define the lifecycle boundaries each mechanism represents"
    ]
  },
  {
    "number": 793,
    "title": "Supporting polymorphic collections",
    "created_at": "2011-12-16T19:09:28Z",
    "closed_at": "2011-12-19T16:05:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/793",
    "body": "Howdy!\n\nRight now backbone seems to only support collections of one type, we're working on a stream with many polymorphic types that all quack the same.\n\nIt'd be nice to implement this via inheritance(extend), rather than our current technique of creating proxies/mixins in the base class.\n\nbackbone collection seems to have a hardcoded new this.model in it,\n\nI was thinking about doing something like:\n\n```\nmodelClass : function(){\n   return  this[postType]\n}\n```\n\n   this.model = this.model || this.modelClass()\n\n```\nnew this.model\n```\n\nis this a change you would like to have implemented, or are you opposed to it for an ideological reason?\n\nIf you want it, I'll implemented, as it will help me on a couple projects I'm working on.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/793/comments",
    "author": "dnsco",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2011-12-19T16:04:59Z",
        "body": "Fortunately, because of the (in my opinion, buggy) way that JavaScript constructors work, you can already do collections with polymorphic models. Like so:\n\n```\nvar Library = Backbone.Collection.extend({\n\n  model: function(attrs, options) {\n    if (condition) {\n      return new PublicDocument(attrs, options); \n    } else {\n      return new PrivateDocument(attrs, options);\n    }\n  }\n\n});\n```\n"
      },
      {
        "user": "dnsco",
        "created_at": "2012-01-17T22:05:42Z",
        "body": "Thanks dude, I wrote this issue when I was working on a client project, but now Imma integrate it into diaspora and it will be better <3333333\n"
      }
    ],
    "satisfaction_conditions": [
      "Support dynamic model type selection in Backbone collections",
      "Maintain Backbone's inheritance patterns",
      "Enable polymorphic model handling without base class modifications",
      "Provide conditional model instantiation based on data"
    ]
  },
  {
    "number": 526,
    "title": "[question] how to handle scroll event for window?",
    "created_at": "2011-08-02T00:51:08Z",
    "closed_at": "2011-08-03T18:39:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/526",
    "body": "``` javascript\nevents: {\n  \"scroll\": \"loadMore\"\n}\n```\n\nI'm not sure how to do it.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/526/comments",
    "author": "amrnt",
    "comments": [
      {
        "user": "jeremyckahn",
        "created_at": "2011-08-02T01:48:14Z",
        "body": "I'm assuming that this is an `events` key for a `View` bound to the window?  If so, then that looks like it should work.  `loadMore` just needs to be a method of that View Object.\n\nIf not, I think you have to manually bind the scroll event to the window:\n\n``` javascript\nvar example = Backbone.View.extend({\n  initialize: function () {\n    var self = this;\n\n    $(window).bind('scroll', function (ev) {\n      self.loadMore(ev);\n    });\n  },\n\n  loadMore: function () {\n    console.log('Loading more.');\n  }\n});\n```\n"
      },
      {
        "user": "amrnt",
        "created_at": "2011-08-02T08:55:45Z",
        "body": "in the first case, the `el` of the view should be `window` right?\n"
      },
      {
        "user": "jeremyckahn",
        "created_at": "2011-08-02T11:09:53Z",
        "body": "Yes, that's correct.  Does that work?\n"
      },
      {
        "user": "amrnt",
        "created_at": "2011-08-03T23:36:04Z",
        "body": "``` javascript\nclass window.MainView extends Backbone.View\n  el: \"window\"\n  events:\n    \"scroll\": \"render\"\n\n  initialize: ->\n    _.bindAll(@, \"render\")\n    @render()\n\n  render: ->\n    console.log \"scroll\"\n```\n\n``` javascript\n  routes:\n    '': 'welcome'\n\n  welcome: ->  \n    new MainView\n```\n\nWhen loading the main page, it will appear on console \"scroll\". but when scroll nothing happened.\n"
      },
      {
        "user": "jeremyckahn",
        "created_at": "2011-08-04T12:46:11Z",
        "body": "Try removing the code you have in `initialize` - just leave that blank.\n\nLet me make sure I'm understanding this; the `render` method gets called once, only on page load?  That's because you have an explicit call to `render` in your `initialize` method.  Try removing all the code you have in `initialize`.  Also, I think you need to replace this line:\n\n``` javascript\nel: \"window\"\n```\n\nwith this:\n\n``` javascript\nel: $(window)\n```\n\nI'm pretty unfamiliar with CoffeeScript's syntax, so perhaps that's implicit or I missed something else.  In either case, I believe that `el` needs to be a jQuery Object, not a raw DOM node or `window` Object.\n"
      },
      {
        "user": "amrnt",
        "created_at": "2011-08-04T12:48:53Z",
        "body": "yep. That just works!\n\nThanks\n"
      }
    ],
    "satisfaction_conditions": [
      "Correctly binds scroll event to window object in Backbone.View",
      "Ensures view's element (el) is properly configured as a jQuery-wrapped DOM element",
      "Maintains Backbone's event delegation pattern without conflicting initialization code",
      "Demonstrates proper event-to-method mapping in Backbone.View events hash"
    ]
  },
  {
    "number": 369,
    "title": "backbone doesn't find objects in (sub?)collections when saved with {silent: true}",
    "created_at": "2011-05-25T15:12:49Z",
    "closed_at": "2011-05-26T17:46:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/369",
    "body": "Hi, say we have a Dokuments collection and a Notes collection within Dokuments.\nI added this note and saved it later on silently. The id is returned from the server and is copied to the object, but it can't be found by get:\n\n> > > dok = Dokuments.get('4ddd0c2de8e6870c5e00000c')\n> > > dok.notes.get('4ddd1359e8e6870c5e00013f')\n> > > undefined\n\nbut:\n\n> > > dok.notes.last().get('id')\n> > > \"4ddd1359e8e6870c5e00013f\"\n\nThank you in advance for any hints\n--Frank\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/369/comments",
    "author": "fwoeck",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2011-05-26T17:46:11Z",
        "body": "That's correct -- the model's id isn't considered to have changed until the next \"change\" event fires. The model can still be found by its old id until that happens. If you'd like to trigger the \"change\" event yourself, just call `model.change()`.\n"
      },
      {
        "user": "fwoeck",
        "created_at": "2011-05-26T18:44:26Z",
        "body": "ahh I see, thank you for your reply!\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how Backbone's collection indexing interacts with silent model changes",
      "Clarification of when model IDs become searchable in collections after updates",
      "Identification of event-driven mechanisms affecting collection organization",
      "Guidance on manual synchronization between model changes and collection indexes"
    ]
  },
  {
    "number": 160,
    "title": "Can't get view events to bind",
    "created_at": "2010-12-31T03:53:25Z",
    "closed_at": "2010-12-31T20:16:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/160",
    "body": "I've been trying many different approaches, but I can't get the click function to bind.\n\nHere is the view I'm using:\n<code>\nsfProjectView = Backbone.View.extend({\n  el: $(\"#header-project\"),\n      events: {\n      \"click .click-project\": \"linkProject\"\n        },\n      linkProject: function() {\n      sfController.changeObject(currentTab(),this.model.sfAttrib(\"project\"));\n    },\n      superHtml: function() {\n      var supers = this.model.get(\"superprojects\");\n      var output = \"\";\n      if (supers) {\n         _.each(supers, function(super) {\n             output = output + \"<a href'#'>\" + sfObjects.get(super).get(\"name\") + \" > \" + \"</a>\";\n           });\n         return output;\n      } else {\n        return \"&nbsp;\";\n      }\n    },\n      initialize: function() {\n      _.bindAll(this, \"render\", \"linkProect\");\n      this.render();\n    },\n      render: function() {\n\n```\n  var project = this.model.sfGet(\"project\");\n  var projectActiveP = this.model.sfActive(\"project\");\n  var projectType = this.model.sfGet(\"projectType\");\n  var projectDom = \"#ajaxProject\";\n  var projectTypeDom = \"#projectType\";\n  var superProjectsDom = \"#superProjects\";\n  if (project) {\n    $(projectDom).text(project).css(\"display\",\"block\");\n    $(superProjectsDom).html(this.superHtml());\n    if (projectActiveP) {\n      $(projectDom).removeClass(\"inactive\");\n      $(projectDom).addClass(\"active\");\n      $(projectTypeDom + \" span:eq(1)\").html(\"\");\n    } else {\n      $(projectDom).removeClass(\"active\");\n      $(projectDom).addClass(\"inactive\");\n      $(projectTypeDom + \" span:eq(1)\").html(\"&nbsp;Project Complete\").addClass(\"green\");\n    }\n    if (projectType) {\n      $(projectTypeDom).css(\"display\",\"block\");\n      $(projectTypeDom + \" span:eq(0)\").text(\"Type:\");\n      $(projectTypeDom + \" a\").text(projectType);\n    }\n  } else {\n    $(this.id).css(\"display\",\"none\");\n  }\n  return this;\n}\n```\n\n</code>\nAny ideas greatly appreciated!\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/160/comments",
    "author": "gibsonf1",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2010-12-31T04:12:38Z",
        "body": "Are you sure that `#header-project` is actually a DOM element on the page at the time that the JS is first loaded?\n"
      },
      {
        "user": "gibsonf1",
        "created_at": "2010-12-31T07:42:32Z",
        "body": "Yes, I moved all the Backbone code after document ready at one point, and also tried with id, none of which worked.  I'm stumped.  What is going on conceptually in achieving the binding?\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2010-12-31T12:16:33Z",
        "body": "What's going on is that you're replacing `this.el` with a new element manually -- probably something you don't want to be doing. Try removing the line:\n\n```\nel: $(\"#header-project\")\n```\n\nAnd adding this to the bottom of `initialize` instead, right before calling `this.render()`.\n\n```\n$(\"#header-project\").append(this.el);\n```\n"
      },
      {
        "user": "gibsonf1",
        "created_at": "2010-12-31T13:54:01Z",
        "body": "Wow, that almost did it.  Backbone made a new div subordinate to the selector with the event, but it was unclickable.  I changed it to this:\n <code>  \n initialize: function() {\n      _.bindAll(this, \"render\");\n      this.render();\n      $(\"#ajaxProject\").wrap(this.el);\n    },\n</code>\nUsing this wrap, I now have events!  I had to narrow the selector of the wrap to the element I wanted to have clicked only.  Is this new element strictly made for event rendering and the view displays itself regardless?\n\nThanks Jeremy!\n"
      }
    ],
    "satisfaction_conditions": [
      "Ensures the view's root element is properly integrated with existing DOM elements for event delegation",
      "Maintains Backbone's event delegation mechanism through correct element attachment",
      "Avoids element replacement that breaks Backbone's event listeners"
    ]
  },
  {
    "number": 126,
    "title": "Collection.create does not return a server response in the success callback",
    "created_at": "2010-12-08T08:15:03Z",
    "closed_at": "2010-12-08T22:23:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/126",
    "body": "After creating a new model (using 'create'), I want to assign an id to the model that corresponds to the id the server generated. Unfortunately there is currently a bug in the create function that removes the response from the model.save success callback.\n\nIt's easy to fix but is there a specific reason for doing this that I'm missing? Should server-generated id's be assigned to models in a different way?\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/126/comments",
    "author": "dickbrouwer",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2010-12-08T14:23:20Z",
        "body": "There's a couple things here... `create` should not be throwing away the `success` callback.\n\n```\ncollection.create(attrs, {success: function(model, response){ ... }});\n```\n\nBut, also, if your server responds with a JSON representation of the model, all of the attributes you send down, including the `id`, should be set on the model for you. There's no need to use the `success` callback for this -- only for triggering some side-effect.\n"
      },
      {
        "user": "dickbrouwer",
        "created_at": "2010-12-11T08:35:40Z",
        "body": "Great - success response is preserved now.\n\nSorry, you're right about how to update the id. My server JSON response wasn't namespaced as 'model'. That works  beautifully now.\n\nThanks for the great work on Backbone!\n"
      }
    ],
    "satisfaction_conditions": [
      "Ensures server-generated IDs are automatically assigned to models without manual intervention",
      "Preserves server response data in success callbacks for create operations",
      "Works with standard Backbone.js attribute parsing behavior"
    ]
  },
  {
    "number": 122,
    "title": "model.previous() example abuses scope in change event callback",
    "created_at": "2010-12-07T06:47:29Z",
    "closed_at": "2010-12-08T00:06:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/pull/122",
    "body": "The example uses `bill.previos(\"name\")` instead of `model.previous(\"name\")` in the `change` callback defined on `bill`.\n\nThe example works just fine, but the callback will not work if `bill` is redefined or lost from scope (pardon if I'm wrong, I'm not as intricately knowledgable in JS as I'd like).\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/122/comments",
    "author": "mtodd",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2010-12-07T16:06:13Z",
        "body": "Hey Matt.\n\nIn JavaScript, using either `model` or `bill` is fine here. `bill` is closed over by the anonymous function, and cannot be lost from its scope. I chose to use `bill` in this example because it's a slightly more descriptive word than `model`, but both are interchangeable.\n"
      },
      {
        "user": "mtodd",
        "created_at": "2010-12-08T04:23:50Z",
        "body": "My main concern, contrived though it was (ironic since this is all contrived API documentation, lol), was if `bill` was overwritten that it would break. But, as API documentation, it matters not :)\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how the callback retains access to the original variable instance despite potential redefinitions in the outer scope",
      "Validation that the example's variable usage is safe in typical JavaScript closure behavior"
    ]
  },
  {
    "number": 90,
    "title": "Access a collection from a model",
    "created_at": "2010-11-23T19:36:47Z",
    "closed_at": "2010-11-24T04:24:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/90",
    "body": "I need to access a collection from a model, and I get an error\n\nRelevant code:\n\n```\n$( function() {\n    var namespace = window;\n\n    namespace.Move = Backbone.Model.extend({\n        markable: function(){\n            var below = namespace.Moves.find(function(move) { // <= HERE !!!\n                return move.get(\"i\") === that.get('i')-1;\n            });\n            if(below !== undefined && !below.isNew()) return true;\n            return false;\n        }\n    });\n\n    namespace.Moves = Backbone.Collection.extend({\n        model: Move,\n        localStorage: new Store(\"moves\")\n    });\n});\n```\n\nStack trace (chromium):\n\n```\nUncaught TypeError: Object function (){return a.apply(this,arguments)} has no method 'find'\nj.c.each.c.forEach:9292/javascripts/vendor/underscore-min.js:9\nnamespace.RowView.Backbone.View.extend.render:9292/javascripts/views.js:30\nc.bind:9292/javascripts/vendor/underscore-min.js:16\nnamespace.AppView.Backbone.View.extend.add:9292/javascripts/views.js:72\nc.bind:9292/javascripts/vendor/underscore-min.js:16\nnamespace.AppView.Backbone.View.extend.render:9292/javascripts/views.js:66\nc.bind:9292/javascripts/vendor/underscore-min.js:16\nnamespace.AppView.Backbone.View.extend.initialize:9292/javascripts/views.js:60\ne.View:9292/javascripts/vendor/backbone-min.js:22\nr.d:9292/javascripts/vendor/backbone-min.js:26\n(anonymous function):9292/javascripts/views.js:77\nc.extend.ready:9292/javascripts/vendor/jquery-1.4.2.min.js:26\nL\n```\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/90/comments",
    "author": "clyfe",
    "comments": [
      {
        "user": "clyfe",
        "created_at": "2010-11-23T19:51:07Z",
        "body": "Note that Model#markable gets called from an `_.template()` via `this.model.markable()`\n\n```\nnamespace.MoveView = Backbone.View.extend({\n    tagName:  \"td\",\n    template: _.template($('#move-template').html()),\n    initialize: function() {\n        _.bindAll(this, \"render\");\n    },\n    render: function() {\n        $(this.el).html(this.template(this.model.toJSON()));\n        return this;\n    }\n});\n\n\n<script type=\"text/html\" id=\"move-template\">\n\n    <%= console.log(this.model.cid) %>\n    <%= console.log(this.model.markable()) %>\n\n  <div\n    id=\"square-<%= i %>-<%= j %>\"\n    class=\"square square-row-<%= i %> square-column-<%= j %>\"\n    ><%= mark %></div>\n\n</script>\n```\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2010-11-23T20:24:16Z",
        "body": "Looks like `Moves` doesn't actually have a `find` method defined. Right? Are you looking for `detect`?\n"
      },
      {
        "user": "clyfe",
        "created_at": "2010-11-24T09:41:51Z",
        "body": "Changing `find` with `detect` doesn't work either\n\n```\nUncaught TypeError: Object function (){return a.apply(this,arguments)} has no method 'detect'\n```\n\nThe thing is either the `namespace.Moves` from inside `Move#markable` is not the same with the later-on-defined `namespace.Moves`, in witch case this seems like a \"chicken and egg\" issue, either `namespace.Moves` is hidden behind some proxy function somewhere...\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2010-11-24T13:14:19Z",
        "body": "Oh, of course. `namespace.Moves` is the collection class (the constructor function) -- not an instance of the collection. If you'd like to make an instance of it, you'll need:\n\n```\nnew namespace.Moves\n```\n"
      },
      {
        "user": "clyfe",
        "created_at": "2010-11-24T15:31:34Z",
        "body": "Indeed that is the issue, basic mistake. Thank you. \n"
      }
    ],
    "satisfaction_conditions": [
      "Clarify the relationship between Backbone Collection classes and instances",
      "Ensure collection methods are called on properly initialized instances"
    ]
  },
  {
    "number": 58,
    "title": "Can't update model from within a change callback",
    "created_at": "2010-11-05T15:37:20Z",
    "closed_at": "2010-11-06T02:58:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/58",
    "body": "I'm trying to figure out how to act on a changed select dropdown. My view renders multiple select controls and changing each one might trigger a change in subsequent ones (think \"Country\" -> \"City\" select sequence).\n\nProblem is, according to \"cautionary notes\" in the docs, \"change\", \"submit\", and \"reset\" events do not bubble in current versions of Internet Explorer. Which means I can't use the view's event delegation, I suppose.\n\nSo, I tried attaching my change handler directly to the select element:\n\n```\n.change(function(e) { currentView.model.set({selectedAttribute: $(this).val()}); })\n```\n\nThis doesn't work, because I end up in a render function that has \"this\" set to the model (?), not the view. The call stack is:\n\nmy view's render function (this is where I end up)\nbackbone.js:92\nbackbone.js:291\nbackbone.js:168\nmy .change() function\n\nSo it seems that changing the model triggers an immediate re-rendering of the view (which is fine), but I end up with this.model being undefined, because this points to my model.\n\nI'm surely doing something wrong, but any pointers appreciated.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/58/comments",
    "author": "jwr",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2010-11-05T19:58:20Z",
        "body": "Give this a try:\n\n```\n.change(function(e) { \n  currentView.model.set({selectedAttribute: $(e.target).val()}); \n})\n```\n"
      },
      {
        "user": "jwr",
        "created_at": "2010-11-05T20:18:38Z",
        "body": "No, that doesn't change anything.\n\nPerhaps I haven't explained precisely what happens. What I get is:\n\"TypeError: Result of expression 'this.model' [undefined] is not an object.\"\n\nin my render function. Same view that has the select control and that defines the change() event handler.\n\nFrom what I understand, the change event fires for the select control, which causes the model to get updated, which causes the model's change event to fire, which causes the view's render function to get called. This is all fine. What I don't understand is why this.model is undefined within the render function. It is only undefined if render is triggered by the change event.\n\nPerhaps I'm doing something really stupid \u2014 but I can't figure out another way to have select controls that update the model (which should cause the view to change).\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2010-11-05T20:24:37Z",
        "body": "Ahh, I'm sorry. Try adding this line to your `initialize` function (which will bind `render` to the current instance).\n\n```\n_.bindAll(this, 'render');\n```\n\nYou can add any other functions to that call, to ensure that their `this` is preserved. Take a look at the docs on Underscore's `bindAll` for the details.\n"
      },
      {
        "user": "jwr",
        "created_at": "2010-11-05T20:40:46Z",
        "body": "Ah, that seems to do the trick. I will do this from now on. I don't understand how the render method can be useful to people without this, though \u2014 I thought most people would eventually see render() called from within an event handler.\n\nMany thanks for your help and for the great code you share!\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2010-11-05T20:45:46Z",
        "body": "It depends on how you call it from within the event handler. If you're calling it like this:\n\n```\nbind(\"event\", model.render);\n```\n\n... you'll have to bind it in advance. If you're calling it like this:\n\n```\nbind(\"event\", function(){ model.render(); });\n```\n\n... you'll have no such problem.\n"
      }
    ],
    "satisfaction_conditions": [
      "Preserves view context in event handlers",
      "Ensures model changes trigger view updates without undefined references",
      "Explains context binding for event-triggered methods",
      "Works with Backbone/Underscore event patterns",
      "Avoids manual context wrapping in anonymous functions"
    ]
  }
]