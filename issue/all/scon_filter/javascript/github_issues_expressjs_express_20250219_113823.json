[
  {
    "number": 5331,
    "title": "Cannot route to a specific route",
    "created_at": "2023-11-23T18:11:28Z",
    "closed_at": "2023-11-25T14:26:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/5331",
    "body": "> This is the route that I want the express to route\r\n```\r\napp.use('/griev', require('./routes/api/grievance'));\r\n\r\napp.all('*', (req, res) => {\r\n    res.status(404);\r\n    if (req.accepts('html')) {\r\n        res.sendFile(path.join(__dirname, 'views', '404.html'));\r\n    } else if (req.accepts('json')) {\r\n        res.json({ \"error\": \"404 Not Found\" });\r\n    } else {\r\n        res.type('txt').send(\"404 Not Found\");\r\n    }\r\n});\r\n```\r\n> This is my grievance api route\r\n\r\n```\r\nconst express = require('express');\r\nconst router = express.Router();\r\nconst grievController = require('../../controllers/grievController');\r\nconst ROLES_LIST = require('../../config/roles_list');\r\nconst verifyRoles = require('../../middleware/verifyRoles');\r\n\r\nconsole.log(\"griev route\")\r\n\r\nif (verifyRoles(ROLES_LIST.User)) {\r\n    router.post(grievController.createIssue);\r\n}\r\nelse\r\n    console.log(\"could not verify\");\r\n\r\n\r\nmodule.exports = router;\r\n```\r\n**All I get is 404 error whenever I make a post request to ```/griev``` route** ",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/5331/comments",
    "author": "premsai-konduru",
    "comments": [
      {
        "user": "AverageY",
        "created_at": "2023-11-23T20:03:32Z",
        "body": "Does adding a route to the post fix it?\n\n```\nrouter.post('/' , controller);\n```"
      },
      {
        "user": "premsai-konduru",
        "created_at": "2023-11-24T14:32:28Z",
        "body": "@AverageY Yeah, It solved, thank you, I did not even notice that simple thing, may be I just copy pasted the code of another route which had something like router.route('/').post.get something, I am sorry for this question "
      }
    ],
    "satisfaction_conditions": [
      "Route path must be explicitly defined in the route handler",
      "Route handler structure must follow Express.js conventions"
    ]
  },
  {
    "number": 5039,
    "title": "[suggestion] Add a new method like response.sendValue() to support number values.",
    "created_at": "2022-11-08T19:29:38Z",
    "closed_at": "2022-11-08T20:19:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/5039",
    "body": "### Issue\r\nIt's always painful to send a number as a response,\r\nI have to un-necessarily convert the value to String before sending a response if value is a number,\r\nhowever, if a use case exists when the same controller sends mixed types as response then there is an additional step involved to convert the value to String only if it's a number.\r\nEven explicitly chaining with `status()` like `res.status(200).send(aNumberValue)` doesn't help.\r\n### Proposal\r\nhow about Adding a new Method like response.sendValue() which can be a wrapper on top of response.send() which will send the value as it is without setting it as the status of the response?\r\nsomething like:\r\n```Javascript\r\nres.sendValue = function sendValue(value) {\r\n  if (typeof value === \"number\") {\r\n    value = String(value);\r\n  }\r\n  return this.send(value);\r\n};\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/5039/comments",
    "author": "shubanker",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2022-11-08T19:41:55Z",
        "body": "Hi @shubanker is the number you are sending a JSON response? If so `res.json()` should work for numbers directly. I ask because `res.send(String(num))` sends a `text/html` response as a.... number? Not sure if that is very useful, though, as the HTML response should usually have more substance to it.\n\n---\n\nFWIW `res.send(number)` no longer does the sending of the status code in Express 5, as that functionality was deprecated in 4.x and removed in 5. Not sure if that achieves what you're asking, though."
      },
      {
        "user": "shubanker",
        "created_at": "2022-11-08T20:19:18Z",
        "body": "> FWIW `res.send(number)` no longer does the sending of the status code in Express 5, as that functionality was deprecated in 4.x and removed in 5. Not sure if that achieves what you're asking, though.\r\n\r\nwow wasn't aware of this (still in 4.x), thanks for the update.\n\n---\n\n> Hi @shubanker is the number you are sending a JSON response? If so `res.json()` should work for numbers directly. I ask because `res.send(String(num))` sends a `text/html` response as a.... number? Not sure if that is very useful, though, as the HTML response should usually have more substance to it.\r\n\r\nThanks a ton, `res.json()` fulfills my purpose (seems I have been using inappropriate method all along \ud83d\ude06)."
      }
    ],
    "satisfaction_conditions": [
      "Solution must allow sending numeric values as responses without manual string conversion",
      "Solution must maintain proper content type handling for numeric responses",
      "Solution must work with existing Express response methods where applicable",
      "Solution must avoid unintended side effects like status code misinterpretation"
    ]
  },
  {
    "number": 4972,
    "title": "express.urlencoded() undefined extended",
    "created_at": "2022-08-18T00:48:09Z",
    "closed_at": "2022-08-24T01:49:54Z",
    "labels": [
      "question",
      "module:body-parser"
    ],
    "url": "https://github.com/expressjs/express/issues/4972",
    "body": "Hi there! I'm sorry if this isn't the place to ask, but I cannot think of how else to find this answer other than asking right on the repo. I've been googling and rereading the docs like crazy around urlencoded() and I see on the docs its \"default\" is set to true.\r\n\r\nI understand I'm supposed to pass in either true or false on extended, but why do I have to if there's already a default to true? I also understand that this may change anyways in Express 5, but for Express 4, it's really bothering me without an explanation. \r\n\r\n`app.use(express.urlencoded());` produces this error: `body-parser deprecated undefined extended: provide extended option`\r\n\r\nProviding the line and error for a visual example. \r\n\r\n**TL;DR** Why do I have to pass in  {extended: bool} instead of leaving it empty for the default of true? \r\n\r\nIf this doesn't belong in issues, feel free to delete/close it. Just hoping someone can answer my burning question on this. I teach Express to students and this has always been hard to dance around when I'm not sure why in the first place! \r\n\r\nTIA! ",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4972/comments",
    "author": "NikkiHmltn",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2022-08-18T03:40:31Z",
        "body": "Hi @NikkiHmltn it's no problem to ask here; we get many questions in the issue tracker and just where ever.\r\n\r\nSo for your question, it comes down to a bit of history, really. Back a long time ago, Express.js started using the Qs module to parse the URL query string, and then also the urlencoded request body. But how exactly Qs worked was non-standard, and also it turned out just surprising to users. Users would end up writing applications that didn't expect urlencoded bodies to have rich values like objects and such, and it was causing applications to contain accidental security issues. This was reported to the Express.js project over the years, and though it's not a vulnerability in Express.js itself, the decision was made in conjunction with application security experts to change the default to a more \"normal\" version and then add this \"warning\" to the current Express.js such that users would explicitly state how they wanted it parsed, so they should more consciously make the decision to use the more rich \"extended\" parser and know they'll be expecting these rich values from user input and write their code to handle them appropriately.\r\n\r\nI hope that helps."
      },
      {
        "user": "NikkiHmltn",
        "created_at": "2022-08-24T01:49:54Z",
        "body": "That helps so much!! I deeply appreciate this answer and will pass it along! :pray: \r\n"
      }
    ],
    "satisfaction_conditions": [
      "Explains the historical context behind requiring explicit 'extended' option configuration",
      "Clarifies the security rationale for deprecating implicit defaults",
      "Addresses the relationship between developer awareness and security practices",
      "Differentiates between technical defaults and deprecation strategy"
    ]
  },
  {
    "number": 4879,
    "title": "The router restore function can incorrectly set variables to undefined",
    "created_at": "2022-04-03T14:26:13Z",
    "closed_at": "2022-04-03T16:13:04Z",
    "labels": [
      "question",
      "module:router"
    ],
    "url": "https://github.com/expressjs/express/issues/4879",
    "body": "I found a case where `request.params` becomes undefined. Here is a concrete test case to reproduce the case:\r\n\r\n```javascript\r\n// test/app.router.js\r\n\r\nit('should have req.params in finish event after handler2 calls next', function(done){\r\n  var app = express();\r\n\r\n  function handler1(req, res, next) {\r\n    res.once('finish', function() {\r\n      setTimeout(function() {\r\n        assert(req.params.id);\r\n      })\r\n    })\r\n\r\n    next()\r\n  }\r\n\r\n  function handler2(req, res, next){\r\n    res.end(req.params.id);\r\n    next()\r\n  }\r\n\r\n  app.get('/user/:id', handler1, handler2);\r\n\r\n  request(app)\r\n  .get('/user/1')\r\n  .expect(200, '1', done);\r\n})\r\n```\r\n\r\nThe test runs fine if there is no `next` call in `handler2`. The `setTimeout` in `handler1` ensures that the test fails.\r\n\r\nAs I understand it, the last `next` will cause the function `done` to be called in the router:\r\n\r\n```javascript\r\n// lib/router/index.js\r\n\r\n// no more matching layers\r\nif (idx >= stack.length) {\r\n    setImmediate(done, layerError);\r\n    return;\r\n}\r\n```\r\n\r\nThe problem is that `done` is not working correctly in this case. If there are middlewares and no router the `done` function will replace `baseUrl`, `next`, and `params` with the value `undefined`.\r\n\r\n```javascript\r\n// lib/router/index.js\r\n\r\n// restore vals\r\nfor (var i = 0; i < props.length; i++) {\r\n    obj[props[i]] = vals[i];\r\n}\r\n```\r\n\r\nHence the `setTimeout` in the `handler1`. Without a timeout, the `handler1` function mostly finishes successfully before `done` is called in the next iteration of the event loop.\r\n\r\nMy proposal to fix the problem would be to check for `undefined`:\r\n\r\n```javascript\r\n// lib/router/index.js\r\n\r\n// restore vals\r\nfor (var i = 0; i < props.length; i++) {\r\n  if (vals[i] !== undefined) {\r\n    obj[props[i]] = vals[i];\r\n  }\r\n}\r\n```\r\n\r\nBefore creating a pull request I would like to hear if I missed some details or a better solution.\r\n\r\nI think better would if the `done` function would not try to restore anything if there is no router at all. But I could not figure out a good way to do that.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4879/comments",
    "author": "floftar",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2022-04-03T16:13:04Z",
        "body": "This is working as designed. When the code path exits the router, all the values are cleared."
      },
      {
        "user": "floftar",
        "created_at": "2022-04-06T16:49:37Z",
        "body": "Thanks for the explanation!\r\n\r\nI guess that function name `restore` confused me because I thought that the function should always try to restore the variables.\r\n\r\nWhy are only `baseUrl`, `next`, and `params` request properties cleared? For instance, `query` and `method` are still available in my test case."
      },
      {
        "user": "dougwilson",
        "created_at": "2022-04-06T16:53:25Z",
        "body": "Hi @floftar because inside the `handle` function, those are the only properties that are manipulated, so it is being responsible for restoring those properties back to the values they were when the `req` first entered into that `handle` function."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why specific request properties (baseUrl, next, params) are cleared when exiting router processing",
      "Clear description of the router's state management design principles",
      "Validation of whether undefined check is an appropriate solution pattern",
      "Guidance on handling asynchronous operations with request context cleanup",
      "Explanation of request property lifecycle management in nested middleware scenarios"
    ]
  },
  {
    "number": 4825,
    "title": "[feature request] disable decode_param for path routing",
    "created_at": "2022-02-16T16:41:08Z",
    "closed_at": "2024-08-23T09:01:42Z",
    "labels": [
      "question",
      "module:router"
    ],
    "url": "https://github.com/expressjs/express/issues/4825",
    "body": "I have some special urls thats get mapped to local files like image50%.png.\r\n\r\n```\r\napp.get('/open/:path(*)', (req, res) => {})\r\n```\r\n\r\nBut it doesn't work because express automaticly calls decode_param.\r\nIt throws `Failed to decode param`.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4825/comments",
    "author": "lublak",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2022-02-16T16:48:23Z",
        "body": "Hi @lublak sorry you are having trouble. There is no need to disable the decoding for this. Your client should be sending the URL as a valid encoding of `/open/image50%25.png` \ud83d\udc4d . If you really want to avoid decoding for your use-case if you need to accept improperly encoded URLs, you can use something like `app.use('/open', (req, res) => {})` and then `req.url` will just be the part after `/open`. I hope that helps!\n\n---\n\nApologies, I didn't mean to close the issue, as we could add some kind of app-level config to disabled/custom the param decoding."
      },
      {
        "user": "lublak",
        "created_at": "2022-02-16T17:21:58Z",
        "body": "@dougwilson The problem is that the client is Firefox and it sends this over quite validly (not with %25) the user of course enters image50%.png and not image50%25.png.\r\nI will try that with `app.use('/open', (req, res) => {})` tomorrow."
      },
      {
        "user": "dougwilson",
        "created_at": "2022-02-16T17:28:53Z",
        "body": "Hi @lublak by invalid, I am referring to what Express.js considers invalid. The reason you are getting the error is indeed because the URL is invalid according to Express.js, as it expects parameters to be URL-encoded and if the JavaScript function to decode URL-encoded strings, `decodeURIComplement` throws as invalid, then Express.js will bubble up that error. I did not make any statements regarding how Firefox works, of course, though my understanding is it will send whatever the user types in, regardless of what the web server is expecting. My guess, though, is that Firefox will still turn spaces into `%20`, so if you disable the param decoding, a URL like `/open/foo bar.jpg` will end up as `foo%20bar.jpg` on the server when you have decoding disabled, even if the user typed in a literal space, so turning it off probably has down sides."
      },
      {
        "user": "lublak",
        "created_at": "2022-02-16T18:03:32Z",
        "body": "@dougwilson That's right I didn't think about that of course blank characters are then given as %20 by the browser. The same is true for other characters like \"\u00e4\".\r\nFor me it means that all \"invalid\" % characters must be replaced by %25 to decodeURIComplement .\r\n\r\n```js\r\napp.use('/open', (req, res) => {\r\n   const path = decodeURIComplement(makeItValid(req.url));\r\n})\r\n```\r\nI will try to implement it tomorrow. Thanks for the thought :)"
      },
      {
        "user": "dougwilson",
        "created_at": "2022-02-16T18:06:30Z",
        "body": "No problem. The current behavior of decoding params won't be changed, as there can be security implications of your proposal, but it would depend on the application if they are relevant or not. But the feature request, as I see it, would allow the user (like yourself) to implement any kind of decoding routine as they see fit, which would allow you to write any type of logic that works for your particular use case \ud83d\udc4d "
      },
      {
        "user": "lublak",
        "created_at": "2022-02-17T10:14:48Z",
        "body": "@dougwilson for me it works fine :) thanks for your tip.\r\nBut i decided only support some %. `urlPath.replace(/%([&$%.-_ #?=*/]|$)/g, '%25$1')`"
      }
    ],
    "satisfaction_conditions": [
      "Ability to process URL paths containing unencoded special characters like '%' without validation errors",
      "Mechanism to bypass Express's automatic parameter decoding while maintaining other URL processing benefits",
      "Support for custom URL decoding logic that can handle mixed properly-encoded and raw characters",
      "Maintain compatibility with standard browser encoding behaviors for spaces/special characters"
    ]
  },
  {
    "number": 4677,
    "title": "Regex as path not functioning as expected",
    "created_at": "2021-08-15T23:09:39Z",
    "closed_at": "2021-08-15T23:15:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4677",
    "body": "In my express app, I have the following code:\r\n```js\r\napp.all(/\\/port\\/(([1-9]\\d{0,3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5]))\\/.*/g,(req,res,next){\r\n   // ...\r\n})\r\n```\r\nHalf the time, when going to /port/3001 it 404s, the other half of the time it works. It seems like the regex system used by Express is the cause as testing this using \r\n```js\r\n/\\/port\\/(([1-9]\\d{0,3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5]))\\/.*/g.test('/port/3001')\r\n``` \r\nreturns true.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4677/comments",
    "author": "williamhorning",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2021-08-15T23:15:08Z",
        "body": "You should not have the global flag on your regexp, as that is how the global flag works. You can see this in plan JavaScript:\r\n```js\r\nvar re = /\\/port\\/(([1-9]\\d{0,3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5]))/g\r\nconsole.log(re.test('/port/3001')) // => true\r\nconsole.log(re.test('/port/3001')) // => false\r\n\r\nvar re = /\\/port\\/(([1-9]\\d{0,3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5]))/ // no global flag\r\nconsole.log(re.test('/port/3001')) // => true\r\nconsole.log(re.test('/port/3001')) // => true\r\n\r\n```\r\n\r\nIf you remove the global flag, then each test will always start from the start of the string, which is what you are expecting. If you didn't want that behavior, you would have the global flag on, but from your report, you are expecting the opposite behavior of the global flag. This is how regular expressions work in javascript, unrelated to Express. I hope that helps."
      },
      {
        "user": "williamhorning",
        "created_at": "2021-08-16T00:45:41Z",
        "body": "> You should not have the global flag on your regexp, as that is how the global flag works. You can see this in plan JavaScript:\r\n> \r\n> ```js\r\n> var re = /\\/port\\/(([1-9]\\d{0,3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5]))/g\r\n> console.log(re.test('/port/3001')) // => true\r\n> console.log(re.test('/port/3001')) // => false\r\n> \r\n> var re = /\\/port\\/(([1-9]\\d{0,3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5]))/ // no global flag\r\n> console.log(re.test('/port/3001')) // => true\r\n> console.log(re.test('/port/3001')) // => true\r\n> ```\r\n> \r\n> If you remove the global flag, then each test will always start from the start of the string, which is what you are expecting. If you didn't want that behavior, you would have the global flag on, but from your report, you are expecting the opposite behavior of the global flag. This is how regular expressions work in javascript, unrelated to Express. I hope that helps.\r\n\r\nah, thanks, i was wondering why this didn't work."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why the global flag causes inconsistent regex matching behavior in Express routes",
      "Clarification that Express route regex patterns should not use global flags",
      "Identification of JavaScript regex statefulness as the root cause rather than Express-specific behavior"
    ]
  },
  {
    "number": 4655,
    "title": "data is not coming on server",
    "created_at": "2021-07-23T13:25:36Z",
    "closed_at": "2021-07-23T16:20:10Z",
    "labels": [
      "question",
      "module:body-parser"
    ],
    "url": "https://github.com/expressjs/express/issues/4655",
    "body": "i was trying node.js in typescript and code is same as JS but data is not coming on server\r\n\r\n\r\napp.ts file\r\n```\r\nimport express from 'express'\r\nimport bodyParser from 'body-parser'\r\nimport config from '../config/config'\r\nimport logging from '../config/logger'\r\nimport { connectDB } from './utils/DB'\r\n// init express variable to app ==========\r\nconst app = express()\r\n\r\n\r\nconst NAMESPACE = 'server'\r\n\r\n\r\n// body parser ===========================\r\napp.use(express.json())\r\napp.use(express.urlencoded({ extended: false }))\r\n\r\nconnectDB()\r\n\r\n// logger ===================================\r\napp.use((req, res, next) => {\r\n    logging.info(NAMESPACE, `METHOD - [${req.method}], URL - [${req.url}], IP - [${req.socket.remoteAddress}]`)\r\n    res.on('finish', () => {\r\n        logging.info(NAMESPACE, `METHOD - [${req.method}], URL - [${req.url}], IP - [${req.socket.remoteAddress}], STATUS - [${res.statusCode}]`)\r\n    })\r\n    next()\r\n})\r\n\r\n\r\n// routes ======================================\r\nimport loginRoutes from './routes/login'\r\n\r\napp.use('/api/login', loginRoutes)\r\n\r\n\r\n\r\n// error handling ===============================\r\napp.use((req, res, next) => {\r\n    const error = new Error('Page not found');\r\n    return res.json({ message: error.message, statusCode: 404 }).status(404);\r\n})\r\n\r\n\r\n// server start =================================\r\napp.listen(config.server.port, () => {\r\n    console.log(`Server started on port ${config.server.port}`);\r\n})\r\n```\r\n\r\n\r\nroute/login.ts file\r\n```\r\nimport express from 'express'\r\nimport login_contollers from '../controllers/login'\r\nconst loginAPI = express.Router()\r\n\r\nloginAPI.post('/user', login_contollers.login)\r\n\r\n\r\nexport default loginAPI\r\n```\r\n\r\ncontroller/login.ts file\r\n\r\n```\r\nimport jwt from \"jsonwebtoken\";\r\n\r\ndeclare var process: {\r\n    env: {\r\n        JWT_SECRET_KEY: string,\r\n        JWT_EXPIRE_TIME: number\r\n    }\r\n}\r\n\r\n\r\nconsole.log(process.env.JWT_EXPIRE_TIME)\r\n\r\n// creating jsonwebtoken\r\n\r\nconst getToken = async (id: String) => {\r\n    console.log('from getToken', id)\r\n    return jwt.sign({ id }, process.env.JWT_SECRET_KEY, {\r\n        // in what time token expire\r\n        expiresIn: process.env.JWT_EXPIRE_TIME\r\n    })\r\n}\r\n\r\n\r\n// interface req {\r\n//     body: string,\r\n// }\r\n\r\n\r\nconst login = async (req: any, res: any, next: any) => {\r\n    console.log(req.body)\r\n     if (!id) {\r\n         return res.json({message:'please add id'}).status(200)\r\n     } else {\r\n         const token = await getToken(id)\r\n         console.log(token)\r\n         return res.json({ message: 'hello', token })\r\n     }\r\n    next()\r\n}\r\n\r\nconst LOGIN_API = {\r\n    login\r\n}\r\n\r\nexport default LOGIN_API\r\n```\r\n\r\n**in terminal it showing blank array like this {}**\r\n\r\nbut it did't work so i try bodyParser but that is also not working....\r\n\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4655/comments",
    "author": "arunsingh28",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2021-07-23T15:05:23Z",
        "body": "Can you put `console.log(req.headers)` right above the output of req.body and paste the output of that here?"
      },
      {
        "user": "arunsingh28",
        "created_at": "2021-07-23T16:17:17Z",
        "body": "its showing the headers \r\n\r\n```\r\n[2021-07-23T16:15:59.835Z] [INFO] [server] METHOD - [POST], URL - [/api/login/user], IP - [::1]\r\n{\r\n  'content-type': 'text/plain',\r\n  'user-agent': 'PostmanRuntime/7.28.2',\r\n  accept: '*/*',\r\n  'postman-token': '744012c2-31fb-485b-9927-0e986da8d27e',\r\n  host: 'localhost:8080',\r\n  'accept-encoding': 'gzip, deflate, br',\r\n  connection: 'keep-alive',\r\n  'content-length': '28'\r\n}\r\n```"
      },
      {
        "user": "dougwilson",
        "created_at": "2021-07-23T16:20:10Z",
        "body": "So the issue is unrelated to your typescript usage. You used two different body prasers, neither of which parse `text/plain` bodies. For that, you want to use the text paraer (`express.text()`)."
      },
      {
        "user": "arunsingh28",
        "created_at": "2021-07-23T16:21:40Z",
        "body": "thanks a lot now it is working."
      }
    ],
    "satisfaction_conditions": [
      "Identify why request body parsing fails for text/plain content-type",
      "Explain how to configure Express middleware for different content types",
      "Demonstrate how to verify request headers affecting body parsing",
      "Address middleware configuration rather than TypeScript-specific issues"
    ]
  },
  {
    "number": 4646,
    "title": "Can I integrate cors library into express Framework? ",
    "created_at": "2021-07-16T11:47:39Z",
    "closed_at": "2021-07-16T13:32:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4646",
    "body": "**Hello everyone! I Hope you are going well!**\r\n\r\nMy question is there is the ability to integrate **cors** library into express.js Framework?\r\nJust like body-parser?\r\nIf not I'm gonna be glad and happy to know the reasons!\r\n\r\n**Thank you!**",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4646/comments",
    "author": "mouadTaoussi",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2021-07-16T13:32:44Z",
        "body": "Hello! This is a duplicate of a similar request, but I can't seem to find it right now. The consensus there was no. The reasoning is that the desire is to keep it to essential components only, and break things into individual middlewares.\r\n\r\nThe body-parser is included only because there is very little you can do if you cannot read the body of a request. But CORS is only necessary if you are trying to share your resources cross domain."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of Express.js' design philosophy regarding middleware inclusion",
      "Clarification of what constitutes an 'essential' component in Express.js",
      "Confirmation that CORS functionality can be added through external middleware"
    ]
  },
  {
    "number": 4529,
    "title": "Router only response first route if using dependency injection on router",
    "created_at": "2021-02-18T07:23:22Z",
    "closed_at": "2021-02-18T07:36:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4529",
    "body": "This is related to #4528 \r\n\r\nFull codes are as per following:\r\n\r\n<details>\r\n<summary>/index.js</summary>\r\n\r\n```js\r\nconst express = require('express');\r\nconst app = express();\r\n\r\napp.use('/buy',require('./routes/buy'))\r\napp.use('/sell',require('./routes/sell'))\r\n\r\napp.listen(5000,()=>{\r\n  console.log('Server start')\r\n})\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>/routes/buy.js</summary>\r\n\r\n```js\r\nconst express = require('express')\r\nconst router = express.Router()\r\nconst buyController = require('../controller/buy.js')\r\n\r\nrouter.use('/:id/log', require('./log')(router, 'BuyModel'))\r\nrouter.route('/').get(buyController.fetchBuys)\r\n\r\nmodule.exports = router\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>/routes/sell.js</summary>\r\n\r\n```js\r\nconst express = require('express')\r\nconst router = express.Router()\r\n\r\nrouter.use('/:id/log', require('./log')(router, 'SaleModel'))\r\n\r\nmodule.exports = router\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>/routes/log.js</summary>\r\n\r\n```js\r\nconst logController = require('../controller/log')\r\n\r\nmodule.exports = function(router, model){\r\n  router.route('/')\r\n    .get(logController.fetchLogs(model))\r\n  return router\r\n}\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>/controller/log.js</summary>\r\n\r\n```js\r\nexports.fetchLogs = model => (req, res, next) => {\r\n  console.log('fetch logs');\r\n  console.log('base_url:', req.baseUrl);\r\n  console.log('...');\r\n\r\n  return res.status(200).send('done')\r\n}\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>/controller/buy.js</summary>\r\n\r\n```js\r\nexports.fetchBuys = (req, res, next) => {\r\n  console.log('base_url:', req.baseUrl);\r\n  console.log('result: fetch buys');\r\n  console.log('...')\r\n  res.status(200).send()\r\n}\r\n\r\n```\r\n</details>\r\n\r\n---\r\n\r\nCurrent code consoles:\r\n\r\n**GET: /buy**\r\nfetch logs\r\nbase_url: /buy\r\n\r\n**GET: /buy/123/log**\r\nfetch logs\r\nbase_url: /buy/123/log\r\n\r\n---\r\n\r\nWhat I hope is:\r\n\r\n**GET: /buy**\r\nfetch buys\r\nbase_url: /buy\r\n\r\n**GET: /buy/123/log**\r\nfetch logs\r\nbase_url: /buy/123/log\r\n\r\n---\r\n\r\nIf I reverse the route sequence in /routes/buy.js like following\r\n\r\n```js\r\nrouter.route('/').get(buyController.fetchBuys)\r\nrouter.use('/:id/log', require('./log')(router, 'BuyModel'))\r\n```\r\n\r\n**GET: /buy**\r\nfetch buys\r\nbase_url: /buy\r\n\r\n**GET: /buy/123/log**\r\nfetch buys\r\nbase_url: /buy/123/log\r\n\r\n---\r\n\r\nWould like to know how can I make it work if I still want to use dependency injection in router",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4529/comments",
    "author": "orzinc",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2021-02-18T07:36:57Z",
        "body": "The issue is that in your `/routes/log.js` file, it has a function that accepts a `router` and attaches the fetchLogs to the GET / route on that router. Of course, you are passing the router that belongs to the buys route in `/routes/buy.js`, so the GET / ends up pointing there. The reason it changes when you arrange lines is because you changed which of the two GET / you have on the same router.\r\n\r\nThere are two ways to fix this:\r\n\r\n1. Change line 5 in `/routes/buy.js` to `router.use('/:id/log', require('./log')(express.Router(), 'BuyModel'))`\r\n2. Change line 5 in `/routes/buy.js` to `router.use(require('./log')(router, 'BuyModel'))` and then change line 4 in `/routes/log.js` to `router.route('/:id/log')` (and of course change line 4 in `/routes/sell.js` to the `app.use` as well.\r\n\r\nI hope this helps!"
      },
      {
        "user": "orzinc",
        "created_at": "2021-02-18T08:06:48Z",
        "body": "@dougwilson Thank you for your help, and it works great \ud83d\udc4d"
      }
    ],
    "satisfaction_conditions": [
      "Ensure route handlers don't conflict when using dependency-injected routers",
      "Maintain proper router instance isolation when injecting dependencies",
      "Preserve dependency injection pattern for model-specific route configuration",
      "Ensure route declaration order doesn't affect functionality",
      "Maintain correct middleware hierarchy in nested routes"
    ]
  },
  {
    "number": 4525,
    "title": "Expressjs dealing with high traffic",
    "created_at": "2021-02-08T13:12:00Z",
    "closed_at": "2021-02-09T22:56:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4525",
    "body": "So I want to know how do I wait for response to be sent to the user ?\r\n\r\nlets say my code has some sort of external requests that takes few seconds to response so using async functions the code waits for the response of that request then process it and sends the result back to the user, but it works only for 1 user meaning that if i request like 100 requests per time I will be getting a response but with conflicts of the entered data\r\nlike the request number 62 had the response of the request number 33 and so.\r\nhow do I mange this ? are there any libraries or methods to overcome it or it's just some sort of errors in my code ? ",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4525/comments",
    "author": "moezemara",
    "comments": [
      {
        "user": "rodion-arr",
        "created_at": "2021-02-08T20:49:56Z",
        "body": "Hi @moezemara! Requests are saving theirs contexts during async operations, so you shouldn\u2019t face such kind of issues. If you\u2019ll be able to provide some reproducible example - it will be interesting to check "
      },
      {
        "user": "moezemara",
        "created_at": "2021-02-09T07:35:51Z",
        "body": "> Hi @moezemara! Requests are saving theirs contexts during async operations, so you shouldn\u2019t face such kind of issues. If you\u2019ll be able to provide some reproducible example - it will be interesting to check\r\n\r\nthis is the request of the outer website\r\n```js\r\nconst fetch = require(\"node-fetch\");\r\nconst config = require(\"../../../config/configs\")\r\n\r\nasync function getquestion(questionid){\r\n\tvar url =  config.url\r\n  const options = {\r\n    headers: {\r\n    'Authorization': config.Authorization,\r\n    'Accept': config.Accept,\r\n    }\r\n  };\r\n\r\n\ttry {\r\n    const response = await fetch(url, options);\r\n      json = await response.json();\r\n      return await json\r\n  }catch(error){\r\n      console.log(error);\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n\tgetquestion\r\n}\r\n```\r\n```js\r\nasync function asyncer(id){\r\n    question = await getquestion(id);\r\n    question = await question.result.content.content\r\n    return [question, answer]\r\n}\r\n```\r\nThen the user gets response using this\r\n```js\r\nqa = await asyncer(id)\r\nif (qa){\r\n return await res.status(200).json({\r\n      success: 1,\r\n      question: qa[0],\r\n      answer: qa[1]\r\n })\r\n}\r\n```\r\n"
      },
      {
        "user": "rodion-arr",
        "created_at": "2021-02-09T16:25:25Z",
        "body": "I assume your issue raised due  to not all variables declared in lexical scope. It is not an issue with `express` nor Node.js - it is a nature of pure JS: you need to use `var/let/const` for variables - otherwise global variables will be created implicitly.\r\n\r\nPlease try following updated code with proper variables declaration:\r\n```javascript\r\nconst fetch = require(\"node-fetch\");\r\nconst config = require(\"../../../config/configs\")\r\n\r\nasync function getquestion (questionid) {\r\n  const url = config.url\r\n  const options = {\r\n    headers: {\r\n      'Authorization': config.Authorization,\r\n      'Accept': config.Accept,\r\n    }\r\n  };\r\n\r\n  try {\r\n    const response = await fetch(url, options);\r\n    const json = await response.json();\r\n    return json;\r\n  } catch (error) {\r\n    console.log(error);\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  getquestion\r\n}\r\n```\r\n\r\n```javascript\r\nasync function asyncer(id){\r\n  const response = await getquestion(id);\r\n  const question = response.result.content.content\r\n  const answer = null; // answer should be defined in case it not global variable\r\n  return [question, answer]\r\n}\r\n```\r\n\r\n```javascript\r\nconst qa = await asyncer(id)\r\nif (qa) {\r\n return await res.status(200).json({\r\n      success: 1,\r\n      question: qa[0],\r\n      answer: qa[1]\r\n })\r\n}\r\n```"
      },
      {
        "user": "moezemara",
        "created_at": "2021-02-09T22:56:34Z",
        "body": "> I assume your issue raised due to not all variables declared in lexical scope. It is not an issue with `express` nor Node.js - it is a nature of pure JS: you need to use `var/let/const` for variables - otherwise global variables will be created implicitly.\r\n> \r\n> Please try following updated code with proper variables declaration:\r\n> \r\n> ```js\r\n> const fetch = require(\"node-fetch\");\r\n> const config = require(\"../../../config/configs\")\r\n> \r\n> async function getquestion (questionid) {\r\n>   const url = config.url\r\n>   const options = {\r\n>     headers: {\r\n>       'Authorization': config.Authorization,\r\n>       'Accept': config.Accept,\r\n>     }\r\n>   };\r\n> \r\n>   try {\r\n>     const response = await fetch(url, options);\r\n>     const json = await response.json();\r\n>     return json;\r\n>   } catch (error) {\r\n>     console.log(error);\r\n>   }\r\n> }\r\n> \r\n> module.exports = {\r\n>   getquestion\r\n> }\r\n> ```\r\n> \r\n> ```js\r\n> async function asyncer(id){\r\n>   const response = await getquestion(id);\r\n>   const question = response.result.content.content\r\n>   const answer = null; // answer should be defined in case it not global variable\r\n>   return [question, answer]\r\n> }\r\n> ```\r\n> \r\n> ```js\r\n> const qa = await asyncer(id)\r\n> if (qa) {\r\n>  return await res.status(200).json({\r\n>       success: 1,\r\n>       question: qa[0],\r\n>       answer: qa[1]\r\n>  })\r\n> }\r\n> ```\r\n\r\nthanks a lot \r\nit's working now"
      }
    ],
    "satisfaction_conditions": [
      "Ensures proper variable scoping in asynchronous operations",
      "Maintains request context isolation during external API calls",
      "Provides error prevention for shared resource access in async flows",
      "Explains JavaScript runtime behavior in request handling"
    ]
  },
  {
    "number": 4344,
    "title": "How to set error.name in extended class Error in Node.js?",
    "created_at": "2020-07-11T00:14:42Z",
    "closed_at": "2020-07-14T01:13:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4344",
    "body": "I'm trying to set the error name `err.name = 'ExpressValidatorError';` \r\n\r\nof an custom Error class `class AppError extends Error` \r\n\r\nthat is passed to centralErrorHandler to filter and handle errors by `err.name`.\r\n\r\nI have did a lot of research but still couldn't figure out why `err.name` in centralErrorHandler console logs as `undefined`.\r\n\r\nWhen I change `return next(err);` in auth.controller.js to `throw err;`, the `err.name` does console log as `'ExpressValidatorError'` but i'm not sure if using throw is correct.\r\n\r\n\r\n\r\ncentralErrorHandler.js\r\n```\r\nmodule.exports = (err, req, res, next) => {           \r\n        console.log(err.name);\r\n        if(err.name === 'ExpressValidatorError') err = handleExpressValidatorError(err);            \r\n}\r\n\r\n```\r\n\r\nauth.controller.js\r\n```\r\nconst {validationResult} = require('express-validator');\r\n\r\nexports.signup = (req, res) => {     \r\n    const errors = validationResult(req); \r\n   \r\n      if (!errors.isEmpty()) {\r\n        let err = new AppError(`Invalid login credentials.`, 422);\r\n        err.name = 'ExpressValidatorError';            \r\n             \r\n        return next(err);\r\n      }\r\n\r\n    res.status(200).send(req.user);          \r\n}\r\n```\r\n\r\nappError.js\r\n```\r\nclass AppError extends Error {\r\n    constructor(message, statusCode){\r\n        super(message);\r\n\r\n        this.statusCode = statusCode;\r\n        this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';        \r\n        this.isOperational = true;        \r\n\r\n        Error.captureStackTrace(this, this.constructor);\r\n    }\r\n}\r\n\r\nmodule.exports = AppError;\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4344/comments",
    "author": "KaizenTamashi",
    "comments": [
      {
        "user": "mastermatt",
        "created_at": "2020-07-11T04:12:59Z",
        "body": "In your signup controller you're calling `return next(err);`, however, you haven't included `next` as a param for the handler.\r\nWhen I run your code, the error I get is `ReferenceError: \"next is not defined\"`. And updating the handler signature to `exports.signup = (req, res, next) => { ...` logs as you expect in `centralErrorHandler`. "
      },
      {
        "user": "KaizenTamashi",
        "created_at": "2020-07-13T14:21:10Z",
        "body": "@mastermatt Thank you, the missing `next` parameter is causing the issue. \r\nFor some reason i didn't encounter the `ReferenceError: \"next is not defined\"` in the console log."
      },
      {
        "user": "mastermatt",
        "created_at": "2020-07-13T15:23:57Z",
        "body": "Glad to help.\r\n\r\nI first changed your logging to log the whole error object instead of just `err.name`, that gave me the `ReferenceError` and it all fell into place from there. "
      },
      {
        "user": "KaizenTamashi",
        "created_at": "2020-07-14T01:13:25Z",
        "body": "@mastermatt Thank you :)"
      },
      {
        "user": "f0rnasier",
        "created_at": "2022-01-26T17:28:45Z",
        "body": "I am trying to implement almost the same code but I am getting the error \"Invalid status code: error\""
      }
    ],
    "satisfaction_conditions": [
      "Ensures error properties are preserved when passing errors through Express middleware",
      "Validates proper middleware parameter configuration in Express route handlers",
      "Maintains error instance integrity through Express error handling flow",
      "Provides clear error propagation mechanism in Express applications"
    ]
  },
  {
    "number": 4333,
    "title": "Router doens't match with an route",
    "created_at": "2020-06-30T13:20:31Z",
    "closed_at": "2020-07-02T02:32:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4333",
    "body": "So, I have a following index.js file, where I define the default route and another endpoint that points to a router.\r\n\r\nTherefore, **when I try to access the endpoint /endpoint/something points to the default route, that is '/'.** I don't know what could happen.\r\n\r\nActivating the debug options shows that the new layer, in that case, endpoint was created, but I cannot figure out how to access it.\r\n\r\nSomeone could help? Thanks in advance.\r\n\r\n```js\r\nimport express from 'express';\r\nimport bodyParser from 'body-parser';\r\nimport dotenv from 'dotenv';\r\nimport endpointRouter from './src/endpoint/endpoint.router';\r\n\r\ndotenv.config();\r\n\r\nconst app = express();\r\napp.use(bodyParser.json());\r\napp.use(bodyParser.urlencoded({ extended: true }));\r\n\r\n// routes\r\napp.use('/', (req, res) => res.status(200).send({message: 'Welcome'}));\r\napp.use('/endpoint', endpointRouter);\r\n\r\napp.listen(process.env.PORT, process.env.IPCONFIG, () => console.log(`Process listening on ${process.env.PORT}`));\r\n\r\nexport default app;\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4333/comments",
    "author": "lukaswilkeer",
    "comments": [
      {
        "user": "losanni",
        "created_at": "2020-06-30T16:13:39Z",
        "body": "Try this. \r\n\r\n```\r\nconst express = require('express');\r\nconst bodyParser = require('body-parser');\r\nconst dotenv = require('dotenv');\r\nconst endpointRouter = require('./src/endpoint/endpoint.router');\r\n\r\ndotenv.config();\r\n\r\nconst app = express();\r\napp.use(bodyParser.json());\r\napp.use(bodyParser.urlencoded({ extended: true }));\r\n\r\n// routes\r\napp.get('/', (req, res) => res.status(200).send({message: 'Welcome'}));\r\napp.use('/endpoint', endpointRouter);\r\n\r\napp.listen(process.env.PORT, () => console.log(`Process listening on ${process.env.PORT}`));\r\n\r\n```"
      },
      {
        "user": "lukaswilkeer",
        "created_at": "2020-07-01T21:55:01Z",
        "body": "Thanks, it's was a mistake. Closed."
      }
    ],
    "satisfaction_conditions": [
      "Clarify route handling priority in Express.js",
      "Differentiate between app.use() and HTTP verb methods",
      "Demonstrate proper route method specification",
      "Address middleware execution order"
    ]
  },
  {
    "number": 4279,
    "title": "Wrong render path",
    "created_at": "2020-05-15T23:18:45Z",
    "closed_at": "2020-05-17T02:52:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4279",
    "body": "Hi, I am taking post id parameter to show blog content, everything is fine on here but there is a problem, it is on code or express rendering I don't know exactly.\r\nExpress trying to send my js/css/img files in 'public/post/', but I want to it send from only 'public' path.\r\n\r\nI tried these;\r\n- I tried to change 'path.join'(express.static) but it is also didn't work.\r\n-> `path.join(__dirname + '../', 'public')` or etc...\r\n- I tried to specify path to router but it didn't.\r\n-> (In app.js) app.use('/', mainRouter, here express.path)\r\n- I searched on google, express docs but I couldn't find any solution to this.\r\n\r\n**Routers:**\r\nOnly one router: _main.js_\r\n\r\n**Public Folder:**  classic express generator\r\n\r\n**Codes:**\r\n```\r\n// Show Post By ID\r\n// 5ebabf454b74f711141a5aa4 -> Test Database ID, It exists.\r\nrouter.get('/post/:postid', (req, res, next) => {\r\n    Post.findById(req.params.postid).then((doc) => {\r\n        res.render('post', { title: devblog.name, post: doc });\r\n    }).catch((err) => {\r\n        next(createError(404, err));\r\n    });\r\n});\r\n```\r\n**Console:**\r\n```\r\nGET /post/5ebabf454b74f711141a5aa4 304 3191.975 ms - -\r\nGET /post/stylesheets/bootstrap.min.css 404 500.526 ms - 2295\r\nGET /post/stylesheets/style.css 404 562.285 ms - 2295\r\nGET /post/javascripts/jquery-3.4.1.slim.min.js 404 1438.587 ms - 2295\r\nGET /post/javascripts/bootstrap.bundle.min.js 404 2100.498 ms - 2295\r\n```\r\nHere is the problem: \r\n> /post/stylesheets/\r\n\r\nHow i can change this to normal? **What should I do?**\r\n> /post/stylesheets/ => /stylesheets/\r\n\r\nSorry for syntax, bad English sentences, If there are many flaws, please forgive me.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4279/comments",
    "author": "ipatavatsizz",
    "comments": [
      {
        "user": "jonchurch",
        "created_at": "2020-05-16T19:49:01Z",
        "body": "This is probably an issue with how you're linking to these files from your template.\r\n\r\nUsually it's forgetting to add a forward slash `/` to the resource's path:\r\n\r\nIf the URL of your page is `/post/1234` and you use a stylesheet link like the following:\r\n\r\n```html\r\n<link rel=\"stylesheet\" type=\"text/css\" href=\"css/mystyle.css\">\r\n```\r\nIt will try to load `/post/1234/css/mystle.css`\r\n\r\nBut if you use a forward slash in the html tag, it will try to load from the root of the website:\r\n\r\n```html\r\n<link rel=\"stylesheet\" type=\"text/css\" href=\"/css/mystyle.css\">\r\n```\r\n\r\nFrom the same page, that tag will try to load `/css/mystle.css`"
      },
      {
        "user": "ipatavatsizz",
        "created_at": "2020-05-17T02:52:44Z",
        "body": "Thanks a lot <3 It worked."
      }
    ],
    "satisfaction_conditions": [
      "Ensure static resources are referenced with root-relative paths in templates",
      "Explain path resolution differences between relative and absolute URLs in HTML",
      "Prevent route-specific URL context from affecting static resource paths"
    ]
  },
  {
    "number": 4094,
    "title": "[Feature]dynamic set and delete route",
    "created_at": "2019-11-03T14:36:24Z",
    "closed_at": "2019-11-05T23:16:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4094",
    "body": "When running a application, I set some routes like this:\r\n```js\r\n[some arrays].forEach(route => {\r\n   app.post(route.path, (req, res) => {\r\n       //...\r\n   })\r\n})\r\n```\r\nwhen I change a route's path in that array, new route is available, \r\n**but old route is available too.**\r\n\r\nhow to let the old routes invalidate.\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4094/comments",
    "author": "kybetter",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2019-11-05T23:16:25Z",
        "body": "Hi @kybetter, a better approach to this would be to create a new router which you mount like this:\r\n\r\n```javascript\r\nlet router\r\nfunction updateRoutes () {\r\n  router = new express.Router()\r\n  [some arrays].forEach(route => {\r\n     router.post(route.path, (req, res) => {\r\n         //...\r\n     })\r\n  })\r\n}\r\n\r\nsetTimeout(updateRoutes, ...)\r\n\r\napp.use((req, res, next) => {\r\n  router.handle(req, res, next)\r\n})\r\n```\r\n\r\nMake sense?"
      },
      {
        "user": "kybetter",
        "created_at": "2019-11-06T02:36:27Z",
        "body": "Thanks a lot, it works fine. ^_^"
      },
      {
        "user": "wmasfoe",
        "created_at": "2022-01-07T03:02:30Z",
        "body": "hello @wesleytodd \r\nI also encountered the same problem. I have a variable `routerName`. I want to change it in the code, and the name of the route will be updated dynamically.\r\nMy code is like this:\r\n\r\n```js\r\nlet routerNames = ['/test']\r\nlet realRouter\r\n\r\nfunction updateRouter () {\r\n  realRouter = new express.Router()\r\n  routerNames.forEach(routerName => {\r\n    realRouter.all(routerName, (req, res) => {\r\n      res.send('routerName === ' + routerNames)\r\n    })\r\n  })\r\n}\r\n\r\nsetTimeout(updateRouter, 300)\r\n\r\napp.use((req, res, next) => {\r\n  realRouter.handle(req, res, next)\r\n})\r\n\r\napp.all('/changeName', (req, res) => {\r\n  routerNames[0] += 's' // change routerName\r\n  res.send('new name === ' + routerNames)\r\n})\r\n```\r\n\r\nWhen I try to access `/changeName` to change the value of routername, the variable changes, the route does not change, and `/test` takes effect `/tests` does not take effect.\r\n\r\nHelp me \ud83d\ude2d\ud83d\ude2d\ud83d\ude2d"
      }
    ],
    "satisfaction_conditions": [
      "Solution must allow dynamic route updates that completely replace previous routes",
      "Old route handlers must be fully removed from application routing",
      "Route configuration must support runtime modifications without server restart",
      "Solution must handle route path changes while maintaining handler functionality"
    ]
  },
  {
    "number": 3998,
    "title": "OPTIONS request doesn't follow the order of route declaration",
    "created_at": "2019-07-02T06:15:04Z",
    "closed_at": "2019-07-02T06:20:00Z",
    "labels": [
      "question",
      "module:router"
    ],
    "url": "https://github.com/expressjs/express/issues/3998",
    "body": "I just notice that an OPTIONS request doesn't follow the order of route declaration and applies for all the routes that are defined using the same instance. \r\nI am not sure if it's bug or an intended behaviour since I don't fully understand the nature of OPTIONS request.\r\n\r\nHere are 2 code snippets\r\n\r\n```js\r\nconst app = require('express')();\r\n\r\napp.use((req, res, next) => {\r\n  res.send('Blocked');\r\n});\r\n\r\napp.get('/route1', (req, res) => {\r\n  res.send('route1');\r\n});\r\n\r\napp.get('/route2', (req, res) => {\r\n  res.send('route2')\r\n});\r\n\r\napp.listen(3000, () => {\r\n  console.log('Server started on port: 3000');\r\n});\r\n```\r\n\r\n```js\r\nconst app = require('express')();\r\n\r\napp.get('/route1', (req, res) => {\r\n  res.send('route1');\r\n});\r\n\r\napp.use((req, res, next) => {\r\n  res.send('Blocked');\r\n});\r\n\r\napp.get('/route2', (req, res) => {\r\n  res.send('route2')\r\n});\r\n\r\napp.listen(3000, () => {\r\n  console.log('Server started on port: 3000');\r\n});\r\n```\r\n\r\nIn first case, both GET and OPTIONS request to any of the 2 routes returns the message \"blocked\" as expected since the middleware is defined prior to both and hence any request to either of these will first pass through it.\r\n\r\nIn second case, both GET and OPTIONS request to the second route return the message \"blocked\". Again as expected.  But for the first route, the GET request return the message \"route1\" while the OPTIONS request returns the message \"Blocked\". \r\n\r\nWhy did the GET request was successfully served but the OPTIONS request first passed through the middleware that was defined after that route?\r\n\r\nI'm using v4.17.1",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3998/comments",
    "author": "abhishekjain2604",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2019-07-02T06:20:00Z",
        "body": "The reason is that the default OPTIONS handling only comes into play if the request reached the end of your declarations and never encountered anything that handled it. Since in your second example the .use handled the OPTIONS request (by not calling next()) the default handling was never invoked.\r\n\r\nYou can think of it in that the OPTIONS auto response is not an aspect of your app.get (i.e. it does not respond at the moment of the app.get declaration for the named route) and is instead an alternative of the 404 response (i.e. only runs if no other route handled the OPTIONS request).\r\n\r\nI hope that helps explain the behavior."
      },
      {
        "user": "abhishekjain2604",
        "created_at": "2019-07-02T07:43:14Z",
        "body": "@dougwilson Yeah that explains the behaviour quite well. Thanks a lot."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of Express.js's default OPTIONS request handling mechanism",
      "Clarification on how middleware order affects OPTIONS requests differently than other methods",
      "Description of conditions triggering Express's automatic OPTIONS response vs custom handling",
      "Differentiation between route-specific handlers and global middleware behavior for OPTIONS"
    ]
  },
  {
    "number": 3980,
    "title": "Client Cannot GET /xxx.html before accessing main ",
    "created_at": "2019-06-11T02:37:33Z",
    "closed_at": "2019-06-11T11:29:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3980",
    "body": "I have the following server side code:\r\n\r\n```\r\nvar app = express();\r\napp.get('/', function (req, res) {\r\n\tres.redirect('/main');\r\n});\r\napp.get('/main', function (req, res) {\r\n\tvar d = new Date();\r\n\tres.sendFile(path.join(__dirname + '/main.html'));\r\n\tInfo(req.ip + ' - Session to main.html built successfully! ');\r\n\tapp.use(express.static(__dirname));\r\n});\r\n```\r\n\r\nAlso there are some other html files in the same directory, e.g. xxx.html.  \r\nI found the following behavior that confuses, if I build a new session, try to access localhost:7778/xxx.html, the client cannot get: Cannot GET /xxx.html:\r\n\r\n```\r\nFailed to load resource: the server responded with a status of 404 (Not Found)\r\n```\r\n\r\nOn the other hand, after accessed localhost:7778/, and then try to access localhost:7778/xxx.html, will succeed.\r\n\r\nCan anyone explain the behavior? Can I set the localhost/xxx.html be able to directly accessed?\r\n\r\nThanks a lot!",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3980/comments",
    "author": "ctlkkc",
    "comments": [
      {
        "user": "r0mflip",
        "created_at": "2019-06-11T03:24:40Z",
        "body": "Your `app.use(express.static(__dirname));` shouldn't be in the route handler."
      },
      {
        "user": "ctlkkc",
        "created_at": "2019-06-11T11:29:27Z",
        "body": "Thanks, the answer solved the issue. "
      }
    ],
    "satisfaction_conditions": [
      "Explains why static files are only accessible after visiting the /main route",
      "Identifies the incorrect placement of static file middleware",
      "Provides a way to make static files available without requiring prior route access",
      "Explains Express middleware execution order concepts"
    ]
  },
  {
    "number": 3962,
    "title": "trust-proxy function not called?",
    "created_at": "2019-05-17T09:36:34Z",
    "closed_at": "2019-05-17T19:52:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3962",
    "body": "My Express server is running in a docker container with an nginx docker container proxying request to it.\r\n\r\n```\r\nRequest -> (nginx) -> (express)\r\n```\r\n\r\nI've been trying to set up Express so it only trusts the one nginx proxy, but so far I've not been able to get the `trust-proxy` setting to work.\r\nThe function I pass to the `trust-proxy` setting seems to never get called in my application.\r\n\r\n```ts\r\napp.set('trust proxy', (ip: string) => {\r\n    console.error(`PROXY ADDR: ${ip}`);\r\n    return false;\r\n});\r\n```\r\nWith this configuration, the `console.error` never appears in the logs.\r\n\r\nAm I doing something wrong here with my configuration, or is `trust proxy` not working as intended?\r\n\r\nMinimal reproduction:\r\n```ts\r\nconst app = express();\r\n\r\napp.set('trust proxy', (ip: string) => {\r\n    console.error(`PROXY ADDR: ${ip}`);\r\n    return false;\r\n});\r\n\r\napp.use('*', (_req: express.Request, res: express.Response) => {\r\n    return res.send('Hi');\r\n});\r\n\r\nconst webServer = createServer(app);\r\nwebServer.listen(3731);\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3962/comments",
    "author": "Ionaru",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2019-05-17T13:59:41Z",
        "body": "Hi @Ionaru . The trust proxy function is called when trust of addresses needs to be established. In your example, there is no code that needs to know anything about the upstream, so for optimization reasons, it will not get invoked.\r\n\r\nIf you add something like `req.ip`, `req.hostname` etc to your example, your function should then get called, as Express tries to determine the address."
      },
      {
        "user": "Ionaru",
        "created_at": "2019-05-17T19:52:03Z",
        "body": "Ah, I see. My bad."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of when Express's trust-proxy function is actually invoked",
      "Clarification of required conditions for trust-proxy evaluation",
      "Identification of Express internal optimization behaviors"
    ]
  },
  {
    "number": 3957,
    "title": "Routing Issue",
    "created_at": "2019-05-15T02:18:52Z",
    "closed_at": "2019-05-15T02:27:59Z",
    "labels": [
      "question",
      "module:router"
    ],
    "url": "https://github.com/expressjs/express/issues/3957",
    "body": "Hello,\r\n\r\nI've been using the Router function for a bit now and have an endpoint that does two different functions, one gets the current user /users/me and one gets a user that is searched /users/:id, sadly these endpoints conflict for some reason, can someone please help me in finding a solution? These endpoints are BOTH in the same file.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3957/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2019-05-15T02:21:22Z",
        "body": "There are two main solutions:\r\n\r\n1. Since the router matches in the strict order in which they are declared, just declare the more specific route first (the `/users/me` router).\r\n2. If the `:id` parameter is only certain characters, like just digits, you can restrict that route to only those characters like `/users/:id([0-9]+)`"
      },
      {
        "user": "ghost",
        "created_at": "2019-05-15T02:22:40Z",
        "body": "@dougwilson call me blind but is there a way in express to route it (2nd way) with just numbers?"
      },
      {
        "user": "dougwilson",
        "created_at": "2019-05-15T02:24:29Z",
        "body": "I'm sorry, I'm not sure I understand your question. What do you mean by to route it with just numbers?"
      },
      {
        "user": "ghost",
        "created_at": "2019-05-15T02:25:34Z",
        "body": "Sorry, I didn't write that quite correctly, this /users/:id is only numbers, does express offer a way to lockdown the endpoint to only numbers?"
      },
      {
        "user": "dougwilson",
        "created_at": "2019-05-15T02:27:05Z",
        "body": "If I'm understanding correctly: `/users/:id([0-9]+)`"
      },
      {
        "user": "ghost",
        "created_at": "2019-05-15T02:27:59Z",
        "body": "@dougwilson Yes, that answers my question, thank you so much!"
      }
    ],
    "satisfaction_conditions": [
      "Solution must resolve route priority conflict between static and parameterized endpoints",
      "Solution must allow numeric-only validation for route parameters",
      "Solution must maintain both endpoints in same routing configuration",
      "Solution must work with Express.js routing mechanics"
    ]
  },
  {
    "number": 3889,
    "title": "Routing by Variable",
    "created_at": "2019-02-22T16:58:02Z",
    "closed_at": "2019-02-23T08:52:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3889",
    "body": "I have the fear it's a totally basic-question. But I got stuck at this point ..  :(\r\n\r\nMy usecase:\r\n\r\nThe root-website is running as a \"show-room\", where no input is possible (it is presenteds to the public on multiple screens). The \"show-room\" asks periodically via ajax for data. \r\n\r\nNo it should be possible to switch from another client (with another website, e.g. /setup) the routing to another view and also give some additional information to it. Beside the ajax-transfer I also have already the POST-Datas in the index.js\r\n\r\nOne more time: The root-page shows \" website A\" and over another website I can tell the server, that it should show \"website B\". The Reload could be managed by Javascript/AJAX.\r\n\r\nMy thought was just changing the Routing, but that does not work. Yes, indeed, I did not understand all the mechanism.... ;)\r\n\r\nMy first try in index.js:\r\n```js\r\n// ...\r\napp.get('/', view01.view01Action);\r\n// ...\r\n\r\n// Getting the form-datas    \r\napp.post('/setuppost', function(req, res) {\r\n        res.render('./../setup01/views/setup.handlebars');\r\n        \r\n// Reacting to the form-datas\r\n        if(req.body.selectedView=='view05'){\r\n            app.get('/', view05.view05Action);\r\n            (... handlebars-helpers and so on...)\r\n        }\r\n```\r\n\r\nCould anybody please tell me, how to solve my usecase? THX a lot!",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3889/comments",
    "author": "alcero",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2019-02-23T01:12:17Z",
        "body": "Hi @alcero welcome! There are various ways to achieve what you're trying to do.\r\n\r\nBased on your current example above, what I would do is just save the view action function in a variable, add a handler that calls that variable, and then have your post just swap out that variable. Here is your example changed to do just that:\r\n```js\r\n// ...\r\nvar viewAction = view01.view01Action\r\n// ...\r\napp.get('/', (req, res, next) => viewAction(req, res, next));\r\n// ...\r\n\r\n// Getting the form-datas    \r\napp.post('/setuppost', function(req, res) {\r\n        res.render('./../setup01/views/setup.handlebars');\r\n        \r\n// Reacting to the form-datas\r\n        if(req.body.selectedView=='view05'){\r\n            viewAction = view05.view05Action;\r\n            (... handlebars-helpers and so on...)\r\n        }\r\n```"
      },
      {
        "user": "alcero",
        "created_at": "2019-02-23T08:52:18Z",
        "body": "Hi @dougwilson \r\nTHANK YOU! It simply works :)\r\nSaving a function to a variable ... I didn't had the idea that may work ... thank you!\r\n"
      }
    ],
    "satisfaction_conditions": [
      "Dynamic route handler switching without redefining routes",
      "State persistence between requests"
    ]
  },
  {
    "number": 3837,
    "title": "Is it a bad practise to wrap an express app by a user defined object?",
    "created_at": "2018-12-27T15:43:14Z",
    "closed_at": "2019-01-03T14:53:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3837",
    "body": "Hi guys. \r\n\r\nI am implementing a middleware which will check whether the given request contains all the required params/body. \r\n\r\n```javascript\r\napp.use(checkRequestData);\r\n\r\napp.post(\"/user\", controller.addUser);\r\napp.get(\"/user/:id\", controller.getUser);\r\n```\r\n\r\nNow in **checkRequestData**, I can get **req.body** but **req.params.id** is returning *undefined*. To get the req.params.id, I have written the following function\r\n```javascript\r\n\r\nexports.checkRequestData = (req, res, next) => {\r\n    /**\r\n     * check whether request carries required data\r\n     */\r\n    next();\r\n};\r\n\r\nexports.applyMiddleware = (app) => (...middleware) => {\r\n    return new class {\r\n\r\n        middeware(req, res, next){            \r\n            middlewares.forEach((mw) => {\r\n                mw(req, res, next);\r\n            });\r\n        }\r\n\r\n        get(route, controller){\r\n            return app.get(route, this.middeware, controller);\r\n        }\r\n\r\n        post(route, controller){\r\n            return app.post(route, this.middeware, controller);\r\n        }\r\n    }\r\n}; \r\n```\r\n\r\nAnd the server file is modified as follows:\r\n\r\n```javascript\r\nconst _app = applyMiddleware(app)(checkRequestData);\r\n\r\n_app.post(\"/user\", controller.addUser);\r\n_app.get(\"/user/:id\", controller.getUser);\r\n```\r\n\r\nUsing this method I am able to get the request data. \r\n\r\nIs this the right approach of using express middlewares? Will this cause any issues to the in-built express methods?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3837/comments",
    "author": "softlore",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2018-12-27T18:12:27Z",
        "body": "Hi @gmk292.  This is probably not the way I would do it, but that is not to say it is wrong.  One other approach you might take is to create an array of reusable middleware and use it on each route.  The reason `params` is missing is because no route has been matched for that middleware.  You could get around this like so:\r\n\r\n```javascript\r\napp.post(\"/user\", checkRequestData, controller.addUser);\r\napp.get(\"/user/:id\", checkRequestData, controller.getUser);\r\n```\r\n\r\nIf you have multiple of these middleware you can group them in an array like this:\r\n\r\n```javascript\r\nconst middleware = [checkRequestData, handleRequestDataErrors];\r\n\r\napp.post(\"/user\", middleware, controller.addUser);\r\napp.get(\"/user/:id\", middleware, controller.getUser);\r\n```\r\n\r\nThis composition approach gets rid of the custom wrapper, and sticks with just usage of the express api.  Usually this makes for easier debugging in the future for you and anyone else who works on your project.  Good luck."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of middleware execution order in Express routing",
      "Comparison of custom wrapper approach vs standard Express patterns",
      "Guidance on maintaining Express API compatibility",
      "Best practices for reusable middleware composition",
      "Error handling considerations for middleware chains"
    ]
  },
  {
    "number": 3744,
    "title": "npm ERR! code EJSONPARSE",
    "created_at": "2018-09-13T18:06:36Z",
    "closed_at": "2018-09-13T18:08:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3744",
    "body": "Help I am getting this error\r\n> C:\\Users\\Admin\\Desktop\\bot>npm install discord.io winston -save.\r\n> npm ERR! file C:\\Users\\Admin\\Desktop\\bot\\package.json\r\n> npm ERR! code EJSONPARSE\r\n> npm ERR! JSON.parse Failed to parse json\r\n>  pm ERR! JSON.parse Unexpected token \ufffd in JSON at position 0 while parsing near '\ufffd\ufffd{\r\n> npm ERR! JSON.parse  \u001c n a m e \u001d ...'\r\n> npm ERR! JSON.parse Failed to parse package.json data.\r\n> npm ERR! JSON.parse package.json must be actual JSON, not just JavaScript.\r\n> \r\n> npm ERR! A complete log of this run can be found in:\r\n> npm ERR!     C:\\Users\\Admin\\AppData\\Roaming\\npm-cache\\_logs\\2018-09-13T17_55_13_036Z-debug.log\r\n> \r\n\r\n\r\nHere is the log:\r\n\r\n> 0 info it worked if it ends with ok\r\n> 1 verbose cli [ 'C:\\\\Program Files\\\\nodejs\\\\node.exe',\r\n> 1 verbose cli   'C:\\\\Program Files\\\\nodejs\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js',\r\n> 1 verbose cli   'install',\r\n> 1 verbose cli   'discord.io',\r\n> 1 verbose cli   'winston',\r\n> 1 verbose cli   '-save.' ]\r\n> 2 info using npm@6.4.1\r\n> 3 info using node@v10.10.0\r\n> 4 verbose npm-session c92302b61857a70f\r\n> 5 silly install loadCurrentTree\r\n> 6 silly install readLocalPackageData\r\n> 7 timing stage:rollbackFailedOptional Completed in 15ms\r\n> 8 timing stage:runTopLevelLifecycles Completed in 89ms\r\n> 9 verbose stack Error: Failed to parse json\r\n> 9 verbose stack Unexpected token \ufffd in JSON at position 0 while parsing near '\ufffd\ufffd{ \r\n>  \r\n> 9 verbose stack  \u001c n a m e \u001d ...'\r\n> 9 verbose stack     at parseError (C:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\read-package-json\\read-json.js:452:11)\r\n> 9 verbose stack     at parseJson (C:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\read-package-json\\read-json.js:104:26)\r\n> 9 verbose stack     at C:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\read-package-json\\read-json.js:51:5\r\n> 9 verbose stack     at C:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\graceful-fs\\graceful-fs.js:78:16\r\n> 9 verbose stack     at FSReqWrap.readFileAfterClose [as oncomplete] (internal/fs/read_file_context.js:53:3)\r\n> 10 verbose cwd C:\\Users\\Admin\\Desktop\\bot\r\n> 11 verbose Windows_NT 10.0.17134\r\n> 12 verbose argv \"C:\\\\Program Files\\\\nodejs\\\\node.exe\" \"C:\\\\Program Files\\\\nodejs\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js\" \"install\" \"discord.io\" \"winston\" \"-save.\"\r\n> 13 verbose node v10.10.0\r\n> 14 verbose npm  v6.4.1\r\n> 15 error file C:\\Users\\Admin\\Desktop\\bot\\package.json\r\n> 16 error code EJSONPARSE\r\n> 17 error JSON.parse Failed to parse json\r\n> 17 error JSON.parse Unexpected token \ufffd in JSON at position 0 while parsing near '\ufffd\ufffd{ \r\n>  \r\n> 17 error JSON.parse  \u001c n a m e \u001d ...'\r\n> 18 error JSON.parse Failed to parse package.json data.\r\n> 18 error JSON.parse package.json must be actual JSON, not just JavaScript.\r\n> 19 verbose exit [ 1, true ]\r\n> \r\n\r\nWhat should I do?\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3744/comments",
    "author": "CubecCubehead",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2018-09-13T18:08:13Z",
        "body": "The error is from the command `npm install discord.io winston -save`, which is `npm`. It states that the file `C:\\Users\\Admin\\Desktop\\bot\\package.json` is not valid JSON."
      },
      {
        "user": "CubecCubehead",
        "created_at": "2018-09-13T18:10:01Z",
        "body": "crap I forgot about that thx\r\nwrong format"
      }
    ],
    "satisfaction_conditions": [
      "Identify that the package.json file contains invalid JSON syntax",
      "Clarify package.json must follow strict JSON format (not JavaScript-like syntax)"
    ]
  },
  {
    "number": 3565,
    "title": "Post request flood?",
    "created_at": "2018-02-14T08:47:11Z",
    "closed_at": "2018-02-15T11:22:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3565",
    "body": "Introduction\r\n================\r\nI\u00b4ve a nodejs application with express that have some post and get request. The whole website works just fine without problems.\r\n\r\nProblem\r\n============\r\nIf I call the post request to much in time the site will crash. It will not respond to other requests. Doesn\u00b4t matter if it\u00b4s get or post request. I just can close the tab and open the site in a new one. Then it work again.\r\n\r\nMy Code\r\n===========\r\n\r\n## Client side ##\r\nIt\u00b4s a easy post request to set a client permission. There is no callback defined.\r\n\r\n    $.post(\r\n       '/clients/set/client/permission',\r\n       {\r\n          permName: globPermissionTable[permName],\r\n          value: checked,\r\n          id: '<%= data[0].id %>'\r\n       }\r\n    );\r\n\r\n----------\r\n\r\n## Server side ##\r\nJust a easy post segment. Even if I will uncomment all in the request it will be not response.\r\n\r\n    app.post('/clients/set/client/permission', function(req, res) {\r\n\t   // Permissioncheck\r\n\t   /*var permName = req.body.permName, val = req.body.value, id = req.body.id;\r\n\t   if(helper.checkParams([permName, val, id])) {\r\n\t\t     database.SetClientPermissions(parseInt(id), permName, (val === 'true') ? true : false);\r\n\t   };*/\r\n    });",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3565/comments",
    "author": "lgund",
    "comments": [
      {
        "user": "lgund",
        "created_at": "2018-02-14T08:58:33Z",
        "body": "I found out now that if a write _res.send('finished');_ this problem doesn\u00b4t happen. If it\u00b4s that important to always send something back?\r\n\r\n-----------\r\nFull Code:\r\n`app.post('/clients/set/client/permission', function(req, res) {\r\n   res.send('finished');\r\n});`"
      },
      {
        "user": "wesleytodd",
        "created_at": "2018-02-14T21:50:51Z",
        "body": "Yes, you always need to send a response.  Otherwise the connection will remain open waiting for that response.  If you are not going to handle a request in a middleware, you can also just call `next` and allow express to respond for you with a 404:\r\n\r\n```\r\napp.post('/foo', function (req, res, next) {\r\n  if (something) {\r\n    return res.send('response');\r\n  }\r\n  next();\r\n});\r\n```"
      },
      {
        "user": "lgund",
        "created_at": "2018-02-15T11:22:27Z",
        "body": "Thanks. That helped a lot!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of the need to properly close HTTP connections in Express",
      "Clarification of Express middleware response lifecycle requirements"
    ]
  },
  {
    "number": 3433,
    "title": "error handled at unknown error handler",
    "created_at": "2017-09-27T18:28:29Z",
    "closed_at": "2017-09-27T19:00:58Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3433",
    "body": "express version : 4.15,\r\nnode version: 8.1.4\r\n\r\nim currently experiencing an odd behavior within my application, I have nested routes and im defining my routes like this\r\n\r\n```js\r\nconst router = require('express').Router();\r\nconst m = require('../modules/index').v1;\r\n\r\nrouter.route('/')\r\n  .post(m.create)\r\n  .get(m.list)\r\n  .all(m.transformer);\r\n\r\nrouter.route('/:id')\r\n  .all(m.middlewareById)\r\n  .put(m.editById)\r\n  .delete(m.deleteById)\r\n  .get(m.getById)\r\n  .all(m.transformer);\r\nmodule.exports = router;\r\n```\r\nIm currently developing m.create API controller, and when and error occurs that is not handled sends me a response of HTML page with error object. \r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n    <head>\r\n        <meta charset=\"utf-8\">\r\n        <title>Error</title>\r\n    </head>\r\n    <body>\r\n        <pre>[object Object]</pre>\r\n    </body>\r\n</html>\r\n```\r\nI want to eliminate this behavior and response with JSON only, but somehow its by passing my defined request handlers, and instead of getting handled at a middle ware that I specify, or the one at `app.js` \r\nits is being handled somewhere else mysteriously, i've been express user for 3 or more years and this is the first time im facing such behavior.\r\nhas something changed in new Express version? \r\n\r\n_app.js_\r\n```js\r\nconst express = require('express');\r\nconst path = require('path');\r\n// const favicon = require('serve-favicon');\r\nconst logger = require('morgan');\r\nconst cookieParser = require('cookie-parser');\r\n...\r\n\r\napp.use('/', index);\r\napp.use('/systemadmin', systemAdminRoutes);\r\n\r\n// catch 404 and forward to error handler\r\napp.use((req, res, next) => {\r\n  const err = new Error('Not Found');\r\n  err.status = 404;\r\n  next(err);\r\n});\r\n\r\n// error handler\r\napp.use((err, req, res) => {\r\n  // next is the last argument in above function\r\n  // set locals, only providing error in development\r\n  // res.locals.message = err.message;\r\n  // res.locals.error = req.app.get('env') === 'development' ? err : {};\r\n  debug(err); // nothing logs here \r\n  debug(err.message);\r\n  debug(err.name);\r\n  debug(err.errorCode);\r\n  debug(err.stack);\r\n  // render the error page\r\n  res.status(err.status || 500);\r\n  res.send({error: err.message}); //this never gets called\r\n});\r\n\r\nmodule.exports = app;\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3433/comments",
    "author": "muhammadfaizan",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-09-27T18:31:28Z",
        "body": "Maybe you ran a linter on your code recently? Your code above you have\r\n```js\r\napp.use((err, req, res) => {\r\n```\r\n\r\nBut (which has always been in the case), it MUST have 4 arguments in order to work:\r\n```js\r\napp.use((err, req, res, next) => {\r\n```"
      },
      {
        "user": "muhammadfaizan",
        "created_at": "2017-09-27T19:00:58Z",
        "body": "@dougwilson this is insane ! \r\nThanks by the way :)\r\nIt did work. "
      }
    ],
    "satisfaction_conditions": [
      "Explanation of Express error handler middleware signature requirements",
      "Clarification of Express' middleware parameter recognition logic",
      "Identification of framework-specific requirements for error handling"
    ]
  },
  {
    "number": 3420,
    "title": "Defining a router-specific error handler",
    "created_at": "2017-09-20T17:44:59Z",
    "closed_at": "2017-09-20T20:41:48Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3420",
    "body": "hi there,\r\n\r\nI would like a little advice on the correct way to define a error handler for a specific router (my use case is a webapp with \"normal\" html routes, and a route `/api` where a new Router instance is attached that only deals in JSON output):\r\n\r\nI am using `Express v4.15.3`, is the following conceptually what I should be doing? :\r\n\r\n```js\r\nconst r = Router;\r\n\r\nr.get('/users', (req, res, next) { res.send({ users : []}); }\r\n\r\n// ... more routes ...\r\n\r\n// add error handler last so that all errors fall into it\r\nr.use((req, res, next, err) { res.send(outputJsonApiError(err)); });\r\n\r\napp.use('/api', r);\r\n```\r\n\r\n\r\nP.S. I have searched the docs and the issues lists but failed to have a \"lightbulb moment\"(tm) ... sorry for the noise (I always struggle a bit with express error handling - in the past I have ended up with a footgun more than once!)",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3420/comments",
    "author": "iamjochem",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-09-20T18:40:06Z",
        "body": "Yea, that would work. Just kind in mine that the routes will run in the order you declared, so you may want to swap the `r.use` with the `r.get` in your example above so the error handler is the last thing in your router so errors that occur in your routes will fall into the error handler."
      },
      {
        "user": "iamjochem",
        "created_at": "2017-09-20T20:41:48Z",
        "body": "@dougwilson - thank you for clarifying (& so quickly)! \r\n\r\nI edited my original post to reflect your comment just in case anyone stumbles across it - I did know about handler ordering but I wasn't thinking when I wrote the snippet)."
      }
    ],
    "satisfaction_conditions": [
      "Error handler is scoped to specific router instance",
      "Error handler is positioned as last middleware in router chain",
      "Solution handles error propagation within router context",
      "Explanation addresses middleware ordering requirements"
    ]
  },
  {
    "number": 3376,
    "title": "Regex-based subrouter cannot route anything",
    "created_at": "2017-07-28T08:31:06Z",
    "closed_at": "2017-07-29T07:53:46Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3376",
    "body": "Hello,\r\nI'm experiencing a routing unavailability at `router2` in the code below. This code can route `/api/awesome` but not `mypage`. This code is of course simplified and the part of bigger system, so it is difficult to change the routing structure of `router1` and `router2`.\r\n\r\nWill there be any idea to resolve this while keeping this subrouter structure?\r\n\r\n```js\r\nconst express = require('express');\r\nconst app = express();\r\n\r\nconst router1 = express.Router();\r\nconst router2 = express.Router();\r\n\r\nrouter2.get('/mypage', function(req, res, next) {\r\n\tres.json('mypage');\r\n\tnext();\r\n});\r\n\r\nrouter1.use(/^\\/(?!api).*/, router2);\r\n\r\nrouter1.get('/api/awesome', function(req, res, next) {\r\n\tres.json('awesome');\r\n\tnext();\r\n});\r\n\r\napp.use(router1);\r\n\r\napp.listen(8080);\r\n```\r\n\r\nExpress version: 4.15.3\r\nNode.js version: 8.2.1",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3376/comments",
    "author": "Kivol",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-07-28T14:22:26Z",
        "body": "Hi @Kivol the reason your `/mypage` route is not matching is because the way `.use` works is that it will cut off whatever matched as it passes down (so you only need to write the rest of the path, not the full path over and over). Your regular expression, `/^\\/(?!api).*/`, since it ends with `.*` will always match the entire url, which in turn means the entire thing is trimmed out, making `router2` only see `req.url` as `/`, which won't match `/mypage`.\r\n\r\nYou can correct this my making the regular expression match nothing on success for what you're trying to do. Example: `/^(?!\\/api)/`. Here is the full example with this change made:\r\n\r\n```js\r\nconst express = require('express');\r\nconst app = express();\r\n\r\nconst router1 = express.Router();\r\nconst router2 = express.Router();\r\n\r\nrouter2.get('/mypage', function(req, res, next) {\r\n\tres.json('mypage');\r\n});\r\n\r\nrouter1.use(/^(?!\\/api)/, router2);\r\n\r\nrouter1.get('/api/awesome', function(req, res, next) {\r\n\tres.json('awesome');\r\n});\r\n\r\napp.use(router1);\r\n\r\napp.listen(8080);\r\n```"
      },
      {
        "user": "Kivol",
        "created_at": "2017-07-29T07:53:46Z",
        "body": "Hi @dougwilson , you save my day. Thank you for clear and kind explanation!"
      }
    ],
    "satisfaction_conditions": [
      "Maintain existing subrouter hierarchy (router1 -> router2)",
      "Ensure regex pattern preserves remaining path for subrouter matching",
      "Explain Express router's path trimming behavior with regex patterns"
    ]
  },
  {
    "number": 3319,
    "title": "why is 'next' in createApplication needed?",
    "created_at": "2017-05-25T03:09:01Z",
    "closed_at": "2017-05-25T03:26:45Z",
    "labels": [
      "3.x",
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3319",
    "body": "```js\r\nfunction createApplication() {\r\n  var app = function(req, res, next) {\r\n    app.handle(req, res, next);\r\n  };\r\n```\r\nI deleted it in my local env,it turns out fine.\r\nAnd It seems no way to assaign it , how to use this 'next' here?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3319/comments",
    "author": "ginobilee",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-05-25T03:26:45Z",
        "body": "Hi @ginobilee it is used when you mount apps on each other. For example:\r\n```js\r\nvar app  = express()\r\nvar app1 = express()\r\n\r\napp.use(app1)\r\n```"
      },
      {
        "user": "ginobilee",
        "created_at": "2017-05-25T04:32:26Z",
        "body": "Thank you !\r\n I just begin learning express.I know it too little to ask this question,almost regret just after i post it .\r\nThank you again!"
      },
      {
        "user": "dougwilson",
        "created_at": "2017-05-25T04:32:59Z",
        "body": "It's not a problem at all, @ginobilee "
      }
    ],
    "satisfaction_conditions": [
      "Explanation of middleware chaining context where 'next' becomes relevant",
      "Clarification of Express's app composition architecture",
      "Identification of scenarios where explicit 'next' usage emerges"
    ]
  },
  {
    "number": 3282,
    "title": "inspect an action/handle/route function before i do with something",
    "created_at": "2017-04-12T22:19:35Z",
    "closed_at": "2017-04-19T16:21:27Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3282",
    "body": "i am trying to create a handering API with my routes.\r\nbut i cannot restrict everything. i add a decorator on the function like:\r\n\r\n```javascript\r\napp.use((req, res, next) => {\r\n   // i got the app inside...\r\n  // if it is decorated the handle/route/function it does it self\r\n  if (app.handle.decorated === true) {\r\n    next();\r\n }\r\n ... verify auth ...\r\n})\r\n\r\nconst decorate.auth = () => {};\r\ndecorate.auth.decorated = true;\r\n\r\n// a decorated auth,  so the middleware should skip\r\nroute.get('/something', decorate.auth('public', (req, res) => {\r\n  res.send('ok');\r\n}\r\n```\r\nThe problem is I want to restrict except the ones that are decorated, but i cannot find the handle/route before it is fired. ",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3282/comments",
    "author": "patrikx3",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-04-12T22:42:03Z",
        "body": "Hi @patrikx3 I'm not 100% sure on what you're trying to do exactly, but it sounds like a pattern for doing granular auth restrictions per route. If that is right, one pattern you can try is to use a middleware pattern to skip, for example:\r\n```js\r\n// 1. Let's assume that you have a middleware that looks up a user's access level\r\napp.use((req, res, next) => {\r\n   req.user.accessLevel = 'public'\r\n})\r\n\r\n// 2. Then you could make an access level checker\r\nfunction requireAccessLevel(level) {\r\n  return (req, res, next) => {\r\n    if (req.user && req.user.accessLevel === level) next()\r\n    else next('route')\r\n  }\r\n}\r\n\r\n// 3. Then you would define your route\r\nroute.get('/something', requireAccessLevel('private'), (req, res) => {\r\n  res.send('ok')\r\n}\r\n```"
      },
      {
        "user": "patrikx3",
        "created_at": "2017-04-12T22:49:09Z",
        "body": "the problem is that i am trying to do everything in reverse. i try to restrict everything, but i try to allow a few routes with public access, but the problem since i already forbid everything my middleware doesnt' got access to my route.\r\n\r\ni can restrict , that is ok.\r\nbut i try to restrict everything automatically, but add a few public route like public, role2, role1. \r\nlike hardening.\r\nsince you created do you have a little idea when you get a little chance how it would be to every action/function/route before i do it?\r\n\r\n**but i would decorate a child app, router, or a route as well.**\r\n\r\nif it has no authorization decorator, forbid.\r\n:) \r\n\r\nciao if you have a little time! thanks so much!"
      },
      {
        "user": "dougwilson",
        "created_at": "2017-04-13T02:08:30Z",
        "body": "Hi @patrikx3 gotcha. I definitely didn't fully understand what you are asking, as I suspected may be the case. I'm still a little fuzzy on what you're trying to do, but I think I may understand this time (?). Typically if you wanted to have a route layout of fully accessible + generally restricted, you could just place the few accessible routes physically before the auth check restriction:\r\n```js\r\n// 1. Declare the routes available to everyone\r\napp.get('/', ..);\r\n\r\n// 2. Add your auth restriction\r\napp.use(blockNonAdmins());\r\n\r\n// 3. Declare the restricted routes\r\napp.get('/control_panel', ...);\r\n```"
      },
      {
        "user": "patrikx3",
        "created_at": "2017-04-13T02:10:07Z",
        "body": "thanks for helping! you are so cool! got it working with you!!!\r\nciao!!"
      }
    ],
    "satisfaction_conditions": [
      "Solution must allow defining public routes that bypass default authentication restrictions",
      "Approach must work with middleware that executes before route handlers",
      "Must support declarative route-specific authorization rules",
      "Solution should maintain a default-deny security model"
    ]
  },
  {
    "number": 3274,
    "title": "TypeError: Router.use() requires middleware function but got a Object",
    "created_at": "2017-04-08T16:12:50Z",
    "closed_at": "2017-04-10T07:24:23Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3274",
    "body": "macOS Sierra 10.12.4\r\nnode v7.8.0\r\nnpm 4.2.0\r\n\r\nindex.js\r\n```javascript\r\nconst express = require('express')\r\nconst bodyParser = require('body-parser')\r\nconst session = require('express-session')\r\nconst mongoose = require('mongoose')\r\nconst MongoStore = require('connect-mongo')(session)\r\nconst morgan = require('morgan')\r\nconst csrf = require('lusca').csrf()\r\nconst fs = require('fs')\r\nconst path = require('path')\r\nconst rfs = require('rotating-file-stream')\r\n\r\nmongoose.connect('mongodb://localhost/test')\r\n\r\nconst app = express()\r\n\r\nconst logDir = path.join(__dirname, 'log')\r\nfs.existsSync(logDir) || fs.mkdirSync(logDir)\r\nconst accessLogStream = rfs('access.log', {\r\n  interval: '1d',\r\n  path: logDir\r\n})\r\n\r\napp.use(bodyParser.json())\r\napp.use(bodyParser.urlencoded({extended: true}))\r\napp.use(session({\r\n  secret: 'ohmy411',\r\n  store: new MongoStore({\r\n    mongooseConnection: mongoose.connection\r\n  })\r\n}))\r\napp.use(morgan('combined'), { stream: accessLogStream })\r\napp.use((req, res, next) => csrf(req, res, next))\r\n\r\napp.get('/', (req, res) => res.send('hello world'))\r\n\r\napp.listen(3000)\r\n```\r\n\r\nerror info\r\n```\r\n\u279c  server (master) \u2717 node index.js\r\nexpress-session deprecated undefined resave option; provide resave option index.js:26:9\r\nexpress-session deprecated undefined saveUninitialized option; provide saveUninitialized option index.js:26:9\r\n/Users/simonqian/Work/ohmy411/server/node_modules/express/lib/router/index.js:458\r\n      throw new TypeError('Router.use() requires middleware function but got a ' + gettype(fn));\r\n      ^\r\n\r\nTypeError: Router.use() requires middleware function but got a Object\r\n    at Function.use (/Users/simonqian/Work/ohmy411/server/node_modules/express/lib/router/index.js:458:13)\r\n    at Function.<anonymous> (/Users/simonqian/Work/ohmy411/server/node_modules/express/lib/application.js:220:21)\r\n    at Array.forEach (native)\r\n    at Function.use (/Users/simonqian/Work/ohmy411/server/node_modules/express/lib/application.js:217:7)\r\n    at Object.<anonymous> (/Users/simonqian/Work/ohmy411/server/index.js:32:5)\r\n    at Module._compile (module.js:571:32)\r\n    at Object.Module._extensions..js (module.js:580:10)\r\n    at Module.load (module.js:488:32)\r\n    at tryModuleLoad (module.js:447:12)\r\n    at Function.Module._load (module.js:439:3)\r\n    at Module.runMain (module.js:605:10)\r\n    at run (bootstrap_node.js:423:7)\r\n    at startup (bootstrap_node.js:147:9)\r\n    at bootstrap_node.js:538:3\r\n```\r\n\r\ndependencies\r\n```json\r\n  {\r\n    \"body-parser\": \"^1.17.1\",\r\n    \"connect-mongo\": \"^1.3.2\",\r\n    \"express\": \"^4.15.2\",\r\n    \"express-session\": \"^1.15.2\",\r\n    \"lusca\": \"^1.4.1\",\r\n    \"mongoose\": \"^4.9.2\",\r\n    \"morgan\": \"^1.8.1\",\r\n    \"rotating-file-stream\": \"^1.2.1\",\r\n    \"uuid\": \"^3.0.1\"\r\n  }\r\n```\r\n\r\nWhere is it wrong?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3274/comments",
    "author": "simonqian",
    "comments": [
      {
        "user": "willyelm",
        "created_at": "2017-04-08T16:25:28Z",
        "body": "here:\r\n\r\n```javascript\r\napp.use(morgan('combined'), { stream: accessLogStream })\r\n```\r\n\r\nseems like you are trying to use 2 middleware where the second is a Object `{ stream: accessLogStream }`. you should have:\r\n\r\n```javascript\r\napp.use(morgan('combined', { stream: accessLogStream }))\r\n```\r\n"
      },
      {
        "user": "simonqian",
        "created_at": "2017-04-09T02:23:17Z",
        "body": "@willyelm its working now thank you so much!"
      }
    ],
    "satisfaction_conditions": [
      "Identify the middleware configuration error causing Router.use() to receive an object instead of a function",
      "Resolve improper parameter passing in Express middleware chain",
      "Address Express middleware initialization patterns",
      "Explain proper middleware function signature requirements"
    ]
  },
  {
    "number": 3238,
    "title": "How to render from string?",
    "created_at": "2017-03-06T19:10:33Z",
    "closed_at": "2017-03-07T02:11:22Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3238",
    "body": "Hello.\r\n\r\nHow to render from string?\r\n\r\nindex.js\r\n```\r\nres.render('index', {\"hello\": \"world\"});\r\n```\r\nindex.ejs\r\n```\r\n<%- hello %>\r\n```\r\n\r\nWe need so:\r\n```\r\nvar hello = '<%- hello %>';\r\nres.render(hello, {\"hello\": \"world\"});\r\n```\r\n\r\nIt's possible?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3238/comments",
    "author": "extensionsapp",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-03-06T19:15:41Z",
        "body": "Depending on the case, typically you would just use the engine directly. For example:\r\n```js\r\nvar hello = '<%- hello %>';\r\nres.send(ejs.render(hello, {\"hello\": \"world\"}));\r\n```"
      },
      {
        "user": "extensionsapp",
        "created_at": "2017-03-06T19:24:52Z",
        "body": "@dougwilson This is exactly what I need. Thank you."
      },
      {
        "user": "dougwilson",
        "created_at": "2017-03-07T02:11:22Z",
        "body": "No problem :)"
      }
    ],
    "satisfaction_conditions": [
      "Ability to render templates from dynamically generated string content rather than static files",
      "Support for template engine syntax processing within strings",
      "Integration with Express.js response handling"
    ]
  },
  {
    "number": 3234,
    "title": "Creating a custom renderer for a JS file",
    "created_at": "2017-03-04T08:29:07Z",
    "closed_at": "2017-03-04T08:38:09Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3234",
    "body": "Not sure if this has been asked here before or on SO but I thought I'd post here incase we need to convert to an issue.\r\n\r\nI have the following route;\r\n\r\n```javascript\r\napp.get('/embed/:id.js', (req, res) => {\r\n  res.header('Content-Type', 'text/javascript')\r\n\r\n  res.sendFile(__dirname + '/views/embedTemplate.js', {\r\n    embedId: req.params.id\r\n  })\r\n})\r\n\r\n```\r\n\r\nObviously `sendFile` doesn't permit modifying the file as it's just the `fs` returning the file. So, instead of creating a custom engine to replace `#embedId#` for example, if there a way to `render` the file and modify the contents?\r\n\r\nMy first guess at something like based on the examples would be \r\n\r\n```javascript\r\napp.get('/embed/:id.js', (req, res) => {\r\n  res.header('Content-Type', 'text/javascript')\r\n\r\n  var filePath = __dirname + '/views/embedTemplate.js'\r\n\r\n  var fileToRender = fs.readFile(filePath, function (err, content) {\r\n    if (err) return callback(err)\r\n\r\n    var rendered = content.toString().replace('#embedId#', req.params.id)\r\n    return rendered\r\n  })\r\n\r\n  res.send(fileToRender)\r\n})\r\n```\r\n\r\nAm I missing something that is built into Express?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3234/comments",
    "author": "notrab",
    "comments": [
      {
        "user": "notrab",
        "created_at": "2017-03-04T08:38:08Z",
        "body": "Ok so I figured this out.\r\n\r\nI also moved the render into the readFile callback to prevent thread blocking.\r\n\r\n```javascript\r\napp.get('/embed/:id.js', (req, res) => {\r\n  var filePath = Path.join(__dirname, '/views/embedTemplate.js')\r\n\r\n  fs.readFile(filePath, function (err, content) {\r\n    if (err) return callback(err)\r\n\r\n    var rendered = content.toString().replace('#embedId#', req.params.id)\r\n\r\n    res.setHeader('Content-Type', 'text/javascript')\r\n    res.write(rendered, 'binary')\r\n    res.end()\r\n  })\r\n})\r\n```\r\n\r\nI've never done this with Express before - Maybe an example I can submit a PR for \ud83d\ude0f"
      },
      {
        "user": "dougwilson",
        "created_at": "2017-03-04T21:16:14Z",
        "body": "You could reduce your last example down to the following:\r\n```js\r\napp.get('/embed/:id.js', (req, res) => {\r\n  var filePath = Path.join(__dirname, '/views/embedTemplate.js')\r\n\r\n  fs.readFile(filePath, function (err, content) {\r\n    if (err) return callback(err)\r\n    res.type('js').send(content.toString().replace('#embedId#', req.params.id))\r\n  })\r\n})\r\n```\r\n\r\nBut even then, it would be nice to do it in some more generic way. You may want to even consider thinking about that file as really not a JS file at all, but as a template. You could then use the `res.render` process directly, perhaps to render a \"tjs\" file (was thinking template js, idk). In that case, you could just use an existing template engine, like handlebars, ejs, pug, whatever, and attach that to handle tjs extensions. Then the only additional thing is that you want to send it with the correct content type:\r\n```js\r\napp.get('/embed/:id.js', (req, res) => {\r\n  res.render('embedTemplate.tjs', { endedId: req.params.id }, function (err, content) {\r\n    if (err) return callback(err)\r\n    res.type('js').send(content)\r\n  })\r\n})\r\n```"
      },
      {
        "user": "notrab",
        "created_at": "2017-03-06T22:19:37Z",
        "body": "Totally missed this response. Thank you @dougwilson - this is exactly what I need! \ud83d\ude4c"
      },
      {
        "user": "dougwilson",
        "created_at": "2017-03-07T02:10:24Z",
        "body": "Awesome, no problem :) !"
      }
    ],
    "satisfaction_conditions": [
      "Demonstrates dynamic content modification of a JS file before serving",
      "Integrates with Express's response handling patterns",
      "Maintains proper MIME type for JavaScript responses",
      "Supports template engine pattern for reusable solutions",
      "Handles file I/O asynchronously"
    ]
  },
  {
    "number": 3219,
    "title": "parser.incoming._addHeaderLines is not a function",
    "created_at": "2017-02-21T17:36:49Z",
    "closed_at": "2017-02-21T17:41:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3219",
    "body": "I tried running express with uws and I get this error : \r\n\r\n> _http_common.js:138\r\n>       parser.incoming._addHeaderLines(headers, headers.length);\r\n>                       ^\r\n> \r\n> TypeError: parser.incoming._addHeaderLines is not a function\r\n>     at HTTPParser.parserOnMessageComplete (_http_common.js:138:23)\r\n> \r\n> npm ERR! Darwin 16.1.0\r\n> npm ERR! argv \"/usr/local/bin/node\" \"/usr/local/bin/npm\" \"run\" \"start:dev\"\r\n> npm ERR! node v7.5.0\r\n> npm ERR! npm  v4.1.2\r\n> npm ERR! code ELIFECYCLE\r\n> npm ERR! AdminMeepV2@0.1.0 start:dev: `npm run resetdb && node server.js`\r\n> npm ERR! Exit status 1\r\n> npm ERR! \r\n> npm ERR! Failed at the AdminMeepV2@0.1.0 start:dev script 'npm run resetdb && node server.js'.\r\n> npm ERR! Make sure you have the latest version of node.js and npm installed.\r\n> npm ERR! If you do, this is most likely a problem with the AdminMeepV2 package,\r\n> npm ERR! not with npm itself.\r\n> npm ERR! Tell the author that this fails on your system:\r\n> npm ERR!     npm run resetdb && node server.js\r\n> npm ERR! You can get information on how to open an issue for this project with:\r\n> npm ERR!     npm bugs AdminMeepV2\r\n> npm ERR! Or if that isn't available, you can get their info via:\r\n> npm ERR!     npm owner ls AdminMeepV2\r\n> npm ERR! There is likely additional logging output above.\r\n> \r\n> npm ERR! Please include the following file with any support request:\r\n> npm ERR!     /Users/gatsbill/Desktop/meepV2/server/npm-debug.log\r\n> Aureliens-MBP:server gatsbill$ \r\n\r\nHere is my code : \r\n\r\n```js\r\n'use strict';\r\n\r\nconst express = require('express');\r\n\r\nObject.setPrototypeOf(express.request, require('uws').http.getRequestPrototype());\r\nObject.setPrototypeOf(express.response, require('uws').http.getResponsePrototype());\r\n\r\nconst app = express();\r\nconst server = require('http').createServer(app);\r\n\r\nconst config = require('./config');\r\nconst setGlobalMiddlewares = require('./middlewares/middlewares');\r\nconst routes = require('./routes');\r\n\r\n// set global middlewares\r\nsetGlobalMiddlewares(app);\r\n\r\n// route controller\r\napp.use(routes);\r\n\r\n// start http server\r\nserver.listen(config.server.port, () => {\r\n   console.log('server listen on port ' + config.server.port);\r\n});\r\n```\r\n\r\nDunno if you need all the middleware ",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3219/comments",
    "author": "billouboq",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-02-21T17:41:15Z",
        "body": "I'm not sure. That error is coming from Node.js core (`_http_common.js:138`), not from this module. Can you share the code you used? Do you have a full stack trace? Perhaps there is a bug somewhere in `uws`? Not sure.\n\n---\n\nAh, you edited the original post. Looks like the issue is your line\r\n```js\r\nconst server = require('http').createServer(app);\r\n```\r\n\r\nYou need to use the `uws` module to create the server, not Node.js core. I believe that line should be:\r\n```js\r\nconst server = require('uws').http.createServer(app);\r\n```"
      },
      {
        "user": "wesleytodd",
        "created_at": "2017-02-21T17:41:24Z",
        "body": "Looks like the server you are using is core `http` with the req/res from uws.  That is probably never going to work.  You MIGHT be able to do it with the uws server.\r\n\r\nEDIT: looks like Doug beat me to it :)"
      },
      {
        "user": "billouboq",
        "created_at": "2017-02-21T17:42:48Z",
        "body": "oh thought I was in the uws git... my bad, and yeah forgot to use uws instead of node core http module, thx"
      },
      {
        "user": "dougwilson",
        "created_at": "2017-02-21T17:46:19Z",
        "body": "No problem :)"
      }
    ],
    "satisfaction_conditions": [
      "Identifies incompatibility between uws prototypes and Node.js core http server",
      "Ensures server creation matches the library providing request/response handling",
      "Resolves prototype chain mismatch in HTTP message handling",
      "Maintains compatibility between server implementation and Express middleware"
    ]
  },
  {
    "number": 3167,
    "title": "Why is `new Layer(path...)` used inside `Router` instead of `Layer(path...)`",
    "created_at": "2017-01-05T08:19:21Z",
    "closed_at": "2017-01-06T01:12:10Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3167",
    "body": "I'm going through the source code and I've noticed the following. \r\nIn the `router/index.js` the layer is created like this:\r\n\r\n```\r\n    var layer = new Layer(path, {\r\n      sensitive: this.caseSensitive,\r\n      strict: false,\r\n      end: false\r\n    }, fn);\r\n```\r\nWhile, in `router/route` the layer is created like this:\r\n\r\n`      var layer = Layer('/', {}, handle);`\r\n\r\nBased on the implementation of `Layer`:\r\n\r\n```\r\nfunction Layer(path, options, fn) {\r\n  if (!(this instanceof Layer)) {\r\n    return new Layer(path, options, fn);\r\n  }\r\n```\r\nboth calls do the same. Why use different initializations?\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3167/comments",
    "author": "maxkoretskyi",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-01-06T01:12:10Z",
        "body": "Honestly it's to get the code coverage up until Express 5.0 when this is already removed & addressed :)"
      },
      {
        "user": "maxkoretskyi",
        "created_at": "2017-01-06T09:29:37Z",
        "body": "got it, thanks for the quick feedback"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of the historical/contextual reason for inconsistent initialization patterns",
      "Clarification that both patterns are functionally equivalent in this context",
      "Connection to maintenance/evolution of the codebase"
    ]
  },
  {
    "number": 3148,
    "title": "Is this usecase recommended or discouraged?",
    "created_at": "2016-12-09T10:37:53Z",
    "closed_at": "2016-12-10T17:59:15Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3148",
    "body": "I created some modules for normalizing URLs in different ways (+ there are some others out there), so I would like to bundle them into a single module. This works right now:\r\n\r\n```js\r\napp.use((req, res, next) => {\r\n  req.app.use((req, res, next) => {\r\n    console.log(\"I am called!\");\r\n    next();\r\n  });\r\n  req.app.use((req, res, next) => {\r\n    console.log(\"Me too!\");\r\n    next();\r\n  });\r\n  console.log(\"Great\");\r\n  next();\r\n});\r\n```\r\n\r\nWhich correctly outputs:\r\n\r\n```\r\nGreat\r\nI am called!\r\nMe too!\r\n```\r\n\r\nHowever I worry that this is abusing express functionality/original intent. So I'd like to ask if this is frowned upon or perfectly valid within express' API.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3148/comments",
    "author": "franciscop",
    "comments": [
      {
        "user": "blakeembrey",
        "created_at": "2016-12-09T20:55:22Z",
        "body": "This is not a good way to do it, you're creating a memory leak by mounting applications every single request loop which means that for each request, you have one extra set of middleware mounted (and a new function for each middleware instance too == more memory overhead). \r\n\r\nIt sounds like what you want to do is to look up how Express routers work. It allows you to do this:\r\n\r\n```js\r\nconst router = express.Router();\r\n\r\nrouter.use((req, res, next) => {\r\n  console.log(\"I am called!\");\r\n  next();\r\n});\r\n\r\nrouter.use((req, res, next) => {\r\n  console.log(\"Me too!\");\r\n  next();\r\n});\r\n\r\napp.use(router);\r\n```\r\n\r\nBasically, you can create any instance you'd like and accept `(req, res, next)` - inside that you can do whatever you'd like - be that routing, request management, etc. I wouldn't mess with the application instance itself as you will create a memory leak adding too many instances of middleware."
      },
      {
        "user": "dougwilson",
        "created_at": "2016-12-10T01:18:36Z",
        "body": "And to build on what @blakeembrey said, from a strict sense of the question \"So I'd like to ask if this is frowned upon or perfectly valid within express' API.\": all of that is valid use of the Express API that is public & supported, though it does seem odd."
      },
      {
        "user": "franciscop",
        "created_at": "2016-12-10T17:59:15Z",
        "body": "@blakeembrey that makes total sense, of course the \"base\" `use` one is also a middleware so it'll be called each time. A flag or counter could be added to avoid leaking, but then your solution with the Router seems way better so I'll use it that way. Thanks!"
      }
    ],
    "satisfaction_conditions": [
      "Confirmation of whether dynamically adding middleware during request processing aligns with Express API design principles",
      "Identification of potential memory/performance issues in the approach",
      "Alignment with Express middleware best practices",
      "Provision of a maintainable alternative for middleware organization"
    ]
  },
  {
    "number": 3136,
    "title": "res.redirect(404, '/path/') Not working. ",
    "created_at": "2016-11-21T23:00:49Z",
    "closed_at": "2016-11-21T23:09:51Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3136",
    "body": "This does not work.\r\n\r\n```res.redirect(404, '/path/to/404/page/')```\r\n\r\nThis does. \r\n\r\n```\r\nres.sendStatus(404)'\r\nres.redirect('/path/to/404/page/')\r\n```\r\n\r\nNot sure if that's by design in the case of a 404? Other status codes like `302` work fine. ",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3136/comments",
    "author": "solocreativeco",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2016-11-21T23:09:51Z",
        "body": "In the first example, the response has a 404 status and basically no browser will do anything besides display the redirect page, as 4xx are not redirect codes.\r\n\r\nIn your second example, even though you put the status as 404, the redirect call will overwrite it with 302.\r\n\r\nUltimately it is up to the web browser to actually follow the redirect, and they will only do it for the redirect codes."
      },
      {
        "user": "solocreativeco",
        "created_at": "2016-11-21T23:11:55Z",
        "body": "Ahhh, cool, thanks for your time! :)"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-11-22T00:53:20Z",
        "body": "No problem :) !"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of HTTP status code behavior with redirects",
      "Clarification of browser handling for 4xx status codes",
      "Differentiation between status codes and redirect mechanics",
      "Explanation of status code precedence in response chains"
    ]
  },
  {
    "number": 3107,
    "title": "unix socket support",
    "created_at": "2016-10-20T15:35:29Z",
    "closed_at": "2016-10-21T13:16:07Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3107",
    "body": "Is it possible to use express with unix socket instead of `host:port` ?\n\nThe `listen` signature just call underlying server `listen` method, so I tried with:\n\n``` node\nserver = require('net').createServer(express());\nserver.listen('/tmp/sock', function() {\n  fs.chmodSync('/tmp/sock', 0777);\n});\n```\n\nBut then when, through nginx, I try to access a page, express crashes with the following error:\n\n```\n[...]/node_modules/express/lib/router/index.js:140\n  var search = 1 + req.url.indexOf('?');\n                          ^\n\nTypeError: Cannot read property 'indexOf' of undefined\n    at Function.handle ([...]/node_modules/express/lib/router/index.js:140:27)\n    at EventEmitter.handle ([...]/node_modules/express/lib/application.js:173:10)\n    at Server.app ([...]/node_modules/express/lib/express.js:38:9)\n    at emitOne (events.js:77:13)\n    at Server.emit (events.js:169:7)\n    at Pipe.onconnection (net.js:1431:8)\n```\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3107/comments",
    "author": "magne4000",
    "comments": [
      {
        "user": "LinusU",
        "created_at": "2016-10-20T15:55:57Z",
        "body": "I think that this is already supported:\n\n``` js\nconst express = require('express')\nconst app = express()\n\n// ...\n\napp.listen('/tmp/sock', () => {\n  console.log('Now listening on /tmp/sock')\n})\n```\n"
      },
      {
        "user": "hacksparrow",
        "created_at": "2016-10-20T17:39:10Z",
        "body": "@magne4000 you will need to use `http`, not `net`.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-10-21T02:42:13Z",
        "body": "Yes, @magne4000 , your code incorrectly used the `net` module; if you simply replace your `require('net')` with `require('http')` it works just fine. In addition, you can just pass in the socket path to `app.listen` and Express.js will handle the rest for you. I'm simply summarizing the great replies from @LinusU and @hacksparrow since there hasn't been a response. @magne4000 please let us know if this works for you and we can close the issue, otherwise we can try to figure out why you can't get your UNIX socket working.\n"
      },
      {
        "user": "magne4000",
        "created_at": "2016-10-21T07:31:26Z",
        "body": "Ok my bad ... it seems rather logical to use `http` instead of `net`.\nNow perhaps we need a note in `listen` documentation to mention that socket are also supported ?\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-10-21T13:16:06Z",
        "body": "Glad to hear you got it working! You're absolutely welcome to make a PR to update/add to our documentation. There is a link to edit the docs and open a PR all within your web browser at the bottom of every documentation page :)\n"
      }
    ],
    "satisfaction_conditions": [
      "Demonstrate proper integration of Express with Unix sockets using the correct Node.js core modules",
      "Show Express's native capability to handle socket paths through its listen method",
      "Clarify documentation requirements for socket usage"
    ]
  },
  {
    "number": 3086,
    "title": "Access native Node.js ClientRequest and ServerResponse objects",
    "created_at": "2016-09-14T07:43:51Z",
    "closed_at": "2016-09-14T07:59:15Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3086",
    "body": "Hello there! Sorry if this question was raised before. How can I access native Node.js request and response objects? For example in `koa` it's possible through getters `context.req = request.req = response.req` and `context.res = request.res = response.res` for request and response respectively.\n\nThanks\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3086/comments",
    "author": "roman-vanesyan",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2016-09-14T07:54:47Z",
        "body": "The only objects are the native ones, just we added our own methods and properties to them.\n"
      },
      {
        "user": "roman-vanesyan",
        "created_at": "2016-09-14T07:59:15Z",
        "body": "Thanks, I just poorly looked into the documentation and didn't notice the note:\n\n```\nThe req object is an enhanced version of Node\u2019s own request object and supports all built-in fields and methods.\n```\n\n\n---\n\nThanks, @dougwilson for fast answer ;)\n"
      }
    ],
    "satisfaction_conditions": [
      "Confirmation that Express provides direct access to native Node.js request/response objects",
      "Clarification about how native objects are extended rather than wrapped"
    ]
  },
  {
    "number": 3085,
    "title": "What is the best practice to place this kind of custom middleware function?",
    "created_at": "2016-09-11T13:11:17Z",
    "closed_at": "2016-09-13T12:20:54Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3085",
    "body": "Man, I have a project whose hierarchy is like this:\n\n```\n\u251c\u2500\u2500 app/\n\u251c\u2500\u2500 config.js\n\u251c\u2500\u2500 index.js\n\u251c\u2500\u2500 node_modules/\n\u251c\u2500\u2500 package.json\n\u2514\u2500\u2500 routes/\n```\n\nCurrently, I place all my router in `routes`, these routes share one public middle function in `routes/middlewares/jwt-verifier.js`.\n\nI want to ask, what is the best practice to place this kind of custom middleware function?\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3085/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "NickNaso",
        "created_at": "2016-09-11T14:09:26Z",
        "body": "Hi @m31271n \nin  my opinion you should place middeware where they are useful.  \nIn general middleware take care to process http request and response so if you reduce the number of used middleware you should increase performance.\nIn express you have three level to place middleware:\n- Main Application\n- Sub Applications \n- Routes\n\n``` javascript\n'use strict';\nconst express = require('express');\nconst app = express();\n\n// Common midleware in the app\napp.use(function middlewareApp(req, res, next) {\n  // Process req and res ...\n  next();\n});\n\nconst mySubApp1 = express.Router();\n\n// Common middleware for the sub apps\nmySubApp1.use(function middlewareSubApp1(req, res, next) {\n  // Process req and res ...\n  next();\n});\n\n\nmySubApp1.get('/my-route1/',\n  // Middleware for the route\n  function myMiddleware1(req, res, next) {\n    // Process req and res ...\n    next();\n  }, \n  function (req, res, next) {\n    res.send();\n  }\n);\n\nmySubApp1.get('/my-route2/',\n  // Middleware for the route\n  function myMiddleware2(req, res, next) {\n    // Process req and res ...\n    next();\n  }, \n  function (req, res, next) {\n    res.send();\n  }\n);\n\napp.use('/my-app', mySubApp1);\n\napp.listen(3000);\n```\n\nYou can understand that if you well split your app you are at good point. You can more easily decide where to place middleware. \nHope this help you\nNick\n"
      }
    ],
    "satisfaction_conditions": [
      "Clear guidance on middleware organization hierarchy in Express.js applications",
      "Criteria for determining middleware scope applicability",
      "Consideration of performance implications in middleware placement",
      "Patterns for reusable middleware across multiple routes",
      "Alignment with Express.js architectural conventions"
    ]
  },
  {
    "number": 3082,
    "title": "Set max SSL fragment size in Express",
    "created_at": "2016-09-11T03:38:22Z",
    "closed_at": "2016-09-12T13:14:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3082",
    "body": "I'm using express to set up an HTTPS server for some embedded devices. However, due to the lack of computing capabilities, the default SSL fragment size 16384 is too large for these devices. I wonder how I can change this size in express.\nI found that in tls modules, TLSSocket class has a method _tlsSocket.setMaxSendFragment(size)_ which may work, but I can't find out how to use it in Express.\nThis is how my server is established:\n\n```\nvar app = require('express')();\nvar cert_path = '/home/houlu/Programs/Node/http/ssl/';\nvar privateKey = fs.readFileSync(cert_path+'server.key', 'utf8');\nvar certificate = fs.readFileSync(cert_path+'server.crt', 'utf8');\nvar credentials = {key: privateKey, cert: certificate};\n\nhttpsServer = https.createServer(credentials, app);\n```\n\nThanks a lot!  :-)\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3082/comments",
    "author": "houluy",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2016-09-11T03:52:30Z",
        "body": "Since this is a socket-level option, this would be handled outside of Express, since Express is request/response-level (multiple request/response pairs can share a single socket).\n\nI think the following would work (not 100% sure, as the Node.js documentation isn't very clear, and I'm not at a computer to test), assuming you wanted all sockets to have this setting:\n\n``` js\nvar app = require('express')();\nvar cert_path = '/home/houlu/Programs/Node/http/ssl/';\nvar privateKey = fs.readFileSync(cert_path+'server.key', 'utf8');\nvar certificate = fs.readFileSync(cert_path+'server.crt', 'utf8');\nvar credentials = {key: privateKey, cert: certificate};\n\nvar httpsServer = https.createServer(credentials, app);\n\nhttpsServer.on('connection', function (tlsSocket) {\n  tlsSocket.setMaxSendFragment(/* whatever size */);\n});\n```\n"
      },
      {
        "user": "houluy",
        "created_at": "2016-09-12T08:41:51Z",
        "body": "Thanks a lot, I'll have a try and let you know the results.\nBesides, I think it should be 'secureConnection' instead of 'connection' in HTTPS context.\n:)\n\n\n---\n\nIt works! Thanks a lot!\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-09-12T13:14:49Z",
        "body": "Awesome, good t hear! Let us know if you have any other questions :)\n"
      }
    ],
    "satisfaction_conditions": [
      "Demonstrates how to configure SSL/TLS fragment size at the server level for all connections",
      "Uses Node.js HTTPS/TLS module events to access socket configuration",
      "Integrates with Express's existing HTTPS server creation pattern"
    ]
  },
  {
    "number": 3058,
    "title": "express.Router()",
    "created_at": "2016-08-17T06:43:11Z",
    "closed_at": "2016-08-17T06:53:26Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3058",
    "body": "A function with a name starting with an uppercase letter should only be used as a constructor.\n\nThe sentence `const router = express.Router();` issues with AirBnb eslint.\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3058/comments",
    "author": "cuni0716",
    "comments": [
      {
        "user": "blakeembrey",
        "created_at": "2016-08-17T06:47:42Z",
        "body": "Can you provide more context? This isn't really a bug, just an issue with your chosen linting. Why not just use `new`?\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-08-17T06:53:26Z",
        "body": "Yea, looks like a non-issue to me :) `express.Router` _is a constructor_; you can do `new express.Router()`. The `new` is optional, just like many of the object constructors in JavaScript itself (i.e. `Error('oh no!')` and `new Error('oh no!')` are identical, as the `new` keyword is optional).\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why express.Router() triggers the AirBnb ESLint rule for constructor naming",
      "Confirmation that express.Router is a valid constructor",
      "Guidance on resolving constructor-style usage with optional 'new' keyword",
      "Clarification of JavaScript's optional 'new' behavior for constructors"
    ]
  },
  {
    "number": 3041,
    "title": "new tag for 5.0 alpha?",
    "created_at": "2016-07-21T13:02:14Z",
    "closed_at": "2017-01-29T03:33:38Z",
    "labels": [
      "5.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3041",
    "body": "5.0-alpha.2 is the latest tag and it seems quite a ways behind the 5.0 branch. Any chance we can get a new tag cut?  \n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3041/comments",
    "author": "zackarychapple",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-01-29T03:33:38Z",
        "body": "Hi @zackarychapple, sorry for the delay in a new alpha. I really want one too, but have been away for actually way longer than I expected for uninteresting reasons. I did already merge in the latest 4.x changes to the 5.0 branch, but we just want to actually land a bunch of the pending 5.x changes.\n\n---\n\nA new Express 5.0 alpha has been released: use `npm install express@5.0.0-alpha.3` to get it :)"
      },
      {
        "user": "zackarychapple",
        "created_at": "2017-01-30T13:26:32Z",
        "body": "Fantastic!  Thank you very much!"
      }
    ],
    "satisfaction_conditions": [
      "A new Express 5.0 alpha tag is released and made available",
      "The new tag demonstrates forward progress from the previous alpha.2 version",
      "The release is accessible through standard package management channels"
    ]
  },
  {
    "number": 2969,
    "title": "Parse Json Strings",
    "created_at": "2016-04-13T16:42:02Z",
    "closed_at": "2016-04-13T17:05:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2969",
    "body": "The solution provided in #2460 does not work. Returns \n`URIError: URI malformed`\n\nIn my case for example, my queries should be something of the sort:\n\n`where={%22name%22:%20{%22$like%22:%20%22%bari%22}}`\n\nWhich translates to: \n\n`\n\"where\": {\n  \"name\": {\n    \"$like\": \"%bar\"\n  }\n}\n`\n\nAny help would be appreciated. #2460 is the most similar problem I could find but did not work for me.\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2969/comments",
    "author": "ybrodsky",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2016-04-13T17:05:43Z",
        "body": "Hi! The solution works, just your URI itself is invalid. You have a literal `%` in there, and `%` has a special meaning in a URI, so it has to be encoded. The correct query string should look like the following:\n\n```\nwhere={%22name%22:%20{%22$like%22:%20%22%25bar%22}}\n```\n"
      },
      {
        "user": "ybrodsky",
        "created_at": "2016-04-13T17:17:34Z",
        "body": "Thanks for the help.\nYou were right, nevertheless I am getting a different error now. \n`SyntaxError: Unexpected token w`\n\nIt's because of the 'where=' part when it tries to parse the json object. \nAny idea how could I go around this, without getting rid of the 'where='\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-04-13T17:20:53Z",
        "body": "If you are actually using a query string with name value pairs, then the issue you referenced actually didn't have anything to do with your issue :) You can just use the `req.query` object and parse the string that is in the `where` property:\n\n``` js\nvar obj = JSON.parse(req.query.where)\n```\n"
      },
      {
        "user": "ybrodsky",
        "created_at": "2016-04-13T17:27:18Z",
        "body": "Yea, guess you are right. =/\nThanks for the prompt help, much appreciated.\n"
      }
    ],
    "satisfaction_conditions": [
      "Proper handling of URL-encoded JSON in query parameters",
      "Valid JSON parsing from query string parameters",
      "Preservation of query parameter structure (where=...)",
      "Handling of special characters in JSON filter conditions"
    ]
  },
  {
    "number": 2911,
    "title": "Modifying req.params",
    "created_at": "2016-02-26T12:39:43Z",
    "closed_at": "2016-02-26T14:21:10Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2911",
    "body": "I am having some issues adding properties to `req.params`. It seems the params get wiped out when stepping to the next middleware:\n\n```\nfunction foobarRouter(type) {\n  var router = express.router();\n  router.use(function (req, res, next) {\n    req.params.type = type;\n    next();\n  });\n  router.get('/',         renderPage('foobars'));\n  router.get('/new',      renderPage('foobar_edit'));\n  router.get('/:id',      renderPage('foobar'));\n  router.get('/:id/edit', renderPage('foobar_edit'));\n}\napp.use('/foo', foobarRouter('foo'));\napp.use('/bar', foobarRouter('bar'));\n```\n\nDespite explicitly setting `req.params.type`, it is undefined in `renderPage`.\n\nI had a look at `mergeParams: true`, but it seems that this only preserves the params from the parent, which doesn't work in this case because the parent (the `app.use`) doesn't have any real params.\n\nIt would work if I did, `app.use('/:type', foobarRouter());`, but the route needs to be restricted to specific types only.\n\nHow can I modify the `req.params` for a sub-router so that it looks like they came from the parent?\n\nThanks.\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2911/comments",
    "author": "SystemParadox",
    "comments": [
      {
        "user": "tunniclm",
        "created_at": "2016-02-26T13:32:20Z",
        "body": "AFAIK `req.params` is populated by the route based on `:` tokens or regexp  capture groups within the route definition and is not for storing general values. Typically middleware will store values as properties directly on the `req` object. Be careful not to chose a property that clashes with the base request object or any other middleware you are using though.\n\n\n---\n\n(Also, I assume this code is not what you are actually using since it contains some typos/bugs)\n\nHere's what I used for checking:\n\n``` js\nvar express = require('express');\nvar app = express();\n\nfunction renderPage(name) {\n  return function(req,res,next) {\n    res.send('params: ' + JSON.stringify(req.params) + ', req.params.type: ' + req.params.type + ', req.mytype: ' + req.mytype);\n  }\n}\n\nfunction foobarRouter(type) {\n  var router = express.Router();\n  router.use(function (req, res, next) {\n    req.params.type = type;\n    req.mytype = type;\n    next();\n  });\n  router.get('/',         renderPage('foobars'));\n  router.get('/new',      renderPage('foobar_edit'));\n  router.get('/:id',      renderPage('foobar'));\n  router.get('/:id/edit', renderPage('foobar_edit'));\n  return router;\n}\napp.use('/foo', foobarRouter('foo'));\napp.use('/bar', foobarRouter('bar'));\n\napp.listen(3000);\n```\n"
      },
      {
        "user": "SystemParadox",
        "created_at": "2016-02-26T14:08:17Z",
        "body": "Adding properties directly to the `req` object isn't any better than passing them to `renderPage` directly, I still have to handle them manually.\n\nIt's a bit frustrating that params can only be added by the URL parser and not in code anywhere.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-02-26T14:21:10Z",
        "body": "Hi @SystemParadox, in your example, you are actually modifying `req.params` just fine, but perhaps asking the question \"where did the object `req.params` come from?\" may help understand why your modification disappears in another route.\n\n`req.params` is not like `res.locals`, which is a global object set at the start of Express, rather `req.params` is actually being set as a result of the URL parse. This means that when you where in `router.use(function (req, res, next) {`, the `req.params` object was the result of parsing the URL against `/\\/?/`, which means `req.params = {}`.\n\nNow, you adding a new property to that object in your middleware, which is nice and all, and actually continues to exist... until the next URL parse, because guess what? Express needs to signal what params it found on the current URL parse.\n\nYour code example is not enough to understand the goal you are trying to achieve by setting `req.params.type`, but perhaps you want to use `res.locals.type` instead, as this is one of the global bags Express provides for you to store things between middlewares and routes.\n\n**Edit** Meant `res.locals`, but accidentally originally wrote `req.locals`.\n"
      },
      {
        "user": "SystemParadox",
        "created_at": "2016-02-26T15:45:02Z",
        "body": "Yes I realise why the `req.params` is being overwritten. However, there is `mergeParams: true` which is half way there, I'm just unable to manually set the params early enough for `mergeParams` to work.\n\nWhat I'm trying to achieve is something akin to this:\n\n```\nvar router = express.Router({ mergeParams: true });\napp.use('/:type', router);\n```\n- (Where `:type` is available to handlers defined on `router`)\n- **BUT** the router should only be traversed for specific types, because there is no way to back-out of a sub-router once in it (apart from making none of the routes inside it match, which is pointless)\n\nI was hoping I was just missing something, but at the moment it seems like this is not possible. I guess I will just have to do it the less concise way. I'm not even sure what changes I would propose to make express handle this, unless anyone else has any suggestions?\n\nThanks.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-02-26T16:04:32Z",
        "body": "Hi @SystemParadox, from your description of the goal, it sounds like what you want is the following:\n\n``` js\nvar router = express.Router({ mergeParams: true });\napp.use('/:type', typeRouter('foo', router)); // only runs router when /foo\n\nfunction typeRouter(type, router) {\n  return function (req, res, next) {\n    if (req.params.type !== type) return next();\n    router(req, res, next);\n  };\n}\n```\n\n\n---\n\nThe `mergeParams` in my example is not needed for it to function, I just included it because you had it. It would only be necessary if you wanted `req.params.type === 'foo'` inside the router itself. The example is also the exact way Express is design to handle the use-case you've provided, and ideally at some point these kinds of design patterns that Express looks for can be documented, as it's only discover-able currently once you fully understand the concepts of Express.\n"
      },
      {
        "user": "tunniclm",
        "created_at": "2016-02-26T16:06:27Z",
        "body": "@dougwilson Would `app.use('/:type(foo|bar)', router);` also be a reasonable solution?\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-02-26T16:08:51Z",
        "body": "@tunniclm, indeed! Didn't even think about that :) That's even simpler if the reduced regular expressions provides the necessary match :)\n"
      },
      {
        "user": "SystemParadox",
        "created_at": "2016-03-03T10:21:44Z",
        "body": "@dougwilson yes that's it exactly! I knew there had to be something!\n\nThanks very much for your help :)\n"
      }
    ],
    "satisfaction_conditions": [
      "Solution must propagate a type parameter to sub-router handlers as if it were part of the URL-derived params",
      "Must enforce type restrictions without manual parameter checking in handlers",
      "Should maintain Express's routing pattern conventions",
      "Must prevent invalid types from reaching the router's handlers"
    ]
  },
  {
    "number": 2910,
    "title": "Blank PDF when served from Express",
    "created_at": "2016-02-25T20:31:06Z",
    "closed_at": "2016-02-25T21:51:56Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2910",
    "body": "Similar to #1555 but that one was closed so not sure if my comment will get any attention.\nCopying my comment from there.\n\nI am running into similar issue with my first ever nodejs service. I have following:\n\n``` javascript\n\nvar headers = {} \n///Setting some custom headers for authentication\n\nvar urlObj = new URL( url );\nvar options = {\n            host: urlObj.host,\n            path: urlObj.pathname + urlObj.query,\n            headers: headers\n };\n http.get( options, function( response ) {\n            var body = '';\n            response.on( 'data', function( data ) {\n                body += data;\n             } );\n\n             response.on( 'end', function() {\n                  res.set( 'Content-Type', 'application/pdf' );\n                  res.send( new Buffer( body, 'binary' ) );\n             } );\n } );\n```\n\nBut I see a blank PDF with the correct number of pages and browser renders it as a PDF but all pages are empty.\nAccessing the `url` directly shows the right pdf so the pdf is fine.\nAny input will be really appreciated.\n\nThanks\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2910/comments",
    "author": "vinodmehta",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2016-02-25T21:40:20Z",
        "body": "For stuff like this I usually use the `request` module, you could try something like this:\n\n``` javascript\nvar request = require('request');\nvar app = require('express')();\n\napp.get('/my-pds.pds', function (req, res) {\n  var opts = {} // ...\n  request.get(opts).pipe(res);\n});\n```\n\nRequest and express handle the rest.\n\nAlso, fyi, people who follow the repo also get notifications for comments on closed issues, so your other comment would get seen.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-02-25T21:44:05Z",
        "body": "> Also, fyi, people who follow the repo also get notifications for comments on closed issues, so your other comment would get seen.\n\nBut I would say it's best practice to open a new issue unless you have something specific to add to the other issue :) More often than not, a \"me too\" ends up with a different answer, and the original issue author gets emails for something they don't care about. It also means that even if we get the emails, we can't forget to answer you, since we'll see an open issue :)\n"
      },
      {
        "user": "wesleytodd",
        "created_at": "2016-02-25T21:45:02Z",
        "body": "Good to know, thanks @dougwilson :)\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-02-25T21:51:56Z",
        "body": "And of course, just to iterate on the answer from @wesleytodd, hopefully his answer should fix your issue, @vinodmehta. The reason you are seeing odd behavior is because the way you are piping the PDF file ends up corrupting the file, because the operation `body += data;` will actually cause the `data` Buffer to get decoded as if it was UTF-8 into a string, which will corrupt binary data.\n\nThe `request` module is a really good approach, and I would recommend that, as it's very straight-forward and simple :)\n\nIf you wanted to tweak your original code to see where you went wrong, here is a simple tweak that should address the binary data corruption:\n\n``` js\nvar headers = {} \n///Setting some custom headers for authentication\n\nvar urlObj = new URL( url );\nvar options = {\n            host: urlObj.host,\n            path: urlObj.pathname + urlObj.query,\n            headers: headers\n };\n http.get( options, function( response ) {\n            var body = []; // we're going to store all the chunks of binary data\n            response.on( 'data', function( data ) {\n                body.push(data); // build up an array of Buffers\n             } );\n\n             response.on( 'end', function() {\n                  res.set( 'Content-Type', 'application/pdf' );\n                  res.send( Buffer.concat(body) ); // join all the buffers together as a binary blob\n             } );\n } );\n```\n"
      },
      {
        "user": "vinodmehta",
        "created_at": "2016-02-26T00:03:53Z",
        "body": "Thanks. Yes `request` module really simplified the code a lot to basically one liner.\n\n``` javascript\nrequest.get( { url: url, headers: headers } ).pipe( res );\n```\n"
      }
    ],
    "satisfaction_conditions": [
      "Preserves binary data integrity during transfer",
      "Simplifies proxy implementation for PDF streaming",
      "Avoids string-based concatenation of binary data"
    ]
  },
  {
    "number": 2770,
    "title": "Each request is calling linux stat",
    "created_at": "2015-09-30T14:39:19Z",
    "closed_at": "2015-09-30T16:42:58Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2770",
    "body": "Hi,\nWe added some monitoring to our servers lately after finding some unexpected latency on some times, and saw on our calls to the servers latency is caused by calling linux stat command.\nWe are still investigating to see if this may be related to other used services, but can it be express related issue? \n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2770/comments",
    "author": "eranbrill",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-09-30T14:47:54Z",
        "body": "The express.static will call stat to see if a file exists or not. If you are using express.static to serve files, then yes, you will see a stat. Ideally your express.static should be .use()d after your routes to avoid unnecessary stat calls.\n"
      },
      {
        "user": "eranbrill",
        "created_at": "2015-09-30T16:42:58Z",
        "body": "Works Like A charm, thanks !\n"
      }
    ],
    "satisfaction_conditions": [
      "Identifies the relationship between Express middleware order and unnecessary filesystem stat calls",
      "Explains how to minimize filesystem checks in Express for latency reduction",
      "Addresses Express.static usage patterns that trigger stat operations"
    ]
  },
  {
    "number": 2740,
    "title": "Middleware conflicts - question",
    "created_at": "2015-08-21T19:20:01Z",
    "closed_at": "2015-08-21T19:23:40Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2740",
    "body": "Following scenario:\n\n``` js\nvar middlewre = function(){\n    return function(req, res, next){\n        // do somthing\n        next();\n   }\n}\n```\n\nthen you use it twice:\n\n``` js\napp.use('/', middleware());\napp.use('/SomePath', middleware());\n```\n\nIf request comes to '/SomePath' the middleware will run twice. does it make sense? I would expect that '/' is superset and the middleware will run only once.\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2740/comments",
    "author": "kfiron",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-08-21T19:23:40Z",
        "body": "Hi! Yes, this is exactly as designed. We always run in declared order, and do not do anything special for de-duplicating or prioritizing in the default router.\n\nIf you need them to only run once, the solution we offer is to attach a flag to `req` or similar:\n\n``` js\nvar middlewre = function(){\n    return function(req, res, next){\n        if (req.middlewareRan) return next();\n        req.middlewareRan = true;\n        // do somthing\n        next();\n   }\n}\n```\n"
      },
      {
        "user": "kfiron",
        "created_at": "2015-08-21T19:25:11Z",
        "body": "Thanks\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of Express.js middleware execution order and path matching behavior",
      "Mechanism to ensure middleware executes only once per request regardless of path registrations",
      "Solution compatible with Express's routing philosophy",
      "Clarification about path specificity vs middleware registration order"
    ]
  },
  {
    "number": 2707,
    "title": "Is there a way to let exceptions bubble up instead of passing to finalhandler",
    "created_at": "2015-07-16T03:55:04Z",
    "closed_at": "2015-07-16T04:03:00Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2707",
    "body": "I'm trying to do some exception handling in my app built on express and it's being problematic that every time I throw an exception it gets printed to the screen.\n\nIs this configurable?\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2707/comments",
    "author": "ericuldall",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-07-16T03:56:09Z",
        "body": "Are you talking about getting printed to your web browser, or to the console you are running Node.js on?\n"
      },
      {
        "user": "ericuldall",
        "created_at": "2015-07-16T04:01:54Z",
        "body": "it does both. I think you just addressed this question on finalhandler issues. Does that answer stand?\n\n\n---\n\nbasically i'm using `process.on('uncaughtException')` and my thrown errors aren't getting there.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-07-16T04:03:00Z",
        "body": "The main two configurations are the following:\n\n``` js\n// don't print errors on your node console window\napp.set('env', 'test')\n\n// don't print errors to your web browser\napp.set('env', 'production')\n```\n\nBy default Express assumes development mode, which is what causes the stack traces to head to your web browser.\n\nAlso by default, Express will dump stack traces to your STDERR handle, which is standard when running the server and redirecting STDERR to an error log (as in `node app.js 2> error.log`).\n\n> I think you just addressed this question on finalhandler issues. Does that answer stand?\n\nYes, it does :) especially if you want it to be extremely configurable :) Another thing you can do is the following to use `finalhandler` but turn those two features off:\n\n``` js\nvar express = require('express')\nvar finalhander = require('finalhandler')\nvar http = require('http')\n\nvar app = express()\n\n// declare things on app\n\nvar server = http.createServer(function (req, res) {\n  app(req, res, finalhandler(req, res, {\n    env: 'production', // no stack traces; option name will be better in 1.0\n    onerror: function (err) {\n      throw err; // rethrow to your uncaughtException handler, but i _highly_ don't suggest this\n    }\n  }))\n})\n\nserver.listen(3000)\n```\n"
      },
      {
        "user": "ericuldall",
        "created_at": "2015-07-16T04:04:07Z",
        "body": "thanks again @dougwilson \n"
      }
    ],
    "satisfaction_conditions": [
      "Configuration to prevent Express from automatically handling exceptions and printing them to client/console",
      "Mechanism to propagate exceptions to global error handlers like uncaughtException",
      "Non-destructive error handling that preserves exception bubbling"
    ]
  },
  {
    "number": 2669,
    "title": "IP address as a url param error",
    "created_at": "2015-06-03T17:47:46Z",
    "closed_at": "2015-06-03T19:36:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2669",
    "body": "When declaring an IP address as a URL parameter `req.params` incorrectly parses the value. \n\nAdd the following param to the URL  `:ip((?:[0-9]{1,3}\\.){3}[0-9]{1,3})`\n\nUse the value 192.168.1.2 for ip\n\nThen check  `req.params.ip` it will return as 1. \n\n```\nconsole.log('req.originalUrl',req.originalUrl);\nconsole.log('(req.params.ip',req.params.ip);\n```\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2669/comments",
    "author": "DaleCox",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-06-03T17:54:54Z",
        "body": "Hi, Can you supply a full app that reproduces the error (as there are many things that can influence this?\n\nAlso, it may just be because your param definition does not work with `path-to-regexp` module. Try using `:ip([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})`\n"
      },
      {
        "user": "DaleCox",
        "created_at": "2015-06-03T19:36:35Z",
        "body": "Unfortunately I don't have anything I can post at this time. \n\nThank you the reg ex you provided solved the issue.  \n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-06-03T23:58:33Z",
        "body": "Gotcha. If the updated reg ex worked, then it looks like it's just a limitation in `path-to-regexp` that we use, which is what I thought (you cannot use `(?:` in the reg ex).\n"
      }
    ],
    "satisfaction_conditions": [
      "The regular expression pattern must be compatible with path-to-regexp's syntax requirements",
      "The parameter pattern must fully capture IPv4 addresses in URL parameters",
      "Solution must address limitations in parameter pattern syntax without relying on non-capturing groups"
    ]
  },
  {
    "number": 2659,
    "title": "params in middleware not work",
    "created_at": "2015-05-24T05:41:16Z",
    "closed_at": "2015-05-24T05:46:51Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2659",
    "body": "I have a router with a middleware for manage entry , but not recognize all params from the request,\n\nby example  I have a route like /:username/:idMessage , then the middleware only recognize the username param but not the idMessage\n\n``` javascript\nvar router = express.Router({mergeParams: true});\nrouter.use(function (req, res, next) {\n    console.log(req.params.username);\n    //juliocanares\n\n    console.log(req.params.idMessage);\n    //undefined\n\n    next();\n});\n\n//localhost:3000/juliocanares\nrouter.get('/', function (req, res) {\n    console.log(req.params.username);\n    //juliocanares\n    return res.json({username: req.params.username});\n});\n\n//localhost:3000/juliocanares/10\nrouter.get('/:idMessage', function (req, res) {\n    console.log(req.params.idMessage);\n    //10\n    return res.json({idMessage: req.params.idMessage});\n});\n\napp.use('/:username', router);\n```\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2659/comments",
    "author": "juliocanares",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-05-24T05:48:00Z",
        "body": "This is working as designed. Your `router` will only ever see the params as defined for it, and in your example, this is `app.use('/:username', router);`, thus `router` will only ever have `req.params.username`.\n\n\n---\n\nYou can always redefine\n\n``` js\nrouter.use(function (req, res, next) {\n    console.log(req.params.username);\n    //juliocanares\n\n    console.log(req.params.idMessage);\n    //undefined\n\n    next();\n});\n```\n\nto be the following instead:\n\n``` js\nrouter.use('/:idMessage', function (req, res, next) {\n    console.log(req.params.username);\n    //juliocanares\n\n    console.log(req.params.idMessage);\n    //10\n\n    next();\n});\n```\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of Express router parameter scoping rules",
      "Clarification of middleware execution context in route hierarchies",
      "Understanding of Express parameter inheritance patterns"
    ]
  },
  {
    "number": 2595,
    "title": "/lib/response.js -> undefined is not a function at this.get()",
    "created_at": "2015-03-16T02:14:46Z",
    "closed_at": "2015-03-16T02:20:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2595",
    "body": "I honestly don't even know what information to provide.\nAll I know is my stack trace says:\n\n_Possibly unhandled TypeError: undefined is not a function... lib\\response.js:130:17_\n\nI am using _bluebird_ promise library and the error is being generated when I try:\n\n```\n.then(response.send, next);\n```\n\nbut not when I do:\n\n```\n.then(function(result) {\n    response.send(result)\n}, next);\n```\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2595/comments",
    "author": "lukeavsec",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-03-16T02:20:36Z",
        "body": "I'm also unsure. Best thing for both of us would be if you could provide an app that reproduces this issue that I can cut-and-paste and run on my own machine. Please note the versions of Bluebird, Express, and Node.js you are seeing this in as well. I honestly don't know anything about Bluebird, but if I could run this on my local, I can probably figure it out. It may be an issue here, or it could simply be an issue of using Bluebird incorrectly.\n\n\n---\n\nOh, spoke to soon, I figured it out: you're just using JavaScript itself incorrectly. See, `.send` is a method, so you cannot pass it like a function. Your line should be:\n\n``` js\n.then(response.send.bind(response), next);\n```\n"
      },
      {
        "user": "lukeavsec",
        "created_at": "2015-03-16T03:13:23Z",
        "body": "Doug. You are the man.\nYou solved my problem and taught me something.\nMuch appreciated.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-03-16T03:17:54Z",
        "body": "No problem, any time :) I'm glad I was able to figure it out after squinting my eyes at your code after my first post :) \n"
      }
    ],
    "satisfaction_conditions": [
      "Explains why passing response.send directly as a callback fails while wrapping it in a function works",
      "Addresses proper context preservation when passing object methods as promise handlers",
      "Clarifies the relationship between method invocation and 'this' binding in promise handlers"
    ]
  },
  {
    "number": 2593,
    "title": "Router mergeParams=true does not work ",
    "created_at": "2015-03-14T17:41:11Z",
    "closed_at": "2015-03-14T17:57:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2593",
    "body": "express 4.12.2. According to the Router doc about `mergeParams` option:\n\n> Preserve the `req.params` values from the parent router. If the parent and the child have conflicting param names, the child\u2019s value take precedence.\n\nMay be I miss something, but it does not behave in that way at all:\n\n``` javascript\nvar express = require('express');\nvar app = express();\n\n\napp.get('/users/:username', function(req, res, next) {\n        console.log('> app.get');\n\n    if (req.params.username !== 'alice') {\n        throw new Error('app.get: username != alice');\n    }\n\n    next();\n});\n\nvar router1 = express.Router({mergeParams: true});\napp.use(router1);\n\nrouter1.get('*', function(req, res, next) {\n        console.log('> router1.get');\n\n        // This throws.  \n    if (req.params.username !== 'alice') {\n        throw new Error('router1.get: username != alice');\n    }\n\n    next();\n});\n\napp.listen(5000, '0.0.0.0');\n```\n\nNow send a GET request with url \"/users/alice\" and it will print:\n\n```\n> app.get\n> router.get\nError: router1.get: username != alice\n```\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2593/comments",
    "author": "ibc",
    "comments": [
      {
        "user": "ibc",
        "created_at": "2015-03-14T17:57:04Z",
        "body": "May be `mergeParams` just work when declaring a named param in the mount path of the router?\n\n\n---\n\nYes, sorry for the noise.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-03-14T21:17:08Z",
        "body": "> Yes, sorry for the noise.\n\nI'm not sure if there is such thing as \"noise\" :) So to answer this, what `mergeParams` does is merge any `req.params` that _exists at the time the router is entered_. The reason it wasn't doing anything in your example above is because `app.use(router1);` does not have any parameters. You can see this by doing something like `app.use(function (req, res, next) { console.dir(req.params); next() })` and seeing it as nothing there.\n\nTo expand on your example, there are two possible solutions to achieve this, and the correct one for your situation depends on exactly how you are looking for the sub router to behave:\n\n``` js\nvar express = require('express');\nvar app = express();\n\napp.get('/users/:username', function(req, res, next) {\n        console.log('> app.get');\n\n    if (req.params.username !== 'alice') {\n        throw new Error('app.get: username != alice');\n    }\n\n    next();\n});\n\nvar router1 = express.Router({mergeParams: true});\n// now router1 will actually inherit parameters, since it's defined on a path with them\napp.all('/users/:username', router1);\n\nrouter1.get('*', function(req, res, next) {\n        console.log('> router1.get');\n\n    if (req.params.username !== 'alice') {\n        throw new Error('router1.get: username != alice');\n    }\n\n    next();\n});\n\napp.listen(5000, '0.0.0.0');\n```\n"
      },
      {
        "user": "ibc",
        "created_at": "2015-03-17T11:36:50Z",
        "body": "Clear, thanks a lot.\n"
      },
      {
        "user": "seyedasfar",
        "created_at": "2019-04-14T09:28:33Z",
        "body": "What is the purpose of using mergeParams?"
      },
      {
        "user": "abdoerrahiem",
        "created_at": "2020-07-07T09:08:42Z",
        "body": "> What is the purpose of using mergeParams?\r\n\r\nto use route in another route"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why mergeParams=true didn't preserve req.params in the original setup",
      "Clear demonstration of how to properly mount a router to inherit parameters",
      "Identification of scenarios where mergeParams provides value",
      "Differentiation between parameter inheritance from mounting path vs other contexts"
    ]
  },
  {
    "number": 2566,
    "title": "Is there a way to register a function/layer after the app.get function",
    "created_at": "2015-02-24T08:35:45Z",
    "closed_at": "2015-03-01T08:31:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2566",
    "body": "I want to do the cleanup thing after each get or post route is done, since `route.use` is called before the `route.$httpmethod`, so I wonder is there a way to register a function which is called **_after**_ the `route.$httpmethod`.\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2566/comments",
    "author": "louis-she",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-03-01T04:08:00Z",
        "body": "So, there currently isn't really a built-in way, since all Express offers is to run a bunch of functions in a specific order. You can accomplish this using something like the `on-finished` module, though:\n\n``` js\nvar onFinished = require('on-finished')\n\n// Put this _before_ your routes\napp.use(function (req, res, next) {\n  onFinished(res, function () {\n    // Perform cleanup here, which is fired after any response that passes through this middleware\n  })\n  next()\n})\n```\n"
      },
      {
        "user": "louis-she",
        "created_at": "2015-03-01T08:25:47Z",
        "body": "yep, I have got this by someone from google group and it's the same answer there .\nSo I think this is now the right solution for this.\n"
      }
    ],
    "satisfaction_conditions": [
      "Mechanism to execute cleanup logic after HTTP method handlers (GET/POST) complete",
      "Solution must work with Express.js routing architecture",
      "Implementation-agnostic approach to post-response processing",
      "Supports multiple HTTP methods (GET/POST)"
    ]
  },
  {
    "number": 2531,
    "title": "Loosing params consistency in child routes with mergeParams",
    "created_at": "2015-02-06T14:00:29Z",
    "closed_at": "2015-02-06T14:15:55Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2531",
    "body": "Hi folks,\n\nI'm facing an issue which is that if I nest 2 routers like in the example below, my modifications on the `req.params` object are not kept in the child route. Any thought on how to resolve it ?\n\n``` js\nvar express = require('express');\n\nmodule.exports = function(app) {\n\n    var myRouter = express.Router();\n    var mySpecificRouter = express.Router({\n        mergeParams: true\n    });\n\n    myRouter.all('*', app.requestHelper.verifyToken);\n\n    myRouter.route('/')\n        .get(app.controller.my.list);\n\n    myRouter\n        .use('/:id', function(req, res, next) {\n            if (/^[0-9]+$/.test(req.params.id)) {\n                console.log('parent params before parsing', req.params);\n                req.params.id = parseInt(req.params.id, 10);\n                console.log('parent params', req.params);\n                next();\n            } else {\n                app.status(400).send({error:'bad request'});\n            }\n        }, mySpecificRouter);\n\n    mySpecificRouter\n        .route('/')\n        .get(function(req, res, next) {\n            console.log('child params', req.params);\n            app.status(200).send({});\n        });\n\n    app.use('/route', myRouter);\n};\n```\n\nSo the console log of a get request on /route/101 give me the following:\n\n```\nparent params before parsing {id: '100'}\nparent params {id: 100}\nchild params {id: '101'}\n```\n\nWhen I check in the `parentParams` in the index of the router I see the original object instead of the altered one...\n\nThanks !\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2531/comments",
    "author": "YouriT",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-02-06T14:15:55Z",
        "body": "It's because `req.params` is not just a \"bag-o-things\"; you have to modify it within a `app.param`/`router.param` declaration, rather than a `.use()`:\n\n``` js\nvar express = require('express');\n\nmodule.exports = function(app) {\n\n    var myRouter = express.Router();\n    var mySpecificRouter = express.Router({\n        mergeParams: true\n    });\n\n    myRouter\n        .param('id', function(req, res, next, val) {\n            if (/^[0-9]+$/.test(val)) {\n                console.log('parent params before parsing', req.params);\n                req.params.id = parseInt(req.params.id, 10);\n                next();\n            } else {\n              res.status(400).send({error:'bad request'});\n            }\n        })\n        .use('/:id', mySpecificRouter);\n\n    mySpecificRouter\n        .route('/')\n        .get(function(req, res, next) {\n            console.log('child params', req.params);\n            res.status(200).send({});\n        });\n\n    app.use('/route', myRouter);\n};\n```\n"
      },
      {
        "user": "YouriT",
        "created_at": "2015-02-06T15:12:36Z",
        "body": "Thanks @dougwilson !!!\n"
      }
    ],
    "satisfaction_conditions": [
      "Demonstrates how to modify request parameters in Express in a way that persists to child routes",
      "Explains the correct Express mechanism for parameter transformation that maintains consistency across routes",
      "Ensures parameter modifications in parent routes are properly merged with child route parameters",
      "Maintains parameter validation while enabling type conversion",
      "Preserves Express router architecture while solving parameter persistence"
    ]
  },
  {
    "number": 2529,
    "title": "Deprecated message thrown when using res.status",
    "created_at": "2015-02-04T05:12:05Z",
    "closed_at": "2015-02-04T05:24:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2529",
    "body": "I have been aware that since express@4.x, `res.send(201, obj)` format has been deprecated. But I am running into a situation where in 4.x I would want to send an `id` back, as shown as follows:\n\n``` js\nvar app = express();\n\napp.use(function(req, res) {\n  res.statusCode(201).send(1111); // where this is the ID.\n});\n\nrequest(app)\n   .get('/')\n   .expect(1111)\n   .expect(201, done);\n```\n\nBut I would get the deprecated message:\n\n`express deprecated res.send(status)`\n\nI was wondering if how should I approach this situation in `express` where I would want to send an integer back without having to do the following:\n\n``` js\napp.use(function(req, res) {\n  res.statusCode(201).send({ id: 1111 }); // where this is the ID.\n});\n```\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2529/comments",
    "author": "limianwang",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-02-04T05:19:12Z",
        "body": "It's an unfortunate edge-case, and a prime sample of why this is deprecated :) `res.send(1111)` actually tries to send a response with the status code of 1111. To signify that you want the number as the body, simply wrap it in `String`: `res.status(201).send(String(1111))`; if you wanted to send JSON, `res.status(201).json(1111)`\n"
      },
      {
        "user": "limianwang",
        "created_at": "2015-02-04T05:21:53Z",
        "body": "Ah okay. I guess `res.status(201).send(String(1111))` isn't a bad work around. I'll use that for now. \n\nThanks!\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-02-04T05:24:28Z",
        "body": "No problem. It wound be necessary even if there was no deprecation at all :) The deprecation means that it finally _won't_ be necessary in 5.0 :D\n"
      }
    ],
    "satisfaction_conditions": [
      "Solution must allow sending a numeric value as raw response body without triggering deprecation warnings",
      "Must maintain the ability to set HTTP status code (201) separately from response content",
      "Should explain why numeric values require special handling in Express response methods",
      "Must work within Express 4.x constraints while avoiding deprecated patterns"
    ]
  },
  {
    "number": 2510,
    "title": "route can not use in chinese",
    "created_at": "2015-01-23T04:09:55Z",
    "closed_at": "2015-01-23T05:16:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2510",
    "body": "work good/articles/:type(%E8%B6%8B%E5%8A%BF|%E8%A7%82%E7%82%B9|%E6%A1%88%E4%BE%8B)\n\nwrong:   /articles/:type(\u8d8b\u52bf|\u89c2\u70b9|\u6848\u4f8b)?\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2510/comments",
    "author": "suzukua",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-01-23T04:16:39Z",
        "body": "When you put strings in the path, they are matches against the literal URL, rather than the decoded component. You can use `req.param` to validate against the decoded value as a work-around:\n\n``` js\napp.param('type', function (req, res, next, val) {\n  var match = type === '\u8d8b\u52bf' || type === '\u89c2\u70b9' || type === '\u6848\u4f8b'\n  next(match ? null : 'route')\n})\n\napp.get('/articles/:type', function (req, res) {\n  res.end()\n})\n```\n"
      },
      {
        "user": "suzukua",
        "created_at": "2015-01-23T05:16:57Z",
        "body": "Good, thank you.\n"
      }
    ],
    "satisfaction_conditions": [
      "Supports validation of URL-decoded Chinese characters in route parameters",
      "Provides a way to handle non-ASCII characters in route definitions",
      "Maintains route matching functionality while supporting special characters"
    ]
  },
  {
    "number": 2387,
    "title": "Router: Cannot use literal characters \\] and \\) in Regex",
    "created_at": "2014-10-09T14:17:28Z",
    "closed_at": "2014-10-09T15:04:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2387",
    "body": "I know is horrible having special characters in URLs but I sadly have to manage them, so I tried to use this route:\n\n``` javascript\nrouter.get(\"/thumb/:file([a-zA-Z\\-0-9\\/ \\._\\%,&\\[\\]]+)/:size\", function (req, res) {\n   //do stuff\n});\n```\n\nto handle an URL like: `/thumb/canada/news-events/event-list/185-Roma_Ghezzi[1].jpg/75x75`\n\nAdding the character `\\\\]` will make the route stop working, even if the URL doesn't contain those characters.\n\nEven worst when you try adding the characters `\\\\(` or `\\\\)` because it crashes the process with the error:\n\n```\nSyntaxError: Invalid regular expression: /^\\/thumb\\/(?:([a-zA-Z-0-9\\/ \\._%,&[]))]+)\\/(?:([^\\/]+?))\\/?$/: Unmatched ')'\n    at new RegExp (<anonymous>)\n```\n\nI'd really prefer to use this a rule like the following one:\n\n``` javascript\nrouter.get(\"/thumb/:file(.+)/:size\", function (req, res) {\n   //do stuff\n});\n```\n\nbut the expression `(.+)` doesn't match a string like: `folder/subfolder/file` because the slashes `/` are considered a stop character (I guess).\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2387/comments",
    "author": "darkoromanov",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2014-10-09T14:28:14Z",
        "body": "Correct, it is a limitation, and our dependency has an update that may fix it, but it's not backwards-compatible, so it can never land inside express 4.\n\nAnother thing is that the URL above, `/thumb/canada/news-events/event-list/185-Roma_Ghezzi[1].jpg/75x75` should be coming into your server as `/thumb/canada/news-events/event-list/185-Roma_Ghezzi%5B1%5D.jpg/75x75`, which you would be able to match using a regular express in your URL.\n\nFor one thing, you can never match on `/` within the part regular expressions, as they only are supposed to span a single path component. You may be interested in the `*` character in the path, which may satisfy your needs:\n\n``` js\nrouter.get(\"/thumb/:file*/:size\", function (req, res) {\n   //do stuff\n});\n```\n\nAs a last resort, the path itself can be whatever regular expression you like:\n\n``` js\nrouter.get(/^\\/thumb\\/(.+?)\\/([^\\/]+)\\/?$/, function (req, res) {\n   //do stuff\n});\n```\n"
      },
      {
        "user": "darkoromanov",
        "created_at": "2014-10-09T15:04:34Z",
        "body": "Ok I understand, URLencoding the file name is a good point. However, this regex:\n\n``` javascript\nrouter.get(\"/thumb/:file*/:size\", function (req, res) {\n   //do stuff\n});\n```\n\ndoesn't work as expected as it returns these params:\n\nURL: /thumb/canada/news-events/event-list/1.jpg/75x75\n\n``` javascript\n{ '0': '75x75',\n  file: 'canada',\n  size: '/news-events/event-list/1.jpg' }\n```\n\nInstead, this rule \n\n``` javascript\nrouter.get(/^\\/thumb\\/(.+?)\\/([^\\/]+)\\/?$/, function (req, res) {\n//do stuff\n});\n```\n\nworks perfectly as it produces:\n\n``` javascript\n{ '0': 'canada/news-events/event-list/1.jpg', '1': '75x75' }\n```\n\nThanks!\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2014-10-09T15:22:31Z",
        "body": "Interesting note on that string rule. And just as a side-note, RegExp paths are of course fully supported, so you're not taking advantage of a \"hidden\" feature or anything :)\n"
      }
    ],
    "satisfaction_conditions": [
      "Supports special characters like [ and ] in URL paths without causing regex errors",
      "Allows matching across multiple path segments (including slashes) for the file parameter",
      "Maintains proper parameter separation between file and size components",
      "Avoids limitations of Express's path-to-regexp implementation for parameter patterns",
      "Provides a stable solution that doesn't crash the process"
    ]
  },
  {
    "number": 5403,
    "title": "Inconsistent Logging Order for GET and POST Requests",
    "created_at": "2024-01-23T10:50:40Z",
    "closed_at": "2024-01-24T20:16:34Z",
    "labels": [
      "help wanted",
      "good first contribution"
    ],
    "url": "https://github.com/expressjs/express/issues/5403",
    "body": "**Issue Description:**\r\nI have implemented middleware in my Express application to log request details and response time. The main application code is provided below:\r\n\r\n```javascript\r\nconst path = require('path');\r\nconst express = require('express');\r\n\r\nconst friendsRouter = require('./routes/friends.router');\r\nconst messagesRouter = require('./routes/messages.router');\r\n\r\nconst app = express();\r\nconst publicPath = path.join(__dirname, 'public');\r\n\r\nconst PORT = 3000;\r\n\r\napp.use((req, res, next) => {\r\n  const start = Date.now();\r\n  next();\r\n\r\n  const delta = Date.now() - start;\r\n  console.log(`${req.method} ${req.baseUrl}${req.url} ${delta}ms`);\r\n});\r\n\r\napp.use(express.json());\r\napp.use('/static', express.static(publicPath));\r\n\r\napp.use('/friends', friendsRouter);\r\napp.use('/messages', messagesRouter);\r\n\r\napp.listen(PORT, () => {\r\n  console.log(`Server listening on port ${PORT}`);\r\n});\r\n```\r\n\r\nIn friendsRouter, I have an extra middleware to log the ip address:\r\n```javascript\r\nfriendsRouter.use((req, res, next) => {\r\n  console.log('ip address', req.ip);\r\n  next();\r\n});\r\n```\r\n\r\nWhen I send a GET request, the logs are as expected:\r\n```bash\r\nGET /friends/ 2ms\r\nip address ::1\r\n```\r\n\r\nHowever, when I send a POST request, the order of logs is not consistent:\r\n```bash\r\nPOST /friends 4ms\r\nip address ::1\r\n```\r\n\r\n**Expected Behavior:**\r\nConsistent order of logs is expected for both GET and POST requests since the order of middleware functions is not changed.\r\n\r\n**Actual Behavior:**\r\nThe order of logs is inconsistent for GET and POST requests, and there's a noticeable difference in the path format for POST requests.\r\nFor a POST request, there is no / at the end.\r\n\r\n**Additional Information:**\r\nExpress version: 4.18.2\r\nNode.js version: 20.10.0\r\nOperating System: WSL2",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/5403/comments",
    "author": "ThomasCode92",
    "comments": [
      {
        "user": "ammyroy119",
        "created_at": "2024-01-24T11:07:11Z",
        "body": "The inconsistency in the order of logs and the difference in the path format for GET and POST requests may be due to the fact that the delta logging is done outside of the asynchronous operation in the middleware stack. When using asynchronous operations like next() or async middleware, the timing of logging might be affected.\r\n\r\nTo address this issue, you can modify the logging middleware to ensure that the delta logging is done after the asynchronous operations complete. One way to achieve this is by using the response event emitted by Express after the response has been sent.\r\n\r\nHere's an updated version of your logging middleware:\r\n```\r\n`app.use((req, res, next) => {\r\n  const start = Date.now();\r\n\r\n  res.on('finish', () => {\r\n    const delta = Date.now() - start;\r\n    console.log(`${req.method} ${req.baseUrl}${req.url} ${delta}ms`);\r\n  });\r\n\r\n  next();\r\n});\r\n```\r\nBy attaching the logging code to the finish event of the response, you ensure that it will be executed after the response has been sent, regardless of any asynchronous operations in the middleware stack.\r\n\r\nAfter making this change, the order of logs for both GET and POST requests should be consistent."
      },
      {
        "user": "ThomasCode92",
        "created_at": "2024-01-24T11:18:19Z",
        "body": "@ammyroy119 Thank you so much for the detailed explanation and solution! I've tested it, and it appears to be working perfectly! Your assistance is greatly appreciated."
      }
    ],
    "satisfaction_conditions": [
      "Ensures consistent middleware execution order for all request types",
      "Handles asynchronous middleware completion before logging"
    ]
  }
]