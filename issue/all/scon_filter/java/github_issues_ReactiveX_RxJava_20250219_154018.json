[
  {
    "number": 7834,
    "title": "DistinctUntilChanged doesn't work on API level 29",
    "created_at": "2025-02-13T18:38:13Z",
    "closed_at": "2025-02-17T08:24:11Z",
    "labels": [
      "Question",
      "Android"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7834",
    "body": "Running this code on API level 25, `t1` and `t2` are different when typing in the edit text.  \nHowever, on API level 29, the `t1 == t2` condition always evaluates to true.\n\n```\nfun TextInputLayout.priceInput(\n    maxValue: Long = Constants.max_value_receipt.toLong(),\n    skipInitialValue: Boolean = false): Observable<CharSequence> {\n\n    var animation: ValueAnimator? = null\n\n    errorIconDrawable = null\n\n    editText!!.inputType =\n        EditorInfo.TYPE_NUMBER_FLAG_DECIMAL\n    editText!!.keyListener =\n        DigitsKeyListener.getInstance(\"0123456789,\")\n\n    editText!!.setOnTouchListener { _, motionEvent ->\n        if (motionEvent.action == MotionEvent.ACTION_UP) {\n            editText!!.showSoftKeyboard()\n        }\n        return@setOnTouchListener true\n    }\n\n    editText!!.setOnFocusChangeListener { _, hasFocus ->\n        if (hasFocus) editText!!.selectAtTheEnd()\n    }\n\n    val afterTextChangeEvents = editText!!.textChanges().let {\n        if (skipInitialValue)\n            it.skipInitialValue()\n        else\n            it.skip(0)\n    }\n    return afterTextChangeEvents\n        .distinctUntilChanged { t1, t2 ->\n            t1 == t2\n        }\n        .concatMap {\n            Observable.fromCallable {\n                val toString = it.toEmptyIfNull().toString()\n                if (toString.isEmpty())\n                    return@fromCallable toString\n                val withoutComma = toString.replace(\",\", \"\")\n                val value = try {\n                    withoutComma.toLong()\n                } catch (e: Exception) {\n                    return@fromCallable (editText!!).text.delete(\n                            editText!!.text.length - 1,\n                            editText!!.text.length)\n                }\n                if (value > maxValue) {\n                    if (animation == null || animation!!.isRunning.not()) {\n                        animation = createAnimationError(editText!!)\n                        animation!!.start()\n                    }\n                    return@fromCallable editText!!.text.delete(\n                            editText!!.text.length - 1,\n                            editText!!.text.length)\n                }\n                val result = Formats.convertPrice_LongToStringWithComma(value)\n                Logger.d { \"formatted: $result\" }\n                if (toString != result)\n                    editText!!.text.replace(0, editText!!.text.length, result)\n                return@fromCallable result\n            }\n                .onErrorReturnItem(\"\")\n        }\n}\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7834/comments",
    "author": "Jacek-Gawel",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2025-02-13T18:46:06Z",
        "body": "As far as I remember, text change events use a mutable `CharSequence`, thus you may be checking the contents of the same reference object.\n\nTry mapping the text changes into Strings\n\n```kotlin\neditText!!.textChanges().map { it.toString() }.let {\n```"
      },
      {
        "user": "Jacek-Gawel",
        "created_at": "2025-02-17T07:59:21Z",
        "body": "Mapping `textChanges()` to `String` resolves issue.\nThx"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why CharSequence reference equality fails to detect text changes on API 29",
      "Solution must ensure distinctUntilChanged compares text content rather than object references",
      "Approach must handle mutable CharSequence behavior differences between Android API levels",
      "Method to create stable content representations for change detection"
    ]
  },
  {
    "number": 7613,
    "title": "3.x: Items dropped by observeOn without backpressure errors",
    "created_at": "2023-10-19T16:29:53Z",
    "closed_at": "2023-10-19T17:13:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7613",
    "body": "RxJava version: 3.1.8\r\n\r\nI'm processing messages from `PublishProcessor` in parallel. On failure, items are put back to the processor for re-processing. I've noticed that events go missing randomly.\r\n\r\nReproduction:\r\n\r\n```java\r\nprocessor\r\n    .doOnNext(s -> logger.trace(\"next: {}\", s)) // item is here\r\n    .onBackpressureDrop(s -> { // never called\r\n        logger.error(\"!!!!!!! DROP {}\", s);\r\n        throw new RuntimeException(\"drop\");\r\n    })\r\n    .observeOn(Schedulers.single()) // switch to single thread\r\n    .doOnNext(s -> logger.trace(\"next single: {}\", s)) // item is missing here\r\n    .parallel()\r\n    .runOn(Schedulers.io())\r\n    .map(s -> { // run in parallel\r\n        logger.info(\"Processing {}\", s);\r\n        Thread.sleep(50);\r\n        logger.warn(\"Processing completed, reprocessing: {}\", s);\r\n        processor.onNext(s); // put item back\r\n        return s;\r\n    })\r\n    .sequential()\r\n    .subscribe();\r\n\r\nprocessor.onNext(\"aaa\");\r\nprocessor.onNext(\"XXX\");\r\n```\r\n\r\nRunning it gives results in under a minute, often quicker - after some time, only one of the items is being processed, the other is lost.\r\n\r\nI'm switching to `Schedulers.single()` for computation I've removed for brevity, and then process items in parallel. I found that items are lost on the `observeOn()` step - item is logged before it, and not logged after.\r\n\r\nI've read the backpressure notice for the `observeOn()`, but as I understand, in case of the backpressure problem the `MissingBackpressureException` should be thrown. That's not happening.\r\n\r\nAlso the `onBackpressureDrop()` callback is never called.\r\n\r\nReplacing `observeOn()` with `delay(0, TimeUnit.SECONDS, Schedulers.single())` seems to solve the problem, however I don't think quietly dropping items by `observeOn()` is expected here?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7613/comments",
    "author": "m-radzikowski",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2023-10-19T16:35:40Z",
        "body": "Did you serialize the `processor`? You are accessing it from possibly many threads."
      },
      {
        "user": "m-radzikowski",
        "created_at": "2023-10-19T17:13:12Z",
        "body": "No \ud83e\udd26\u200d\u2642\ufe0f\r\n\r\nI did not notice that Publishers are not all methods are thread-safe by default. Serializing it solves the issue. Sorry."
      }
    ],
    "satisfaction_conditions": [
      "Identifies thread-safety requirements for RxJava components",
      "Explains interaction between backpressure mechanisms and multi-threaded access",
      "Clarifies expectations around observeOn's item handling behavior"
    ]
  },
  {
    "number": 7555,
    "title": "3.x: Different behavior between blockingForEach and forEach",
    "created_at": "2023-04-17T13:54:15Z",
    "closed_at": "2023-04-18T07:21:58Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7555",
    "body": "Hello,\r\n\r\nI'm surprise to see that the observable:\r\n```java\r\nObservable.just(0, 1, 2)\r\n    .doOnSubscribe(ignored -> LOG.info(\"On subscribe\"))\r\n    .doOnTerminate(() -> LOG.info(\"On terminate\"))\r\n```\r\n\r\nproduce the following result with `.forEach(i -> LOG.info(\"Data: {}\", i));`:\r\n```\r\n15:30:25.501 [main] INFO manual.NonBlockingTest - On subscribe\r\n15:30:25.501 [main] INFO manual.NonBlockingTest - Data: 0\r\n15:30:25.501 [main] INFO manual.NonBlockingTest - Data: 1\r\n15:30:25.501 [main] INFO manual.NonBlockingTest - Data: 2\r\n15:30:25.501 [main] INFO manual.NonBlockingTest - On terminate\r\n```\r\n\r\nand with `.blockingForEach(i -> LOG.info(\"Data: {}\", i));`:\r\n```\r\n15:32:04.932 [main] INFO manual.BlockingTest - On subscribe\r\n15:32:04.934 [main] INFO manual.BlockingTest - On terminate\r\n15:32:04.935 [main] INFO manual.BlockingTest - Data: 0\r\n15:32:04.936 [main] INFO manual.BlockingTest - Data: 1\r\n15:32:04.936 [main] INFO manual.BlockingTest - Data: 2\r\n```\r\n\r\nI expected to have the same result (subscribe, datas, terminate) with `blockingForEach` as with `forEach` without using any scheduler. I have the same result with `subscribe`.\r\n\r\nI tested with versions 3.1.3 and 3.1.6.\r\n\r\nThe documentation does not mention any difference between the two behaviors except that the blocking behavior blocks the current thread (which is what I want).\r\n\r\nDid I not understand correctly the difference between the two or it is a bug?\r\n\r\nThanks for your time.\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7555/comments",
    "author": "JaquierM",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2023-04-17T14:05:18Z",
        "body": "Not a bug. `blockingForEach` has an internal blocking buffer that can fill up before the control reaches its consumer callbacks.\r\n\r\nIn such synchronous cases, the upstream produces all items plus the terminal signal upon subscription, before `blockingForEach` switches to its consumer loop. With asynchronous sources, the production will usually happen on some other thread so the switch to the consumer loop pretty much immediately."
      },
      {
        "user": "JaquierM",
        "created_at": "2023-04-18T07:21:58Z",
        "body": "Ok, thanks for the answer.\r\n\r\nI was not expecting that difference. I will just move my logic from `doOnTerminate` after the blocking call."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why blockingForEach executes termination callback before processing items in synchronous scenarios",
      "Clarification of internal buffering mechanism in blockingForEach",
      "Differentiation between synchronous and asynchronous source handling"
    ]
  },
  {
    "number": 7475,
    "title": "repeatWhen bocking",
    "created_at": "2022-10-09T07:41:26Z",
    "closed_at": "2022-10-16T09:55:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7475",
    "body": "Observable.just(1)\r\n  .repeatWhen(o->o.flatMap(os->Observable.empty()))\r\n  .blockingIterable().forEach(System.out::println);\r\n\r\n// blocking on here\r\n\r\nSystem.out.println(\"Complete\");\r\n\r\nnot print Complete",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7475/comments",
    "author": "VectorWen",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2022-10-09T09:17:30Z",
        "body": "What where you trying to achieve? \r\n\r\nIn order to stop repeating, the inner sequence has to be completed, however, `flatMap`ping an empty source does not complete the sequence. You need some kind of `takeUntil` inside `repeatWhen` to trigger a completion."
      },
      {
        "user": "VectorWen",
        "created_at": "2022-10-12T03:23:18Z",
        "body": "@akarnokd e.g.\r\n\r\n```java\r\npublic class RepeatWhenMain {\r\n    private static int i = 0;\r\n\r\n    public static void main(String[] args) {\r\n        Observable.just(0)\r\n                .map(o -> i)\r\n                .repeatWhen(o -> o.flatMap(s -> {\r\n                    if (i < 15) {\r\n                        i++;\r\n                        return Observable.just(1);\r\n                    }\r\n                    //need complete, but  not completed\r\n                    return Observable.empty();\r\n                }))\r\n                .blockingIterable().forEach(System.out::println);\r\n    }\r\n}\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2022-10-12T05:43:03Z",
        "body": "Try `o.takeUntil(v -> v == 15).flatMap(etc.)`."
      },
      {
        "user": "VectorWen",
        "created_at": "2022-10-14T04:00:38Z",
        "body": "@akarnokd thank you"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how to properly terminate the repeatWhen operator's repetition",
      "Clarification on why Observable.empty() in flatMap doesn't complete the sequence",
      "Demonstration of condition-based termination for repeatWhen",
      "Guidance on proper operator chaining within repeatWhen"
    ]
  },
  {
    "number": 7370,
    "title": "Update the object emitted by Single in async way",
    "created_at": "2021-12-07T13:19:56Z",
    "closed_at": "2021-12-07T13:33:25Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7370",
    "body": "Hello, Could you please clarify whether I can update the object emitted by Single in async way by several methods?\r\nI have the folliwing code:\r\n```\r\nreturn Single.just(order)\r\n                .flatMap(o -> updateProducerInfo(o))\r\n                .flatMap(o -> updateCustomerInfo(o));\r\n\r\nprivate Single<Order> updateProducerInfo(Order order) {\r\n        // takes a long time\r\n    }\r\nprivate Single<Order> updateCustomerInfo(Order order) {\r\n        // takes a long time\r\n    }\r\n```\r\nIs there a way to execute these methods in parallel to reduce the overall execution time?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7370/comments",
    "author": "YauheniZarembin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2021-12-07T13:31:22Z",
        "body": "Yes, provided both update methods touch independent parts of `Order`:\r\n\r\n```java\r\nreturn Single.zip(\r\n              updateProducerInfo(order).subscribeOn(Schedulers.io()),\r\n              updateCustomerinfo(order).subscribeOn(Schedulers.io()),\r\n              (a, b) -> order);\r\n```"
      }
    ],
    "satisfaction_conditions": [
      "Demonstrate parallel execution of asynchronous operations on an RxJava Single",
      "Ensure thread-safe modification of the Order object",
      "Maintain the Single emission contract",
      "Handle result combination from parallel operations",
      "Utilize proper RxJava concurrency mechanisms"
    ]
  },
  {
    "number": 7327,
    "title": "How can I check completion of saving which is processed  in async way?",
    "created_at": "2021-08-26T13:36:31Z",
    "closed_at": "2021-08-26T16:16:30Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7327",
    "body": "Hi. could you please clarify how I can wait async execution of saving?\r\nI Have the following methods in repository class.\r\n```\r\npublic Completable save(Book book) {\r\n        // logic to save book in DB\r\n    }\r\n\r\npublic Single<Boolean> exist(Book book) {\r\n        // logic to check if book exists in DB\r\n    }\r\n```\r\nAnd there is method in service that uses _save_ method from repository\r\n```\r\npublic Single<Book> saveBook(Book book) {\r\n        bookRepo.save(book);\r\n        return Sing.just(book);\r\n    }\r\n```\r\n\r\nThe problem is that after _saveBook_ method execution the book may not be in the database as saving is processed  in async way.\r\nHow can I change me _saveBook_ method using _exist_ method to be sure that after _saveBook_ method execution I will have the book in DB?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7327/comments",
    "author": "YauheniZarembin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2021-08-26T13:53:24Z",
        "body": "You can compose them via `flatMapCompletable`, for example:\r\n\r\n```java\r\npublic Single<Book> saveBook(Book book) {\r\n    return exist(book)\r\n           .flatMapCompletable(exists -> exists ? Completable.complete() : bookRepo.save(book))\r\n           .andThen(Single.just(book));\r\n```"
      },
      {
        "user": "YauheniZarembin",
        "created_at": "2021-08-26T14:03:26Z",
        "body": "No, maybe I should clarify my case.\r\n\r\nAt First I have nothing in DB. Then I save book by _saveBook_ method from service.\r\nAfter that I want to update this book.\r\nBut when I try to receive book from DB for update I have nothing, as save is still executing very long in asycn way and DB is empty.\r\n\r\nSo in _saveBook_ method I want to wait to be sure that when I need to update book it will be in DB."
      },
      {
        "user": "akarnokd",
        "created_at": "2021-08-26T14:11:39Z",
        "body": "It depends on how you structured your save-update workflow.\r\n\r\nOne possibility is to cache the `saveBook` above; it will make sure the save runs at most once and there will be a value ready after, indicating the save completed.\r\n\r\n```java\r\nSingle<Book> bookCached = saveBook(book).cache();\r\nbookCached.subscribe(/* trigger the save */);\r\n\r\n// later\r\nbookCached\r\n  .flatMap(book -> updateBook(book))\r\n  .subscribe(/* trigger update */)\r\n```"
      },
      {
        "user": "YauheniZarembin",
        "created_at": "2021-08-26T15:05:32Z",
        "body": "Thanks!\n\n---\n\n@akarnokd Maybe I foung what I want.\r\nCould you please review is that a good way to check?\r\n\r\n```\r\npublic Single<Book> saveBook(Book book) {\r\n        bookRepo.save(book);\r\n        \r\n        boolean saved = Single.defer(() -> bookRepo.exist(book))\r\n                .repeat()\r\n                .takeUntil(b -> b)\r\n                .ignoreElements()\r\n                .blockingAwait(10000, TimeUnit.MILLISECONDS);\r\n                \r\n        if (saved) {\r\n            return Single.just(book);\r\n        } else {\r\n            //error\r\n        }\r\n  \r\n    }\r\n```\r\n\r\n\u0421an this code be simplified?"
      },
      {
        "user": "akarnokd",
        "created_at": "2021-08-26T15:44:28Z",
        "body": "That repeat will be very eagle, perhaps waiting a second may be preferable: `repeatWhen(o -> o.delay(1, TimeUnit.SECONDS))`.\r\n\r\nIf you block, there is no value in returning a `Single`. Also depending on where this code runs, you may not be allowed to block."
      },
      {
        "user": "YauheniZarembin",
        "created_at": "2021-08-26T16:16:30Z",
        "body": "Thanks a lot!"
      }
    ],
    "satisfaction_conditions": [
      "Ensures async save operation completes before proceeding to subsequent operations",
      "Properly handles reactive programming patterns without blocking threads",
      "Provides verification of database persistence before returning from saveBook",
      "Handles potential delays in async persistence gracefully",
      "Maintains reactive stream integrity throughout the process"
    ]
  },
  {
    "number": 7317,
    "title": "What\u2018s the reason that \"relaying the upstream's Disposable directly is not allowed in RxJava\"?",
    "created_at": "2021-08-24T08:24:13Z",
    "closed_at": "2021-08-24T15:50:48Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7317",
    "body": "Thanks check my question.\r\nWhen I implement `ObservableOperator`, find the comment \"Note that relaying the upstream's Disposable directly is not allowed in RxJava\" above observable operator `lift` sample.\r\nI searched net, but found nobody explains the reason.  If i follow the sample for `lift`\uff0c the class seems complex a little bit, but relay the upstream's Disposable,  the class seems more clean.\r\n```\r\npublic final class CustomObserver<T> implements Observer<T>, Disposable {\r\n\r\n     final Observer<? super String> downstream;\r\n\r\n     Disposable upstream;\r\n\r\n     public CustomObserver(Observer<? super String> downstream) {\r\n         this.downstream = downstream;\r\n     }\r\n\r\n     // In the subscription phase, the upstream sends a Disposable to this class\r\n     // and subsequently this class has to send a Disposable to the downstream.\r\n     // Note that relaying the upstream's Disposable directly is not allowed in RxJava\r\n     @Override\r\n     public void onSubscribe(Disposable d) {\r\n         if (upstream != null) {\r\n             d.dispose();\r\n         } else {\r\n             upstream = d;\r\n             downstream.onSubscribe(this);\r\n         }\r\n     }\r\n\r\n     @Override\r\n     public void onNext(T item) {\r\n         ... do something...\r\n     }\r\n\r\n     @Override\r\n     public void onError(Throwable throwable) {\r\n         downstream.onError(throwable);\r\n     }\r\n\r\n     @Override\r\n     public void onComplete() {\r\n         downstream.onComplete();\r\n     }\r\n\r\n     @Override\r\n     public void dispose() {\r\n         upstream.dispose();\r\n     }\r\n\r\n     @Override\r\n     public boolean isDisposed() {\r\n         return upstream.isDisposed();\r\n     }\r\n }\r\n\r\n```\r\n\r\n```\r\npublic final class CustomObserver<T> implements Observer<T>, Disposable {\r\n\r\n     final Observer<? super String> downstream;\r\n\r\n     Disposable upstream;\r\n\r\n     public CustomObserver(Observer<? super String> downstream) {\r\n         this.downstream = downstream;\r\n     }\r\n\r\n     // Not follow sample says\r\n     @Override\r\n     public void onSubscribe(Disposable d) {\r\n         downstream.onSubscribe(d);\r\n     }\r\n\r\n     @Override\r\n     public void onNext(T item) {\r\n         ... do something...\r\n     }\r\n\r\n     @Override\r\n     public void onError(Throwable throwable) {\r\n         downstream.onError(throwable);\r\n     }\r\n\r\n     @Override\r\n     public void onComplete() {\r\n         downstream.onComplete();\r\n     }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7317/comments",
    "author": "chxchen",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2021-08-24T10:17:14Z",
        "body": "It breaks operator fusion, which is detected by checking the `Disposable` sent via `onSubscribe`. If, for example, the upstream supports fusion and you relay that `Disposable` to the downstream, it will skip your operator and will talk to the upstream directly.\r\n\r\nIn general, it is rare not to intercept `dispose()` in an operator."
      },
      {
        "user": "chxchen",
        "created_at": "2021-08-24T11:14:32Z",
        "body": "> It breaks operator fusion, which is detected by checking the `Disposable` sent via `onSubscribe`. If, for example, the upstream supports fusion and you relay that `Disposable` to the downstream, it will skip your operator and will talk to the upstream directly.\r\n> \r\n> In general, it is rare not to intercept `dispose()` in an operator.\r\n\r\nThank you!\r\nDo you mean if an custom operator by `lift` is very simple, Relaying the upsteam's disposable does not make hidden error, but recommand to implement `Disposable` and delivery `this` to downstream?  (The simple operator just pass values to downstream.)"
      },
      {
        "user": "akarnokd",
        "created_at": "2021-08-24T11:28:03Z",
        "body": "Yes."
      },
      {
        "user": "chxchen",
        "created_at": "2021-08-24T15:50:47Z",
        "body": "> Yes.\r\nThanks a lot\r\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why relaying upstream's Disposable breaks RxJava's internal mechanisms",
      "Clarification of how operator fusion interacts with Disposable handling",
      "Guidance on when/why custom Disposable implementation is necessary",
      "Identification of potential hidden errors from direct Disposable relay"
    ]
  },
  {
    "number": 7281,
    "title": "Methos to() requires mock in unit test",
    "created_at": "2021-06-08T16:17:32Z",
    "closed_at": "2021-06-09T07:39:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7281",
    "body": "Hi. could you please clarify question?\r\nI Have the following method\r\n```\r\npublic Single<Book> load(String bookName, String author) {\r\n        return bookRepo.load(bookName)\r\n                .switchIfEmpty(Observable.error(EntityNotFoundException::new))\r\n                .toList()\r\n                .flatMap(books-> bookService.loadbookByAuthor(Observable.fromIterable(books), autor)\r\n                        .switchIfEmpty(Maybe.error(() -> new ValidationErrorException()))\r\n                        .toSingle());\r\n    }\r\n```\r\n\r\nAnd I have unit test for this method. which works\r\n```\r\npublic void shouldValidatePolicyExists() {\r\n        when(bookRepo.load(any())).thenReturn(Observable.empty());\r\n\r\n        testObject.load(request).test()\r\n                .assertError(EntityNotFoundException.class)\r\n    }\r\n```\r\n\r\nI want to get rid of toList() in my method and found the following way\r\n```\r\npublic Single<Book> load(String bookName, String author) {\r\n        return bookRepo.load(bookName)\r\n                .switchIfEmpty(Observable.error(EntityNotFoundException::new))\r\n                .to(books-> bookService.loadbookByAuthor(books, autor)\r\n                        .switchIfEmpty(Maybe.error(() -> new ValidationErrorException()))\r\n                        .toSingle());\r\n    }\r\n```\r\nBut unit test does not work for this method implementation.\r\nIt does not return EntityNotFoundException and requires bookService is mocked.\r\nCould you please clarify why ?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7281/comments",
    "author": "YauheniZarembin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2021-06-08T16:43:48Z",
        "body": "How is `loadbookByAuthor` implemented?\r\n\r\nSince your original used `flatMap`, the error just skipped the `loadbookByAuthor` entirely. With `to`, it is always executed and receives the error via `books`."
      },
      {
        "user": "YauheniZarembin",
        "created_at": "2021-06-08T17:02:41Z",
        "body": "@akarnokd \r\n`loadbookByAuthor` just filters observable\r\n\r\n```\r\npublic Maybe<Book> loadbookByAuthor (Observable<Book> books, String author) {\r\n        return books\r\n                .filter(txInTerm -> TransactionRoutine.isEffectiveOnDate(txInTerm, onDate))\r\n                .firstElement();\r\n    }\r\n```\r\nBut, the problem is that I can't change it.\r\n\r\nThen I will reformulate the question : \r\nHow can I change the first method to get rid of toList() without changing `loadbookByAuthor ` ?\r\n\r\nNow I convert Observable `toList()` and then make from it Observable again. For many books I suppose It will affect performance.\r\n\r\nThank you!\r\n\r\n\r\n\r\n\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2021-06-08T17:46:54Z",
        "body": "It is a bit convoluted to do it. Try\r\n\r\n```java\r\nbookRepo.load(bookName)\r\n    .switchIfEmpty(Observable.error(EntityNotFoundException::new))\r\n    .publish(o -> \r\n        o.take(1)\r\n        .flatMap(v -> \r\n            bookService.loadbookByAuthor(o.startWith(v), autor)   \r\n            .switchIfEmpty(Maybe.error(() -> new ValidationErrorException()))\r\n            .toObservable()\r\n        )\r\n    )\r\n    .toSingle()\r\n```"
      },
      {
        "user": "YauheniZarembin",
        "created_at": "2021-06-09T07:39:53Z",
        "body": "Thank you!"
      }
    ],
    "satisfaction_conditions": [
      "Maintain original error handling behavior for empty bookRepo.load()",
      "Avoid converting Observable to List and back",
      "Ensure error paths don't execute downstream transformations",
      "Maintain Single<Book> return type compatibility"
    ]
  },
  {
    "number": 7158,
    "title": "intervalRange behaviour",
    "created_at": "2021-01-23T18:25:25Z",
    "closed_at": "2021-01-24T13:25:19Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7158",
    "body": "As per documentation `intervalRange` : \r\n>The sequence completes immediately after the last value (start + count - 1) has been reached.\r\n\r\nWhich mean `doOnComplete` is called directly once the last interval is reached (and not _completed_)\r\n\r\n```\r\nprivate fun launchQuestionGame() {\r\n        Flowable\r\n            .fromIterable(mQuestions.asIterable()) // mQuestions contains 3 items\r\n\r\n            .zipWith(\r\n                startTimeIntervalAndCancelItUponUnUneButtonClick(mQuestions.size + 1)\r\n\r\n                    .observeOn(AndroidSchedulers.mainThread())\r\n                    .doOnEach {\r\n                        onEachIntervalEmittion(it)\r\n                    }\r\n\r\n                    .repeat(mQuestions.size.toLong()), // repeat the interval mQuestions.size.toLong() times.\r\n\r\n                BiFunction { t1: Question, _: Long ->\r\n                    Timber.d(t1.toString())\r\n                    doOnCompleteEachFile(t1)\r\n                })\r\n\r\n            .doOnComplete {\r\n                Timber.d(\"doOnComplete\")\r\n                doOnCompleteAllFiles()\r\n            }\r\n\r\n            .subscribe()\r\n    }\r\n```\r\n\r\n2021-01-23 18:38:49.526 17549-17549/ Item 1\r\n2021-01-23 18:38:53.531 17549-17549/ Item 2\r\n2021-01-23 18:38:57.527 17549-17549/ Item 3\r\n2021-01-23 18:38:57.544 17549-17549/ doOnComplete\r\n\r\nI tried to delay before `doOnComplete` but it doesn't work.\r\n\r\nIs there anyway to have `doOnComplete` called after the last interval is finished ?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7158/comments",
    "author": "cloudshooterhuman",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2021-01-23T19:11:42Z",
        "body": "I don't understand your question. If you want to execute `doOnComplete` with a similar delay as between the items, append a timer:\r\n\r\n```kotlin\r\n\r\n     .zipWith ( ... )\r\n     .concatWith(Completable.timer(4, TimeUnit.SECONDS))\r\n     .doOnComplete {\r\n           Timber.d(\"doOnComplete\")\r\n           doOnCompleteAllFiles()\r\n      }\r\n```"
      },
      {
        "user": "cloudshooterhuman",
        "created_at": "2021-01-23T19:56:19Z",
        "body": "Thank you it did  work gracfully. just curious, why `delay` didn't have the same effect as ` .concatWith(Completable.timer(4, TimeUnit.SECONDS))` ?\r\n"
      }
    ],
    "satisfaction_conditions": [
      "Ensures completion action (doOnComplete) is triggered after the last interval's duration has elapsed",
      "Explains why direct delay operators might not work as expected in this flow composition"
    ]
  },
  {
    "number": 7137,
    "title": "2.x: Question about threading and doFinally()",
    "created_at": "2020-12-22T10:34:42Z",
    "closed_at": "2020-12-22T12:07:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7137",
    "body": "I am using RxJava 2 on Android. The modifyUi() function inside doFinally() should be called from main thread only.\r\n```\r\ntask_1\r\n    .subscribeOn(Schedulers.io())\r\n    .doOnSuccess { ... }\r\n    .flatMap { \r\n        task_2\r\n            .subscribeOn(Schedulers.io()) \r\n    }\r\n    .observeOn(AndroidSchedulers.mainThread())\r\n    .doFinally { modifyUi() }\r\n```\r\nHowever, there are certain edge cases where observeOn() is ignored and doFinally() is fired in background.\r\n\r\nQuestion 1: What these cases can be? So far, I've discovered only one of them - a very fast disposing of the chain. If I add\r\n```\r\n.doOnSubscribe { it.dispose() }\r\n```\r\nright after doFinally(), observeOn() becomes ignored, so doFinally() is fired from background. Why is that and what the other cases can be?\r\n\r\nQuestion 2: Is there any reliable way to clean up the chain once it's done that can be set to a particular thread? As I see, doFinally() fails in some cases. Should I resort to duplicating the cleanup code in onSuccess() and onError() methods of the observer/consumer in subscribe()?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7137/comments",
    "author": "BorisLaskov",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-12-22T10:51:43Z",
        "body": "`doFinally` can run when the downstream disposes on whatever thread it is on, thus `observeOn` has likely no effect. You can apply `unsubscribeOn` after `doFinally` to make sure any dispose call is routed to the desired thread."
      },
      {
        "user": "BorisLaskov",
        "created_at": "2020-12-22T12:07:10Z",
        "body": "Thank you for the clarification :)"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why observeOn() might be ignored in edge cases involving chain disposal",
      "Identification of thread context scenarios where doFinally() executes unexpectedly",
      "A thread-safe cleanup strategy that works across success/error/disposal scenarios",
      "Clarification of RxJava operator execution order relative to disposal events"
    ]
  },
  {
    "number": 7078,
    "title": "RxJava Branching/Conditional operators [question][feature]",
    "created_at": "2020-09-18T15:45:41Z",
    "closed_at": "2020-09-18T18:48:54Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7078",
    "body": "We had this problem a while ago that we wanted to have branches for our flow. To set an example:\r\n\r\n```\r\nupstream\r\n    .filter{ condition }\r\n    .map {...}\r\n    .filter { !condition }\r\n    .map {...}\r\n    .subscribe(...) // both maps generate same type of output\r\n```\r\nWhich obviously does not work. Because the conditions are simply contradictory to each other. But we needed to process all the items but in different ways.\r\n\r\nI am aware of grouping and other operators that can help with this need but all of them come down to having if else statements somewhere in the code.\r\n\r\nSo I have one question and one suggestion.\r\n1) Is there any operator that can help branch the item flows in a linear way? (Not having inner blocks with if statements)\r\n2) Is it a good idea to create a branching (or conditional) operator (like `parallel()/sequential()` in Flowable) that creates branches of the flow and merges them in the end? I wanted to contribute by adding this feature but thought it might be a good idea to ask first. Something like the following for the above example:\r\n```\r\nupstream\r\n    .branch()\r\n    .if { condition }\r\n    .then {...}\r\n    .if { !condition }\r\n    .then {...}\r\n    .else {...}\r\n    .merge()\r\n    .subscribe(...) // both maps generate same type of output\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7078/comments",
    "author": "saeedntt",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-09-18T15:59:30Z",
        "body": "You can use `publish` to split the flow and merge them back:\r\n\r\n```java\r\n\r\nsource.publish(shared ->\r\n   merge(shared.filter()..., shared.filter()...)\r\n)\r\n```"
      },
      {
        "user": "saeedntt",
        "created_at": "2020-09-18T16:11:06Z",
        "body": "That's Great.\r\nSo you don't think adding a branch operator is a good idea? It keeps the stream creation linear."
      },
      {
        "user": "akarnokd",
        "created_at": "2020-09-18T18:48:54Z",
        "body": "Not a good idea, the usage pattern differs from the generic RxJava approach.\r\n\r\nAt least you seem to be on Kotlin so you can add any DSL you see fit via extension methods."
      }
    ],
    "satisfaction_conditions": [
      "Avoids nested conditional logic in the operator chain",
      "Maintains linear readability of the stream definition",
      "Aligns with RxJava's existing operator patterns and paradigms",
      "Provides clear branch merging semantics",
      "Supports multiple exclusive processing paths"
    ]
  },
  {
    "number": 7045,
    "title": "Is it possible to run a multistage pipeline in parallel?",
    "created_at": "2020-08-02T05:25:22Z",
    "closed_at": "2020-08-02T15:22:18Z",
    "labels": [
      "Question",
      "3.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7045",
    "body": "Hi, suppose I have a query that entails a multi-stage pipeline of operations (e.g., `map(x -> intenseComputation(x)).map(...).map(...)...`)\r\nIs it possible to implement such a query using multiple threads where each thread handles a stage of the computation (e.g., a single `map`)?\r\n\r\nTo illustrate,\r\ninput items -> map1 (assigned to thread1) -> map2 (thread2) -> map3 (thread3) ... -> Observer\r\n\r\nI read the documentation of RxJava and checked many related materials, but now I only found codes and tutorials that taught me how to distribute the input items to multiple threads, where each thread runs the same query (e.g., using `flatMap(o -> ...subscribeOn(...))`).\r\n\r\nCan someone help me to answer this question or refer me to some related materials? \r\nThanks a lot!\r\n\r\nBTW, I am using RxJava version 3.05.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7045/comments",
    "author": "Ohyoukillkenny",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-08-02T06:51:45Z",
        "body": "Put `observeOn` between the stages."
      },
      {
        "user": "Ohyoukillkenny",
        "created_at": "2020-08-02T15:22:18Z",
        "body": "thanks a lot. I confuse the usage of observeOn with subscribeOn where `observeOn` acts only downstream."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how to assign different threads to sequential pipeline stages in RxJava",
      "Clarification of thread-switching operators' behavior between stages",
      "Demonstration of pipeline stage isolation without item-level parallelism",
      "Reference to RxJava's capability for staged concurrency model"
    ]
  },
  {
    "number": 7019,
    "title": "App Crash when ObserveOn Android main thread",
    "created_at": "2020-06-28T07:54:41Z",
    "closed_at": "2020-06-28T08:00:53Z",
    "labels": [
      "Question",
      "Android",
      "3.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7019",
    "body": "**Issue** \r\nI try to implement observeOn **AndroidSchedulers.mainThread()** But it always crash \r\nif I remove this line it working fine \r\n\r\n       myObservable = Observable.fromArray(intArray);\r\n       myObservable.subscribeOn(Schedulers.io())\r\n        .observeOn(AndroidSchedulers.mainThread()).\r\n         subscribeWith(getObserver());\r\n\r\n**Error Log** \r\n\r\n        java.lang.BootstrapMethodError: Exception from call site #1 bootstrap method\r\n        at io.reactivex.rxjava3.android.schedulers.AndroidSchedulers.<clinit>(AndroidSchedulers.java:33)\r\n        at io.reactivex.rxjava3.android.schedulers.AndroidSchedulers.mainThread(AndroidSchedulers.java:44)\r\n        at com.example.rxjavasample.SecondActivity.onCreate(SecondActivity.java:38)\r\n\r\n\r\n**Gradle dependencies** \r\n\r\n\r\n    implementation \"io.reactivex.rxjava3:rxjava:3.0.4\"\r\n    implementation 'io.reactivex.rxjava3:rxandroid:3.0.0' ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7019/comments",
    "author": "RanjithTawari",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-06-28T08:00:53Z",
        "body": "You probably have to set your project to Java 8 mode:\r\n\r\n```groovy\r\ncompileOptions {\r\n    sourceCompatibility JavaVersion.VERSION_1_8\r\n    targetCompatibility JavaVersion.VERSION_1_8\r\n}\r\n```"
      },
      {
        "user": "RanjithTawari",
        "created_at": "2020-06-29T08:34:36Z",
        "body": "yes its fixed "
      }
    ],
    "satisfaction_conditions": [
      "Identifies the root cause as Java version incompatibility with RxAndroid/RxJava 3",
      "Ensures Android project configuration meets library requirements",
      "Provides guidance for runtime environment alignment with reactive libraries"
    ]
  },
  {
    "number": 6939,
    "title": "doOnSubscribe don't work as expected.",
    "created_at": "2020-03-19T08:25:50Z",
    "closed_at": "2020-03-19T12:26:43Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6939",
    "body": "RxJava 2.2.19\r\nMy code(sample):\r\n```\r\nclass Foo {\r\n\r\n\tprivate val someCachedData = listOf(1, 2, 3)\r\n\r\n\tprivate val publisher = PublishProcessor.create<Int>()\r\n\r\n\tfun getPublisher(): Flowable<Int> = publisher.onBackpressureBuffer().publish().refCount()\r\n\r\n\tfun subscribe() {\r\n\t\tprintln(\"subscribe called\")\r\n\r\n\t\tsomeCachedData.forEach(publisher::onNext)\r\n\t}\r\n }\r\n\r\n fun main() {\r\n\r\n\tval foo = Foo()\r\n\r\n\tfoo.getPublisher()\r\n\t\t.subscribeOn(Schedulers.computation())\r\n\t\t.doOnSubscribe {\r\n\t\t\tprintln(\"doOnSubscribe called\")\r\n\t\t\tfoo.subscribe()\r\n\t\t}\r\n\t\t.subscribe { print(it) }\r\n\r\n\tThread.sleep(10000)\r\n}\r\n```\r\n\r\nOutput:\r\n```\r\ndoOnSubscribe called\r\nsubscribe called\r\n\r\nProcess finished with exit code 0\r\n```\r\nIf i add some delay to call `foo.subscribe()`, App works fine.\r\nThe following code works fine:\r\n```\r\nfoo.getPublisher()\r\n\t\t.subscribeOn(Schedulers.computation())\r\n\t\t.doOnSubscribe {\r\n\t\t\tprintln(\"doOnSubscribe called\")\r\n\t\t\tSingle.just(true)\r\n\t\t\t\t.subscribeOn(Schedulers.single())\r\n\t\t\t\t.delay(1, TimeUnit.SECONDS)\r\n\t\t\t\t.subscribe { _ ->\r\n\t\t\t\t\tfoo.subscribe()\r\n\t\t\t\t}\r\n\t\t}\r\n\t\t.subscribe { print(it) }\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6939/comments",
    "author": "VovaStelmashchuk",
    "comments": [
      {
        "user": "VovaStelmashchuk",
        "created_at": "2020-03-19T08:31:12Z",
        "body": "Maybe, I do something wrong. Can you provide some fix? Ad Hoc solution welcome."
      },
      {
        "user": "akarnokd",
        "created_at": "2020-03-19T08:32:40Z",
        "body": "In your setup, `doOnSubscribe` runs just before the `PublishProcessor` finishes the registration of the subscriber and thus when you try to signal the values then, the processor simply won't see the subscriber. Also such re-entrant use is not encouraged.\r\n\r\n> Can you provide some fix?\r\n\r\nWhat were you trying to achieve there? If you want a source to signal when a subscriber arrives, use a cold source."
      },
      {
        "user": "VovaStelmashchuk",
        "created_at": "2020-03-19T08:47:52Z",
        "body": "In my case, I connect to socket. Some data load from cache, another from the real socket. I want to emit cached data immediately after consumer subscribe.  How i can implement this?"
      },
      {
        "user": "akarnokd",
        "created_at": "2020-03-19T08:57:18Z",
        "body": "Use `startWith` for example."
      },
      {
        "user": "VovaStelmashchuk",
        "created_at": "2020-03-19T12:26:35Z",
        "body": "Thx, I fix my problem."
      }
    ],
    "satisfaction_conditions": [
      "Solution must emit cached data immediately upon subscription",
      "Mechanism must work without relying on artificial delays",
      "Must follow RxJava best practices for cold/hot observable interaction",
      "Solution should handle combined cached+real-time data sources",
      "Must ensure subscriber is fully registered before emitting"
    ]
  },
  {
    "number": 6933,
    "title": "Merge delay error for multiple API calls.",
    "created_at": "2020-03-14T19:05:20Z",
    "closed_at": "2020-03-16T17:32:14Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6933",
    "body": "```\r\nlaunchJob {\r\n            Observable.mergeDelayError(\r\n                    getCareUseCase.getAllGetCareItems().toObservable(),\r\n                    appointmentUseCase.getAllAppointment().toObservable()\r\n                        .mergeWith(\r\n                            prescriptionRefillsUseCase.getAllPrescriptionRefills())\r\n                            .mergeWith(billUseCase.getAllPayBills())\r\n                        .mergeWith(careTeamUseCase.getMyCareTeam())\r\n                        .mergeWith(favoriteFacilitiesUseCase.getAllFavoriteFacilities())\r\n                ).iOSubscribeMainThreadObserve()\r\n                .subscribe({\r\n                    mapSection(it)\r\n                    flattenAndEmit()\r\n                }, {\r\n                   Log.e(TAG, \"Failed to load dashboard contents\")\r\n                })\r\n        }\r\n\r\n\r\n```\r\n\r\nIf any of the API is failing entire stream is failing.  Any one knows why?\r\n\r\nThis is my requirement, I want to make all the API calls parallel,  I don't care about the order in which response arrives, I don't care if one fails, which one come fast, I just display in the order that receives. ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6933/comments",
    "author": "pollux-",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-03-14T19:25:19Z",
        "body": "`mergeWith` doesn't delay errors so if any of those fails, the subsequence will fail. Looks like you can simply use use `mergeArrayDelayError` with those 6 sources direclty:\r\n\r\n```java\r\nObservable.mergeArrayDelayError(\r\n    getCareUseCase.getAllGetCareItems().toObservable(),\r\n    appointmentUseCase.getAllAppointment().toObservable(),\r\n    prescriptionRefillsUseCase.getAllPrescriptionRefills(),\r\n    billUseCase.getAllPayBills(),\r\n    careTeamUseCase.getMyCareTeam(),\r\n    favoriteFacilitiesUseCase.getAllFavoriteFacilities()\r\n)\r\n.iOSubscribeMainThreadObserve()\r\n```"
      },
      {
        "user": "pollux-",
        "created_at": "2020-03-14T19:53:27Z",
        "body": "@akarnokd  \r\n\r\nI ran into an issue.  Observable.mergeArrayDelayError() give me compilation error when I add more than 4 observable? I know this a super dumb question. As per signature it should work though?\r\n\r\n**_mergeArrayDelayError(ObservableSource<? extends T>... sources)_**\r\n\r\n   ```\r\nObservable.mergeDelayError(\r\n            getCareUseCase.getAllGetCareItems().toObservable(),\r\n            getCareUseCase.getAllGetCareItems().toObservable(),\r\n            getCareUseCase.getAllGetCareItems().toObservable(),\r\n            getCareUseCase.getAllGetCareItems().toObservable(),\r\n            getCareUseCase.getAllGetCareItems().toObservable()\r\n        )\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2020-03-14T20:07:46Z",
        "body": "What is the error?"
      },
      {
        "user": "pollux-",
        "created_at": "2020-03-14T20:15:48Z",
        "body": "\r\n_None of the following functions can be called with the arguments supplied: \r\npublic final fun <T : Any!> mergeDelayError(p0: ((Observer<in (???..???)>) -> Unit)!, p1: ((Observer<in (???..???)>) -> Unit)!): Observable<(???..???)>! defined in io.reactivex.Observable\r\npublic final fun <T : Any!> mergeDelayError(p0: ((Observer<in (???..???)>) -> Unit)!, p1: ((Observer<in (???..???)>) -> Unit)!, p2: ((Observer<in (???..???)>) -> Unit)!): Observable<(???..???)>! defined in io.reactivex.Observable\r\npublic final fun <T : Any!> mergeDelayError(p0: ((Observer<in (???..???)>) -> Unit)!, p1: ((Observer<in (???..???)>) -> Unit)!, p2: ((Observer<in (???..???)>) -> Unit)!, p3: ((Observer<in (???..???)>) -> Unit)!): Observable<(???..???)>! defined in io.reactivex.Observable\r\npublic final fun <T : Any!> mergeDelayError(p0: ((Observer<in ObservableSource<out (???..???)>!>) -> Unit)!): Observable<(???..???)>! defined in io.reactivex.Observable\r\npublic final fun <T : Any!> mergeDelayError(p0: ((Observer<in ObservableSource<out (???..???)>!>) -> Unit)!, p1: Int): Observable<(???..???)>! defined in io.reactivex.Observable\r\npublic open fun <T : Any!> mergeDelayError(p0: ObservableSource<out ObservableSource<out (???..???)>!>!): Observable<(???..???)>! defined in io.reactivex.Observable\r\npublic open fun <T : Any!> mergeDelayError(p0: ObservableSource<out ObservableSource<out (???..???)>!>!, p1: Int): Observable<(???..???)>! defined in io.reactivex.Observable\r\npublic open fun <T : Any!> mergeDelayError(p0: ObservableSource<out Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>!, p1: ObservableSource<out Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>!): Observable<Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>! defined in io.reactivex.Observable\r\npublic open fun <T : Any!> mergeDelayError(p0: ObservableSource<out Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>!, p1: ObservableSource<out Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>!, p2: ObservableSource<out Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>!): Observable<Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>! defined in io.reactivex.Observable\r\npublic open fun <T : Any!> mergeDelayError(p0: ObservableSource<out Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>!, p1: ObservableSource<out Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>!, p2: ObservableSource<out Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>!, p3: ObservableSource<out Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>!): Observable<Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>! defined in io.reactivex.Observable\r\npublic open fun <T : Any!> mergeDelayError(p0: (Mutable)Iterable<ObservableSource<out (???..???)>!>!): Observable<(???..???)>! defined in io.reactivex.Observable\r\npublic open fun <T : Any!> mergeDelayError(p0: (Mutable)Iterable<ObservableSource<out (???..???)>!>!, p1: Int): Observable<(???..???)>! defined in io.reactivex.Observable\r\npublic open fun <T : Any!> mergeDelayError(p0: (Mutable)Iterable<ObservableSource<out (???..???)>!>!, p1: Int, p2: Int): Observable<(???..???)>! defined in io.reactivex.Observable\r\n\r\nFAILURE: Build failed with an exception._\r\n\r\n* What went wrong:\r\nExecution failed for task ':kpflagshipapp:compileRefreshKotlin'.\r\n> Compilation error. See log for more details\r\n\r\n* Try:\r\n\r\n\r\n```\r\nval dashboardObservables = listOf(\r\n            getCareUseCase.getAllGetCareItems().toObservable(),\r\n            appointmentUseCase.getAllAppointment().toObservable(),\r\n            prescriptionRefillsUseCase.getAllPrescriptionRefills(\r\n                application.getString(R.string.prescription_refills_title),\r\n                application.getString(R.string.prescription_refills_subtitle),\r\n                R.drawable.ic_prescription_refill\r\n            ),\r\n            billUseCase.getAllPayBills().toObservable(),\r\n            careTeamUseCase.getMyCareTeam().toObservable(),\r\n            favoriteFacilitiesUseCase.getAllFavoriteFacilities().toObservable()\r\n        )\r\n\r\n        launchJob {\r\n            Observable.mergeDelayError(dashboardObservables)\r\n                .iOSubscribeMainThreadObserve()\r\n                .subscribe({\r\n                    mapSection(it)\r\n                    flattenAndEmit()\r\n                }, {\r\n                   Log.e(TAG, \"Failed to load dashboard contents\")\r\n                })\r\n        }\r\n```\r\n\r\n@akarnokd  thank you so much for responding. \r\n\r\nThe above should work,  or do you see any issue with that?"
      },
      {
        "user": "akarnokd",
        "created_at": "2020-03-14T20:25:07Z",
        "body": "I wrote: `mergeArrayDelayError()`\r\nYou had: `mergeDelayError()`\r\nSee the difference?"
      },
      {
        "user": "pollux-",
        "created_at": "2020-03-16T17:32:14Z",
        "body": "ya .. my bad .. thanks :) "
      }
    ],
    "satisfaction_conditions": [
      "Ensures individual API failures do not terminate the entire stream",
      "Maintains parallel execution of all API calls",
      "Handles merging of multiple error-delayed observables",
      "Supports merging more than 4 observable sources",
      "Preserves emission order based on arrival time"
    ]
  },
  {
    "number": 6623,
    "title": "Observers run order issue while using observeOn() `2.x`",
    "created_at": "2019-08-19T09:30:56Z",
    "closed_at": "2019-08-19T09:55:30Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6623",
    "body": "Library version 2.2.11\r\nI have two `PublishSubject`s and two `Observer`s subscribed respectively. Between `PubslishSubject` and `Subscriber` I switch from [main] thread to [RxSingleScheduler] thread using `observeOn(Schedulers.single())`. I start to publish (`PubslishSubject.onNext()`) on both `PublishSubject`s inside the loop.\r\n\r\n    publishSubject1.onNext(\"next\");\r\n    publishSubject2.onNext(\"next\");\r\nWhat I expected was the both subscribers run in the same order as emissions were published but the results I get is completely different. Subsriber1 handles all it's emissions and then Subscriber2 handles all it's emissions.\r\nI expected emission scheduled and run in publish order. Is there any way to achive this?\r\n```java\r\nimport java.util.concurrent.TimeUnit;\r\n\r\nimport io.reactivex.schedulers.Schedulers;\r\nimport io.reactivex.subjects.PublishSubject;\r\n\r\npublic class ObserveOnApp {\r\n    \r\n    public static void main(String[] args) {\r\n        PublishSubject<String> publishSubject1 = PublishSubject.create();\r\n        PublishSubject<String> publishSubject2 = PublishSubject.create();\r\n        \r\n        publishSubject1\r\n        .observeOn(Schedulers.single())\r\n        .subscribe(next -> {\r\n            System.out.println(\"Subscriber1\");\r\n        });\r\n        \r\n        publishSubject2\r\n        .observeOn(Schedulers.single())\r\n        .subscribe(next -> {\r\n            System.out.println(\"Subscriber2\");\r\n        });\r\n        \r\n        for (int i= 0; i < 10; i++) {\r\n            publishSubject1.onNext(\"next\");\r\n            publishSubject2.onNext(\"next\");\r\n        }\r\n        \r\n        try {\r\n            TimeUnit.SECONDS.sleep(2);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6623/comments",
    "author": "pkrysztofiak",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-08-19T09:38:58Z",
        "body": "`Schedulers.single` uses a single thread and both of your subjects post work to this one thread. `observeOn` keeps working as long as it sees events so if you post events fast enough, the first subscription will get as much work done as it can, hence you don't see perfect interleaving of the two consumers.\r\n\r\nYou can try `delay(0, TimeUnit.SECONDS, Schedulers.single())` instead which posts events one by one.\r\n"
      },
      {
        "user": "pkrysztofiak",
        "created_at": "2019-08-19T09:49:29Z",
        "body": "delay() works but I'm extremly confused. Isn't it should be the default behaviour? When calling\r\n```\r\npublishSubject1.onNext(\"next\");\r\npublishSubject2.onNext(\"next\");\r\n```\r\nfirst line should schedule an execution. The second line should do the same and since I use the same scheduler subscriptions should interleave perfectly."
      },
      {
        "user": "akarnokd",
        "created_at": "2019-08-19T09:55:30Z",
        "body": "No. Any operator with a queue does as much work as it can in one run, including `observeOn`. Delay has to post events individually as it has to apply an user-defined delay to each, and there is no queue involved in RxJava for that. The underlying `ScheduledExecutorService` will interleave tasks in its own queue. Posting items individually to a thread pool is really inefficient as it causes a lot of extra allocation per task. The way RxJava does this is automatically coalescing nearby events and have one task serving them at once."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why observeOn() with same scheduler doesn't guarantee interleaved execution order",
      "Method to enforce interleaved execution order across multiple observables",
      "Clarification of efficiency vs ordering tradeoffs in RxJava scheduling"
    ]
  },
  {
    "number": 6568,
    "title": "2.2.10: Flowable do not use correct scheduler once bufferSize is reached",
    "created_at": "2019-07-11T10:00:41Z",
    "closed_at": "2019-07-11T11:59:11Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6568",
    "body": "Hi, I was playing with Flowable to get a deep understanding on how to handle backpressure without dropping events and running the following code I noticed that the flowable starts to emit events on the subscriber scheduler once bufferSize given to observeOn method is reached.\r\n\r\nHere's the code :\r\n\r\n```\r\n    public static void main(String[] args) throws InterruptedException {\r\n        int maxI = 12;\r\n        int bufferSize = 5;\r\n        CountDownLatch waitForIt = new CountDownLatch(1);\r\n        CompositeDisposable compositeDisposable = new CompositeDisposable();\r\n\r\n        Flowable<Integer> integerFlow = Flowable.<Integer, Integer>generate(\r\n                () -> 0,\r\n                (i, emitter) -> {\r\n                    if (i < maxI) {\r\n                        log(\"Emitting: \" + i);\r\n                        emitter.onNext(i);\r\n                    } else {\r\n                        emitter.onComplete();\r\n                    }\r\n                    return i + 1;\r\n                }).observeOn(Schedulers.io(), false, bufferSize);\r\n\r\n        compositeDisposable.add(\r\n                integerFlow\r\n                        .subscribeOn(Schedulers.computation())\r\n                        .subscribeWith(new DisposableSubscriber<Integer>() {\r\n\r\n                            @Override\r\n                            public void onNext(Integer i) {\r\n                                try {\r\n                                    log(\"Receiving: \" + i);\r\n                                    Thread.sleep(10L);\r\n                                } catch (InterruptedException e) {\r\n                                    e.printStackTrace();\r\n                                }\r\n                            }\r\n\r\n                            @Override\r\n                            public void onError(Throwable throwable) {\r\n\r\n                            }\r\n\r\n                            @Override\r\n                            public void onComplete() {\r\n                                compositeDisposable.remove(this);\r\n                                waitForIt.countDown();\r\n                            }\r\n                        }));\r\n\r\n        System.out.println(compositeDisposable.size());\r\n        log(\"Waiting for finish\");\r\n        waitForIt.await();\r\n        System.out.println(compositeDisposable.size());\r\n    }\r\n\r\n    private static void log(String message) {\r\n        System.out.println(message + String.format(\" (%s)\", Thread.currentThread().getName()));\r\n    }\r\n```\r\nHere's the output:\r\n\r\n```\r\n1\r\nWaiting for finish (main)\r\nEmitting: 0 (RxComputationThreadPool-1)\r\nEmitting: 1 (RxComputationThreadPool-1)\r\nEmitting: 2 (RxComputationThreadPool-1)\r\nEmitting: 3 (RxComputationThreadPool-1)\r\nEmitting: 4 (RxComputationThreadPool-1)\r\nReceiving: 0 (RxCachedThreadScheduler-1)\r\nReceiving: 1 (RxCachedThreadScheduler-1)\r\nReceiving: 2 (RxCachedThreadScheduler-1)\r\nReceiving: 3 (RxCachedThreadScheduler-1)\r\nEmitting: 5 (RxCachedThreadScheduler-1)\r\nEmitting: 6 (RxCachedThreadScheduler-1)\r\nEmitting: 7 (RxCachedThreadScheduler-1)\r\nEmitting: 8 (RxCachedThreadScheduler-1)\r\nReceiving: 4 (RxCachedThreadScheduler-1)\r\nReceiving: 5 (RxCachedThreadScheduler-1)\r\nReceiving: 6 (RxCachedThreadScheduler-1)\r\nReceiving: 7 (RxCachedThreadScheduler-1)\r\nEmitting: 9 (RxCachedThreadScheduler-1)\r\nEmitting: 10 (RxCachedThreadScheduler-1)\r\nEmitting: 11 (RxCachedThreadScheduler-1)\r\nReceiving: 8 (RxCachedThreadScheduler-1)\r\nReceiving: 9 (RxCachedThreadScheduler-1)\r\nReceiving: 10 (RxCachedThreadScheduler-1)\r\nReceiving: 11 (RxCachedThreadScheduler-1)\r\n0\r\n```\r\nI would expect all `Emitting: ...`  log lines to be in an RxComputationThreadPool-x. But once `bufferSize` events have been emitted (and the subscriber starts working), the flowable emits in the same thread has the subscriber.\r\n\r\nIs this normal behavior ?\r\n\r\nThanks, regards",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6568/comments",
    "author": "gauthierj",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-07-11T10:46:33Z",
        "body": "This is an allowed behavior. The `generate` responds to requests on whatever thread the request comes from. Initially, the first batch is triggered on the computation thread due to `subscribeOn`. Later on, `observeOn` takes over with requesting from its IO thread and thus generator runs on the IO thread too. \r\n\r\nThe main problem in your code is the position of `subscribeOn`. If you put it just after `generate`, the operator will make sure the subscription and subsequent requests happen on the designated thread."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why Flowable switches to subscriber's scheduler after bufferSize is reached",
      "Clarification of operator execution order impact on threading",
      "Description of request propagation mechanics in backpressure scenarios",
      "Differentiation between subscription context and observation context",
      "Documentation of Flowable's thread safety guarantees during backpressure"
    ]
  },
  {
    "number": 6495,
    "title": "SwitchIfEmpty on a Subject",
    "created_at": "2019-06-04T07:43:33Z",
    "closed_at": "2019-06-04T07:57:52Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6495",
    "body": "I have an issue with the Observable.switchIfEmpty operator. It\u2019s not called properly. See sample code\r\n\r\n```kotlin\r\nclass TestObs {\r\n\r\n    @Test\r\n    fun testSwitchIfEmpty() {\r\n        val subject = BehaviorSubject.create<List<String>>()\r\n        subject.onNext(listOf(\"a\"))\r\n        subject.test().assertValueCount(1)\r\n\r\n        // works\r\n//        Observable.create<List<String>> { emitter ->\r\n//            emitter.onNext(listOf(\"a\"))\r\n//            emitter.onComplete()\r\n//        }\r\n\r\n        // fails\r\n        subject\r\n            .flatMapIterable { it }\r\n            .filter { it == \"c\" }\r\n            .switchIfEmpty(Observable.create { emitter ->\r\n                emitter.onNext(\"c\")\r\n                emitter.onComplete()\r\n            })\r\n            .test()\r\n            .assertValue(\"c\")\r\n    }\r\n}\r\n```\r\n\r\nI just want to filter \"c\" and if there is no \"c\" switch to a new Observable an emit a \"c\". \r\n\r\nThis works if the origin of my rx chain starts with an Observable, but my test fails if my source is a subject. Does this make any sense to you?\r\n\r\nThanks!\r\n\r\nrxJavaVersion = '2.2.6'",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6495/comments",
    "author": "Voto",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-06-04T07:57:52Z",
        "body": "An observable is empty if doesn't signal onNext but only `onComplete`. Your code doesn't call `onComplete` and thus the `Subject` is infinite, preventing `switchIfEmpty` to function as you expected."
      },
      {
        "user": "Voto",
        "created_at": "2019-06-04T11:26:19Z",
        "body": "Oh sure! Thanks for helping me out\n\n---\n\nFor those interested in this issue. I made a workaround like this:\r\n\r\n```kotlin\r\n    @Test\r\n    fun testSwitchIfEmpty() {\r\n        val subject = BehaviorSubject.create<List<String>>()\r\n        subject.onNext(listOf(\"a\"))\r\n        // works\r\n        Maybe.create<List<String>> { emitter ->\r\n            if (subject.value != null) {\r\n                subject.value?.let {\r\n                    emitter.onSuccess(it)\r\n                }\r\n            } else {\r\n                emitter.onComplete()\r\n            }\r\n        }\r\n            .toObservable()\r\n            .flatMapIterable { it }\r\n            .filter { it == \"c\" }\r\n            .switchIfEmpty(Observable.create { emitter ->\r\n                emitter.onNext(\"c\")\r\n                emitter.onComplete()\r\n            })\r\n            .test()\r\n            .assertValue(\"c\")\r\n    }\r\n```"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why switchIfEmpty doesn't trigger with an infinite Subject source",
      "Guidance on converting a non-completing source into a completing one for switchIfEmpty",
      "Clarification of Observable lifecycle requirements for switchIfEmpty operator",
      "Solution pattern for conditional fallback emission when filtering yields no results"
    ]
  },
  {
    "number": 6391,
    "title": "I don't know why Schedulers class NewThreadTask implements Callable ",
    "created_at": "2019-01-29T11:39:52Z",
    "closed_at": "2019-01-29T11:58:28Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6391",
    "body": "static final class NewThreadTask implements Callable<Scheduler> {\r\n        @Override\r\n        public Scheduler call() throws Exception {\r\n            return NewThreadHolder.DEFAULT;\r\n        }\r\n    }\r\n\r\nchange to\r\n\r\ngetInstance(){\r\n return NewThreadHolder.DEFAULT;\r\n}\r\n\r\nthe first What are the benefits?\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6391/comments",
    "author": "guohaiping521",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-01-29T11:58:28Z",
        "body": "It works around a problem with premature initialization of schedulers when they are overridden but the default implementation is not required nor is desirable to get initialized in the first place. This several indirections allow this to happen.\r\n\r\nYou can follow the Git Blame to find the relevant PRs/issues, such as #4585."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how the structural change prevents premature scheduler initialization",
      "Clarification of how this pattern enables safe scheduler override capabilities",
      "Description of the role of indirection in managing initialization dependencies"
    ]
  },
  {
    "number": 6339,
    "title": "Delayed events do not keep order doOnNext and doOnComplete (groupBy with publish) ",
    "created_at": "2018-12-14T07:40:12Z",
    "closed_at": "2018-12-14T08:36:34Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6339",
    "body": "Hi,\r\nI'm a bit confused about how doOnComplete works in example below. \r\nrxjava version: 2.2.4\r\n\r\n```java\r\nFlowable<String> emitter = Flowable.just(\"aa\", \"ba\", \"ab\", \"bb\", \"ac\")\r\n                .doOnComplete(() -> logger.info(\"End emit\"));\r\n\r\n        Flowable<GroupedFlowable<Character, String>> groupBy = emitter.groupBy(s -> s.charAt(0));\r\n\r\n        groupBy.flatMap(characterStringGroupedFlowable -> stats(characterStringGroupedFlowable)\r\n                .publish(stringFlowable -> stringFlowable.concatMap(s -> \r\n                     Flowable.just(s).delay(100, TimeUnit.MILLISECONDS))))\r\n                .subscribeOn(Schedulers.from(Executors.newFixedThreadPool(1)))\r\n                .test()\r\n                .await();\r\n```\r\n```java\r\nprivate Flowable<String> stats(GroupedFlowable<Character, String> groupedFlowable) {\r\n        return groupedFlowable.compose(upstream -> {\r\n            AtomicLong count = new AtomicLong(0);\r\n            return upstream\r\n                    .doOnNext(s -> {\r\n                        count.incrementAndGet();\r\n                        logger.info(\"Group: {} - stats - [{}] - count: {}\", \r\n                        groupedFlowable.getKey(), s, count.get());\r\n                    })\r\n                    .doOnComplete(() -> {\r\n                        logger.info(\"Group: {} - stats - complete - count: {}\", \r\n                        groupedFlowable.getKey(), count.get());\r\n                    });\r\n\r\n        });\r\n    }\r\n```\r\nOutput:\r\n```\r\n08:13:39.349 | INFO  | pool-1-thread-1 | Group: a - stats - [aa] - count: 1\r\n08:13:39.355 | INFO  | pool-1-thread-1 | Group: b - stats - [ba] - count: 1\r\n08:13:39.356 | INFO  | pool-1-thread-1 | Group: a - stats - [ab] - count: 2\r\n08:13:39.356 | INFO  | pool-1-thread-1 | Group: b - stats - [bb] - count: 2\r\n08:13:39.356 | INFO  | pool-1-thread-1 | End emit\r\n08:13:39.356 | INFO  | pool-1-thread-1 | Group: a - stats - complete - count: 2\r\n08:13:39.356 | INFO  | pool-1-thread-1 | Group: b - stats - complete - count: 2\r\n08:13:39.459 | INFO  | RxComputationThreadPool-1 | Group: a - stats - [ac] - count: 3\r\n```\r\nI expected that this line `Group: a - stats - [ac] - count: 3` will be before that line `Group: a - stats - complete - count: 2`. I think it is a bug, of course I can be wrong. Removing `publish` operator solving a problem but in real world I need it to my business logic.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6339/comments",
    "author": "lukaszguz",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-12-14T08:36:34Z",
        "body": "Sometimes due to backpressure, `publish` may emit on the requestor thread, in this case the thread `delay` uses. To ensure proper ordering, use `observeOn` and then log."
      },
      {
        "user": "lukaszguz",
        "created_at": "2018-12-14T11:51:16Z",
        "body": "You mean something like that?\r\n```\r\nScheduler scheduler = Schedulers.from(Executors.newFixedThreadPool(1));\r\ngroupBy.flatMap(characterStringGroupedFlowable -> stats(characterStringGroupedFlowable)\r\n                        .publish(stringFlowable -> stringFlowable.observeOn(scheduler).concatMap(s -> Flowable.just(s).delay(100, TimeUnit.MILLISECONDS))))\r\n                        .subscribeOn(scheduler)\r\n                        .test()\r\n                        .await();\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-12-14T12:03:03Z",
        "body": "Try `characterStringGroupedFlowable.observeOn(scheduler)`."
      },
      {
        "user": "lukaszguz",
        "created_at": "2018-12-14T14:28:46Z",
        "body": "```\r\ngroupBy.flatMap(characterStringGroupedFlowable -> stats(characterStringGroupedFlowable)\r\n                .observeOn(scheduler)\r\n                .publish(stringFlowable -> stringFlowable.concatMap(s -> Flowable.just(s).delay(100, TimeUnit.MILLISECONDS))))\r\n                .subscribeOn(scheduler)\r\n                .test()\r\n                .await();\r\n```\r\nAwesome. Thanks for hints! :)"
      }
    ],
    "satisfaction_conditions": [
      "Ensures ordered processing of events within grouped streams when using publish operator",
      "Explains thread synchronization requirements for grouped Flowable sequences",
      "Preserves business logic requirements of using publish operator",
      "Addresses backpressure handling in grouped streams",
      "Provides mechanism to serialize processing within groups"
    ]
  },
  {
    "number": 6315,
    "title": "IO Thread Purge policy",
    "created_at": "2018-11-19T20:55:25Z",
    "closed_at": "2018-12-03T11:25:28Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6315",
    "body": "Hi,\r\n\r\nwe use RX 1.2.7 and we are trying to debug an issue where we see an abnormally high count of idle RxIoScheduler threads (up to 16k) in some boxes even though traffic type and load to all the boxes are evenly distributed. The variance in those boxes can range from hundreds to the abovementioned 16k.\r\n\r\nIs this a normal thing to observe for the CachedThreadScheduler in 1.2.7? We don't use 2.x but is this also a common thing for IOScheduler in 2.x?\r\n\r\nWe have tried different things to troubleshoot the root cause.\r\n\r\n1) Shortening the keep alive time of the ThreadWorkers in CachedThreadScheduler gives us mixed results and we are concerned that too aggressively evicting ThreadWorkers could be counterproductive since starting new ThreadWorkers should be more expensive than reusing existing ones in as much as possible, right? We don't want to solve a performance problem by creating another one. More importantly, since production traffic varies, there's a big question mark on what the optimal keep alive time should be and how could we could be forced to keep adjusting the keep alive time frequently. We had hoped that the IO scheduler thread pool should elastically grow and shrink automatically by itself.\r\n\r\n2) Another thought is to upgrade to 2.x where we noticed that the purge thread is turned on by default. \r\nWhat is the correct way to purge idle IO scheduler threads in 1.2.7 or 1.x? We are wondering if perhaps some code in our application caused the ThreadWorker lifecycle to not terminate correctly and thus hold on too longer than was necessary but we are not sure what. One potential suspect is the onCompleted call. We noticed that different types of clean up happens in onCompleted in 1.x and onComplete in 2.x.  However, we also noticed that the IO scheduler threads are not ended if onCompleted is not called on the Observer in 1.2.7, but they are ended regardless in 2.x even if onComplete is not called, why is this so? Would it be a safe thing to end a ThreadWorker if onComplete was not called on the Observer.\r\n\r\nIn a nutshell, what is the right way to keep the number of idle RxIoScheduler threads low in 1.x?\r\n\r\nThanks in advance for any pointers that you can share to help us.\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6315/comments",
    "author": "pp112018",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-11-19T23:05:56Z",
        "body": "> Is this a normal thing to observe for the CachedThreadScheduler in 1.2.7\r\n\r\nNo. You have a scheduler leak somewhere. This could be custom operators, manual `Scheduler.createWorker` usages or never ending sources running on those schedulers.\r\n\r\nWhat are you using the IO threads for?\r\n\r\n> purge thread is turned on by default\r\n\r\nThe purge thread removes timed but cancelled tasks which Java doesn't do by default. It has nothing to do with recycling IO scheduler threads.\r\n\r\n> Thanks in advance for any pointers that you can share to help us.\r\n\r\n- Use `Schedulers.from` with a dedicated `ThreadPoolExecutor` where you control the maximum number of threads.\r\n- You are running a pretty old version, the latest of 1.x is 1.3.8.\r\n- 1.x is no longer supported and 2.x fixed many internal inconsistencies that could have lead to leaks."
      },
      {
        "user": "pp112018",
        "created_at": "2018-11-20T05:13:15Z",
        "body": "We use the IO threads mainly for making asynchronous service calls between services. Many times, these calls are also wrapped in Hystrix, and we provide this as a platform to hundreds of services in production. We found that many of these services are affected, but each extent varies, the severe case in thousands up to 15k. Inspection of the thread dumps show that the idle IO threads were long-lived but did very, very little CPU work.\r\n\r\nCan you help us understand the move from setting the removal on cancel policy in 1.x to a dedicated purge thread in 2.x? What is behind the decision to using a dedicated thread in 2.x? \r\n\r\nI also apologize for not making clear our example. So we also surmised that there was some kind of leakage somewhere and one of the testings that we did was to observe what happens if the onCompleted call was not made in 1.x versus the onComplete call not being made in 2.x because we suspected (rightly or wrongly) that this was missing in some of the application code. Our test code is very simple, we use the Observable create factory method to create an Observable and then two Observers that subscribe to that Observable using the io scheduler. We deliberately leave out onCompleted/onComplete when creating the observable and we let the main thread idle for a few minutes to give the evictor thread more than one chance to run after the IO threads complete their work. What we saw was the IO threads forcibly being removed in 2.x but not in 1.x, that was what we meant by the \"purging\" in 2.x, that the behavior has changed\n\n---\n\nPlease ignore the last paragraph in the last comment, on diving deep into the code, we see what has happened in that test case, onCompleted was required by the SafeSubscriber in 1.x to unsubscribe which will eventually release the thread back to the queue, since this was missing in the flow created by the test code, those IO threads never get released and evicted; in 2.x, the parent Scheduler parent class wraps the work to be done within a DisposeTask that guarantees that the IO thread gets released back to the queue for eviction. The subscription list approach seems quite complex and the DisposeTask very elegant.\r\n\r\nSo, closing comments from you David, for the sake of repeating for our benefit, given how complex this one example is, there's no telling what foibles exist in our application code, the upgrade to 2.x would be best thing to do for us, correct?\r\n\r\nAlso, please don't forget to enlighten us on the design decision to use a dedicated purge thread instead of remove on cancel policy?"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-11-20T09:04:15Z",
        "body": "In general, without seeing your code, it could be both a programming error on your part or a corner case/quirk of RxJava 1.\r\n\r\n> Can you help us understand the move from setting the removal on cancel policy in 1.x to a dedicated purge thread in 2.x? What is behind the decision to using a dedicated thread in 2.x?\r\n\r\nIt needed reflection as it was a Java 7+ feature. Certain phones mess up reflection for one. The secondary reason is that `purge` is overall more efficient and is available to Java 6+.\r\n\r\nYou can wrap an `ExecutorService` via `Schedulers.from` that has this policy enabled if you really need it.\r\n\r\n> 2.x would be best thing to do for us, correct?\r\n\r\n1.x is end of life so there won't be any support, changes, fixes etc. to it. 2.x has architectural, performance and API benefits over 1.x. I recommend upgrading to 2.x; most other libraries have upgraded as well by now so it shouldn't be much of a problem."
      },
      {
        "user": "pp112018",
        "created_at": "2018-11-20T14:29:00Z",
        "body": "We would love to share the code with you if we have even the possibility of narrowing it down to a few suspects, the problem that we face is we use RX so widely in our ecosystem and idle thread behavior is so pervasive that it is hard to pinpoint exactly what might be responsible. Some high traffic services suffer the problem more severely than others so the one thing that we are certain of is that it is load induced. Also, since we use RX at all levels and given how common the problem is, what we can reasonably surmise is that it must be some library code. However, it is hard to ascertain if it is a quirk of RX 1.2.7 at high load, or whether a bug exists in how we use 1.2.7 in either our platform or application code as you say. The only thing that is certain from looking at the 1.2.7 code is for some reason, those large number of idle threads were not released back to the queue, because for if they were, the evictor should have multiple chances to reclaim them given how long-lived the threads were.\r\n\r\nThis was what prompted us to create the abovementioned test case for we saw that the only way a ThreadWorker would be released back to the queue is if onCompleted was called on the subscriber at which unsubscription would happen; or if onError happened.\r\n\r\nJust one minor question that I have, it seems like several layers of subscriptions can be created through the SubscriptionList and CompositeSubscription model even for our simple test case, and the code has to work through a bit of unwinding to do before it is able to get to the subscription to effectively release the worker back to the queue. We also noticed that the work to unsubscribe is submitted as a different task to the same executor that handles the work request for the thread worker unlike the DisposeTask which wraps the work request and dispose task within the same runnable. In the face of high load and multiple context switching, does the possibility of race conditions exist for 1.2.7? We have searched quite thoroughly for why onCompleted would not be called in our code and in the absence of any concrete findings, we are wondering if race conditions under high load might somewhat be responsible."
      },
      {
        "user": "akarnokd",
        "created_at": "2018-11-20T16:22:07Z",
        "body": "> We also noticed that the work to unsubscribe is submitted to the same executor that handles the work request for the thread worker.\r\n\r\nThis may lead to a same-pool deadlock if the scheduler is blocked on non-interruptible code, unsubscription may never run.\r\n\r\n> In the face of high load and multiple context switching, does the possibility of race conditions exist?\r\n\r\nNo.\r\n\r\nYou could have a wrapper `Scheduler` that tracks the calls to `createWorker` and `Worker.unsubscribe` before delegating, so you could log what created those workers."
      },
      {
        "user": "pp112018",
        "created_at": "2018-11-20T16:26:23Z",
        "body": "> > We also noticed that the work to unsubscribe is submitted to the same executor that handles the work request for the thread worker.\r\n> \r\n> This may lead to a same-pool deadlock if the scheduler is blocked on non-interruptible code, unsubscription may never run.\r\n> \r\n> > In the face of high load and multiple context switching, does the possibility of race conditions exist?\r\n> \r\n> No.\r\n\r\nWhat makes you certain about that? We are trying to figure out why the problem is exacerbated in the face of high load\r\n> \r\n> You could have a wrapper `Scheduler` that tracks the calls to `createWorker` and `Worker.unsubscribe` before delegating, so you could log what created those workers.\r\n\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-11-20T17:19:04Z",
        "body": "> What makes you certain about that?\r\n\r\nRace condition inside the schedulers manifested themselves pretty soon during development of RxJava. If the JVM is not broken, there is no way to have a race condition within the schedulers.\r\n\r\n> We are trying to figure out why the problem is exacerbated in the face of high load\r\n\r\nYou could do a thread dump to see what's going on. If threads are waiting in the `LockSupport.park` pretty close to a `ScheduledThreadPoolExecutor`, you don't end the sequences properly. If they are blocked somewhere in user code or external API call, you have likely non-interruptible task.\r\n\r\nYou can switch to an `ExecutorService` with a maximum number of threads and use `Schedulers.from`, but note that this will eventually hang if all threads get blocked an never unblock.\r\n\r\n"
      },
      {
        "user": "pp112018",
        "created_at": "2018-11-20T17:28:31Z",
        "body": "> > What makes you certain about that?\r\n> \r\n> Race condition inside the schedulers manifested themselves pretty soon during development of RxJava. If the JVM is not broken, there is no way to have a race condition within the schedulers.\r\n> \r\n> > We are trying to figure out why the problem is exacerbated in the face of high load\r\n> \r\n> You could do a thread dump to see what's going on. If threads are waiting in the `LockSupport.park` pretty close to a `ScheduledThreadPoolExecutor`, you don't end the sequences properly. If they are blocked somewhere in user code or external API call, you have likely non-interruptible task.\r\n> \r\n> You can switch to an `ExecutorService` with a maximum number of threads and use `Schedulers.from`, but note that this will eventually hang if all threads get blocked an never unblock.\r\n\r\nWe did that, they are all waiting in LockSupport.park which made us contrive the test case that did not call onCompleted in 1.2.7. We were also able to replicate this in 1.3.8 but the problem disappears when we update the test to use 2.2.3. \r\n\r\nMany thanks for your time, I think that in the face of so many uncertain probable root causes in 1.x against the guarantees that we saw with the DisposeTask in 2.2.3, we really have no option but to upgrade.\r\n\r\nPlease feel free to close this issue. Once again, many thanks!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of thread lifecycle management differences between RxJava 1.x and 2.x",
      "Guidance on sustainable thread pool management without manual keep-alive tuning",
      "Validation of upgrade path to RxJava 2.x as solution",
      "Methodology to identify thread leaks in RxJava 1.x applications",
      "Explanation of design trade-offs between remove-on-cancel vs purge thread approaches",
      "Assurance of solution stability under high load conditions"
    ]
  },
  {
    "number": 6261,
    "title": "Proposal: Make NonBlockingThread public",
    "created_at": "2018-10-25T22:35:52Z",
    "closed_at": "2018-10-26T06:59:04Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6261",
    "body": "The `NonBlockingThread` plugin control is pretty cool, but becomes unusable when using a custom `ThreadFactory` since it's internal. Would you be open to making this interface public so that custom provided threads could indicate that they should not be blocking as well?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6261/comments",
    "author": "ZacSweers",
    "comments": [
      {
        "user": "ZacSweers",
        "created_at": "2018-10-26T05:32:35Z",
        "body": "Alternatively - a plugin hook like `onBlockingOperator` such that we can basically perform our own check. That would allow for failing on threads we maybe don't control, such as the main thread on Android"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-10-26T06:35:36Z",
        "body": "There is the RxJavaPlugins.setOnBeforeBlocking hook for the case where existing threading can be checked."
      },
      {
        "user": "ZacSweers",
        "created_at": "2018-10-26T06:59:03Z",
        "body": "Ah! I misread the logic here\r\n\r\n```java\r\nThread.currentThread() instanceof NonBlockingThread\r\n                        || RxJavaPlugins.onBeforeBlocking()\r\n```\r\n\r\nand thought it was `&&` \ud83d\ude44 . That covers it then!"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-10-26T07:31:18Z",
        "body": "I thought about such scenarios back then because of Android main thread which you don't control type-vise."
      },
      {
        "user": "ZacSweers",
        "created_at": "2018-10-26T07:45:42Z",
        "body": "yep it makes a lot of sense to have. Thanks again"
      }
    ],
    "satisfaction_conditions": [
      "Provides a way to detect blocking operations on threads not controlled via type-checking",
      "Supports extensibility for custom thread management scenarios",
      "Maintains compatibility with existing thread validation logic"
    ]
  },
  {
    "number": 6240,
    "title": "2.0: Operator for specifying used scheduler for all operators downstream",
    "created_at": "2018-10-08T22:57:21Z",
    "closed_at": "2018-10-09T20:47:20Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6240",
    "body": "**Question/Enhancement**\r\n\r\nWhy there is no operator that would enable specifying scheduler used by all operators downstream?\r\nWith assumption that `scheduleOn` and `observeOn` would still keep working as they were so far.\r\n \r\n**Problem/Background**\r\nRecently I learned that there isn't really a concise, reliable way to specify on which scheduler actions from operators like eg. `doOnDispose` or `doOnSubscribe` will be executed. \r\nFurthermore, position of these operators in chain influences scheduler used by them, which seems logical, but how it's determined is rather unclear - at least from perspective of API. \r\n\r\nEsentially I would like to be able to write code like:\r\n```\r\nrepository.getProducts()\r\n    ...\r\n    .subscribeOn(schedulers.io)\r\n    ...\r\n    .observeOn(schedulers.main)\r\n    ...\r\n    .doOnSubscribe {\r\n        products.value = Resource.loading(emptyList())\r\n    }.subscribe({\r\n        products.value = Resource.success(it)\r\n    }, {\r\n        products.value = Resource.error(it.message)\r\n    })\r\n```\r\nand feel safe that `doOnSubscribe` will be executed on main thread.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6240/comments",
    "author": "PawlikMichal25",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-10-09T07:46:00Z",
        "body": "> Why there is no operator that would enable specifying scheduler used by all operators downstream?\r\n\r\nBecause it is not possible. Operators can't have such reach.\r\n\r\n> which scheduler actions from operators like eg. doOnDispose\r\n\r\n`unsubscribeOn` affects where the `dispose()` call of its upstream will be called.\r\n\r\n> doOnSubscribe\r\n\r\nThere is no direct support for moving `doOnSubscribe` onto another thread but you can side-effect a different a preceding sequence.\r\n\r\n```java\r\nsource\r\n.startWith(\r\n    Completable.fromAction(() -> { /* your onSubscribe */ })\r\n    .subscribeOn(mainThread())\r\n    .toObservable()\r\n)\r\n.subscribe(/* ... */);\r\n```\r\n\r\nWith Kotlin, you can even create an extension method for the `startWith` part."
      },
      {
        "user": "PawlikMichal25",
        "created_at": "2018-10-09T20:20:35Z",
        "body": "Thanks for clarifying, just one more question then:\r\n\r\n> Because it is not possible. Operators can't have such reach.\r\n\r\nso the fact that sometimes eg. action from `doOnSubscribe` is executed on different schedulers  should be considered as a \"side effect\"?"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-10-09T20:26:03Z",
        "body": "The `doOnXXX` operators allow you to insert side effect at various points into a flow. They are not predicated on schedulers."
      },
      {
        "user": "PawlikMichal25",
        "created_at": "2018-10-09T20:47:20Z",
        "body": "Ok, thanks for responding, \r\nI will close the issue now"
      }
    ],
    "satisfaction_conditions": [
      "Clarification of how schedulers influence operator callbacks like `doOnSubscribe` and `doOnDispose`",
      "A method to reliably control the execution thread for lifecycle callbacks (e.g., `doOnSubscribe`)",
      "Explanation of why a global downstream scheduler operator isn't feasible",
      "Workaround that aligns with RxJava's existing operator semantics"
    ]
  },
  {
    "number": 6233,
    "title": "2.2.0 - Question - Flowable.GroupBy Memory Usage",
    "created_at": "2018-09-30T18:12:41Z",
    "closed_at": "2018-09-30T22:13:11Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6233",
    "body": "I have some questions about the groupBy operator and its memory usage.\r\n\r\n1. Does Flowable.groupBy begin to emit GroupedFlowables as the groupBy keys are encountered or are they held back until the full set of groupBy keys can be identified?  How much buffering of source emissions does Flowable.groupBy do?  Or is it more like a situation where Flowable.groupBy publishes to the GroupedFlowable for a corresponding groupBy key as it's encountered?\r\n2. If I have a very long source Flowable (millions of emissions) which emits its items in sorted order of the value I want to use as a groupBy key, should I be concerned about memory issues (OutOfMemoryError, etc.) with using Flowable.groupBy()?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6233/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-09-30T18:43:58Z",
        "body": "> Does Flowable.groupBy begin to emit GroupedFlowables as the groupBy keys are encountered\r\n\r\nYes.\r\n\r\n> How much buffering of source emissions does Flowable.groupBy\r\n\r\nNone.\r\n\r\n> Flowable.groupBy publishes to the GroupedFlowable for a corresponding groupBy key as it's encountered?\r\n\r\nYes.\r\n\r\n> If I have a very long source Flowable (millions of emissions) which emits its items in sorted order of the value I want to use as a groupBy key, should I be concerned about memory issues (OutOfMemoryError, etc.) with using Flowable.groupBy()?\r\n\r\nYes, groups live until they are individually no longer observed or when the source terminates.\r\n"
      },
      {
        "user": "ghost",
        "created_at": "2018-09-30T19:12:50Z",
        "body": "Thanks so much for the response, I really appreciate it.  I have some follow up questions if you'd be so kind, then I will close the issue.\r\n> Yes, groups live until they are individually no longer observed or when the source terminates.\r\n\r\nWhen does a GroupedFlowable signal completion?  Only when the source terminates?  In the scenario I described where the source emissions come in the order of the groupBy key, what would happen if I applied a .take(n) operator to inner GroupedFlowables specifying an upper bound?  Would the GroupedFlowables be disposed in that case and then recreated if/when the groupBy key is seen again, or are they still kept alive?\r\n\r\nThanks again"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-09-30T19:18:25Z",
        "body": "> When does a GroupedFlowable signal completion? Only when the source terminates?\r\n\r\nYes.\r\n\r\n> what would happen if I applied a .take(n) operator to inner GroupedFlowables specifying an upper bound?\r\n\r\nAssuming you have strictly ordered keys, a take would end a group, freeing the associated resources and the operator would not create another one.\r\n\r\n> Would the GroupedFlowables be disposed in that case and then recreated if/when the groupBy key is seen again\r\n\r\nYes."
      },
      {
        "user": "ghost",
        "created_at": "2018-09-30T22:13:11Z",
        "body": "Perfect, thank you."
      }
    ],
    "satisfaction_conditions": [
      "Clarification of GroupedFlowable emission timing",
      "Explanation of group lifecycle management",
      "Memory impact analysis for ordered key sequences",
      "Behavior clarification on group recreation"
    ]
  },
  {
    "number": 6214,
    "title": "RxJava 2.2.2 startsWith subscribes the subsequence streams without subscribing to the upper stream",
    "created_at": "2018-09-16T14:58:16Z",
    "closed_at": "2018-09-16T16:42:26Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6214",
    "body": "Hi, I'm not sure if this is a bug or an expected behavior. \r\nSee an example below:\r\n```\r\n        PublishSubject<Integer> subject = PublishSubject.create();\r\n        AtomicBoolean bool = new AtomicBoolean();\r\n        subject\r\n                .doOnSubscribe(s->{}) << not called\r\n                .doOnNext(s->{}) << not called\r\n                .startWith(0)\r\n                .switchMap(o -> Observable\r\n                        .empty()\r\n                        .doOnSubscribe(s -> {\r\n                            if (!bool.get()) {\r\n                                subject.onNext(1); << called\r\n                            }\r\n                        }))\r\n                .subscribe();\r\n```\r\nScenario:\r\nIn my use case, I subscribed to a source that chained with a #startWith operator.\r\nI performed a switchMap, expecting the next value terminates it and starts a new one. \r\nSubject emits something during the switchmap. Happens on both Observable/Flowable.\r\n\r\nExpected: receive the new event\r\nActual: receive nothing due to subject not subscribed yet.\r\n\r\nHave not tested on other version.\r\n\r\nThanks\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6214/comments",
    "author": "ykinuse",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-09-16T16:03:59Z",
        "body": "This is a valid behavior. The `PublishSubject` is not subscribed at that time because `startWith` hasn't finished yet switching to it. Consider using `BehaviorSubject.create(0)` instead and not doing that reentrant `onNext` call."
      },
      {
        "user": "ykinuse",
        "created_at": "2018-09-16T16:06:44Z",
        "body": "Thanks for the clarification. PublishSubject was used as an example of some source. So I'm assuming doOnSubscribe() chained after startWith does not guaranteed subscription established to the source? Was expecting a guaranteed subscription to source before startWith emits. "
      },
      {
        "user": "akarnokd",
        "created_at": "2018-09-16T16:21:06Z",
        "body": "No. StartWith is like concat, subscribes the next source after the previous source has completed, thus no `doOnSubscribe` is called on the next source until that."
      },
      {
        "user": "ykinuse",
        "created_at": "2018-09-16T16:30:33Z",
        "body": "Cleared my doubts. Thanks for the swift & clear response!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how startWith operator manages upstream subscriptions",
      "Clarification of when upstream subscription actually occurs relative to startWith emissions",
      "Identification of safe patterns for reentrant onNext calls during stream setup",
      "Differentiation between PublishSubject and BehaviorSubject behaviors in cold/hot observable scenarios"
    ]
  },
  {
    "number": 6190,
    "title": "Why doesn't Flowable#buffer(long, TimeUnit, int) support backpressure?",
    "created_at": "2018-08-31T19:16:59Z",
    "closed_at": "2018-08-31T19:55:53Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6190",
    "body": "Why doesn't Flowable#buffer(long, TimeUnit, int) support backpressure?\r\n\r\nI'm using version 2.2.1, and here's the code for my experiment:\r\n```java\r\n\tpublic static void main(String[] args) throws Exception {\r\n\t\tFlowable.range(0, 10000)\r\n\t\t.buffer(5, TimeUnit.SECONDS, 100)\r\n//\t\t.onBackpressureBuffer()\r\n\t\t.concatMap(list -> {\r\n\t\t\tSystem.out.println(list.size());\r\n\t\t\treturn Flowable.just(list).delaySubscription(500, TimeUnit.MILLISECONDS);\r\n\t\t})\r\n\t\t.blockingSubscribe();\r\n\t}\r\n```\r\nThe code above will cause a `MissingBackpressureException` unless I add `.onBackpressureBuffer()` after `.buffer(5, TimeUnit.SECONDS, 100)`, which is to be expected because the Javadoc for `Flowable#buffer(long, TimeUnit, int)` says `This operator does not support backpressure as it uses time`.\r\n\r\nSo here are my questions:\r\n1. I understand why a size based buffer can support backpressure while a time based buffer cannot. But why can't a time and size based buffer support backpressure like a purely size based buffer does?\r\n2. Is there a way to achieve a backpressured size based buffer with a time based \"kick\"?\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6190/comments",
    "author": "slisaasquatch",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-08-31T19:26:38Z",
        "body": "> But why can't a time and size based buffer support backpressure like a purely size based buffer does\r\n\r\nBecause the time part makes it backpressure incompatible and backpressuring would result in time not being honored.\r\n\r\n> Is there a way to achieve a backpressured size based buffer with a time based \"kick\"?\r\n\r\nWhat if the downstream is not ready to receive a buffer when this \"kick\" happens? Apply one of the `onBackpressureXXX` operators to decide what should happen."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why combining time and size parameters in buffer() inherently conflicts with backpressure mechanisms",
      "Strategy for handling downstream unavailability during time-based buffer emission",
      "Approach to maintain size-based backpressure while allowing time-based buffer flushing",
      "Clarification of backpressure responsibility boundaries between operators"
    ]
  },
  {
    "number": 6184,
    "title": "flatmap from observable to completable,onComplete Action no call!",
    "created_at": "2018-08-29T09:44:07Z",
    "closed_at": "2018-08-29T09:54:41Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6184",
    "body": "RxJava version:2.1.12\r\n\r\ncode:\r\n``` kotlin\r\nObservable.create<Unit> { it.onNext(Unit) }\r\n                    .observeOn(Schedulers.io())\r\n                    .flatMap { Observable.create<Unit> { it.onNext(Unit) } }\r\n                    .flatMap { Observable.create<Unit> { it.onNext(Unit) } }\r\n                    .flatMap { Observable.create<Unit> { it.onNext(Unit) } }\r\n                    .flatMapCompletable {\r\n                        Completable.create {\r\n                            Thread.sleep(3000)\r\n                            //do something\r\n                            it.onComplete()\r\n                        }\r\n                    }\r\n                    .observeOn(AndroidSchedulers.mainThread())\r\n                    .subscribe(Action {\r\n                        //no call\r\n                        print(\"11111\")\r\n                    }, Consumer {\r\n                        print(\"1111\")\r\n                    })\r\n```\r\nI don't know why, the final onComplete Action is not called. Is there a problem with my usage?\r\nIf you replace all Observable.create with Observable.just() , the final onComplete Action will be called. Why?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6184/comments",
    "author": "linzhengloser",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-08-29T09:54:41Z",
        "body": "You need a finite sequence in each `create` in order for the various `flatMap`s to complete at which point the entire sequence completes and you get that Action call.\r\n\r\nPlease, next time ask such questions on StackOverflow."
      },
      {
        "user": "linzhengloser",
        "created_at": "2018-08-30T01:14:44Z",
        "body": "Thank you very much!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why Observable.create prevents the final onComplete Action from being called",
      "Clarification about finite Observable sequences in flatMap chains",
      "Identification of proper Observable termination requirements"
    ]
  },
  {
    "number": 6169,
    "title": "Give Flowable.sequenceEqual()/BiPredicate the option to use Single<Boolean> instead of boolean",
    "created_at": "2018-08-23T09:15:45Z",
    "closed_at": "2018-08-31T19:29:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6169",
    "body": "I need to compare two `Flowable`s, that unfortunaley, due to `groupBy()` do not complete until all items it contains are subscribed to. \r\n\r\nCurrently, this is not possible since test() in the BiPredicate you can implement for `sequenceEqual()` can only return a `boolean`, it expects the `Flowable` to be comparable one by one. I suggest to overload `test()` so that it can also return `Single<Boolean>` - thus allowing the comparison to happen for all elements of the `Flowable` before expecting it to complete, which lets every item be subscribed to.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6169/comments",
    "author": "Namnodorel",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-08-23T09:24:41Z",
        "body": "I'm not sure what you try to achieve here. `sequenceEqual` compares item by item when both sources have at least one item ready for comparison."
      },
      {
        "user": "Namnodorel",
        "created_at": "2018-08-23T09:36:01Z",
        "body": "@akarnokd Yes. And this one-after-the-other comparison doesn't work if the items are (or come from a Flowable that was a) `GroupedFlowable`s. In that case, the first item won't complete until all the other items are subscribed to. But currently, `sequenceEqual()` waits until the first item comparison completes until it moves on to the next one. For this to work, `sequenceEqual()` would need to be able to compare the `Flowable`s asynchronously."
      },
      {
        "user": "akarnokd",
        "created_at": "2018-08-23T09:42:43Z",
        "body": "Please show some actual code that demonstrates your issue."
      },
      {
        "user": "Namnodorel",
        "created_at": "2018-08-23T09:56:50Z",
        "body": "Given a class `ValueGroup` with an object `key` and a `Flowable`. I want to squash multiple `ValueGroup`s with the same key together, like this:\r\n```\r\nFlowable<ValueGroup> myFlowable = ...;\r\nmyFlowable\r\n.groupBy(ValueGroup::getKey)\r\n    .map(groupedValueGroups -> new ValueGroup(\r\n        groupedValueGroups.getKey(),\r\n        groupedValueGroups\r\n            .flatMap((Function<ValueGroup, Publisher<? extends Value>>) ValueGroup::getFlowable)\r\n))\r\n```\r\nAt some point later in the code, I then use\r\n```\r\nFlowable.sequenceEqual(myFlowable, anotherFlowable)\r\n```\r\n(`anotherFlowable` is basically the same as `myFlowable`)\r\n\r\nWhat then happens, is: `sequenceEqual()` takes the first item of both Flowables, tries to compare them, and... gets stuck. Because to compare the `ValueGroup`s, the `Flowable`s inside them also need to be compared. But they don't complete, because all the other elements have not yet been subscribed to."
      },
      {
        "user": "akarnokd",
        "created_at": "2018-08-23T10:03:49Z",
        "body": "You have to consume the groups in order for them to make progress. A Single predicate won't help your case as it is too late by then. Turn the groups into Lists and compare that way."
      },
      {
        "user": "Namnodorel",
        "created_at": "2018-08-23T10:15:03Z",
        "body": "Turning `Flowable`s into a `List` is in th category of \"it technically works, but it's not really a clean solution\"...\r\n\r\nI honestly don't quite understand why it wouldn't work for `sequenceEqual()` to call `test()` asynchronously for all objects that it will compare. That way, all `Flowable`s would be subscribed to \"at once\", and could properly complete. The groups would be consumed in the sense that their comparison emits a `Single<Boolean>`."
      },
      {
        "user": "akarnokd",
        "created_at": "2018-08-23T10:33:17Z",
        "body": "> I honestly don't quite understand why it wouldn't work \r\n\r\n`Flowable.groupBy` has backpressure and in order to have the sequence progress at all, you have to consume all groups it creates. Thus you can't just save up an inner `Flowable` to be compared later.\r\n\r\n> call test() asynchronously \r\n\r\nDoesn't work, the operator would subscribe to that `Single` and then hang as well because of the above.\r\n\r\nYou could try and adapt the following:\r\n\r\n```java\r\nFlowable<Flowable<Integer>> seq1 = ...;\r\nFlowable<Flowable<Integer>> seq2 = ...;\r\n\r\nFlowable.zip(seq1, seq2, (a, b) -> \r\n    return Flowable.sequenceEqual(a, b);\r\n)\r\n.flatMapSingle(v -> v)\r\n.all(v -> v);\r\n```"
      },
      {
        "user": "Namnodorel",
        "created_at": "2018-08-28T13:21:45Z",
        "body": ">Flowable.groupBy has backpressure and in order to have the sequence progress at all, you have to consume all groups it creates. Thus you can't just save up an inner Flowable to be compared later.\r\n\r\nI know, that's not what I'm having trouble with understanding.\r\n>Doesn't work, the operator would subscribe to that `Single` and then hang as well because of the above.\r\n\r\nThat would happen if it subscribed to only one `Single` at a time. But because it is async, it wouldn't need to wait for the first `Single` to complete, but could instead go on and subscribe to the rest of them as well. Until at some point, it has subscribed to all, and then they'll be able to complete.\r\n\r\nI'll try your example.\n\n---\n\nExample is also stuck. "
      },
      {
        "user": "akarnokd",
        "created_at": "2018-08-28T13:27:26Z",
        "body": "Try with an `Observable`-based setup."
      },
      {
        "user": "Namnodorel",
        "created_at": "2018-08-31T19:20:36Z",
        "body": "Nevermind, the first example was actually correct, and I made a mistake in implementing it (my actual scenario is a little more complex, but that isn't relevant to the problem itself).\r\n\r\nThe issue I had is thus solved, however I'd still like to keep the suggestion: Implement this as an alternative to the existing `sequenceEqual()` so that it works with data that can't be compared one after the other for one reason or the other. "
      },
      {
        "user": "akarnokd",
        "created_at": "2018-08-31T19:29:46Z",
        "body": "> Nevermind, the first example was actually correct\r\n\r\nGreat!\r\n\r\n> Implement this as an alternative\r\n\r\nI'm not convinced this is common enough to add it to RxJava. What if the structure is different? What if other properties are different? What if the operation should be different?"
      },
      {
        "user": "Namnodorel",
        "created_at": "2018-08-31T19:47:16Z",
        "body": "Structure? Of what? The elements held in the compared Flowable/Observable? I think that is specific to my case, what's on my mind is more something that is just capable of comparing sequences not \"in order\".\r\n\r\nBasically a `sequenceEqual()` that does what your example did, but instead of returning `Flowable.sequenceEqual(a, b)` in `zip()` accessing an interface similar to `BiPredicate`, with the change of returning a `Single<Boolean>`. The elements themselves would be compared like usual; if they contain (or are) nested Flowables/Observables, you'll need a custom implementation of the comparing interface one way or the other.\r\n\r\nRegarding being common... Well, to me it sounds like it could be common enough to be included, but - well, you're the expert :D"
      }
    ],
    "satisfaction_conditions": [
      "Supports asynchronous comparison of Flowable sequences where elements require concurrent subscription to complete",
      "Allows comparing nested Flowable structures without materializing them into collections",
      "Provides a way to compare entire sequences atomically rather than element-by-element",
      "Maintains backpressure compatibility with RxJava operators",
      "Offers a generalized solution for comparing complex reactive stream topologies"
    ]
  },
  {
    "number": 6163,
    "title": "Why rx throws OnErrorNotImplementedException when I have doOnError",
    "created_at": "2018-08-18T02:40:36Z",
    "closed_at": "2018-08-18T02:47:28Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6163",
    "body": "version:\r\n2.2.0\r\n\r\nThe code:\r\n\r\n```java\r\n        Observable.create(new ObservableOnSubscribe<String>() {\r\n            @Override\r\n            public void subscribe(ObservableEmitter<String> emitter) throws Exception {\r\n                Log.d(TAG, \"subscribe: \" + \" 111111111\");\r\n                emitter.onNext(\"success\");\r\n                emitter.onError(new Throwable(\"2222222\"));\r\n            }\r\n        })\r\n                .doOnNext(new Consumer<String>() {\r\n                    @Override\r\n                    public void accept(String s) throws Exception {\r\n                        Log.d(TAG, \"accept: doOnNext \" + s);\r\n                    }\r\n                })\r\n                .doOnError(new Consumer<Throwable>() {\r\n                    @Override\r\n                    public void accept(Throwable throwable) throws Exception {\r\n                        Log.d(TAG, \"accept: doOnError \" + throwable);\r\n                    }\r\n                })\r\n               .subscribe();\r\n```\r\nThe Exception:\r\n\r\nio.reactivex.exceptions.OnErrorNotImplementedException: 2222222\r\n\r\nIf the `doOnError` can not handle the exception, the `doOnError` is design for what?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6163/comments",
    "author": "anatta-feng",
    "comments": [
      {
        "user": "JakeWharton",
        "created_at": "2018-08-18T02:43:12Z",
        "body": "It's for side-effects (e.g., logging). If you want to handle the error, add something which can handle errors to the `subscribe` call."
      }
    ],
    "satisfaction_conditions": [
      "Clarify the distinction between error observation and error handling in RxJava operators",
      "Explain the required components for proper error handling in RxJava subscriptions",
      "Define the intended purpose of doOnError operator",
      "Differentiate between side-effect operators and terminal error handlers"
    ]
  },
  {
    "number": 6008,
    "title": "2.x: Single, toObservable and share: sometimes NoSuchElementException",
    "created_at": "2018-05-16T09:38:23Z",
    "closed_at": "2018-05-17T02:15:26Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6008",
    "body": "Hello. I periodically have a NoSuchElementException. Version 2.1.12.\r\n\r\nCode:\r\n```\r\nSingle<String> single = Single.just(\"12345\")\r\n              .toObservable()\r\n              .share()\r\n              .singleOrError();\r\n      \r\n      for (int i = 0; i < 10; i++) {\r\n         new Thread(() -> {\r\n            single.subscribe((t) -> {\r\n            }, thrw -> {\r\n               if (NoSuchElementException.class.equals(thrw.getClass())) {\r\n                  printStackTrace();\r\n                  return;\r\n               }\r\n            });\r\n         }).start();\r\n\r\n         if (i % 2 != 0) {\r\n            Thread.sleep(4);\r\n         }\r\n      }\r\n\r\n```\r\nStacktrace:\r\n```\r\nat io.reactivex.internal.observers.ConsumerSingleObserver.onError(ConsumerSingleObserver.java:47)\r\n\tat io.reactivex.internal.operators.observable.ObservableSingleSingle$SingleElementObserver.onComplete(ObservableSingleSingle.java:113)\r\n\tat io.reactivex.internal.operators.observable.ObservableRefCount$ConnectionObserver.onComplete(ObservableRefCount.java:145)\r\n\tat io.reactivex.internal.operators.observable.ObservablePublish$PublishObserver.onComplete(ObservablePublish.java:193)\r\n\tat io.reactivex.internal.observers.DeferredScalarDisposable.complete(DeferredScalarDisposable.java:85)\r\n\tat io.reactivex.internal.operators.single.SingleToObservable$SingleToObservableObserver.onSuccess(SingleToObservable.java:73)\r\n\tat io.reactivex.internal.operators.single.SingleJust.subscribeActual(SingleJust.java:30)\r\n\tat io.reactivex.Single.subscribe(Single.java:3220)\r\n\tat io.reactivex.internal.operators.single.SingleToObservable.subscribeActual(SingleToObservable.java:36)\r\n\tat io.reactivex.Observable.subscribe(Observable.java:12005)\r\n\tat io.reactivex.internal.operators.observable.ObservablePublish.connect(ObservablePublish.java:116)\r\n\tat io.reactivex.internal.operators.observable.ObservableRefCount.subscribeActual(ObservableRefCount.java:68)\r\n\tat io.reactivex.Observable.subscribe(Observable.java:12005)\r\n\tat io.reactivex.internal.operators.observable.ObservableSingleSingle.subscribeActual(ObservableSingleSingle.java:35)\r\n\tat io.reactivex.Single.subscribe(Single.java:3220)\r\n\tat io.reactivex.Single.subscribe(Single.java:3206)\r\n```\r\n\r\nIs this a bug or an incorrect code? For cycle is written to demonstrate the problem.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6008/comments",
    "author": "neyron91",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-05-16T10:19:27Z",
        "body": "This is a plausible outcome when using `share`. The underlying `publish` operator emits items to currently subscribed observers only. With that race in your code, some observers may come after the \"12345\" has been emitted but just before `onComplete` is signalled, thus they encounter an empty sequence. \r\n\r\nUse `replay(1).refCount()` to ensure you don't lose that single item."
      },
      {
        "user": "neyron91",
        "created_at": "2018-05-17T01:45:51Z",
        "body": "Thanks, it works!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why NoSuchElementException occurs with share() in concurrent subscriptions",
      "Identification of race condition between subscription timing and emission completion",
      "Solution ensuring cached emission for late subscribers",
      "Guidance on operator selection for shared cold-to-hot observable conversion"
    ]
  },
  {
    "number": 5941,
    "title": "[RxJava 2.1] Executing blocking operations on IO scheduler switches execution to a single thread",
    "created_at": "2018-03-31T03:43:40Z",
    "closed_at": "2018-04-15T11:28:20Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5941",
    "body": "RxJava 2.1.3\r\n\r\nSample that demonstrates the problem:\r\n\r\n```java\r\nimport java.util.concurrent.ConcurrentHashMap;\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\nimport java.util.concurrent.atomic.AtomicLong;\r\n\r\nimport io.reactivex.Observable;\r\nimport io.reactivex.ObservableTransformer;\r\nimport io.reactivex.functions.Action;\r\nimport io.reactivex.schedulers.Schedulers;\r\n\r\npublic class Main {\r\n  private static final int NUM_THREADS = 8;\r\n  private static final int NUM_EVENTS = 200;\r\n\r\n  public static void main(String[] args) throws Exception {\r\n    System.out.println(\"Executing blocking operation...\");\r\n    observe(() -> Thread.sleep((long) (Math.random() * 100)));\r\n\r\n    System.out.println(\"Executing non-blocking operation...\");\r\n    observe(() -> {});\r\n  }\r\n\r\n  private static void observe(Action op) {\r\n    AtomicInteger messageReceived = new AtomicInteger(0);\r\n    AtomicInteger observableComplete = new AtomicInteger(0);\r\n    ConcurrentHashMap<String, AtomicInteger> counters = new ConcurrentHashMap<>();\r\n\r\n    createObservable()\r\n        .compose(createThreadPoolTransformer())\r\n        .compose(performOperation(op))\r\n        .subscribe(\r\n            e -> {\r\n              counters.compute(Thread.currentThread().getName(), (key, ai) -> {\r\n                ai = ai == null ? new AtomicInteger(0) : ai;\r\n                ai.incrementAndGet();\r\n                return ai;\r\n              });\r\n              messageReceived.incrementAndGet();\r\n\r\n              if (messageReceived.get() == NUM_EVENTS) {\r\n                System.out.println(String.format(\"Counts per thread: %s \\n\", counters));\r\n              }\r\n            }, e -> {}, observableComplete::incrementAndGet);\r\n\r\n    while(observableComplete.get() == 0) {\r\n      // wait until it's complete\r\n    }\r\n  }\r\n\r\n  private static Observable<Long> createObservable() {\r\n    return Observable.just(0).repeat(NUM_EVENTS).map(al -> {\r\n      Thread.sleep(10);\r\n      return System.currentTimeMillis();\r\n    });\r\n  }\r\n\r\n  private static ObservableTransformer<Long, Long> createThreadPoolTransformer() {\r\n    AtomicLong counter = new AtomicLong(0);\r\n    return upstream ->\r\n        upstream\r\n            .groupBy(e -> counter.getAndIncrement() % NUM_THREADS)\r\n            .flatMap(g -> g.observeOn(Schedulers.io()));\r\n  }\r\n\r\n  private static ObservableTransformer<Long, Long> performOperation(Action op) {\r\n    return upstream -> upstream\r\n        .map(\r\n            e -> {\r\n              if (Math.random() < 0.5) {\r\n                op.run();\r\n              }\r\n              return e;\r\n            });\r\n  }\r\n}\r\n```\r\nRunning the program should print something like:\r\n```\r\nExecuting blocking operation...\r\nCounts per thread: {RxCachedThreadScheduler-1=200} \r\n\r\nExecuting non-blocking operation...\r\nCounts per thread: {RxCachedThreadScheduler-1=25, RxCachedThreadScheduler-2=25, RxCachedThreadScheduler-3=25, RxCachedThreadScheduler-8=25, RxCachedThreadScheduler-4=25, RxCachedThreadScheduler-5=25, RxCachedThreadScheduler-6=25, RxCachedThreadScheduler-7=25} \r\n```\r\n\r\nIt shows that after scheduling execution of blocking operations on an IO pool, the observable runs all these operations on a single thread instead.\r\n\r\nI would really appreciate any suggestions to retain equal load on all threads even in the presence of blocking operations!",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5941/comments",
    "author": "sndre",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-03-31T08:51:28Z",
        "body": "The outcome is completely within allowed behavior for two things:\r\n\r\n- `flatMap` doesn't guarantee that a source thread will be able to push through. It is completely possible that one or few threads will perform the merge for the other threads, therefore, it may appear only one or two threads are only involved pushing data further to the downstream.\r\n- You are measuring the thread use at the end consumer, which is always serialized thus there is no guarantee you'll see that many thread hopping there. To make sure `op` is executed in various background threads, you should apply it after `g.observeOn(Schedulers.io())` inside `flatMap` as well as do the current thread check there."
      },
      {
        "user": "sndre",
        "created_at": "2018-04-17T18:32:57Z",
        "body": "@akarnokd, thank you so much for looking into it! That make sense and we followed your suggestion to to apply operations after `observeOn` \ud83d\udcaf "
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why blocking operations cause thread starvation in RxJava's IO scheduler",
      "Solution ensuring parallel execution across multiple IO threads when blocking operations exist",
      "Clarification of RxJava operator behavior regarding thread scheduling and merging",
      "Guidance on proper operator ordering for concurrent execution"
    ]
  },
  {
    "number": 5869,
    "title": "No successful subscription when running `using` and `retry` together",
    "created_at": "2018-02-27T08:43:11Z",
    "closed_at": "2018-02-27T09:29:07Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5869",
    "body": "Version: 'io.reactivex.rxjava2:rxjava:2.1.10'\r\n\r\nNo successful subscription when running `using` and `retry` together, without `retry` or with other `Single` everything is fine.\r\n\r\n```        \r\nSingle.just(\"input\").flatMap(val ->\r\n                Single.using(\r\n                        () -> {\r\n                            System.out.println(\"create\");\r\n                            return \"\";\r\n                            },\r\n                        call -> singleSubscriber -> {\r\n                            System.out.println(\"sub\");\r\n                            singleSubscriber.onSuccess(val);\r\n                            System.out.println(\"sub done\");\r\n                            },\r\n                        call -> {\r\n                            System.out.println(\"close\");\r\n                        }\r\n                        )\r\n                .retry((count, error) -> {\r\n                    System.out.println(\"retry\");\r\n                    return true;\r\n                })\r\n        )\r\n                .subscribe(val -> System.out.println(\"output \" + val));\r\n```\r\nOutput:\r\n```\r\ncreate\r\nsub\r\nclose\r\nsub done\r\n```\r\n\r\nExpected:\r\n```\r\ncreate\r\nsub\r\nclose\r\noutput input\r\nsub done\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5869/comments",
    "author": "dmitart",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-02-27T09:16:51Z",
        "body": "You should not create a `SingleSource` via lambda as people often forget to follow the protocol: `onSubscribe (onSuccess | onError)?`. Use `Single.create()` instead:\r\n\r\n```java\r\nSingle.create(singleSubscriber -> {\r\n    System.out.println(\"sub\");\r\n    singleSubscriber.onSuccess(val);\r\n    System.out.println(\"sub done\");\r\n})\r\n```\r\n\r\nwith which now prints:\r\n\r\n```\r\ncreate\r\nsub\r\nclose\r\noutput input\r\nsub done\r\n```\r\n\r\nWhat happens is that `retry` converts to `Flowable` internally to reuse that operator, which requires downstream requests. However, since `onSubscribe` was never called, the request channel is never established below that operator and the single element is hold up indefinitely."
      },
      {
        "user": "dmitart",
        "created_at": "2018-02-27T09:29:07Z",
        "body": "This solves my issue, thank you. I was not using `using` a lot before and didn't knew about this convention."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of RxJava subscription protocol requirements when combining resource management operators",
      "Clarification of operator interaction between retry and resource-managing operators like using",
      "Guidance on proper error recovery patterns with Single.using"
    ]
  },
  {
    "number": 5855,
    "title": "Why zip(range(0, 1mi)), range(0, 100)) never finishes, when inverting the order does?",
    "created_at": "2018-02-15T23:19:53Z",
    "closed_at": "2018-02-15T23:33:47Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5855",
    "body": "Version: \"2.1.9\"\r\n\r\nI recently ran into a problem where the order of my parameters to the Zip function matters, and now I'm trying to understand why.\r\n\r\nHere's a simplified test:\r\n\r\n```kotlin\r\nval bigRange = Observable.range(0, 1_000_000_000)\r\nval shortRange = Observable.range(0, 100)\r\n\r\nval ts = Observable.zip(shortRange, bigRange, BiFunction<Int, Int, Int> { _, b -> b }).test()\r\n// val ts = Observable.zip(bigRange, shortRange, BiFunction<Int, Int, Int> { a, _ -> a }).test()\r\n\r\nts.awaitTerminalEvent(10, TimeUnit.SECONDS)\r\n```\r\n\r\nIn the test above, the stream completes as expected; with 100 items. However, if I uncomment the other `ts`, then the app hangs.\r\n\r\nFrom the docs it makes me believe that if any of the streams completes, then the whole \"zip\" completes, but this is maybe not the case? Is it something to do with the Observable being a \"pusher\" and not a \"puller\"?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5855/comments",
    "author": "AllanHasegawa",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-02-15T23:24:17Z",
        "body": "`Observable` doesn't have backpressure and `range` is synchronous and will fill up the internal queue of `zip` before giving the chance to the other source. If the short one is first, that happens quickly. If the longer one is first, that may take a lot of time and memory. Try with `Flowable` and you should see both cases complete within reasonable time.\r\n\r\nRxJava is synchronous by default and you have to introduce asynchrony explicitly."
      },
      {
        "user": "AllanHasegawa",
        "created_at": "2018-02-15T23:33:47Z",
        "body": "Awesome explanation; very clear.\r\n\r\nMade a few experiments with Flowable and others \"async\" operators (intervalRange) and I think I understand it now :)\r\n\r\nThank you very much."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how Observable.zip handles synchronous sources with different lengths",
      "Clarification of backpressure mechanisms in RxJava",
      "Description of queueing behavior in zipped synchronous observables",
      "Guidance on when to use asynchronous operators",
      "Explanation of zip termination conditions"
    ]
  },
  {
    "number": 5829,
    "title": "Improve takeUntil method",
    "created_at": "2018-01-31T09:26:46Z",
    "closed_at": "2018-01-31T09:53:33Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5829",
    "body": "rxJava version : 2.x\r\n\r\nBoth 'takeUntil' and 'takeWhile' functions have no inclusive functions.\r\nSo It is impossible to make the following code.\r\n\r\n```java\r\nObservable.just(1,2,3,4,-1,1,2,3,4)\r\n.takeUntil(value -> value == -1)\r\n// I wish : 1, 2, 3, 4, -1\r\n// actually : 1, 2, 3, 4\r\n```\r\n\r\nor in real world...\r\n```java\r\nObservable.merge(\r\n    cacheRequest,\r\n    networkRequest\r\n)\r\n.takeUntilInclusive(data -> data.dataType == FROM_NETWORK);\r\n// Load mem/network data. But when it comes to network data, it stops.\r\n```\r\n\r\nhow about create blow functions?\r\n\r\n`takeWhileInclusive`\r\n`takeUntilInclusive`\r\n`skipWhileInclusive`\r\n`skipUntilInclusive`",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5829/comments",
    "author": "JSpiner",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-01-31T09:34:26Z",
        "body": "Have you actually tried your code?\r\n\r\n```java\r\nObservable.just(1,2,3,4,-1,1,2,3,4)\r\n        .takeUntil(value -> value == -1)\r\n        .subscribe(System.out::println);\r\n```\r\n\r\nprints:\r\n\r\n```\r\n1\r\n2\r\n3\r\n4\r\n-1\r\n```\r\n\r\nI'm not sure what you tried to accomplish originally, but `merge()` looks suspicious as it can interleave your data unexpectedly. Try `concat()`."
      },
      {
        "user": "JSpiner",
        "created_at": "2018-01-31T09:53:33Z",
        "body": "Opps.....\r\nIt looks not tested enough. I was so ashame...\r\nI'll close it.\r\n\r\nThanks!"
      }
    ],
    "satisfaction_conditions": [
      "Demonstrate that existing RxJava operators can include the triggering element in the output",
      "Clarify proper usage of operators for termination conditions",
      "Verify observable termination behavior with concrete examples",
      "Address potential misunderstandings about operator interleaving effects"
    ]
  },
  {
    "number": 5814,
    "title": "2.x: doOnTerminate addition for Single",
    "created_at": "2018-01-18T09:41:26Z",
    "closed_at": "2018-01-18T09:51:15Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5814",
    "body": "I'm using RxJava 2.1.8. I often use the `doOnTerminate` operator for Single and Completable to handle certain events but I find there's no equivalent for Single. Is that intended and, if not, can it be added?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5814/comments",
    "author": "ValCanBuild",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-01-18T09:49:22Z",
        "body": "There is no particular reason and so far many got by without it. You can use `doOnEvent`."
      },
      {
        "user": "ValCanBuild",
        "created_at": "2018-01-18T09:51:15Z",
        "body": "I just read the docs for `doOnEvent` and it does seem like what i need. Thanks!"
      }
    ],
    "satisfaction_conditions": [
      "Provides a way to handle termination events for Single in RxJava 2.x",
      "Explains how to achieve the same outcome as `doOnTerminate` using existing operators",
      "Clarifies whether the absence of `doOnTerminate` for Single was intentional"
    ]
  },
  {
    "number": 5812,
    "title": "2.x: Surprising `startWith` scheduling behaviour",
    "created_at": "2018-01-17T09:13:58Z",
    "closed_at": "2018-01-17T09:40:19Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5812",
    "body": "Android and RxJava 2.1.8:\r\n\r\nI ran into a surprising behaviour of `startWith` that I'd like to verify. I've boiled it down to a simple example:\r\n```\r\nObservable.just(Unit)\r\n                .observeOn(Schedulers.io())\r\n                .startWith(Unit)\r\n                .switchMap {\r\n                    Observable.create<Unit> { emitter ->\r\n                        Thread.sleep(5000)\r\n                        emitter.onNext(Unit)\r\n                        emitter.onComplete()\r\n                    }\r\n                }\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribe()\r\n```\r\n\r\nIn the above example, execution of the observable inside `switchMap` happens on the main scheduler and blocks my UI. \r\n\r\nI would expect that it will happen on the `io` scheduler and it does indeed, as soon as I remove `startWith`. \r\n\r\nI realise I can just add another `observeOn` after `startWith` but it's puzzling. We're already on the `io` scheduler when the `startWith` gets hit, so why would it switch threads?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5812/comments",
    "author": "Rosomack",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-01-17T09:21:54Z",
        "body": "`startWith` subscribes to its argument (constants are turned into Observable.just()) on the current thread and `observeOn` is above it, thus can't have any effect of it. Let me rewrite your code to make it more apparent:\r\n\r\n```java\r\nObservable.concat(\r\n    Observable.just(Unit),\r\n    Observable.just(Unit).observeOn(Schedulers.io())\r\n)\r\n.switchMap {\r\n       Observable.create<Unit> { emitter ->\r\n                Thread.sleep(5000)\r\n                emitter.onNext(Unit)\r\n                emitter.onComplete()\r\n       }\r\n }\r\n .observeOn(AndroidSchedulers.mainThread())\r\n .subscribe()\r\n```\r\n\r\nAs the subscription travels up, the thread hasn't changed so the first `just` will emit `Unit` on the caller thread which then goes into the blocking `switchMap`. \r\n\r\nYou can apply `subscribeOn` instead and the `switchMap` will trigger on the background thread:\r\n\r\n```java\r\nObservable.just(Unit)\r\n                .startWith(Unit)\r\n                .switchMap {\r\n                    Observable.create<Unit> { emitter ->\r\n                        Thread.sleep(5000)\r\n                        emitter.onNext(Unit)\r\n                        emitter.onComplete()\r\n                    }\r\n                }\r\n                .subscribeOn(Schedulers.io())\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribe()\r\n```\r\n\r\nor move the `observeOn` below the `startWith`:\r\n\r\n```java\r\nObservable.just(Unit)\r\n                .startWith(Unit)\r\n                .observeOn(Schedulers.io())\r\n                .switchMap {\r\n                    Observable.create<Unit> { emitter ->\r\n                        Thread.sleep(5000)\r\n                        emitter.onNext(Unit)\r\n                        emitter.onComplete()\r\n                    }\r\n                }\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribe()\r\n```"
      },
      {
        "user": "Rosomack",
        "created_at": "2018-01-17T09:32:29Z",
        "body": "Ordinarily I would use `subscribeOn`, but sadly I'm using RxBinding which requires the subscription to happen on the main thread.\r\n\r\nThanks for your complete explanation! It makes sense."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how operator order affects thread scheduling in RxJava",
      "Clarification of startWith's subscription behavior relative to observeOn",
      "Alternative approaches that respect RxBinding's main thread requirement",
      "General principles for controlling execution context in operator chains"
    ]
  },
  {
    "number": 5730,
    "title": "How to execute a flowable dependent from another?",
    "created_at": "2017-11-18T15:29:43Z",
    "closed_at": "2017-11-22T14:32:59Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5730",
    "body": "I want to chain two flowables, when the first one finishes to collect data from the network its result (an array list) must be passed to the second flowable.\r\nThe flowables update the UI as described in the scenario shown below, when an error occurs the execution is stopped.\r\n\r\nI hope to be more clear as possible adding all details about the expected result and the code I wrote\r\n\r\nThe scenario\r\n\r\n1. flowable-1 makes X network calls (X value depends on some condition COND)\r\n2. every network call returns a list of items (size can vary)\r\n3. the UI shows the count of items (eg. \"Retrieved 1 items\", \"Retrieved 5 items\")\r\n4. all calls are done (the condition COND is satisfied)\r\n5. all items collected now must post-processed by flowable-2\r\n6. the UI shows the progress (eg. 'item 1 of 9', 'item 2 of 9', ..., 'item 9 of 9')\r\n\r\nA possible expected output should be\r\n\r\n    Retrieved 1 item(s) |  \r\n    Retrieved 3 item(s) |- printed inside the doOnNext() 'called' by flowable-1\r\n    Retrieved 5 item(s) |  the array contains 9 items (1 + 3 + 5)\r\n\r\n    Item 1 of 9         |\r\n    ...                 |- printed inside the doOnNext() 'called' by flowable-2\r\n    Item 9 of 9         |\r\n      \r\n    Finished            | printed inside the subscribe()\r\n\r\n\r\nI've used Flowable.generate() to collected items from network calls\r\n\r\n```java\r\npublic Flowable<List<String>> fetchFromNetFlowable() {\r\n    offset = 0;\r\n    return Flowable.generate(new Consumer<Emitter<List<String>>>() {\r\n        @Override\r\n        public void accept(Emitter<List<String>> emitter) throws Exception {\r\n            List<String> subset = networkCall(offset);\r\n            boolean loadNext = subset.size() > 0;\r\n            offset += subset.size();\r\n\r\n            final ArrayList<String> validItems = new ArrayList<>();\r\n            for (String dummy : subset) {\r\n                if (conditionMet(dummy)) {\r\n                    validItems.add(dummy);\r\n                } else {\r\n                    loadNext = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (!validItems.isEmpty()) {\r\n                emitter.onNext(validItems);\r\n            }\r\n            if (!loadNext) {\r\n                emitter.onComplete();\r\n            }\r\n        }\r\n    });\r\n}\r\n```\r\n\r\nThe second flowable will be used to update UI from onNext() caller\r\n\r\n```java\r\npublic Flowable secondFlowable(final Iterator<String> iterator) {\r\n    return Flowable.generate((emitter) -> {\r\n        if (iterator.hasNext()) {\r\n            // do some stuff with value\r\n            emitter.onNext(iterator.next());\r\n        } else {\r\n            emitter.onComplete();\r\n        }\r\n    });\r\n}\r\n```\r\n\r\nThen I would use both flowables but I don't understard how to make the second dependent from the first one, the `processTheListCallingTheSecondFlowable()` must be called only when `fetchFromNetFlowable()` has finished\r\n\r\n```java\r\npublic readDataAndProcess() {\r\n    total = 0;\r\n    compositeDisposable.add(postRetrieverRx.readPhotoPosts(blogName)\r\n            .subscribeOn(Schedulers.io())\r\n            .observeOn(AndroidSchedulers.mainThread())\r\n            .toObservable()\r\n            .doOnNext((tumblrPost) -> {\r\n                    total += tumblrPost.size();\r\n                    System.out.println(\"Retrieved \" + total + \" items\");\r\n            })\r\n            .flatMap((posts) -> Observable.fromIterable(posts))\r\n            .toList() // <--- now I have the single list with all items\r\n            // I don't know how to do\r\n            // processTheListCallingTheSecondFlowable() isn't an rx operator\r\n            // consider it only pseudo code\r\n            .processTheListCallingTheSecondFlowable()\r\n            .subscribe((allPosts) -> System.out.println(\"Finished\")\r\n    );\r\n}\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5730/comments",
    "author": "dafi",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-11-18T15:59:12Z",
        "body": "The `flatMap` is a typical dependent continuation operator:\r\n\r\n```java\r\n    .toList()\r\n    .flatMapPublisher(list -> processTheListViaFlowable(list))\r\n    .subscribe(/* ... */);\r\n```"
      },
      {
        "user": "dafi",
        "created_at": "2017-11-18T16:34:41Z",
        "body": "Oh my God! Is it so simple?!?!\r\nI turned around flatMapXXX for two days without notice this method.\r\n\r\nThanks a lot!!"
      }
    ],
    "satisfaction_conditions": [
      "Demonstrate how to chain two Flowables where the second starts only after the first fully completes and provides its aggregated result",
      "Show proper handling of stream completion before starting dependent processing",
      "Use standard RxJava operators for continuation rather than custom implementations",
      "Maintain UI update requirements for both progress tracking phases"
    ]
  },
  {
    "number": 5727,
    "title": "[RxJava 2.1.0] Single with Cache cancellable behaviour",
    "created_at": "2017-11-15T17:52:41Z",
    "closed_at": "2017-11-16T10:32:56Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5727",
    "body": "Hi,\r\nI'm using `Single` in the following way,\r\n\r\n           val bleConnection = Single.create({  \r\n             emitter -> // Do some one-time bluetooth connection operation and emit ble connection\r\n             emitter.setCancellable { \r\n                    // close the ble connection as this single is unsubscribed\r\n             }\r\n           }).cache()\r\n\r\n\r\nNow I expected `setCancellable` block to run when all the subscribers are disposed. But that block gets called on `onSuccess` or `onError`. So `Single` terminates itself when either success or error happens. But I want to run some cleanup operation when all my subscribers are disposed. How would I do that with `Single`? This can be easily achieved with `Flowable` or `Observable`. But this is essentially `Single` operation (Not a stream, just an one-time connection value). So I thought `Single` is the correct operator to use in this case.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5727/comments",
    "author": "BharathMG",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-11-15T18:04:36Z",
        "body": "This is not supported by `Single`. You have to use `Observable.create()`, `share()` and `singleOrError()` to have the final type `Single`. A longer path is similar, given the current `cache()`, convert it via `toObservable()`, `share()` and then `singleOrError()` back."
      },
      {
        "user": "BharathMG",
        "created_at": "2017-11-16T05:57:13Z",
        "body": "Sure, but another problem with `cache()` is,\r\n\r\n         val single = Single.create<Boolean>({ emitter ->\r\n         emitter.setCancellable {\r\n              println(\"CANCELLED\")\r\n          }\r\n        }).cache()\r\n\r\n        val test1 = single.subscribe()\r\n        val test2 = single.subscribe()\r\n        val test3 = single.subscribe()\r\n\r\n        test1.dispose()\r\n        test2.dispose()\r\n        test3.dispose()\r\n\r\n        println(\"ALL DISPOSED\")\r\n\r\nHere CANCELLED will not be printed as desired. It waits for `Single` to emit some value before cancelling and not for disposal. Is this intended?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-11-16T08:27:00Z",
        "body": "You have to do it through `Observable` as I described:\r\n\r\n```java\r\nvar single = Observable.create(emitter -> {\r\n    emitter.setCancellable(() -> System.out.println(\"Cancelled\"));\r\n})\r\n.replay()\r\n.refCount()\r\n.singleOrError();\r\n```"
      }
    ],
    "satisfaction_conditions": [
      "Solution must trigger cleanup when all subscribers are disposed, not when the Single terminates",
      "Maintain Single semantics for one-time operations",
      "Support multiple subscribers with shared execution",
      "Avoid premature cancellation before disposal"
    ]
  },
  {
    "number": 5610,
    "title": "how to retry when subscriber error ?",
    "created_at": "2017-09-20T11:59:51Z",
    "closed_at": "2017-09-21T07:34:56Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5610",
    "body": "```java\r\n\r\n          final int[] a = {0};\r\n            Observable.interval(1, TimeUnit.SECONDS).retry(new Predicate<Throwable>() {\r\n                @Override\r\n                public boolean test(Throwable throwable) throws Exception {\r\n                    a[0]=0;\r\n                    System.out.println(\" reset Observable\");\r\n                    return true;\r\n                }\r\n            }).subscribe(new io.reactivex.functions.Consumer<Long>() {\r\n                @Override\r\n                public void accept(Long aLong) throws Exception {\r\n                    a[0]++;\r\n                    System.out.println(a[0]+\"=====\"+System.currentTimeMillis());\r\n                    if (a[0] >5){\r\n                        /*\r\n                        *  it will throw error  i want to retry\r\n                        * */\r\n                        System.out.println(\"a[2] = \" + a[2]);\r\n                    }\r\n                }\r\n            }, new io.reactivex.functions.Consumer<Throwable>() {\r\n                @Override\r\n                public void accept(Throwable throwable) throws Exception {\r\n                    System.out.println(\"e.getLocalizedMessage() = \" + throwable.getLocalizedMessage());\r\n                    a[0]=0;\r\n                }\r\n            });\r\n```\r\n\r\nthis is my log \r\n\r\n```\r\n1=====1505908635697\r\n2=====1505908636687\r\n3=====1505908637684\r\n4=====1505908638684\r\n5=====1505908639684\r\n6=====1505908640684\r\ne.getLocalizedMessage() = 2\r\n```\r\nIf the consumer throws an error, this wording can not be retried? If  i  want to try again, what should I do?\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5610/comments",
    "author": "AllenCoder",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-09-20T12:09:46Z",
        "body": "`retry` can only deal with errors upstream to it. You have to reorganize your flow in a way that the operation that may throw happens before `retry`:\r\n\r\n```java\r\nObservable.interval(1, TimeUnit.SECONDS)\r\n.doOnNext(v -> {\r\n   /* your potentially crashing code here */\r\n})\r\n.retry(e -> true)\r\n.subscribe(v -> { /* non-crashing code here */ }, e -> { /* ... */ }}\r\n```"
      },
      {
        "user": "AllenCoder",
        "created_at": "2017-09-21T01:39:01Z",
        "body": "thank you very much!"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-09-21T07:34:56Z",
        "body": "Great!"
      },
      {
        "user": "TomasThibaut",
        "created_at": "2019-08-13T07:34:09Z",
        "body": "But is there anyway to retry error on downstreams like ``` subscribe() ```,cuz if error happens here, it'll be catch by error callback in ```subscribe()``` and interrupt the whole steam?"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of error propagation boundaries in RxJava operator chains",
      "Strategy to handle errors occurring in subscriber callbacks",
      "Pattern for isolating error-prone operations upstream of retry",
      "Clarification of retry operator's scope of influence"
    ]
  },
  {
    "number": 5591,
    "title": "Caused by: java.lang.NullPointerException                                                                             at io.reactivex.internal.operators.observable.ObservableConcatMap$SourceObserver.onNext(ObservableConcatMap.java:128)",
    "created_at": "2017-09-07T02:59:13Z",
    "closed_at": "2017-09-07T07:40:29Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5591",
    "body": "```java\r\npublic class BluetoothActivity extends AppCompatActivity {\r\n   @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_bluetooth);\r\n        Observable.just(\"a\")\r\n                .concatMap(b->getResponse(b))\r\n                .concatMap(b->getResponse(b))\r\n                .subscribe(new Consumer<Object>() {\r\n                    @Override\r\n                    public void accept(Object o) throws Exception {\r\n                    }\r\n\r\n                }, new Consumer<Throwable>() {\r\n                    @Override\r\n                    public void accept(Throwable throwable) throws Exception {\r\n                    }\r\n                });\r\n}\r\npublic Observable<Object> getResponse(Object o){\r\n        Log.d(\"program\",\"getResponse():\"+o.toString());\r\n        return new Observable<Object>() {\r\n            @Override\r\n            protected void subscribeActual(Observer<? super Object> observer) {\r\n                observer.onNext(\"b\");\r\n                observer.onComplete();\r\n            }\r\n\r\n        };\r\n    }\r\n}\r\n```\r\n\r\nLog:\r\n```\r\n09-06 18:55:58.312 20589-20589/? E/dalvikvm: /system/framework/pm.jar odex has stale dependencies\r\n09-06 18:55:58.472 20589-20589/? E/memtrack: Couldn't load memtrack module (No such file or directory)\r\n09-06 18:55:58.472 20589-20589/? E/android.os.Debug: failed to load memtrack module: -2\r\n09-06 18:55:58.632 1478-20601/? E/ActivityThread: Failed to find provider info for com.leadcore.sdb\r\n09-06 18:56:06.622 20618-20618/? E/dalvikvm: /system/framework/am.jar odex has stale dependencies\r\n09-06 18:56:06.832 20618-20618/? E/memtrack: Couldn't load memtrack module (No such file or directory)\r\n09-06 18:56:06.832 20618-20618/? E/android.os.Debug: failed to load memtrack module: -2\r\n09-06 18:56:09.082 20638-20638/com.example.z.myplayer E/dalvikvm: Could not find class 'android.graphics.drawable.RippleDrawable', referenced from method android.support.v7.widget.AppCompatImageHelper.hasOverlappingRendering\r\n09-06 18:56:09.252 20638-20638/com.example.z.myplayer E/AndroidRuntime: FATAL EXCEPTION: main\r\n                                                                        Process: com.example.z.myplayer, PID: 20638\r\n                                                                        java.lang.RuntimeException: Unable to start activity ComponentInfo{com.example.z.myplayer/com.example.z.myplayer.BluetoothActivity}: java.lang.NullPointerException\r\n                                                                            at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2209)\r\n                                                                            at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2258)\r\n                                                                            at android.app.ActivityThread.access$800(ActivityThread.java:147)\r\n                                                                            at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1211)\r\n                                                                            at android.os.Handler.dispatchMessage(Handler.java:102)\r\n                                                                            at android.os.Looper.loop(Looper.java:136)\r\n                                                                            at android.app.ActivityThread.main(ActivityThread.java:5135)\r\n                                                                            at java.lang.reflect.Method.invokeNative(Native Method)\r\n                                                                            at java.lang.reflect.Method.invoke(Method.java:515)\r\n                                                                            at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:798)\r\n                                                                            at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:614)\r\n                                                                            at dalvik.system.NativeStart.main(Native Method)\r\n                                                                         Caused by: java.lang.NullPointerException\r\n                                                                            at io.reactivex.internal.operators.observable.ObservableConcatMap$SourceObserver.onNext(ObservableConcatMap.java:128)\r\n                                                                            at com.example.z.myplayer.BluetoothActivity$5.subscribeActual(BluetoothActivity.java:170)\r\n                                                                            at io.reactivex.Observable.subscribe(Observable.java:10903)\r\n                                                                            at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarXMapObservable.subscribeActual(ObservableScalarXMap.java:166)\r\n                                                                            at io.reactivex.Observable.subscribe(Observable.java:10903)\r\n                                                                            at io.reactivex.internal.operators.observable.ObservableConcatMap.subscribeActual(ObservableConcatMap.java:52)\r\n                                                                            at io.reactivex.Observable.subscribe(Observable.java:10903)\r\n                                                                            at io.reactivex.Observable.subscribe(Observable.java:10889)\r\n                                                                            at io.reactivex.Observable.subscribe(Observable.java:10818)\r\n                                                                            at com.example.z.myplayer.BluetoothActivity.onCreate(BluetoothActivity.java:79)\r\n                                                                            at android.app.Activity.performCreate(Activity.java:5356)\r\n                                                                            at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1087)\r\n                                                                            at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2163)\r\n                                                                            at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2258)\u00a0\r\n                                                                            at android.app.ActivityThread.access$800(ActivityThread.java:147)\u00a0\r\n                                                                            at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1211)\u00a0\r\n                                                                            at android.os.Handler.dispatchMessage(Handler.java:102)\u00a0\r\n                                                                            at android.os.Looper.loop(Looper.java:136)\u00a0\r\n                                                                            at android.app.ActivityThread.main(ActivityThread.java:5135)\u00a0\r\n                                                                            at java.lang.reflect.Method.invokeNative(Native Method)\u00a0\r\n                                                                            at java.lang.reflect.Method.invoke(Method.java:515)\u00a0\r\n                                                                            at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:798)\u00a0\r\n                                                                            at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:614)\u00a0\r\n                                                                            at dalvik.system.NativeStart.main(Native Method)\u00a0\r\n09-06 18:56:09.402 1478-20662/? E/ActivityThread: Failed to find provider info for com.leadcore.sdb\r\n09-06 18:56:09.662 20660-20660/? E/dalvikvm: /system/framework/am.jar odex has stale dependencies\r\n09-06 18:56:09.822 20660-20660/? E/memtrack: Couldn't load memtrack module (No such file or directory)\r\n09-06 18:56:09.822 20660-20660/? E/android.os.Debug: failed to load memtrack module: -2\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5591/comments",
    "author": "youngonlyforyou",
    "comments": [
      {
        "user": "youngonlyforyou",
        "created_at": "2017-09-07T03:00:43Z",
        "body": "activity crash ..............app crash .........."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-09-07T07:39:35Z",
        "body": "The problem is that you use `new Observable()` where you should follow the observable protocol and call `onSubscribe`:\r\n\r\n```java\r\npublic Observable<Object> getResponse(Object o){\r\n        Log.d(\"program\",\"getResponse():\"+o.toString());\r\n        return new Observable<Object>() {\r\n```\r\n\r\nYou should use `Observable.create()`  instead:\r\n\r\n```java\r\npublic Observable<Object> getResponse(Object o){\r\n    Log.d(\"program\",\"getResponse():\"+o.toString());\r\n    return Observable.<Object>create(new ObservableOnSubscribe<Object>() {\r\n        @Override \r\n        public void subscribe(ObservableEmitter<Object> observer) {\r\n             observer.onNext(\"b\");\r\n             observer.onComplete();\r\n        }\r\n    });\r\n```"
      },
      {
        "user": "youngonlyforyou",
        "created_at": "2017-09-07T16:31:24Z",
        "body": "thx very much ,my friend. I have solved the problem      \uff1a\uff09   \uff1a\uff09"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of proper Observable creation in RxJava",
      "Identification of missing Observable protocol requirements"
    ]
  },
  {
    "number": 5588,
    "title": "ConnectableObservable.connect() causes NetworkOnMainThreadException",
    "created_at": "2017-09-06T15:02:52Z",
    "closed_at": "2017-09-14T14:25:23Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5588",
    "body": "## Versions \r\nRxJava: 2.1.0\r\nRxAndroid: 2.0.1\r\n\r\n## Issue\r\nI'm using the following pattern to allow me to share the result of an expensive network call across two observables, which both transform the result in different ways:\r\n\r\n```java\r\nConnectableObservable<Model> connectableObservable = doExpensiveNetworkCall().publish();\r\n\r\n// Transform in one way.\r\nconnectableObservable\r\n    .filter(...)\r\n    .subscribeOn(mDataManager.getScheduler())\r\n    .observeOn(AndroidSchedulers.mainThread())\r\n    .subscribe(...);\r\n\r\n// Transform in another.\r\nconnectableObservable\r\n    .filter(....)\r\n    .subscribeOn(mDataManager.getScheduler())\r\n    .observeOn(AndroidSchedulers.mainThread())\r\n    .subscribe(...);\r\n\r\n// And connect... Uh oh,  NetworkOnMainThreadException!\r\nconnectableObservable.connect();\r\n```\r\n\r\nThis is a very useful pattern, however, calling `.connect()` causes `NetworkOnMainThreadException` as the expensive network call is then run on the *main thread*, despite all subscribers of the downstream observables being on a separate thread.\r\n\r\nIs there an equivalent of `.connectOn()` or another alternative which can be used to also let the ConnectableObservable know that it should be run on a different thread? Alternatively, if there's a better way of achieving the above, any guidance would be much appreciated!",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5588/comments",
    "author": "DCRichards",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-09-14T14:25:23Z",
        "body": "`publish` turns the cold source into a hot one, similar to a `PublishSubject`, and `subscribeOn` has no practical effect on hot publish-like sources. In other terms, applying `subscribeOn` after the `ConnectableObservable` has no effect. You have to apply `subscribeOn` before the publishing:\r\n\r\n```java\r\nConnectableObservable<Model> connectableObservable = doExpensiveNetworkCall()\r\n    .subscribeOn(mDataManager.getScheduler())                  // <------------------------------\r\n    .publish();\r\n\r\n// Transform in one way.\r\nconnectableObservable\r\n    .filter(...)\r\n    .observeOn(AndroidSchedulers.mainThread())\r\n    .subscribe(...);\r\n```\n\n---\n\nLooks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      },
      {
        "user": "DCRichards",
        "created_at": "2017-09-14T14:52:01Z",
        "body": "Thank you @akarnokd, that was exactly what I needed, had a bit of a wood from the trees moment. Sorted \ud83d\udc4c"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why subscribeOn placement affects thread execution for ConnectableObservable sources",
      "Guidance on proper operator ordering to control threading in RxJava pipelines",
      "Solution ensuring network operation executes on background thread while maintaining shared observable pattern",
      "Clarification about hot vs cold observables in threading context"
    ]
  },
  {
    "number": 5583,
    "title": "how to subscribe BiConsumer with 2.x",
    "created_at": "2017-09-04T10:05:34Z",
    "closed_at": "2017-09-05T01:33:31Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5583",
    "body": "Hi,\r\n\r\nHow can I subscribe BiConsumer just like subscribe Consumer?\r\n code like this:\r\n\r\n```java\r\nBiConsumer<Integer, String> biConsumer = new BiConsumer<Integer, String>() {\r\n\r\n            @Override\r\n            public void accept(Integer integer, String s) throws Exception {\r\n\r\n            }\r\n        };\r\nObservable.create().subscribe(biConsumer);\r\n```       \r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5583/comments",
    "author": "TxShon",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-09-04T10:14:55Z",
        "body": "That is not possible with RxJava. You have to combine data elements into classes or tuples."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how to handle two separate data elements in RxJava 2.x subscription",
      "Compatibility with RxJava 2.x architecture constraints",
      "Demonstration of data combination patterns",
      "Alternative to BiConsumer interface for multi-parameter handling"
    ]
  },
  {
    "number": 5562,
    "title": "in this case subscribe onNext not working",
    "created_at": "2017-08-23T03:47:21Z",
    "closed_at": "2017-08-26T10:38:24Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5562",
    "body": "Thanks for using RxJava but before you post an issue, please consider the following points:\r\n\r\nhere is my retrofit and rxjava version\uff1a\r\n\r\n    //rx\r\n    compile 'io.reactivex.rxjava2:rxjava:2.0.3'\r\n    compile 'io.reactivex.rxjava2:rxandroid:2.0.1'\r\n    //retrofit\r\n    compile 'com.squareup.retrofit2:retrofit:2.2.0'\r\n    compile 'com.squareup.retrofit2:converter-gson:2.0.2'\r\n    compile 'com.squareup.retrofit2:adapter-rxjava2:2.2.0'\r\n    //okhttp3\r\n    compile 'com.squareup.okhttp3:okhttp:3.4.1'\r\n    compile 'com.squareup.okhttp3:logging-interceptor:3.4.1'\r\n    compile 'com.squareup.okio:okio:1.6.0'\r\n\r\n retrofit like this\r\n`    @GET(\"getAppList\")\r\n    Flowable<EBApiResult<List<UserAppInfo>>> testGetUserApp();`\r\n\r\nrxjava like this\r\n\r\n`          Flowable<EBApiResult<List<UserAppInfo>>>  flowable = testGetAppInfos();`\r\n\r\n        flowable.map(new Function<EBApiResult<List<UserAppInfo>>, List<UserAppInfo>>() {\r\n\r\n            @Override\r\n            public List<UserAppInfo> apply(EBApiResult<List<UserAppInfo>> result) throws Exception {\r\n                return result.getResultData();\r\n            }\r\n        }).subscribeOn(Schedulers.io())\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribe(new Subscriber<List<UserAppInfo>>() {\r\n                    @Override\r\n                    public void onSubscribe(Subscription s) {\r\n                        Log.i(\"123\");\r\n                    }\r\n\r\n                    @Override\r\n                    public void onNext(List<UserAppInfo> userAppInfos) {\r\n                        uiPresenter.bindAppInfoList(result);\r\n                    }\r\n\r\n                    @Override\r\n                    public void onError(Throwable t) {\r\n                        uiPresenter.errPage(t.getMessage());\r\n                    }\r\n\r\n                    @Override\r\n                    public void onComplete() {\r\n                        uiPresenter.errPage(null);\r\n                    }\r\n                });`\r\n\r\nI can see that onSubscribe is called back\r\nbut onNext onError is not\u3002\r\n\r\nIf I call rxjava like this\r\n\r\n`          Flowable<EBApiResult<List<UserAppInfo>>>  flowable = testGetAppInfos();`\r\n\r\n      flowable.map(new Function<EBApiResult<List<UserAppInfo>>, List<UserAppInfo>>() {\r\n\r\n            @Override\r\n            public List<UserAppInfo> apply(EBApiResult<List<UserAppInfo>> result) throws Exception {\r\n                return result.getResultData();\r\n            }\r\n        }).subscribeOn(Schedulers.io())\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribe(new Consumer<List<UserAppInfo>>() {\r\n                    @Override\r\n                    public void accept(List<UserAppInfo> appInfos) throws Exception {\r\n                        storeAppInfos(appInfos);\r\n                        List<UserAppInfo> result = filterListByCurrentCondition(appInfos, CURRENT_NEED_SHOW_APPS);\r\n                        uiPresenter.bindAppInfoList(result);\r\n                    }\r\n                }, new Consumer<Throwable>() {\r\n                    @Override\r\n                    public void accept(Throwable t) throws Exception {\r\n                        uiPresenter.errPage(t.getMessage());\r\n                    }\r\n                }, new Action() {\r\n                    @Override\r\n                    public void run() throws Exception {\r\n                    }\r\n                });`\r\n\r\nevery accept can be reached\r\ni dont know why\u3002\r\nbut i debug with source\uff0cI doubt it because...my Flowable\u2018s implementation is not QueueSubscription\u3002\r\n\r\nI don't know how to fix my problem. I hope you can understand",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5562/comments",
    "author": "neodreamtale",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-08-23T10:05:48Z",
        "body": "You have to call `s.request(Long.MAX_VALUE)` in the first case where you have `Log.i(\"123\")`."
      },
      {
        "user": "neodreamtale",
        "created_at": "2017-08-25T06:53:43Z",
        "body": "@akarnokd thank you \r\nBecause of the language barrier, I didn't know how to use it before\u3002After your prompt, I went to the relevant documents\u3002it's working\uff0cthankyou\uff01"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why Subscriber's onNext/onError aren't called when using Subscriber interface but work with separate Consumer callbacks",
      "Identification of missing backpressure management requirement in Subscriber implementation",
      "Clarification of differences between Subscriber implementations and Consumer-based subscribe() overloads",
      "Documentation reference for Flowable subscription requirements"
    ]
  },
  {
    "number": 5534,
    "title": " [1.2.0]Caused by: rx.exceptions.OnErrorNotImplementedException: HTTP 500 Internal Server Error",
    "created_at": "2017-08-03T09:41:38Z",
    "closed_at": "2017-08-03T10:32:12Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5534",
    "body": "when i use retrofit+rxjava+rxCalladapter,  foud error  here :\r\n\r\n```\r\n08-03 17:12:50.864 18778-18809/com.xuebansoft.xinghuo.manager E/AndroidRuntime: FATAL EXCEPTION: RxIoScheduler-2\r\nProcess: com.xuebansoft.xinghuo.manager, PID: 18778\r\njava.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.\r\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:57)\r\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\r\n    at java.util.concurrent.FutureTask.run(FutureTask.java:237)\r\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\r\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\r\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\r\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\r\n    at java.lang.Thread.run(Thread.java:841)\r\n Caused by: rx.exceptions.OnErrorNotImplementedException: HTTP 500 Internal Server Error\r\n    at rx.internal.util.InternalObservableUtils$ErrorNotImplementedAction.call(InternalObservableUtils.java:386)\r\n    at rx.internal.util.InternalObservableUtils$ErrorNotImplementedAction.call(InternalObservableUtils.java:383)\r\n    at rx.internal.util.ActionSubscriber.onError(ActionSubscriber.java:44)\r\n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:152)\r\n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:115)\r\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.checkTerminated(OperatorObserveOn.java:276)\r\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:219)\r\n    at rx.internal.schedulers.CachedThreadScheduler$EventLoopWorker$1.call(CachedThreadScheduler.java:228)\r\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\r\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\u00a0\r\n    at java.util.concurrent.FutureTask.run(FutureTask.java:237)\u00a0\r\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\u00a0\r\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\u00a0\r\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\u00a0\r\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\u00a0\r\n    at java.lang.Thread.run(Thread.java:841)\u00a0\r\n Caused by: retrofit2.adapter.rxjava.HttpException: HTTP 500 Internal Server Error\r\n    at retrofit2.adapter.rxjava.BodyOnSubscribe$BodySubscriber.onNext(BodyOnSubscribe.java:51)\r\n    at retrofit2.adapter.rxjava.BodyOnSubscribe$BodySubscriber.onNext(BodyOnSubscribe.java:36)\r\n    at retrofit2.adapter.rxjava.CallArbiter.deliverResponse(CallArbiter.java:115)\r\n    at retrofit2.adapter.rxjava.CallArbiter.emitResponse(CallArbiter.java:97)\r\n    at retrofit2.adapter.rxjava.CallExecuteOnSubscribe.call(CallExecuteOnSubscribe.java:46)\r\n    at retrofit2.adapter.rxjava.CallExecuteOnSubscribe.call(CallExecuteOnSubscribe.java:24)\r\n    at retrofit2.adapter.rxjava.BodyOnSubscribe.call(BodyOnSubscribe.java:33)\r\n    at retrofit2.adapter.rxjava.BodyOnSubscribe.call(BodyOnSubscribe.java:25)\r\n    at rx.Observable.unsafeSubscribe(Observable.java:10151)\r\n    at rx.internal.operators.OperatorSubscribeOn$1.call(OperatorSubscribeOn.java:94)\r\n    at rx.internal.schedulers.CachedThreadScheduler$EventLoopWorker$1.call(CachedThreadScheduler.java:228)\u00a0\r\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\u00a0\r\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\u00a0\r\n    at java.util.concurrent.FutureTask.run(FutureTask.java:237)\u00a0\r\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\u00a0\r\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\u00a0\r\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\u00a0\r\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\u00a0\r\n    at java.lang.Thread.run(Thread.java:841)\u00a0\r\n```\r\n\r\nand  the running code is here:\r\n\r\n```java\r\n    ManagerApi.getIns().updateChannelInfoForMobileUser(AppHelper.getIUser().getMobileUserId(), ((XhEvent.BindEvent) event).getmChannelId(), ((XhEvent.BindEvent) event).getmUserId())\r\n                                .subscribeOn(Schedulers.io()).observeOn(Schedulers.io()).subscribe(new Action1<EduCommResponse>() {\r\n                            @Override\r\n                            public void call(EduCommResponse eduCommResponse) {\r\n                                if (eduCommResponse.isSuccess()) {\r\n                                    RememberMe.get().devBindedUser();\r\n                                }\r\n                            }\r\n                        });\r\n```\r\nwhen the http response code is 500 ,will throw this error",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5534/comments",
    "author": "pMotato",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-08-03T09:57:18Z",
        "body": "The key message is:\r\n\r\n> Add onError handling.\r\n\r\ni.e., use `subscribe(Action1<T>, Action1<Throwable>)` at least."
      },
      {
        "user": "pMotato",
        "created_at": "2017-08-03T10:14:17Z",
        "body": "awesome!!!thks"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of proper error handling for HTTP 500 responses in RxJava+Retrofit subscriptions",
      "Demonstration of RxJava subscription that includes both success and error callbacks",
      "Clarification about RxJava's requirement to handle all error paths",
      "Guidance on handling non-2xx HTTP responses in Retrofit+RxJava integration"
    ]
  },
  {
    "number": 5532,
    "title": "RxJava 2 and async subscriber",
    "created_at": "2017-08-02T17:16:46Z",
    "closed_at": "2017-08-03T05:55:57Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5532",
    "body": "Hi, I am using RxJava 2.1.2 and found recently sample code that worked in RxJava 1.x but seems to work differently in RxJava 2.\r\nWhen I execute the code below I assume that each \"subscribe\" code will be run in new thread. However it is run in new but the same thread \"RxNewThreadScheduler-1\". I assume that Schedulers.io() should create a new thread per each long-running task. Please advice.\r\n\r\n```java\r\npublic class SampleRx {\r\n\tpublic static void main(String[] args) throws Exception {\r\n\t\tObservable.fromArray(\"1\", \"2\", \"3\")\r\n\t\t\t.observeOn(Schedulers.io())\r\n\t\t\t.subscribe(item -> { \r\n\t\t\t\tSystem.out.println(\r\n\t\t\t\t\t\tThread.currentThread().getName());\r\n\t\t\tThread.sleep(2000); });\r\n\t\tThread.sleep(7000);\r\n\t}\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5532/comments",
    "author": "sergey-morenets",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-08-02T18:02:32Z",
        "body": "`Schedulers.io()` reuses threads so if there is a small delay after a flow terminates, the same thread will appear to serve the next flow. This behavior should be the same for both v1 and v2. Your sample code has one flow so it can't show any effects of multiple flows. Could you clarify it?"
      },
      {
        "user": "sergey-morenets",
        "created_at": "2017-08-02T18:19:32Z",
        "body": "Hi @akarnokd \r\n\r\nYes, it's strange but it seems to work the same way in 1.x.\r\nCan you advise then how to to modify the original code so that each subscribe method will be invoked in the separate thread ?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-08-02T18:22:58Z",
        "body": "There is the `Schedulers.newThread` for that."
      },
      {
        "user": "sergey-morenets",
        "created_at": "2017-08-02T18:31:29Z",
        "body": "Thank you, @akarnokd \r\n\r\nDo you mean this code? Unfortunately it still uses one thread \"RxNewThreadScheduler-1\"\r\n\r\n```java\r\n\t\tObservable.fromArray(\"1\", \"2\", \"3\")\r\n\t\t\t.observeOn(Schedulers.newThread())\r\n\t\t\t.subscribe(item -> { \r\n\t\t\t\tSystem.out.println(\r\n\t\t\t\t\t\tThread.currentThread().getName());\r\n\t\t\tThread.sleep(2000); });\r\n\t\tThread.sleep(7000);\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-08-02T19:27:46Z",
        "body": "It's unclear to me how do you expect multiple threads when subscribing once?\r\n\r\nTry this:\r\n\r\n```java\r\nObservable<String> source = \r\n    Observable.fromArray(\"1\", \"2\", \"3\")\r\n    .observeOn(Schedulers.newThread());\r\n\r\nsource.subscribe(v -> System.out.println(Thread.currentThread().getName()));\r\n\r\nsource.subscribe(v -> System.out.println(Thread.currentThread().getName()));\r\n\r\nThread.sleep(10000);\r\n```\r\n\r\nor this:\r\n\r\n```java\r\nObservable.fromArray(\"1\", \"2\", \"3\")\r\n  .flatMap(v -> \r\n    Observable.just(v)\r\n       .subscribeOn(Schedulers.newThread())\r\n       .map(v -> Thread.currentThread().getName())\r\n  )\r\n  .subscribe(System.out::println);\r\n\r\nThread.sleep(10000);\r\n```"
      },
      {
        "user": "sergey-morenets",
        "created_at": "2017-08-03T05:55:57Z",
        "body": "Thank you, @akarnokd \r\n\r\nIt works perfectly."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how to ensure each subscription runs in a separate thread",
      "Clarification of Observable chain structure requirements for concurrent execution",
      "Differentiation between Schedulers.io() and Schedulers.newThread() behavior",
      "Demonstration of proper concurrency patterns in RxJava 2.x"
    ]
  },
  {
    "number": 5510,
    "title": "Why doOnComplete / doOnSubscribe / subscribe not called?",
    "created_at": "2017-07-20T21:45:45Z",
    "closed_at": "2017-07-20T21:59:44Z",
    "labels": [
      "Question",
      "Kotlin"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5510",
    "body": "Why are `doOnComplete`, `doOnSubscribe` (and also `doFinally`) not called?\r\n\r\n```kotlin\r\n//    val obs = createObservable()\r\nval obs = createCompletable()\r\n\r\n@JvmStatic fun main(args: Array<String>) {\r\n\r\n    obs.doOnSubscribe {\r\n        println(\"on subscribe!\")\r\n    }\r\n\r\n    obs.doOnComplete {\r\n        println(\"complete!\")\r\n    }\r\n\r\n    obs.doFinally{\r\n        println(\"dofinally!\")\r\n    }\r\n\r\n    obs.subscribe{\r\n        println(\"subscribe\")\r\n    }\r\n}\r\n\r\nfun createCompletable(): Completable =\r\n    Completable.create{ emitter ->\r\n        println(\"calling oncomplete\")\r\n        emitter.onComplete()\r\n    }\r\n\r\nfun createObservable(): Observable<Void> =\r\n    Observable.create<Void> { emitter ->\r\n        println(\"calling oncomplete\")\r\n        emitter.onComplete()\r\n    }\r\n```\r\n\r\nAlso, the subscribe block is called only when using `Completable`, with `Observable<Void>` this is also not called, why?\r\n\r\nIt seems that I'm missing something basic but not being able to figure out exactly what it is. \r\n\r\nI assume that the reason `subscribe` is not called when using the observable, is that this reacts only to `onNext` (?), but why isn't `doOnComplete` called either?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5510/comments",
    "author": "ivnsch",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-07-20T21:53:44Z",
        "body": "The methods on the base reactive types return a new instance which you have to subscribe to or continue chaining:\r\n\r\n```kotlin\r\ncreateCompletable()\r\n.doOnSubscribe {\r\n        println(\"on subscribe!\")\r\n}\r\n.doOnComplete {\r\n        println(\"complete!\")\r\n}\r\n.doFinally {\r\n        println(\"dofinally!\")\r\n}\r\n.subscribe{\r\n        println(\"success\")\r\n}\r\n```\r\n"
      },
      {
        "user": "ivnsch",
        "created_at": "2017-07-20T21:59:36Z",
        "body": "Ah, my bad! I thought these could be attached anywhere and it would somehow just work. Thanks!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how operator chaining works in reactive programming",
      "Clarification of Observable vs Completable completion semantics",
      "Demonstration of proper subscription to operator-modified instances"
    ]
  },
  {
    "number": 5496,
    "title": "Merge works not as expected",
    "created_at": "2017-07-18T12:31:19Z",
    "closed_at": "2017-07-18T12:57:14Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5496",
    "body": "The operator merge not work as expected.\r\nVersion: 2.1.0\r\n```java\r\n    public static void main(String[] args){\r\n\r\n        Observable<Integer> i = Observable.create((ObservableEmitter<Integer> e) -> {\r\n            throw new RuntimeException(\"h1\");\r\n        }).subscribeOn(Schedulers.io());\r\n\r\n        Observable<Integer> i2 = Observable.create((ObservableEmitter<Integer> e) -> {\r\n            throw new RuntimeException(\"h2\");\r\n        }).subscribeOn(Schedulers.io());\r\n\r\n        Observable.merge(i, i2)\r\n                .subscribeOn(Schedulers.io())\r\n                .subscribe(\r\n                        integer -> {\r\n                            System.out.println(\"integer = \" + integer);\r\n                        },\r\n                        throwable -> {\r\n                            System.out.println(\"throwable = \" + throwable);\r\n                        });\r\n\r\n        try {\r\n            Thread.sleep(20 * 1000);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n```\r\n\r\nIf I remove `i`, `i2` subscribeOn operator. It works fine.\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5496/comments",
    "author": "gengjiawen",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-07-18T12:39:51Z",
        "body": "I don't see how you have any expectation about this setup or how you'd define \"doesn't work\" in this context."
      },
      {
        "user": "gengjiawen",
        "created_at": "2017-07-18T12:46:25Z",
        "body": "It crash.I expect it will deal with the first stream error occured, kill other stream."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-07-18T12:52:56Z",
        "body": "This setup behaves correctly because you race the emission of two errors due to `subscribeOn` on two independent threads. There are a couple of outcomes possible and legal:\r\n\r\n- h1 wins and cancels i2, no h2 emission\r\n- h2 wins and cancels i, no h1 emission\r\n- h1 wins but h2 reaches the merge and a composite exception is formed\r\n- h2 wins but h1 reaches the merge and a composite exception is formed\r\n- h1 wins but h2 reaches the merge and gets routed to the global error handler\r\n- h2 wins but h1 reaches the merge and gets routed to the global error handler\r\n- h1 wins and i2 is cancelled just before trying to signal h2, which then gets routed to the global error handler\r\n- h2 wins and i is cancelled just before trying to signal h1, which then gets routed to the global error handler"
      },
      {
        "user": "gengjiawen",
        "created_at": "2017-07-18T12:57:08Z",
        "body": "thanks, it's very clear."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how concurrent error handling works with merged Observables",
      "Clarification of Observable.merge's error propagation behavior with concurrent sources",
      "Description of possible legal outcomes when merging concurrent error-throwing Observables",
      "Explanation of how subscribeOn affects error propagation timing in merged streams"
    ]
  },
  {
    "number": 5446,
    "title": "2.x: #delay() operator emits items non-deterministically",
    "created_at": "2017-06-26T22:44:48Z",
    "closed_at": "2017-06-27T18:09:22Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5446",
    "body": "I am using RxJava 2.1.0.\r\n\r\n**tl;dr: I think this is a real issue because sometimes the test case is single-threaded (as expected), but sometimes it is multi-threaded. This non-determinism seems problematic.**\r\n\r\nI had a flaky test in my test suite. I have boiled it down to the following reproducible (failing) test case:\r\n\r\n```java\r\n    @Test\r\n    public void test() throws Exception {\r\n        // Looping to demonstrate flakiness\r\n        for (int i = 0; i < 10; i++) {\r\n            Single<String> source = Single.create(new ErrorsProvider());\r\n\r\n            source.observeOn(Schedulers.trampoline()) // Schedulers.io() in production\r\n                    .retryWhen(delayedRetry())\r\n                    .test()\r\n                    .assertResult(\"Success\");\r\n        }\r\n    }\r\n\r\n    private static class ErrorsProvider implements SingleOnSubscribe<String> {\r\n\r\n        private AtomicInteger count = new AtomicInteger(0);\r\n\r\n        @Override public void subscribe(@NonNull SingleEmitter<String> e) throws Exception {\r\n            if (count.getAndIncrement() == 0) {\r\n                e.onError(new Throwable(\"fail\"));\r\n            } else {\r\n                e.onSuccess(\"Success\");\r\n            }\r\n        }\r\n    }\r\n\r\n    private static Function<Flowable<Throwable>, Publisher<?>> delayedRetry() {\r\n        return errors -> errors.flatMap(error -> {\r\n            if (error.getMessage().equals(\"fail\")) {\r\n                // This delay would be non-zero in production but set to 0 during test runs\r\n                return Flowable.just(0).delay(0, TimeUnit.SECONDS);\r\n            }\r\n            return Flowable.error(error);\r\n        });\r\n    }\r\n```\r\n\r\nI would expect this test to pass 100% of the time, but instead it fails every time I run it inside this loop. More to the point, even with 1 iteration, it'll fail on CI regularly.\r\n\r\nI have modified my test like so to workaround the issue:\r\n\r\n```java\r\n            Single<String> source = Single.create(new ErrorsProvider());\r\n\r\n            source.observeOn(Schedulers.trampoline())\r\n                    .retryWhen(delayedRetry())\r\n                    .test()\r\n                    .awaitCount(1) // new line\r\n                    .assertResult(\"Success\");\r\n```\r\n\r\nBut I feel like this should not be necessary.\r\n\r\nIn my production code, I have extensive logging enabled, and by reading them carefully I noticed that _sometimes_, after the `retryWhen()` operator was called, subsequent emissions occurred on a new thread. Most of the time, all emissions are called on a single thread (which is what I'd expect when using `Schedulers.trampoline()`). It was at this point I noticed that the `delay()` operator operates by default on `Schedulers.computation()`. I thought perhaps I was simply mis-using the library, and so I changed my delay call to `delay(...).observeOn(Schedulers.trampoline())`, but that had no effect.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5446/comments",
    "author": "autonomousapps",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-06-27T07:23:55Z",
        "body": "`delay` runs on the computation scheduler and observing it on the trampoline scheduler has no effect. The trampoline scheduler isn't there to pin execution to a particular thread, its purpose is to make sure tasks submitted from multiple threads execute one after the other. You could use the `delay(long, TimeUnit, Scheduler)` overload to override the scheduler and not introduce asynchrony in your tests.\r\n\r\nAlternatively, you could use `awaitDone(long, TimeUnit)` to wait for the async flow and then assert on the contents. `awaitCount` waits only for the `onNext` event and your workaround may still fail to receive `onComplete` in time."
      },
      {
        "user": "autonomousapps",
        "created_at": "2017-06-27T17:24:20Z",
        "body": "Thank you for correcting my misunderstanding of some of these issues. (I actually wish the javadoc were as clear as your sentence \"The trampoline scheduler isn't there to pin execution to a particular thread, its purpose is to make sure tasks submitted from multiple threads execute one after the other\".)\r\n\r\nNevertheless, the non-deterministic behavior seems wrong. Why would the test sometimes pass (when not in a loop), but other times fail? Why would I sometimes observe all code paths on a single thread, and sometimes on two threads?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-06-27T17:34:46Z",
        "body": "The moment you have an async scheduler in there somewhere (via opeator overload default), you open yourself to concurrent behavior thus events may not arrive \"immediately\" like in a fully synchronous case.\r\n\r\n> non-deterministic behavior seems wrong\r\n\r\nConcurrent behavior is often non-intuitive and non-deterministic.\r\n\r\n> Why would the test sometimes pass (when not in a loop), but other times fail?\r\n\r\nBecause the test thread and the consuming thread run concurrently and the test thread might get delayed just enough so the other thread has time to signal all of its events. Other times, the other thread may get things done a bit later and the test thread has already at or behind its checks.\r\n\r\n> Why would I sometimes observe all code paths on a single thread, and sometimes on two threads?\r\n\r\nConcurrent events are serialized into a single thread and if more events are involved, the same thread may deliver all events if the timing is right."
      },
      {
        "user": "autonomousapps",
        "created_at": "2017-06-27T18:09:22Z",
        "body": "Got it! Thank you."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why retryWhen/delay operator combination causes non-deterministic thread behavior in tests",
      "Identification of root cause for test flakiness between single-threaded vs multi-threaded execution",
      "Guidance on achieving deterministic test execution with RxJava operators",
      "Clarification of trampoline scheduler's actual behavior vs user expectations",
      "Explanation of how operator default schedulers impact execution context"
    ]
  },
  {
    "number": 5424,
    "title": "RxJava1.3.0 stackoverflow at android4.4",
    "created_at": "2017-06-19T07:23:07Z",
    "closed_at": "2017-06-19T08:35:55Z",
    "labels": [
      "Question",
      "Android",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5424",
    "body": "version:1.3.0\r\nos:android4.4\r\nMy app is running is very good at other version of android except for android4.4.\r\nThere is the crash log:\r\n```\r\n\r\njava.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\r\n                                                       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:59)\r\n                                                       at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\r\n                                                       at java.util.concurrent.FutureTask.run(FutureTask.java:237)\r\n                                                       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\r\n                                                       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\r\n                                                       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\r\n                                                       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\r\n                                                       at java.lang.Thread.run(Thread.java:841)\r\n                                                    Caused by: java.lang.StackOverflowError\r\n                                                       at java.util.concurrent.ConcurrentLinkedQueue.isEmpty(ConcurrentLinkedQueue.java:397)\r\n                                                       at rx.internal.schedulers.CachedThreadScheduler$CachedWorkerPool.get(CachedThreadScheduler.java:90)\r\n                                                       at rx.internal.schedulers.CachedThreadScheduler$EventLoopWorker.<init>(CachedThreadScheduler.java:188)\r\n                                                       at rx.internal.schedulers.CachedThreadScheduler.createWorker(CachedThreadScheduler.java:176)\r\n                                                       at rx.internal.operators.OperatorSubscribeOn.call(OperatorSubscribeOn.java:44)\r\n                                                       at rx.internal.operators.OperatorSubscribeOn.call(OperatorSubscribeOn.java:30)\r\n                                                       at rx.Observable.unsafeSubscribe(Observable.java:10256)\r\n                                                       at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41)\r\n                                                       at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30)\r\n                                                       at rx.Observable.unsafeSubscribe(Observable.java:10256)\r\n                                                       at rx.internal.operators.CachedObservable$CacheState.connect(CachedObservable.java:183)\r\n                                                       at rx.internal.operators.CachedObservable$CachedSubscribe.call(CachedObservable.java:248)\r\n                                                       at rx.internal.operators.CachedObservable$CachedSubscribe.call(CachedObservable.java:230)\r\n                                                       at rx.Observable.unsafeSubscribe(Observable.java:10256)\r\n                                                       at rx.internal.operators.OperatorZip$Zip.start(OperatorZip.java:202)\r\n                                                       at rx.internal.operators.OperatorZip$ZipSubscriber.onNext(OperatorZip.java:143)\r\n                                                       at rx.internal.operators.OperatorZip$ZipSubscriber.onNext(OperatorZip.java:109)\r\n                                                       at rx.internal.util.ScalarSynchronousObservable$WeakSingleProducer.request(ScalarSynchronousObservable.java:276)\r\n                                                       at rx.Subscriber.setProducer(Subscriber.java:209)\r\n                                                       at rx.internal.util.ScalarSynchronousObservable$JustOnSubscribe.call(ScalarSynchronousObservable.java:138)\r\n                                                       at rx.internal.util.ScalarSynchronousObservable$JustOnSubscribe.call(ScalarSynchronousObservable.java:129)\r\n                                                       at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\r\n                                                       at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\r\n                                                       at rx.Observable.unsafeSubscribe(Observable.java:10256)\r\n                                                       at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:48)\r\n                                                       at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:33)\r\n                                                       at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\r\n                                                       at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\r\n                                                       at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\r\n                                                       at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\r\n                                                       at rx.Observable.unsafeSubscribe(Observable.java:10256)\r\n                                                       at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:248)\r\n                                                       at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:148)\r\n                                                       at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\r\n                                                       at rx.internal.producers.SingleDelayedProducer.emit(SingleDelayedProducer.java:102)\r\n                                                       at rx.internal.producers.SingleDelayedProducer.setValue(SingleDelayedProducer.java:85)\r\n                                                       at rx.internal.operators.OperatorAny$1.onNext(OperatorAny.java:62)\r\n                                                       at rx.internal.operators.NotificationLite.accept(NotificationLite.java:135)\r\n                                                       at rx.internal.operators.CachedObservable$ReplayProducer.replay(CachedObservable.java:403)\r\n                                                   \tat rx.internal.operators.CachedObservable$CacheState.dispatch(CachedObservable.j\r\n\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5424/comments",
    "author": "yangwuan55",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-06-19T07:28:23Z",
        "body": "Maybe the default stack size on that platform is low. You can break the stack depth at places by introducing `observeOn` or (somehow) specify the minimum thread stack depth for the application."
      },
      {
        "user": "yangwuan55",
        "created_at": "2017-06-19T08:35:55Z",
        "body": "@akarnokd Thank you! I do the observeOn is useful."
      }
    ],
    "satisfaction_conditions": [
      "Identifies the root cause of RxJava stack overflow specifically on Android 4.4",
      "Provides a method to reduce call stack depth in RxJava operations",
      "Offers compatibility with RxJava 1.x architecture",
      "Addresses thread scheduling limitations in older Android versions",
      "Maintains application functionality across Android versions"
    ]
  },
  {
    "number": 5420,
    "title": "Subscribe is not returning disposable when using repeat operator",
    "created_at": "2017-06-16T11:20:24Z",
    "closed_at": "2017-07-05T22:29:42Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5420",
    "body": "Hi, I'm using rxjava 2.1.0. I want to make a pooling to a server, so I'm using a repeat operator. But when I subscribe to the observable, it does not return a disposable. \r\n\r\nFor example, if I do: \r\n\r\n Disposable s = Observable.just(true).repeat().subscribe();\r\n int i = 0;\r\n\r\nThe second line i = 0 is never reached. I cant get a disposable reference after calling to subscribe(), in order to call to dispose() when I want to finish my pooling.\r\n\r\nI'm not sure if this is a bug, or I dont understand the behaviour of the repeat operator. It is working fine, but I'm not able to finish the subscription when using the repeat operator. ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5420/comments",
    "author": "vicpinm",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-06-16T11:31:03Z",
        "body": "You built a sequence that repeats a constant, immediate source indefinitely upon subscription on the current thread and thus you won't get the control back. You have to specify where the asynchronous execution should happen via `subscribeOn` in this case. Also such immediate repeats are not really recommended for pooling and instead you should consider using `interval()`."
      },
      {
        "user": "vicpinm",
        "created_at": "2017-06-16T12:18:29Z",
        "body": "You are right, is a thread-related issue. I have fixed it with a the subscribeOn operator, thanks a lot!"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-07-05T22:29:42Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why the repeat operator prevents returning a Disposable reference",
      "Solution for managing thread execution to avoid blocking the subscription call",
      "Alternative approach suggested for polling implementation",
      "Mechanism to properly dispose of indefinite repeating observables"
    ]
  },
  {
    "number": 5417,
    "title": "2.x defaultIfEmpty for Maybe",
    "created_at": "2017-06-16T07:46:51Z",
    "closed_at": "2017-06-16T08:36:02Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5417",
    "body": "Hi. I'm glad that I started using 2.x and be able to use Maybe.\r\nI started using it, and wanted to ask a question.\r\n\r\nNow `Maybe#defaultIfEmpty` returns `Maybe`, but because this operator guarantees to emit data, I think should be `Maybe#defaultIfEmpty` returns `Single`.\r\n\r\nI would like to know if there is a reason to return `Maybe`.\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5417/comments",
    "author": "uzzu",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-06-16T08:00:04Z",
        "body": "It was probably overlooked but we can't change the type now."
      },
      {
        "user": "vanniktech",
        "created_at": "2017-06-16T08:02:50Z",
        "body": "`defaultIfEmptySingle` that returns Single?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-06-16T08:14:48Z",
        "body": "There is the `toSingle(T defaultValue)`.\n\n---\n\nAlso `defaultIfEmpty` is based on `switchIfEmpty` thus it returns `Maybe`."
      },
      {
        "user": "uzzu",
        "created_at": "2017-06-16T08:36:02Z",
        "body": "OK. :+1:\r\nI write unit tests and it seems that there is no problem with substituting `toSingle(T defaultValue)`, so I will use that.\r\n\r\n[IMO] I think that `defaultIfEmpty` is more readable than `toSingle` , so I'd like to return `Single` in 3.x or future versions.\r\n\r\nThank you for answering my question \ud83d\ude04 "
      }
    ],
    "satisfaction_conditions": [
      "Explanation of design rationale for returning Maybe instead of Single",
      "Identification of alternative method that returns Single with equivalent functionality",
      "Acknowledgement of API evolution constraints"
    ]
  },
  {
    "number": 5412,
    "title": "combineLatest(Iterable<Publisher<>>, Function<>) not emitting on empty iterable ",
    "created_at": "2017-06-14T10:33:48Z",
    "closed_at": "2017-06-28T08:58:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5412",
    "body": "I am using RxJava 2.10 and operator\r\n\r\nio.reactivex.Flowable#combineLatest(java.lang.Iterable<? extends org.reactivestreams.Publisher<? extends T>>, io.reactivex.functions.Function<? super java.lang.Object[],? extends R>)\r\n\r\n but I've seen this behavior in 1.x as well. \r\n\r\nOverload of combineLatests (and combineLatestsDelayError) that takes Iterable of Publishers is not emitting any items and 'combiner' function passed to it is not called when iterable is empty. For this operator I would expect it to scale linearly, that is:\r\n\r\n- If I pass Iterable of size 2 as a first argument I expect an Array of size 2 to be passed to combiner function\r\n- If I pass Iterable of size 1 as a first argument I expect an Array of size 1 to be passed to combiner function\r\n- If I pass Iterable of size 0 as a first argument I expect an Array of size 0 to be passed to combiner function\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5412/comments",
    "author": "Sroka",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-06-14T10:46:46Z",
        "body": "Wrong expectation. If you know you have zero sources, you are using the wrong operator to trigger actions. You can pick `just`, `map` it and actually ignore the input value. If you don't know you have zero sources, you still have the option to switch to a non-empty source via `switchIfEmpty`."
      },
      {
        "user": "Sroka",
        "created_at": "2017-06-14T11:11:57Z",
        "body": "@akarnokd Well, OK, makes sense. It took me quite a while to track this one down. Do you think it should be included in the docs? I can document it and make pull request "
      },
      {
        "user": "akarnokd",
        "created_at": "2017-06-14T11:16:14Z",
        "body": "Yes, something along the line of this:\r\n\r\n> Providing an empty array/Iterable will result in an immediate completion without any calls to the provided combiner function.\r\n\r\nNote that there are several overloads to be considered in both `Flowable` and `Observable`."
      }
    ],
    "satisfaction_conditions": [
      "Clarification of expected behavior when using combineLatest with empty Iterable",
      "Documentation of empty Iterable handling behavior",
      "Guidance on alternative approaches for empty sources",
      "Explanation of operator's fundamental design principles"
    ]
  },
  {
    "number": 5402,
    "title": "combineLatest with Iterable  not work ",
    "created_at": "2017-06-08T19:46:08Z",
    "closed_at": "2017-06-11T07:07:47Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5402",
    "body": "What I am currently using:\r\n```\r\nObservable.combineLatest(countsObslist,objects -> {\r\n            Log.d(\"Rx\",\"check\");\r\n            for (Object obj:objects) {\r\n                if(((CharSequence)obj).length()>0){\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }).subscribe(aBoolean -> RxView.enabled(btnOder).accept(aBoolean));\r\n```\r\ncountsObslist is List<Observable<CharSequence>> type\r\n\r\nthis funtion can not run correctly.....",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5402/comments",
    "author": "benlinx1018",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-06-08T20:06:21Z",
        "body": "What exactly are you trying to achieve and what is it that doesn't work?"
      },
      {
        "user": "benlinx1018",
        "created_at": "2017-06-09T00:25:30Z",
        "body": "I want to subscribe all edittext in  list view\r\nif anyone has value,enable button\r\n\r\nusing follow code subscribe the edittext and add to list:\r\n\r\n`  countsObslist.add(RxTextView.textChanges(viewHolder.edtTxtCount));`"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-06-09T07:23:55Z",
        "body": "`combineLatest` acts only if all sources have emitted an item. You have to start the sources with some default value to get it going:\r\n\r\n```java\r\ncountsObslist.add(RxTextView.textChanges(viewHolder.edtTxtCount).startWith(\"\"));\r\n```"
      }
    ],
    "satisfaction_conditions": [
      "Ensures combineLatest triggers when any Observable in the list emits a value",
      "Handles initial empty states of Observables",
      "Validates presence of non-empty content in any CharSequence emission",
      "Works with dynamic lists of Observables from list view items"
    ]
  },
  {
    "number": 5398,
    "title": "Execute specific (automatic) actions when the client un/subscribe to Flowable.",
    "created_at": "2017-06-06T19:07:33Z",
    "closed_at": "2017-07-05T22:22:39Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5398",
    "body": "I was trying to create a `Flowable` that is connected to a source when the client subscribes, and disconnect from the source when the client unsubscribes.\r\n\r\nI tried first using a custom `Flowable`, in this way:\r\n\r\n```\r\npublic final class SensorEventFlowable extends Flowable<RxSensorEvent> {\r\n\r\n    private final SensorManager sensorManager;\r\n    private final Sensor sensor;\r\n    private final int samplingPeriodUs;\r\n\r\n    SensorEventFlowable(SensorManager sensorManager, Sensor sensor, int samplingPeriodUs) {\r\n        this.sensorManager = sensorManager;\r\n        this.sensor = sensor;\r\n        this.samplingPeriodUs = samplingPeriodUs;\r\n    }\r\n\r\n    @Override\r\n    protected void subscribeActual(Subscriber<? super RxSensorEvent> subscriber) {\r\n        Listener listener = new Listener(sensorManager, subscriber);\r\n        subscriber.onSubscribe(listener);\r\n        sensorManager.registerListener(listener, sensor, samplingPeriodUs);\r\n    }\r\n\r\n    static final class Listener implements Subscription, SensorEventListener {\r\n        private final SensorManager sensorManager;\r\n        private final Subscriber<? super RxSensorEvent> subscriber;\r\n\r\n        Listener(SensorManager sensorManager, Subscriber<? super RxSensorEvent> subscriber) {\r\n            this.sensorManager = sensorManager;\r\n            this.subscriber = subscriber;\r\n        }\r\n\r\n        @Override\r\n        public void onSensorChanged(SensorEvent event) {\r\n            subscriber.onNext(new RxSensorEvent(event));\r\n        }\r\n\r\n        @Override\r\n        public void request(long n) { }\r\n\r\n        @Override\r\n        public void cancel() {\r\n            sensorManager.unregisterListener(this);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\nbut I was suggested to use `Flowable.create()` instead. So I tried to use it:\r\n\r\n```\r\npublic final class SensorEventFlowableFactory {\r\n\r\n    public static Flowable<RxSensorEvent> create(SensorManager sensorManager, Sensor sensor, int samplingPeriodUs) {\r\n        return Flowable.create(e -> {\r\n            Listener listener = new Listener(e);\r\n            sensorManager.registerListener(listener, sensor, samplingPeriodUs);\r\n        }, BackpressureStrategy.MISSING);\r\n    }\r\n\r\n    static final class Listener implements SensorEventListener {\r\n        private final FlowableEmitter<RxSensorEvent> emitter;\r\n\r\n        Listener(FlowableEmitter<RxSensorEvent> emitter) {\r\n            this.emitter = emitter;\r\n        }\r\n\r\n        @Override\r\n        public void onSensorChanged(SensorEvent event) {\r\n            emitter.onNext(new RxSensorEvent(event));\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\nI have some doubts about this code:\r\n\r\n1. In the first implementation I have `cancel` method that will execute `sensorManager.unregisterListener(this);`. How can I make this happens in the second implementation? (when the client unsubscribe from the flowable). I don't want the client to be aware about this.\r\n\r\n2. Actually, if I am not wrong, the method `sensorManager.registerListener(listener, sensor, samplingPeriodUs);` is called when the Flowable is created, and not when the client subscribe. Is that correct? If so, where do I need to place that call (registerListner) in order to be executed only if and when the client subscribes?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5398/comments",
    "author": "Joseph82",
    "comments": [
      {
        "user": "JakeWharton",
        "created_at": "2017-06-06T19:14:09Z",
        "body": "You can set a cancelation action (callback) on the `e` param. And no, the lambda is invoked once per subscriber when they subscribe."
      },
      {
        "user": "Joseph82",
        "created_at": "2017-06-06T19:18:33Z",
        "body": "Oh, cool! It works fine :) Thank you @JakeWharton "
      },
      {
        "user": "akarnokd",
        "created_at": "2017-07-05T22:22:39Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ],
    "satisfaction_conditions": [
      "Automatic resource cleanup on unsubscription",
      "Subscription-triggered resource initialization",
      "Transparent lifecycle management"
    ]
  },
  {
    "number": 5392,
    "title": "RxJava 2.1.0 SerialDisposable#isDisposed() return false for Disposables#disposed() initial value",
    "created_at": "2017-06-05T12:35:17Z",
    "closed_at": "2017-06-05T13:37:29Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5392",
    "body": "Consider following code:\r\n```java\r\nSerialDisposable disposable = new SerialDisposable(Disposables.disposed());\r\nif (disposable.isDisposed()) {\r\n   // do somesing\r\n}\r\n```\r\nI wanted to set my initial value to be disposed and thought ```isDispossed()``` will return ```true``` for ```Disposable``` returned from ```Disposables.disposed()```, but it actually returns ```false```. Find out thats because ```SerialDisposable#isDisposed()``` just check if current ```Disposable``` equals to ```DisposableHelper#DISPOSED```, which is weird. So to fix this I have to go with this:\r\n```java\r\nSerialDisposable disposable = new SerialDisposable(DisposableHelper.DISPOSED);\r\nif (disposable.isDisposed()) {\r\n   // do somesing\r\n}\r\n```\r\nIs this intended behavior? If so, can you please explicitly indicate this in the documentation?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5392/comments",
    "author": "bejibx",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-06-05T13:14:30Z",
        "body": "> Is this intended behavior?\r\n\r\nYes. The containers don't care of the actual state of what they contain and if they did, that would disrupt the state of the system. For example, if a Disposable in the CompositeDisposable container is disposed, should the the CompositeDisposable report itself as disposed despite all other content not being disposed? Also containers act as a deferred cancellation mechanism so having a disposes content doesn't mean the end of life since that disposed item can be replaced by a non-disposed item any time and continue.\r\n\r\n> If so, can you please explicitly indicate this in the documentation?\r\n\r\nTrying to prevent all those possible misunderstandings or mis-assumptions via documentation is infeasible, especially in a free and open-source project where you can find out and experiment with the code on your own to clear up your understanding. I firmly think this question and the original assumptions behind it are not suitable for explicit mention in the documentation."
      },
      {
        "user": "bejibx",
        "created_at": "2017-06-05T13:37:29Z",
        "body": "It seems I just misunderstood ```SerialDisposable``` concept. Sorry about that.\r\n\r\n> Trying to prevent all those possible misunderstandings or mis-assumptions via documentation is infeasible, especially in a free and open-source project where you can find out and experiment with the code on your own to clear up your understanding.\r\n\r\nNot quite agree with that. Having this little clarification in documentation would have saved me about 2 hours trying to understand why my app behave so strange. There could be another developers who may at first misunderstood how ```SerialDisposable``` behaves.\r\n\r\nAnyway, closing this issue. Again, sorry for bother you.\r\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why SerialDisposable's isDisposed() checks reference equality rather than the contained Disposable's state",
      "Documentation clarification about the relationship between container disposables and their contained items",
      "Clear distinction between container lifecycle management and contained disposable state management"
    ]
  },
  {
    "number": 5375,
    "title": "2.0.9 possible bug with Maybe.switchIfEmpty ",
    "created_at": "2017-05-29T11:55:42Z",
    "closed_at": "2017-05-29T12:29:09Z",
    "labels": [
      "Question",
      "2.x",
      "Kotlin"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5375",
    "body": "So, not sure if it's a bug or am I not using the operator right.\r\n\r\n    Maybe.empty<Int>()\r\n            .switchIfEmpty { Maybe.just(2) }\r\n            .subscribe {\r\n                println(\"got $it\")\r\n            }\r\n\r\nBlock above completes without any results as if `Maybe` is empty. While block below completes successfully with `got 2` output.\r\n\r\n    Maybe.empty<Int>()\r\n            .switchIfEmpty(Maybe.just(2))\r\n            .subscribe {\r\n                println(\"got $it\")\r\n            }\r\n\r\nFrom documentation I expect, that both cases should work the same.\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5375/comments",
    "author": "mjurkus",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-05-29T12:03:10Z",
        "body": "The first case creates a lambda that does nothing, courtesy of Kotlin I guess. If written out in Java syntax:\r\n\r\n```java\r\n.switchIfEmpty(mo -> { Maybe.just(2); })\r\n```\r\n\r\nwhere you are supposed to signal on `mo` according to the `Maybe` protocol but you just create and throw away a `Maybe` instance."
      },
      {
        "user": "mjurkus",
        "created_at": "2017-05-29T12:27:41Z",
        "body": "You're right, but, lambda does something.\r\n`.switchIfEmpty { ... }` creates `MaybeSource` where `subscribe` is executed and `Maybe.just(2)` is created, but nothing happens after that.\r\nso in this case:\r\n`.switchIfEmpty { it.onSuccess(2) }` and `.switchIfEmpty(Maybe.just(2))` are the same.\r\n\r\nThanks for pointing out my mistake."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of the difference between passing a Maybe instance vs. a lambda to switchIfEmpty",
      "Clarification of the Maybe protocol requirements for the lambda parameter",
      "Demonstration of proper signaling in reactive streams when using operator parameters",
      "Differentiation between creating a Maybe instance and properly subscribing to it"
    ]
  },
  {
    "number": 5349,
    "title": "2.0.8 flowableOnSubscribe onNext not working",
    "created_at": "2017-05-17T10:33:20Z",
    "closed_at": "2017-05-19T06:48:28Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5349",
    "body": "```java\r\nFlowable<List<String>> flowable = Flowable.just(Arrays.asList(\"one\",\"two\",\"three\"));\r\n\t\tflowable.subscribe(new FlowableSubscriber() {\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic void onComplete() {\r\n\t\t\t\t// TODO Auto-generated method stub\r\n\t\t\t\tSystem.out.println(\"completed\");\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic void onError(Throwable arg0) {\r\n\t\t\t\t// TODO Auto-generated method stub\r\n\t\t\t\t\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic void onNext(Object arg0) {\r\n\t\t\t\t// TODO Auto-generated method stub\r\n\t\t\t\tSystem.out.println((String)arg0);\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic void onSubscribe(Subscription arg0) {\r\n\t\t\t\t// TODO Auto-generated method stub\r\n\t\t\t\tSystem.out.println(\"on subscribe\");\r\n\t\t\t}\r\n\t\t});\r\n```\r\n\r\nflowableOnSubscribe onNext and onComplete not working,only onSubscribe is working",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5349/comments",
    "author": "mithunkumarc",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-05-17T11:03:11Z",
        "body": "You should call `Subscription.request(n)` to have the data start flowing."
      },
      {
        "user": "mithunkumarc",
        "created_at": "2017-05-19T06:48:25Z",
        "body": "@akarnokd Correct asnwer. Thanks."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why data isn't flowing to onNext/onComplete",
      "Identification of missing demand signaling requirement",
      "Guidance on proper FlowableSubscriber implementation",
      "Clarification of Reactive Streams protocol requirements"
    ]
  },
  {
    "number": 5342,
    "title": "2.x: withLatestFrom() doesn't return the latest value",
    "created_at": "2017-05-15T11:55:22Z",
    "closed_at": "2017-05-15T19:39:02Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5342",
    "body": "Version of RxJava - `2.1.0`. Here is an example which involves use of `PublishSubject`:\r\n\r\n```\r\n// Subject is used to communicate changes in the model\r\nPublishSubject modelSubject = PublishSubject.create();\r\nmodelSubject.subscribe(model -> {\r\n    editText.setText(model.value());   // this will cause a new event in the stream below\r\n});\r\n\r\n// Observing changes in the form\r\nRxTextView.afterTextChangeEvents(editText)\r\n     .takeUntil(RxView.detaches(parent))\r\n     .filter(event -> event.editable() != null)\r\n     .withLatestFrom(modelSubject, (event, model) -> {\r\n          return Pair.create(event, model);\r\n     })\r\n     .filter(pair -> {\r\n         return !pair.val0().editable().toString()\r\n             .equals(String.valueOf(pair.val1().value()));\r\n         })\r\n     .debounce(512, TimeUnit.MILLISECONDS)\r\n     .map(pair -> RowAction.create(pair.val1().uid(),\r\n            pair.val0().editable().toString()))\r\n     .subscribe(processor::onNext, throwable -> {\r\n            throw new OnErrorNotImplementedException(throwable);\r\n      });\r\n```\r\n\r\nAs you can see, `modelSubject` here can trigger events in the `RxTextView.afterTextChangeEvents(editText)` stream, meaning that consequent call to the `.withLatestFrom()` should return the value which caused the event in the stream. \r\n\r\nIt is quite interesting that for the first event emitted by `RxTextView.afterTextChangeEvents(editText)`, `withLatestFrom()` captures correct model value. Let's say that we push second model through subject which triggers another event in `editText` observable. Instead of pulling newest model instance from `modelSubject`, `.withLatestFrom()` returns an old value which is not relevant anymore. ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5342/comments",
    "author": "arazabishov",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-05-15T12:11:34Z",
        "body": "There are two subscribers to the `modelSubject` of which the first one triggers a text event change synchronously before the second subscriber is notified, thus when the `withLatestFrom` is reached you'll have the old model. Swap the two `subscribe()` calls which should make sure `withLatestFrom` is notified first.\r\n\r\nAlternatively, consider using `BehaviorSubject` and `map` by mapping in the `BehaviorSubject.getValue()` instead of `withLatestFrom`.\r\n\r\n```java\r\nBehaviorSubject modelSubject = BehaviorSubject.create();\r\n\r\n .map(event -> {\r\n      return Pair.create(event, modelSubject.getValue());\r\n })\r\n```"
      },
      {
        "user": "arazabishov",
        "created_at": "2017-05-15T19:39:02Z",
        "body": "Thank you very much for pointing out the problem with synchronicity. "
      }
    ],
    "satisfaction_conditions": [
      "Addresses synchronization timing between model updates and UI event processing",
      "Ensures latest model state is available when processing UI events",
      "Offers alternatives to withLatestFrom for accessing current state"
    ]
  },
  {
    "number": 5329,
    "title": "2.x Completable stops the chain",
    "created_at": "2017-05-02T12:57:35Z",
    "closed_at": "2017-05-02T17:28:18Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5329",
    "body": "I discovered that once Completable is done (method of `CompletableEmitter.onComplete()` is called), the chain stops and all operators are not called. \r\n\r\nSo I have the following source code\r\n```\r\nCompletable setup() {\r\n...\r\n}\r\n....\r\n            payment.setup()\r\n                          .toObservable()\r\n                          .flatMap(new Function<Object, ObservableSource<List<String>>() {\r\n                                       @Override\r\n                                       public ObservableSource<String>> apply(@io.reactivex.annotations.NonNull Object o) throws Exception {\r\n                                           return \"Some mapping is here\";\r\n                                       }\r\n                                   });\r\n```\r\n\r\nOnce `setup()` method finished successfully, `flatMap()` is not called. Is it supposed to be so? Is it possible to have a chain to Completable?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5329/comments",
    "author": "dkhmelenko",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-05-02T13:02:22Z",
        "body": "`Completable` does not have values and `flatMap` doesn't work without values. Use `Completable.andThen`."
      },
      {
        "user": "dkhmelenko",
        "created_at": "2017-05-02T17:28:18Z",
        "body": "Perfect. Thanks! "
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why Completable.flatMap() doesn't trigger in this scenario",
      "Identification of a mechanism to continue chaining after Completable completion",
      "Alternative operator/method that works with Completable's completion signal",
      "Clarification about value emission differences between Completable and Observable"
    ]
  },
  {
    "number": 5312,
    "title": "Disposable state in onComplete",
    "created_at": "2017-04-23T06:03:45Z",
    "closed_at": "2017-06-16T09:18:52Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5312",
    "body": "Hello! Version of RxJava is 2.0.9.\r\nIn my app I use ```Disposable```'s state to determine if some work is done or still running.\r\nI noticed, that in ```onComplete``` callback ```Single```'s ```Disposable``` returns ```true``` from isDisposed while ```Completable```'s ```Disposable``` returns ```false```.\r\n\r\nDoes it correct? Or I should not rely on ```Disposable``` state in ```onComplete``` callback?\r\n\r\nCode sample:\r\n```\r\nimport io.reactivex.Completable\r\nimport io.reactivex.Single\r\nimport io.reactivex.disposables.Disposable\r\nimport io.reactivex.schedulers.Schedulers\r\n\r\nfun main(args: Array<String>) {\r\n\r\n    var sin_disposable: Disposable? = null\r\n    sin_disposable = Single.just(34)\r\n            .subscribeOn(Schedulers.computation())\r\n            .observeOn(Schedulers.io())\r\n            .subscribe { _, _ ->\r\n                println(\"sin 1 ${sin_disposable?.isDisposed}\")\r\n            }\r\n    println(\"sin 2 ${sin_disposable?.isDisposed}\")\r\n\r\n    var \u0441om_disposable: Disposable? = null\r\n    \u0441om_disposable = Completable.complete()\r\n            .subscribeOn(Schedulers.computation())\r\n            .observeOn(Schedulers.io())\r\n            .subscribe({\r\n                println(\"\u0441om 1 ${\u0441om_disposable?.isDisposed} completed\")\r\n            }, { e ->\r\n                println(\"\u0441om 1 ${\u0441om_disposable?.isDisposed} error $e\")\r\n            })\r\n    println(\"\u0441om 2 ${\u0441om_disposable?.isDisposed}\")\r\n\r\n    Thread.sleep(1000)\r\n    println(\"sin 3 ${sin_disposable?.isDisposed}\")\r\n    println(\"\u0441om 3 ${\u0441om_disposable?.isDisposed}\")\r\n\r\n}\r\n```\r\n\r\nOutput is:\r\n```\r\nsin 2 false\r\nsin 1 true\r\n\u0441om 2 false\r\n\u0441om 1 false completed\r\nsin 3 true\r\n\u0441om 3 true\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5312/comments",
    "author": "qwert2603",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-04-23T08:20:16Z",
        "body": "Relying on such external `isDisposed` is not recommended and is considered a non-reactive thinking. The Completable.subscribe() sets the disposed state after the callback, probably because some test wants to call dispose that propagates upstream."
      },
      {
        "user": "qwert2603",
        "created_at": "2017-04-23T14:01:51Z",
        "body": "Thanks for reply. I'll rethink some things in my app to avoid relying on ```isDisposed```."
      }
    ],
    "satisfaction_conditions": [
      "Clarification of whether Completable's Disposable.isDisposed=false in onComplete is expected behavior",
      "Explanation of whether Disposable state can be reliably checked in onComplete callbacks",
      "Explanation of reactive principles that make Disposable state observation unreliable"
    ]
  },
  {
    "number": 5311,
    "title": "Confusing about request() method in a custom Flowable",
    "created_at": "2017-04-22T12:16:44Z",
    "closed_at": "2017-05-04T09:17:41Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5311",
    "body": "Let's say I create a custom `Flowable`:\r\n\r\n```\r\npublic final class CustomFlowable extends Flowable<Integer> {\r\n\r\n    @Override\r\n    protected void subscribeActual(Subscriber subscriber) {\r\n        Listener listener = new Listener(subscriber);\r\n        subscriber.onSubscribe(listener);\r\n    }\r\n\r\n    static final class Listener implements Subscription {\r\n        private final Subscriber<Integer> subscriber;\r\n\r\n\r\n        Listener(Subscriber<Integer> subscriber) {\r\n            this.subscriber = subscriber;\r\n        }\r\n\r\n       public void onSensorChanged(SensorEvent event) {\r\n            subscriber.onNext(event));\r\n        }\r\n\r\n        @Override\r\n        public void request(long n) {\r\n            // how to deal with this method?\r\n        }\r\n\r\n        @Override\r\n        public void cancel() {\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nI have no clue about how to implement the `request(long n)` method in order to handle gracefully the backpressure. \r\nMy guess it is that when the `request()` method is called, I should send a number of items equals to `n` . But, should I stop in the meantime the normal stream of data coming from external source ( sensors)?\r\nDo I have a way for accessing the items in the queue and call a sequence of `onNext()` for those items? ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5311/comments",
    "author": "Joseph82",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-04-22T12:20:36Z",
        "body": "There is rarely any reason to implement custom Flowables. Why do you want it? Based on the naming, you should be using `Flowable.create()` instead."
      },
      {
        "user": "Joseph82",
        "created_at": "2017-04-22T13:04:25Z",
        "body": "With `Flowable.create()` I have to define a `BackpressureStrategy` (as second parameter). \r\n\r\nWhat if I want to let the user to define a different backpressure strategy? "
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-22T13:21:50Z",
        "body": "There is the `BackpressureStrategy.MISSING` and the requirement that the consumer applies one of the `onBackpressureX` operators."
      },
      {
        "user": "Joseph82",
        "created_at": "2017-04-22T13:25:26Z",
        "body": "Ok. I wasn't sure about the meaning of `MISSING`. \r\n\r\nI'll try to switch to a Flowable created with `Flowable.create()`.\r\n\r\nThank you."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-05-04T09:17:40Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how to handle backpressure without manual request() implementation",
      "Clarification on allowing different backpressure strategies for consumers",
      "Guidance on proper use of RxJava abstractions over custom implementations",
      "Explanation of responsibility separation between producer and consumer in backpressure handling"
    ]
  },
  {
    "number": 5292,
    "title": "NPE in defer().flatMap() chain [2.0.6]",
    "created_at": "2017-04-18T20:26:12Z",
    "closed_at": "2017-04-18T21:08:09Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5292",
    "body": "I get \"java.lang.NullPointerException: Attempt to invoke interface method 'void io.reactivex.disposables.Disposable.dispose()' on a null object reference\" running following sample code\r\n\r\n`    CompositeDisposable subs = new CompositeDisposable();\r\n\r\n    private Integer getInt() {\r\n        if(true)\r\n            throw new IllegalStateException();\r\n        return 0;\r\n    }\r\n\r\n    private void test() {\r\n        subs.add(Observable.defer(() -> observer -> {\r\n            observer.onNext(1);\r\n            observer.onComplete();\r\n        }).flatMap(o -> Observable.fromCallable(this::getInt))\r\n                .subscribe(integer -> {}, Throwable::printStackTrace)\r\n        );\r\n    }`\r\n\r\nAm I using defer in a wrong way? ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5292/comments",
    "author": "kamehamehajim",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-04-18T20:29:42Z",
        "body": "Could you post the entire stacktrace?"
      },
      {
        "user": "kamehamehajim",
        "created_at": "2017-04-18T20:32:24Z",
        "body": "```\r\n04-18 23:27:23.310 12259-12259/? E/AndroidRuntime: FATAL EXCEPTION: main\r\n                                                   Process: com.example.testapp, PID: 12259\r\n                                                   java.lang.RuntimeException: Unable to resume activity {com.example.testapp/com.example.testapp.ui.MainActivity}: java.lang.NullPointerException: Attempt to invoke interface method 'void io.reactivex.disposables.Disposable.dispose()' on a null object reference\r\n                                                       at android.app.ActivityThread.performResumeActivity(ActivityThread.java:3145)\r\n                                                       at android.app.ActivityThread.handleResumeActivity(ActivityThread.java:3176)\r\n                                                       at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2517)\r\n                                                       at android.app.ActivityThread.access$900(ActivityThread.java:158)\r\n                                                       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1364)\r\n                                                       at android.os.Handler.dispatchMessage(Handler.java:102)\r\n                                                       at android.os.Looper.loop(Looper.java:148)\r\n                                                       at android.app.ActivityThread.main(ActivityThread.java:5515)\r\n                                                       at java.lang.reflect.Method.invoke(Native Method)\r\n                                                       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:764)\r\n                                                       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:654)\r\n                                                    Caused by: java.lang.NullPointerException: Attempt to invoke interface method 'void io.reactivex.disposables.Disposable.dispose()' on a null object reference\r\n                                                       at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.disposeAll(ObservableFlatMap.java:498)\r\n                                                       at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.checkTerminate(ObservableFlatMap.java:490)\r\n                                                       at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drainLoop(ObservableFlatMap.java:331)\r\n                                                       at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drain(ObservableFlatMap.java:323)\r\n                                                       at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.tryEmitScalar(ObservableFlatMap.java:224)\r\n                                                       at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.subscribeInner(ObservableFlatMap.java:146)\r\n                                                       at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onNext(ObservableFlatMap.java:139)\r\n                                                       at com.example.testapp.presenters.ListSpecsPresenter.lambda$null$0(ListSpecsPresenter.java:51)\r\n                                                       at com.example.testapp.presenters.ListSpecsPresenter$$Lambda$8.subscribe(Unknown Source)\r\n                                                       at io.reactivex.internal.operators.observable.ObservableDefer.subscribeActual(ObservableDefer.java:39)\r\n                                                       at io.reactivex.Observable.subscribe(Observable.java:10700)\r\n                                                       at io.reactivex.internal.operators.observable.ObservableFlatMap.subscribeActual(ObservableFlatMap.java:55)\r\n                                                       at io.reactivex.Observable.subscribe(Observable.java:10700)\r\n                                                       at io.reactivex.Observable.subscribe(Observable.java:10686)\r\n                                                       at io.reactivex.Observable.subscribe(Observable.java:10615)\r\n                                                       at com.example.testapp.presenters.ListSpecsPresenter.test(ListSpecsPresenter.java:54)\r\n                                                       at com.example.testapp.presenters.ListSpecsPresenter.onAttachView(ListSpecsPresenter.java:34)\r\n                                                       at com.example.testapp.presenters.ListSpecsPresenter.onAttachView(ListSpecsPresenter.java:15)\r\n                                                       at com.example.testapp.ui.SpecListFragment.onResume(SpecListFragment.java:158)\r\n                                                       at android.support.v4.app.Fragment.performResume(Fragment.java:2235)\r\n                                                       at android.support.v4.app.FragmentManagerImpl.moveToState(FragmentManager.java:1346)\r\n                                                       at android.support.v4.app.FragmentManagerImpl.moveFragmentToExpectedState(FragmentManager.java:1528)\r\n                                                       at android.support.v4.app.FragmentManagerImpl.moveToState(FragmentManager.java:1595)\r\n                                                       at android.support.v4.app.FragmentManagerImpl.dispatchResume(FragmentManager.java:2898)\r\n                                                       at android.support.v4.app.FragmentController.dispatchResume(FragmentController.java:223)\r\n                                                       at android.support.v4.app.FragmentActivity.onResumeFragments(FragmentActivity.java:509)\r\n                                                       at android.support.v4.app.FragmentActivity.onPostResume(FragmentActivity.java:498)\r\n                                                       at android.support.v7.app.AppCompatActivity.onPostResume(AppCompatActivity.java:172)\r\n                                                       at android.app.Activity.performResume(Activity.java:6548)\r\n                                                       at android.app.ActivityThread.performResumeActivity(ActivityThread.java:3134)\r\n                                                       at android.app.ActivityThread.handleResumeActivity(ActivityThread.java:3176)\u00a0\r\n                                                       at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2517)\u00a0\r\n                                                       at android.app.ActivityThread.access$900(ActivityThread.java:158)\u00a0\r\n                                                       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1364)\u00a0\r\n                                                       at android.os.Handler.dispatchMessage(Handler.java:102)\u00a0\r\n                                                       at android.os.Looper.loop(Looper.java:148)\u00a0\r\n                                                       at android.app.ActivityThread.main(ActivityThread.java:5515)\u00a0\r\n                                                       at java.lang.reflect.Method.invoke(Native Method)\u00a0\r\n                                                       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:764)\u00a0\r\n                                                       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:654)\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-18T20:32:43Z",
        "body": "Okay, the problem is that you are not supposed to create observables via the lambda (even though they appear to be functional interfaces) because you have to call `onSubscribe` with a `Disposable`. Use `Observable.just()` or `Observable.create()` instead."
      },
      {
        "user": "kamehamehajim",
        "created_at": "2017-04-18T20:39:38Z",
        "body": "```java\r\n    private void test() {\r\n        subs.add(Observable.defer(() -> new ObservableSource<Integer>() {\r\n            @Override\r\n            public void subscribe(Observer<? super Integer> observer) {\r\n                observer.onNext(1);\r\n                observer.onComplete();\r\n            }\r\n        }).flatMap(o -> Observable.fromCallable(this::getInt))\r\n                .subscribe(integer -> {}, Throwable::printStackTrace)\r\n        );\r\n    }\r\n```\r\n\r\nFails too. Am I still doing it wrong? (sorry for badly inserted code, I don't know what's going on)"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-18T20:51:30Z",
        "body": "```java\r\npublic void test() {\r\n    subs.add(Observable.defer(() -> Observable.create(observer -> {\r\n        observer.onNext(1);\r\n        observer.onComplete();\r\n    })).flatMap(o -> Observable.fromCallable(this::getInt))\r\n        .subscribe(integer -> {}, Throwable::printStackTrace)\r\n    );\r\n}\r\n```"
      },
      {
        "user": "kamehamehajim",
        "created_at": "2017-04-18T21:08:09Z",
        "body": "Ok, I got it, I should've just called observer.onSubscribe() to provide some kind of disposable. Thanks for quick reply."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why a NullPointerException occurs in the Observable chain when using defer() with flatMap()",
      "Guidance on proper Observable creation that handles Disposable lifecycle",
      "Clarification of when to use Observable.create() vs other creation methods"
    ]
  },
  {
    "number": 5272,
    "title": "1.x repeatWhen does not call onCompleted on child subscription",
    "created_at": "2017-04-07T21:37:26Z",
    "closed_at": "2017-04-07T22:08:32Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5272",
    "body": "Tested using RxJava 1.2.9.\r\n\r\nThe description of `repeatWhen` implies if the `notificationHandler` call an `onComplete` it should pass it onto the child subscription: \"If that Observable calls onComplete or onError then repeatWhen will call onCompleted or onError on the child subscription.\"\r\n\r\nHowever, this doesn't seem to happen. The `onError` seems to work, but `onCompleted` does not. This code illustrates this:\r\n\r\n```java\r\nSubscriber<Integer> subscriber = new Subscriber<Integer>() {\r\n    @Override public void onCompleted() {\r\n        System.out.println(\"completed\");\r\n    }\r\n\r\n    @Override public void onError(Throwable e) {\r\n        System.out.println(\"error\");\r\n    }\r\n\r\n    @Override public void onNext(Integer i) {\r\n\r\n    }\r\n};\r\n\r\n// Does not output anything\r\nObservable.just(1)\r\n        .repeatWhen(observable -> observable.flatMap(ignored -> Observable.empty()))\r\n        .subscribe(subscriber);\r\n\r\n// Prints \"error\" (as expected)\r\nObservable.just(1)\r\n        .repeatWhen(observable -> observable.flatMap(ignored -> Observable.error(new Exception())))\r\n        .subscribe(subscriber);\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5272/comments",
    "author": "Chubacca",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-04-07T21:42:40Z",
        "body": "You can't complete an entire `flatMap` with an inner `empty()` source, that just counts as 'skipping' and the merged flow is kept intact. For `repeatWhen` and `retryWhen`, you need a different mechanism and make `observable` complete, for example, with `takeWhile` or `takeUntil` or some lifted operator that can turn an `onNext` into an `onCompleted`."
      },
      {
        "user": "Chubacca",
        "created_at": "2017-04-07T22:08:32Z",
        "body": "Ah, makes sense, the flatMap won't pass the onComplete through (because it's mapped). Thanks!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how completion propagation works in repeatWhen's notificationHandler",
      "Identification of correct termination patterns for repeatWhen notificationHandler",
      "Clarification of Observable operator behavior differences in completion propagation",
      "Guidance on achieving intended child subscription termination"
    ]
  },
  {
    "number": 5264,
    "title": "doOnDispose / doOnLifecycle onDisposed action not being called",
    "created_at": "2017-04-04T20:31:22Z",
    "closed_at": "2017-04-11T11:51:36Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5264",
    "body": "Maybe I am doing something wrong, but this just stopped working when I updated version from 2.01 to 2.07 and 2.08.\r\n\r\nThe doOnDispose and the doOnLifecycle onDisposed action are not being called.\r\n\r\nSample code:\r\n\r\n        Observable.fromCallable(() -> \"1\")\r\n                .doOnLifecycle(\r\n                        disposable -> Log.i(TAG, \"1:doOnSubscribe\"),\r\n                        () -> Log.i(TAG, \"1:doOnDispose\")\r\n                )\r\n                .subscribe()\r\n                .dispose();\r\n\r\n        Observable.fromCallable(() -> \"2\")\r\n                .doOnSubscribe(disposable -> Log.i(TAG, \"2:doOnSubscribe\"))\r\n                .doOnDispose(() -> Log.i(TAG, \"2:doOnDispose\"))\r\n                .subscribe()\r\n                .dispose();",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5264/comments",
    "author": "fqborges",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-04-04T20:39:30Z",
        "body": "`subscribe` disconnects the upstream `Disposable` when it receives a terminal event thus you can't dispose an already completed sequence. This change was introduced in 2.0.5 via #4957."
      },
      {
        "user": "fqborges",
        "created_at": "2017-04-04T20:52:36Z",
        "body": "Is there a way to receive onDispose events after 2.0.5?\r\nI was using subscribe and dispose events for showing and hiding activity indicators/progress bar on when doing network.\r\n\r\nFor example, I used to do something like this:\r\n\r\n                doSomethingUsingNetwork()\r\n                .doOnSubscribe(d -> showProgress() )\r\n                .doOnDispose(() -> hideProgress() )\r\n                .subscribe(\r\n                        this::handleNext,\r\n                        this::handleError\r\n                )\r\n\r\nEdit: Why using onDispose? Because I missed the onFinally events when the subscription was disposed before onComplete/onError"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-04T20:54:09Z",
        "body": "Use doFinally."
      },
      {
        "user": "fqborges",
        "created_at": "2017-04-04T20:57:55Z",
        "body": "Thanks, it works like a charm in this version."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-11T11:51:36Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ],
    "satisfaction_conditions": [
      "Provides a way to reliably detect subscription termination (both completion and disposal)",
      "Works with RxJava 2.0.5+ lifecycle changes",
      "Handles both successful completions and early disposals",
      "Maintains equivalent functionality to previous doOnDispose behavior"
    ]
  },
  {
    "number": 5254,
    "title": "RxJava 1.2.9 : calling onError without finishing / unsubscribing / onCompleted",
    "created_at": "2017-04-01T10:58:49Z",
    "closed_at": "2017-04-27T13:04:17Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5254",
    "body": "my code\uff1a\r\n\r\n```\r\nSubscription subscription = Observable.create(new Observable.OnSubscribe<ProgressModel>() {\r\n            @Override\r\n            public void call(Subscriber<? super ProgressModel> subscriber) {\r\n                try {\r\n                    OkHttpClient httpClient = new OkHttpClient();\r\n                    Call call = httpClient.newCall(new Request.Builder().url(URL).build());\r\n                    Response response = call.execute();\r\n                    if (response.code() == 200) {\r\n\r\n                        makeFileFullPath(savePath);\r\n\r\n                        File file = new File(savePath);\r\n\r\n                        FileOutputStream outputStream = null;\r\n\r\n                        InputStream inputStream = null;\r\n                        try {\r\n\r\n                            inputStream = response.body().byteStream();\r\n                            outputStream = new FileOutputStream(file);\r\n                            byte[] buff = new byte[1024 * 4];\r\n                            long downloaded = 0;\r\n                            long target = response.body().contentLength();\r\n\r\n                            ProgressModel progressModel = new ProgressModel();\r\n                            progressModel.updateData(0, target, false);\r\n                            subscriber.onNext(progressModel);\r\n                            int length = 0;\r\n                            long oldPro = 0;\r\n                            while ((length = inputStream.read(buff)) != -1) {\r\n                                outputStream.write(buff, 0, length);\r\n                                downloaded += length;\r\n\r\n                                long tmp = (downloaded *100 /target);\r\n\r\n                               if(tmp != oldPro) {\r\n                                   progressModel.updateData(downloaded, target, false);\r\n                                   subscriber.onNext(progressModel);\r\n                                   oldPro = tmp;\r\n                               }\r\n\r\n                                if(isStop.get()) {\r\n                                    break;\r\n                                }\r\n                                System.out.println(\"complemnt\"+tmp+\",\"+oldPro);\r\n                            }\r\n                            if (downloaded == target) {\r\n                                subscriber.onCompleted();\r\n                            } else {\r\n                                subscriber.onNext(new ProgressModel(-1,-1,false));\r\n                            }\r\n\r\n                        } catch (IOException ignore) {\r\n                            subscriber.onNext(new ProgressModel(-1,-1,false));\r\n\r\n                        } finally {\r\n                            if (inputStream != null) {\r\n                                inputStream.close();\r\n                            }\r\n                            if(outputStream != null) {\r\n                                outputStream.close();\r\n                            }\r\n                        }\r\n                    } else {\r\n                        subscriber.onNext(new ProgressModel(-1,-1,false));\r\n                    }\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n\r\n            }\r\n        }).subscribeOn(Schedulers.io())\r\n                .observeOn(AndroidSchedulers.mainThread()).subscribe(new Subscriber<ProgressModel>() {\r\n            @Override\r\n            public void onNext(ProgressModel s) {\r\n                if(s == null) return;\r\n\r\n               if(!progressListener.update(s.already,s.total,s.done)) {\r\n                   System.out.println(\"calback1111111112 kaishi zhixingle\");\r\n                   isStop.set(true);\r\n               }\r\n            }\r\n\r\n            @Override\r\n            public void onCompleted() {\r\n                progressListener.update(-1,-1,true);\r\n            }\r\n\r\n            @Override\r\n            public void onError(Throwable e) {\r\n                System.out.println(\"calback1111111112 kaishi zhixingle\");\r\n            }\r\n        });\r\n        mCompositeSubscription.add(subscription);\r\n```\r\nI did not call the method   ```public void onError(Throwable e)``` ,\r\n, but it was called by itself.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5254/comments",
    "author": "trycatchx",
    "comments": [
      {
        "user": "trycatchx",
        "created_at": "2017-04-01T11:07:04Z",
        "body": "> When I Calling onNext very many times\uff0cSubscriber calls the onError method through itself\u3002why ?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-01T11:42:20Z",
        "body": "It would be great if you actually shared the exception you are getting."
      },
      {
        "user": "trycatchx",
        "created_at": "2017-04-12T09:56:20Z",
        "body": "@akarnokd I can not get any exception. But i add .onBackpressureBuffer()  in Observable ,  and the problem is solved.  if I add onBackpressureDrop the problem is still there . "
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-12T10:28:49Z",
        "body": "> I can not get any exception\r\n\r\nI can't tell what's wrong without knowing at least the name of the exception you are getting. Any stacktrace would be equally helpful. \r\n\r\nYou should avoid using `Observable.create(Observable.OnSubscribe)` because it has no safeguards and you are responsible for implementing the Observable protocol correctly. Use `Observable.create(Action<Emitter<T>>, Emitter.BackpressureMode)` instead."
      },
      {
        "user": "trycatchx",
        "created_at": "2017-04-17T10:24:17Z",
        "body": "@akarnokd  Thank you for your help ! I use `Observable.create(Action<Emitter>, Emitter.BackpressureMode) ` instead \uff0c and the code works fine \uff01"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-27T13:04:17Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why onError is being triggered automatically without explicit calls",
      "Guidance on proper backpressure handling in Observable creation",
      "Recommendation to avoid raw Observable.create(OnSubscribe) implementation",
      "Explanation of Observable contract requirements for error handling",
      "Identification of potential protocol violations in subscriber interactions"
    ]
  },
  {
    "number": 5218,
    "title": "FlatMap with Completable ",
    "created_at": "2017-03-24T06:38:08Z",
    "closed_at": "2017-03-24T10:13:32Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5218",
    "body": "Basically I want to have the option of converting an Observable from flatMap to use as Completable. I am using RxJava 1.2.1 and trying to migrate to RxJava 2. Following the lead by Jake, I am removing all the Observable<Void> declarations  and replacing them with Completable. Here is the problem where I am stuck\r\n```\r\n public Observable<Void> saveReminder(final Reminder reminder)\r\n    {\r\n        return Observable.fromEmitter((Emitter<DataSnapshot> dataSnapshotAsyncEmitter) ->\r\n        {\r\n            FirebaseApi.getReminderReference().addListenerForSingleValueEvent(new ValueEventListener()\r\n            {\r\n                @Override\r\n                public void onDataChange(DataSnapshot dataSnapshot)\r\n                {\r\n                    dataSnapshotAsyncEmitter.onNext(dataSnapshot);\r\n                    dataSnapshotAsyncEmitter.onCompleted();\r\n                }\r\n\r\n                @Override\r\n                public void onCancelled(DatabaseError databaseError)\r\n                {\r\n                    if (databaseError != null)\r\n                    {\r\n                        dataSnapshotAsyncEmitter.onError(databaseError.toException());\r\n                    }\r\n                }\r\n            });\r\n        }, Emitter.BackpressureMode.LATEST).observeOn(Schedulers.io()).flatMap(reminderCardsSnapshot ->\r\n        {\r\n            try\r\n            {\r\n                return Observable.just(saveData(reminder, reminderCardsSnapshot));\r\n            } catch (Exception e)\r\n            {\r\n                return Observable.error(e);\r\n            }\r\n        });\r\n    }\r\n```\r\nI need to replace **Observable<Void>** with **Completable**. Plz help",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5218/comments",
    "author": "reactivedroid",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-03-24T08:42:05Z",
        "body": "Which one?"
      },
      {
        "user": "reactivedroid",
        "created_at": "2017-03-24T08:52:13Z",
        "body": "@akarnokd I want to replace Observable<Void> to return Completable. \r\n`try\r\n            {\r\n                return Observable.just(saveData(reminder, reminderCardsSnapshot));\r\n            } catch (Exception e)\r\n            {\r\n                return Observable.error(e);\r\n            }`\r\nHow can the above method return Completable when it is wrapped inside flatMap which returns an Observable. Can you plz change the method above to return Completable?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-24T09:02:18Z",
        "body": "```java\r\n.flatMapCompletable(reminderCardsSnapshot ->\r\n    Completable.fromAction(() -> saveData(reminder, reminderCardsSnapshot)))\r\n```\r\n\r\nAs a general tip, I suggest you walk through each method in the classes so you can build a mental map on what's available.\r\n"
      },
      {
        "user": "reactivedroid",
        "created_at": "2017-03-24T10:08:05Z",
        "body": "Agreed. But `flatMapCompletable` is available in RxJava2...do you know any way where we can achieve the same in RxJava 1.2.1?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-24T10:09:18Z",
        "body": "Upgrade to 1.2.9."
      },
      {
        "user": "reactivedroid",
        "created_at": "2017-03-24T10:13:32Z",
        "body": "@akarnokd Thanks \ud83d\udc4d "
      }
    ],
    "satisfaction_conditions": [
      "Solution must work with RxJava 1.x (specifically 1.2.1 or minor version upgrades)",
      "Must demonstrate conversion of Observable<Void> to Completable in flatMap context",
      "Should provide migration path without requiring major architectural changes",
      "Must handle error propagation from saveData operation"
    ]
  },
  {
    "number": 5180,
    "title": "When using retryWhen why is there not a resubscription if the return is Observable.error(...)",
    "created_at": "2017-03-13T21:49:42Z",
    "closed_at": "2017-03-29T08:58:04Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5180",
    "body": "Thanks for using RxJava but before you post an issue, please consider the following points:\r\n\r\n  - RxJava Version: 1.2.7\r\n\r\nOverview:\r\nI wanted to test the scenario where I use RxJava to poll a service. The expectation is that the service will return a list with transactions, an empty list, or an exception will be thrown. Whenever, a list with transactions is returned they will be published to any subscribe to the relevant Rx subject. From Rx perspective polling and retry will be indefinite by will be throttled and the intent is to use a circuit breaker higher up the call stack to reduce necessary calls when the server is not available. \r\n\r\nIn my research all works as expected if you return list data, empty list or throw an exception. However, if one was to return say:\r\n\r\n  Observable.error(new RuntimeException());\r\n\r\nThen resubscription does not appear to take place.\r\n\r\nHere's the pretty much self contain code.  I've made it so that I can simulate having a mix of list items, empty list or exception returning. I can also have a specific set of the above options return. Additionally, I can simulate throwing an exception or returning Observable.error(...).\r\n\r\n```java\r\npackage com.shapestone.transaction.publisher;\r\n\r\nimport rx.Observable;\r\nimport rx.Observer;\r\nimport rx.Subscription;\r\nimport rx.subjects.PublishSubject;\r\nimport rx.subjects.Subject;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Random;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\nimport static java.lang.String.format;\r\nimport static rx.Observable.just;\r\nimport static rx.Observable.timer;\r\n\r\n/**\r\n * Date: 3/13/17.\r\n */\r\npublic class TransactionSubjectPlaypen {\r\n  enum ExceptionType { OBSERVABLE_EXCEPTION, THROW_EXCEPTION}\r\n  private static ExceptionType exceptionType;\r\n  private static final int COUNTER_START = 1;\r\n  private static final int ATTEMPTS = 5;\r\n  private static final int ORIGINAL_DELAY_IN_SECONDS = 10;\r\n  private Subject<TestTransaction, TestTransaction> transactionSubject;\r\n\r\n  public TransactionSubjectPlaypen() {\r\n    this.transactionSubject = PublishSubject.create();\r\n  }\r\n\r\n  public static void main(String[] args) {\r\n    try {\r\n      exceptionType = ExceptionType.THROW_EXCEPTION;\r\n      final TransactionSubjectPlaypen transactionSubjectPlaypen = new TransactionSubjectPlaypen();\r\n      transactionSubjectPlaypen.subscribe(new TestTransactionObserver());\r\n      transactionSubjectPlaypen.start();\r\n      Thread.sleep(120000);\r\n    } catch (InterruptedException e) {\r\n      e.printStackTrace();\r\n    }\r\n  }\r\n\r\n  public Subscription subscribe(Observer<TestTransaction> transactionObserver) {\r\n    return transactionSubject.subscribe(transactionObserver);\r\n  }\r\n\r\n  public void start() {\r\n    startPeriodicTransactionRetrieval();\r\n  }\r\n\r\n  // Emits Transaction\r\n\r\n  private void startPeriodicTransactionRetrieval() {\r\n    System.out.println(\"TransactionSubjectPlaypen.startPeriodicTransactionRetrieval\");\r\n    TransactionSubjectPlaypen.exceptionType = ExceptionType.OBSERVABLE_EXCEPTION;\r\n    Observable.fromCallable(() -> pollRemoteForTransactions(1))\r\n      .retryWhen(errors -> {\r\n        System.out.println(\"retryWhen\");\r\n        return errors.flatMap(error -> {\r\n          return Observable.just(null);\r\n        });\r\n      })\r\n      .repeatWhen(observable -> {\r\n        System.out.println(\"repeatWhen\");\r\n        return observable.concatMap(v -> timer(4, TimeUnit.SECONDS));\r\n      })\r\n      .flatMap(listObservable -> {\r\n       return listObservable;\r\n      }).flatMapIterable(testTransactions -> {\r\n        return testTransactions;\r\n      }).subscribe(transactionSubject);\r\n  }\r\n\r\n  // This is a bit superfluous however it is included to gave a more complete understanding of the problem.\r\n  private Observable<List<TestTransaction>> pollRemoteForTransactions(Integer i) {\r\n    System.out.println(\"TransactionSubjectPlaypen.pollRemoteForTransactions\");\r\n    return remoteServiceClientSimulation(i);\r\n  }\r\n\r\n  private Observable<List<TestTransaction>> remoteServiceClientSimulation(Integer i) {\r\n    System.out.println(\"TransactionSubjectPlaypen.remoteServiceClientSimulation\");\r\n    try {\r\n      randomNetworkDelaySimulation();\r\n      return getTransactions(i);\r\n    } catch (InterruptedException e) {\r\n      throw new RuntimeException(e.getMessage());\r\n    }\r\n  }\r\n\r\n  private void randomNetworkDelaySimulation() throws InterruptedException {\r\n    System.out.println(\"TransactionSubjectPlaypen.randomNetworkDelaySimulation\");\r\n    final int MAX_DELAY = 8000;\r\n    Thread.sleep(new Random().nextInt(MAX_DELAY));\r\n  }\r\n\r\n  @SuppressWarnings(\"Duplicates\")\r\n  private Observable<List<TestTransaction>> getTransactions(Integer requestedOption) {\r\n    System.out.println(\"TransactionSubjectPlaypen.getTransactions\");\r\n    final List<TestTransaction> transactions = new ArrayList<>();\r\n    int ZERO_RETURN_TRANSACTIONS = 0, ONE_RETURN_EXCEPTION = 1;\r\n\r\n    int MAX_OPTIONS = 3;\r\n    final int i = (requestedOption != null ? requestedOption : new Random().nextInt(MAX_OPTIONS));\r\n    if (i == ZERO_RETURN_TRANSACTIONS) {\r\n\r\n      transactions.add(new TestTransaction(\"addVendor\"));\r\n      transactions.add(new TestTransaction(\"addPersonAccount\"));\r\n      transactions.add(new TestTransaction(\"addSystemAccount\"));\r\n      transactions.add(new TestTransaction(\"addDeploymentContext\"));\r\n      transactions.add(new TestTransaction(\"addProperty\"));\r\n\r\n      System.out.println(format(\"Return %d transaction\", transactions.size()));\r\n\r\n      return just(transactions);\r\n\r\n    } else if (i == ONE_RETURN_EXCEPTION) {\r\n\r\n      if (exceptionType == ExceptionType.THROW_EXCEPTION) {\r\n        System.out.println(\"Return exception\");\r\n        throw new RuntimeException();\r\n        //return error(new RuntimeException());\r\n      } else {\r\n        System.out.println(format(\"Returning %d transaction\", transactions.size()));\r\n        return Observable.error(new RuntimeException());\r\n      }\r\n    } else {\r\n\r\n      System.out.println(format(\"Returning %d transaction\", transactions.size()));\r\n      return just(transactions);\r\n\r\n    }\r\n\r\n  }\r\n\r\n  public static class TestTransactionObserver implements Observer<TestTransaction> {\r\n\r\n    @Override\r\n    public void onCompleted() {\r\n      System.out.println(\"TestTransactionObserver.onCompleted\");\r\n    }\r\n\r\n    @Override\r\n    public void onError(Throwable e) {\r\n      System.out.println(\"TestTransactionObserver.onError\");\r\n      System.out.println(e);\r\n    }\r\n\r\n    @Override\r\n    public void onNext(TestTransaction testTransaction) {\r\n      System.out.println(\"TestTransactionObserver.onNext\");\r\n      System.out.println(\"Value = \" + testTransaction);\r\n    }\r\n  }\r\n\r\n  public static class TestTransaction {\r\n    private String name;\r\n\r\n    public TestTransaction() {\r\n    }\r\n\r\n    public TestTransaction(String name) {\r\n      this.name = name;\r\n    }\r\n\r\n    public String getName() {\r\n      return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n      this.name = name;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n      return \"TestTransaction{\" +\r\n        \"name='\" + name + '\\'' +\r\n        '}';\r\n    }\r\n  }\r\n\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5180/comments",
    "author": "michaaelw",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-03-13T22:10:59Z",
        "body": "The `pollRemoteForTransactions` returns an `Observable` from the `fromCallable` which is considedered a success value and thus `retryWhen` doesn't see its inner exception. Only the first `flatMap` will unbox it and will find the error, but ther is no `retryWhen` further down. \r\n\r\nNote that error handling such as `retryWhen` can operate on errors that are above them, not below in the chain. \r\n\r\nPlace the `retryWhen` and `repeatWhen` just before the `subscribe()` call and you should see the retry/repeat happening."
      },
      {
        "user": "michaaelw",
        "created_at": "2017-03-13T22:23:39Z",
        "body": "Thanks for the prompt response @akarnokd. That make sense."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-29T08:58:04Z",
        "body": "Looks like this question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how error propagation works in Observable chains with retryWhen/repeatWhen",
      "Clarification on operator placement for proper error handling in RxJava 1.x",
      "Differentiation between errors as Observable values vs terminal exceptions",
      "Guidance on Observable chain construction for polling patterns"
    ]
  },
  {
    "number": 5166,
    "title": "1.x Execute action after flattened observable completes",
    "created_at": "2017-03-08T20:57:05Z",
    "closed_at": "2017-03-12T14:51:27Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5166",
    "body": "Hello,\r\n\r\ni'm with a doubt that i don't know how to write a flow that use a connection from database, but closes it a soon as the query ends, and before the downstream consume it's events.\r\n\r\nI'm using vert.x rxfied jdbc client, example code:\r\n\r\n```\r\njdbcClient.getConnectionObservable()\r\n                  .flatMap(conn -> conn.queryWithParamsObservable(\"SQL QUERY ...\", new JsonArray())\r\n                                       .doOnTerminate(conn::close))\r\n                  .map(ResultSet::getRows)\r\n                  .groupBy( // ... )\r\n```\r\n\r\nHow can i make the `conn::close` be classed **BEFORE** `map`, `groupby` and the rest of chian operators execute?\r\n\r\nCurrently, it will run the `doOnTerminate` only when the `subscriber` `unsubscribes`, since i'm returning it to other code, someone could do expensive things with the results, and i don't want the connection to be held due to that.\r\n\r\nOther thing, ideally i will be using `Observable.using` to create generic repository methods, because `getConnectionObservable` isn't lazy, it fetches a connection on calling, but it's not a `hot` observable since it don't pushes the values until subscribed, so, a sampel code would look like this:\r\n\r\n```\r\nObservable.defer(jdbcClient::getConnectionObservable)\r\n                  .flatMap(conn -> Observable.using(() -> {\r\n                                                      log.debug(\"Fetching database connection\");\r\n                                                      return conn;\r\n                                                  },\r\n                                                  // handle the connection here,\r\n                                                  connToClose -> {\r\n                                                      log.debug(\"Returning connection to pool\");\r\n                                                      connToClose.close();\r\n                                                  }));\r\n```\r\n\r\nI need to close the connection after it's used, before the chain ends.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5166/comments",
    "author": "kennedyoliveira",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-03-08T21:13:33Z",
        "body": "Hi. You were almost there: you have to apply Observable.using() on the outside:\r\n\r\n```java\r\nObservable.using(\r\n    jdbcClient::getConnectionObservable,\r\n    conn -> conn.queryWithParamsObservable(...)\r\n               .map(ResultSet::getRows)\r\n               .groupBy( ... )\r\n    conn -> conn.close(),\r\n    false\r\n)\r\n\r\n// or\r\nObservable.using(\r\n    jdbcClient::getConnectionObservable,\r\n    conn -> conn.queryWithParamsObservable(...)\r\n    conn -> conn.close(),\r\n    false\r\n)\r\n.map(ResultSet::getRows)\r\n.groupBy( ... )\r\n\r\n```"
      },
      {
        "user": "kennedyoliveira",
        "created_at": "2017-03-08T21:41:25Z",
        "body": "Hey @akarnokd, thank you for the fast answer!\r\n\r\nI forgot to mention i'm using 1.x version, and `jdbcClient.getConnectionObservable` returns a `Observable<SQLConnection>` and not a connection, so  i would not be able to close it on last function, or i'm missing something?\r\n\r\nBy the way, i don't understand how the last parameter `disposeEagerly`, would you mind explaining it or pointing a resource to read more, besides the documentation?\r\n\r\nThank you"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-08T22:19:03Z",
        "body": "In that case your `defer` approach should work.\r\n\r\n> would you mind explaining it\r\n\r\nIf true, the dispose action is called before the onComplete is sent downstream. If false, the dispose action is called after. Sometimes you have to delay the dispose action with it because computation may still depend on the resource."
      },
      {
        "user": "kennedyoliveira",
        "created_at": "2017-03-08T23:38:18Z",
        "body": "@akarnokd thanks for explaining about the `disposeEagerly`, know i understand.\r\n\r\nBack to the main question, the `defer` approach doesn't work, i created a simple example:\r\n\r\n```\r\n// defer because jdbcClient.getConnectionObservable() fetches a connection\r\nfinal Observable<SQLConnection> lazyConnection = Observable.defer(() -> {\r\n  log(\"Fetching connection\");\r\n  return jdbcClient.getConnectionObservable();\r\n});\r\n\r\nreturn lazyConnection\r\n  .flatMap(resource ->\r\n             Observable.using(\r\n               () -> {\r\n                 log(\"Creating resource\");\r\n                 return resource;\r\n               },\r\n               conn -> {\r\n                 log(\"Doing select on the connection\");\r\n                 return conn.queryObservable(\"SELECT * FROM INFORMATION_SCHEMA.HELP \");\r\n               },\r\n               conn -> {\r\n                 conn.close();\r\n                 log(\"Closing the connection\");\r\n               }, false))\r\n  .map(resultSet -> {\r\n    log(\"Mapping, connection should be close\");\r\n    // this doesn't need database connection, because it's eagerly fetched by the jdbc client\r\n    return resultSet.getRows();\r\n  })\r\n  .map(rows -> {\r\n    log(\"Mapping again, the connection should be closed\");\r\n\r\n    // sleep to simulate some delay\r\n    try { Thread.sleep(1_000); } catch (InterruptedException e) { }\r\n\r\n    // random\r\n    return rows.get(1);\r\n  });\r\n```\r\n\r\nThe output is the following:\r\n\r\n```\r\n2017-03-08T20:35:33.515 [vert.x-eventloop-thread-0] Fetching connection\r\n2017-03-08T20:35:33.515 [vert.x-eventloop-thread-0] Creating resource\r\n2017-03-08T20:35:33.516 [vert.x-eventloop-thread-0] Doing select on the connection\r\n2017-03-08T20:35:33.518 [vert.x-eventloop-thread-0] Mapping, connection should be close\r\n2017-03-08T20:35:33.519 [vert.x-eventloop-thread-0] Mapping again, the connection should be closed\r\n2017-03-08T20:35:34.525 [vert.x-eventloop-thread-0] Closing the connection\r\n```\r\n\r\nI can upload the project on Github if you want to review.\r\n\r\nThank you."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-09T08:45:14Z",
        "body": "So you need the connection closed before the downstream starts processing the single result set, right? In that case apply `.singleOrError()` before your first map and have the `using` eagerly dispose."
      },
      {
        "user": "kennedyoliveira",
        "created_at": "2017-03-09T12:41:00Z",
        "body": "Yes, that's exactly it, using single worked, now the connection is release before downstream starts to process.\r\n\r\nI was trying to understand the `OperatorSingle`, but i got a little confused with the parent child relationship on subscribing, could you explain it a little?\r\n\r\n```\r\n    @Override\r\n    public Subscriber<? super T> call(final Subscriber<? super T> child) {\r\n\r\n        final ParentSubscriber<T> parent = new ParentSubscriber<T>(child, hasDefaultValue,\r\n                defaultValue);\r\n        child.add(parent);\r\n        return parent;\r\n    }\r\n```\r\n\r\nThank you!\n\n---\n\nAnother thing, i noticed there are 2 single operators, `toSingle` and `single`, one use `Single.create` and other use `lift`, what are the differences between them?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-10T18:17:01Z",
        "body": "I'm sorry, I currently don't have time to educate you personally."
      },
      {
        "user": "kennedyoliveira",
        "created_at": "2017-03-10T19:16:04Z",
        "body": "I see, sorry for taking you time, i appreciate your help."
      }
    ],
    "satisfaction_conditions": [
      "Ensure database connection closure occurs immediately after query execution completes, before downstream processing of results",
      "Provide a mechanism that triggers resource cleanup when the query observable completes, not just on subscription termination",
      "Demonstrate proper use of RxJava resource management patterns for JDBC connections",
      "Explain how operator chaining affects resource disposal timing",
      "Support lazy connection acquisition aligned with RxJava subscription semantics"
    ]
  },
  {
    "number": 5118,
    "title": "Why is there no share or publish/refcount for single?",
    "created_at": "2017-02-19T09:04:44Z",
    "closed_at": "2017-02-19T10:03:00Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5118",
    "body": "RX Java version 2.0.4 - Single doesn't have share/publish/refcount and therefore we can't have hot observables. Is there any reason for the same.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5118/comments",
    "author": "bangarharshit",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-02-19T09:53:14Z",
        "body": "It has a `cache` operator and a `SingleSubject` to help with many cases when the single item should be cached. You can always convert back to `Observable` and have access to the `publish` and `refCount` operators."
      },
      {
        "user": "bangarharshit",
        "created_at": "2017-02-19T10:03:00Z",
        "body": "Got it. Resolving."
      },
      {
        "user": "afaucogney",
        "created_at": "2020-11-04T09:54:21Z",
        "body": "I come back to the issue. Could we have more context about the \"why\" there is no \"share\" operator for single ? Even if we can maybe solve some requirement in another way. Is it by design decision ?"
      },
      {
        "user": "akarnokd",
        "created_at": "2020-11-04T10:02:19Z",
        "body": "We limit the API surface of the library and the need for share in other types is rare."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of the design rationale for omitting share/publish/refcount operators in Single",
      "Confirmation of whether the omission is intentional or a design decision",
      "Identification of valid alternative approaches to achieve hot observable-like behavior with Single"
    ]
  },
  {
    "number": 5095,
    "title": "replay() for Maybe?",
    "created_at": "2017-02-14T01:21:04Z",
    "closed_at": "2017-02-14T21:11:34Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5095",
    "body": "How come there's no `replay()` method for `Maybe`? I'd like to replay the emission of `Maybe` without having to re-execute the expensive operations.\r\n\r\nVersion: 2.0.1\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5095/comments",
    "author": "thelastbirth",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-02-14T08:29:20Z",
        "body": "Have you looked at `cache()`?"
      },
      {
        "user": "thelastbirth",
        "created_at": "2017-02-14T19:17:05Z",
        "body": "`cache()` works. Thanks. I wonder why's the decision not putting `replay()` in `Maybe`?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-02-14T21:11:34Z",
        "body": "There is no notion for connectable-maybe and `cache()` fulfills most of the user demand along with `MaybeSubject`."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why replay() isn't implemented for Maybe type",
      "Identification of alternative approaches to achieve replay functionality",
      "Clarification of architectural constraints affecting Maybe implementation",
      "Coverage of recommended patterns for shared Maybe execution"
    ]
  },
  {
    "number": 5073,
    "title": "2.x - groupBy() Parallelization Not Working like in 1.0",
    "created_at": "2017-02-05T02:24:15Z",
    "closed_at": "2017-02-05T14:16:18Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5073",
    "body": "Hi David, \r\n\r\nWhile I was writing the Packt book, I think I might have found a problem with RxJava 2.0, unless this was an intended change and I'm missing something. When I do the parallelization pattern with `groupBy()` and a modulus Integer, it works fine in RxJava 1.0. Everything parallelizes across multiple threads as expected. \r\n\r\n```java \r\n\r\nimport rx.Observable;\r\nimport rx.schedulers.Schedulers;\r\nimport java.time.LocalTime;\r\nimport java.util.concurrent.ThreadLocalRandom;\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\n\r\npublic class Launcher {\r\n    public static void main(String[] args) {\r\n\r\n       int coreCount = Runtime.getRuntime().availableProcessors();\r\n       AtomicInteger assigner = new AtomicInteger(0);\r\n\r\n       Observable.range(1,10)\r\n               .groupBy(i -> assigner.incrementAndGet() % coreCount)\r\n               .flatMap(grp -> grp.observeOn(Schedulers.io())\r\n                       .map(i2 -> intenseCalculation(i2))\r\n               )\r\n               .subscribe(i -> System.out.println(\"Received \" + i + \" \"\r\n                       + LocalTime.now() + \" on thread \"\r\n                       + Thread.currentThread().getName()));\r\n\r\n       sleep(20000);\r\n    }\r\n\r\n    public static <T> T intenseCalculation(T value) {\r\n        sleep(ThreadLocalRandom.current().nextInt(3000));\r\n        return value;\r\n    }\r\n    public static void sleep(long millis) {\r\n        try {\r\n            Thread.sleep(millis);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**OUTPUT:**\r\n\r\n```\r\nReceived 1 20:17:23.422 on thread RxIoScheduler-2\r\nReceived 3 20:17:23.840 on thread RxIoScheduler-4\r\nReceived 4 20:17:24.053 on thread RxIoScheduler-5\r\nReceived 9 20:17:24.273 on thread RxIoScheduler-2\r\nReceived 5 20:17:24.695 on thread RxIoScheduler-6\r\nReceived 8 20:17:24.950 on thread RxIoScheduler-9\r\nReceived 6 20:17:25.242 on thread RxIoScheduler-7\r\nReceived 7 20:17:25.251 on thread RxIoScheduler-8\r\nReceived 2 20:17:25.324 on thread RxIoScheduler-3\r\nReceived 10 20:17:27.532 on thread RxIoScheduler-3\r\n\r\n```\r\n\r\nBut if I switch to RxJava 2.0, this no longer parallelizes. Everything stays strictly serial and only one thread is used. \r\n\r\n```java\r\n\r\nimport io.reactivex.Observable;\r\nimport io.reactivex.schedulers.Schedulers;\r\n\r\nimport java.time.LocalTime;\r\nimport java.util.concurrent.ThreadLocalRandom;\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\n\r\npublic class Launcher {\r\n    public static void main(String[] args) {\r\n\r\n       int coreCount = Runtime.getRuntime().availableProcessors();\r\n       AtomicInteger assigner = new AtomicInteger(0);\r\n\r\n       Observable.range(1,10)\r\n               .groupBy(i -> assigner.incrementAndGet() % coreCount)\r\n               .flatMap(grp -> grp.observeOn(Schedulers.io())\r\n                       .map(i2 -> intenseCalculation(i2))\r\n               )\r\n               .subscribe(i -> System.out.println(\"Received \" + i + \" \"\r\n                       + LocalTime.now() + \" on thread \"\r\n                       + Thread.currentThread().getName()));\r\n\r\n       sleep(20000);\r\n    }\r\n\r\n    public static <T> T intenseCalculation(T value) {\r\n        sleep(ThreadLocalRandom.current().nextInt(3000));\r\n        return value;\r\n    }\r\n    public static void sleep(long millis) {\r\n        try {\r\n            Thread.sleep(millis);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**OUTPUT:**\r\n\r\n```\r\nReceived 1 20:21:03.321 on thread RxCachedThreadScheduler-1\r\nReceived 9 20:21:05.273 on thread RxCachedThreadScheduler-1\r\nReceived 2 20:21:05.559 on thread RxCachedThreadScheduler-1\r\nReceived 10 20:21:07.390 on thread RxCachedThreadScheduler-1\r\nReceived 3 20:21:10.055 on thread RxCachedThreadScheduler-1\r\nReceived 4 20:21:11.962 on thread RxCachedThreadScheduler-1\r\nReceived 5 20:21:12.850 on thread RxCachedThreadScheduler-1\r\nReceived 6 20:21:15.779 on thread RxCachedThreadScheduler-1\r\nReceived 7 20:21:17.927 on thread RxCachedThreadScheduler-1\r\nReceived 8 20:21:20.540 on thread RxCachedThreadScheduler-1\r\n```\r\n\r\nIs there something new that I'm supposed to do? Or is this a possible behavior regression? ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5073/comments",
    "author": "thomasnield",
    "comments": [
      {
        "user": "thomasnield",
        "created_at": "2017-02-05T02:28:51Z",
        "body": "Hmmm... this makes things more interesting. Using a `subscribeOn()` instead of an `observeOn()` seems to make parallelization work. I don't know if this was intended or not. \r\n\r\n```java\r\n\r\nimport io.reactivex.Observable;\r\nimport io.reactivex.schedulers.Schedulers;\r\n\r\nimport java.time.LocalTime;\r\nimport java.util.concurrent.ThreadLocalRandom;\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\n\r\npublic class Launcher {\r\n    public static void main(String[] args) {\r\n\r\n       int coreCount = Runtime.getRuntime().availableProcessors();\r\n       AtomicInteger assigner = new AtomicInteger(0);\r\n\r\n       Observable.range(1,10)\r\n               .groupBy(i -> assigner.incrementAndGet() % coreCount)\r\n               .flatMap(grp -> grp.subscribeOn(Schedulers.io())\r\n                       .map(i2 -> intenseCalculation(i2))\r\n               )\r\n               .subscribe(i -> System.out.println(\"Received \" + i + \" \"\r\n                       + LocalTime.now() + \" on thread \"\r\n                       + Thread.currentThread().getName()));\r\n\r\n       sleep(20000);\r\n    }\r\n\r\n    public static <T> T intenseCalculation(T value) {\r\n        sleep(ThreadLocalRandom.current().nextInt(3000));\r\n        return value;\r\n    }\r\n    public static void sleep(long millis) {\r\n        try {\r\n            Thread.sleep(millis);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n**OUTPUT:**\r\n\r\n```\r\nReceived 8 20:27:03.291 on thread RxCachedThreadScheduler-8\r\nReceived 6 20:27:03.446 on thread RxCachedThreadScheduler-6\r\nReceived 5 20:27:03.495 on thread RxCachedThreadScheduler-5\r\nReceived 4 20:27:03.681 on thread RxCachedThreadScheduler-4\r\nReceived 7 20:27:03.989 on thread RxCachedThreadScheduler-7\r\nReceived 2 20:27:04.797 on thread RxCachedThreadScheduler-2\r\nReceived 1 20:27:05.172 on thread RxCachedThreadScheduler-1\r\nReceived 9 20:27:05.327 on thread RxCachedThreadScheduler-1\r\nReceived 10 20:27:05.913 on thread RxCachedThreadScheduler-2\r\nReceived 3 20:27:05.957 on thread RxCachedThreadScheduler-3\r\n```\r\n\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-02-05T09:07:25Z",
        "body": "Works for me on RxJava 2.0.5."
      },
      {
        "user": "thomasnield",
        "created_at": "2017-02-05T14:16:18Z",
        "body": "Ah, okay. I was using 2.0.3 where apparently there was an issue. It looks like it was resolved by 2.0.5. Sorry I didn't check that first. "
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why RxJava 2.x groupBy() parallelization behavior differs from 1.x in the original code pattern",
      "Identification of minimum required RxJava 2.x version where parallelization works as expected",
      "Clarification on proper operator combination (subscribeOn vs observeOn) for achieving parallelization in RxJava 2.x",
      "Documentation of threading model changes between RxJava 1.x and 2.x affecting groupBy/flatMap patterns"
    ]
  },
  {
    "number": 5022,
    "title": "Doubt about the terms Upstream vs Downstream",
    "created_at": "2017-01-26T20:07:36Z",
    "closed_at": "2017-01-27T16:00:42Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5022",
    "body": "Hello everyone,\r\n\r\ni'm confused with the terms upstream and downstream, and hope someone could describe better who is who, and maybe illustrate with some examples?\r\n\r\nFor example, the documentation about zipWith in a Flowable:\r\n\r\n`The operator expects backpressure from the sources and honors backpressure from the downstream. (I.e., zipping with interval(long, TimeUnit) may result in MissingBackpressureException, use one of the onBackpressureX to handle similar, backpressure-ignoring sources.`\r\n\r\nHow do i interpret it? The downstream is the source i'm zipping (The parameter of `zipWith`) and the upstream is the `Flowable` i'm calling `zipWith`? ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5022/comments",
    "author": "kennedyoliveira",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-01-26T20:14:40Z",
        "body": "Let me illustrate it:\r\n\r\n```\r\n           upstream                           downstream\r\nsource <------------- operator (parameters) -------------> consumer/further operators\r\n```\r\n\r\nSome operators have multiple upstreams such as `zipWith` which is an instance convenience for `zip(upstream1, upstream2, func2)`."
      },
      {
        "user": "kennedyoliveira",
        "created_at": "2017-01-27T16:00:42Z",
        "body": "Thank you @akarnokd, you made it very clear."
      },
      {
        "user": "keshavvgarg",
        "created_at": "2022-03-10T12:57:22Z",
        "body": "@akarnokd, What does the arrow symbol apply here?"
      }
    ],
    "satisfaction_conditions": [
      "Clear directional relationship illustration between upstream/downstream",
      "Explanation of operator's role in the flow chain",
      "Clarification of multiple upstream scenarios"
    ]
  },
  {
    "number": 5010,
    "title": "How can `.buffer(2,1)` ever emit a list with only one item?",
    "created_at": "2017-01-20T21:07:28Z",
    "closed_at": "2017-01-20T21:19:47Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5010",
    "body": "Using RxJava version 1.2.5. (kotlin code below) \r\n\r\n```\r\nObservable.just(\"1\")\r\n                .startWith(emptyList<String>())\r\n                .buffer(2, 1)\r\n                .map { Pair(it[0], it[1]) } //throws java.lang.IndexOutOfBoundsException: Index: 1, Size: 1\r\n                .subscribe()\r\n\r\n```\r\n\r\nHow can `.buffer(2,1)` ever emit a list with only one item?\r\n\r\n\r\nOr, if you prefer java\r\n\r\n```\r\npublic class BufferTest {\r\n\r\n    @Test\r\n    public void name() throws Exception {\r\n        Observable.just(\"1\")\r\n                .startWith(new ArrayList<String>(0))\r\n                .buffer(2, 1)\r\n                .map(\r\n                        new Func1<List<String>, Pair>() {\r\n                            @Override\r\n                            public Pair call(List<String> list) {\r\n                                return new Pair(list.get(0), list.get(1)); //throws java.lang.IndexOutOfBoundsException: Index: 1, Size: 1\r\n                            }\r\n                        })\r\n                .subscribe();\r\n    }\r\n\r\n    private static class Pair {\r\n        final String first;\r\n        final String second;\r\n\r\n        Pair(String first, String second) {\r\n            this.first = first;\r\n            this.second = second;\r\n        }\r\n    }\r\n}\r\n\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5010/comments",
    "author": "ZakTaccardi",
    "comments": [
      {
        "user": "ZakTaccardi",
        "created_at": "2017-01-20T21:19:47Z",
        "body": "My bad - when the observable completes, the remaining buffer is emitted, hence the exception"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-01-20T21:21:12Z",
        "body": "It's quite easy: if there is a non-empty buffer when `onComplete` arrives, emit it. Operators try to avoid data loss so you can get partial buffers. If you don't want those, filter them out with `filter`."
      },
      {
        "user": "ZakTaccardi",
        "created_at": "2017-01-20T21:39:39Z",
        "body": "yep - that's what I'm doing now. Thanks!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of buffer operator behavior when the source observable completes",
      "Clarification about partial buffer emissions in RxJava",
      "Strategy to handle incomplete buffers",
      "Understanding of data preservation guarantees in RxJava operators"
    ]
  },
  {
    "number": 4995,
    "title": "Share does not work with just() and from()",
    "created_at": "2017-01-14T22:46:02Z",
    "closed_at": "2017-01-19T14:00:58Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4995",
    "body": "Tested with RxJava <= 1.2.5:\r\n\r\nCreating observable with _interval()_:\r\n```java\r\nObservable<Long> interval = Observable.interval(100, TimeUnit.MILLISECONDS);\r\nObservable<Long> source = interval\r\n        .take(2)\r\n        .doOnNext(aLong -> System.out.println(\"Side effect\"));\r\nObservable<Long> published = source.share();\r\nObservable<Zip> zip = Observable.zip(\r\n        published.buffer(2),\r\n        OperatorMinMax.max(published),\r\n        Zip::new\r\n);\r\nzip.toBlocking().single();\r\n```\r\n\r\nresults in (which is **correct** because of the _share()_ operator):\r\n```\r\nSide effect\r\nSide effect\r\n```\r\n\r\nHowever, when creating Observable with _just()_:\r\n```java\r\nObservable<Long> interval = Observable.just(0L, 1L);\r\nObservable<Long> source = interval\r\n        .take(2)\r\n        .doOnNext(aLong -> System.out.println(\"Side effect\"));\r\nObservable<Long> published = source.share();\r\nObservable<Zip> zip = Observable.zip(\r\n        published.buffer(2),\r\n        OperatorMinMax.max(published),\r\n        Zip::new\r\n);\r\nzip.toBlocking().single();\r\n```\r\nthe result is:\r\n```\r\nSide effect\r\nSide effect\r\nSide effect\r\nSide effect\r\n```\r\nwhich is in my opinion **incorrect** as I used the _share()_ operator. The same applies for operators _from()_, _range()_...\r\nIs this a bug, or am I missing something important here?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4995/comments",
    "author": "xdom",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-01-14T22:56:35Z",
        "body": "With `share()`, if the upstream terminates, the internal subscriber count is set to zero. If a new subscriber comes in, that makes `share()` resubscribe to the upstream. \r\n\r\nIn your second case, `just` completes within the buffer size of `zip` and now you have two subscriptions."
      },
      {
        "user": "xdom",
        "created_at": "2017-01-14T23:10:37Z",
        "body": "Thank you @akarnokd for clarification. Can you think of any solution for my issue?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-01-14T23:12:52Z",
        "body": "Use `publish()` and when everything is set up, including the end consumer(s), call `connect()` on the `ConnectableObservable`."
      },
      {
        "user": "xdom",
        "created_at": "2017-01-14T23:18:09Z",
        "body": "Alright, and what if (in my real scenario) I return the zipped observable from a method and thus when subscribing to it, I don't have any access to the `ConnectableObservable`? Am I lost then?"
      },
      {
        "user": "JakeWharton",
        "created_at": "2017-01-14T23:28:30Z",
        "body": "You can use the overload of `publish()` that takes a function.\r\n```java\r\nObservable<Zip> zip = source.publish(published -> {\r\n    return Observable.zip(\r\n          published.buffer(2),\r\n          OperatorMinMax.max(published),\r\n          Zip::new);\r\n});\r\n```"
      },
      {
        "user": "xdom",
        "created_at": "2017-01-14T23:54:24Z",
        "body": "@JakeWharton Looks like this works perfectly! Thank you."
      }
    ],
    "satisfaction_conditions": [
      "Ensures a single subscription to the source observable when using multiple downstream operators",
      "Works with cold observables (like just/from) without requiring manual connection management",
      "Maintains operator composition compatibility (zip, buffer, etc.)",
      "Avoids multiple emission of side effects from the source observable"
    ]
  },
  {
    "number": 4960,
    "title": "1.x Documentation issue for .doOnUnsubscribe()",
    "created_at": "2017-01-05T20:32:20Z",
    "closed_at": "2017-01-05T20:39:32Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4960",
    "body": "Looking at the javadoc for .doOnUnsubscribe, there's a caveat:\r\n\r\n```\r\nNote that terminal events trigger the action unless the Observable is subscribed to via unsafeSubscribe().\r\n```\r\n\r\nRunning a quick test, this seems wrong:\r\n\r\n```\r\nSubscription subscription = Observable.never()\r\n                .doOnSubscribe(() -> Timber.e(\"Sub\"))\r\n                .doOnUnsubscribe(() -> Timber.e(\"Unsub\"))\r\n                .unsafeSubscribe(new Subscriber<Object>() {\r\n                    @Override\r\n                    public void onCompleted() {}\r\n\r\n                    @Override\r\n                    public void onError(Throwable e) {}\r\n\r\n                    @Override\r\n                    public void onNext(Object o) {}\r\n                });\r\n        subscription.unsubscribe();\r\n```\r\n\r\nprints out:\r\n\r\n```\r\nSub\r\nUnsub\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4960/comments",
    "author": "danh32",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-01-05T20:35:09Z",
        "body": "`terminal events == onError | onCompleted`"
      },
      {
        "user": "danh32",
        "created_at": "2017-01-05T20:39:32Z",
        "body": "Yep, sorry! Misreading on my part. It sounded to me like the doOnUnsubscribe action wouldn't trigger in these cases."
      }
    ],
    "satisfaction_conditions": [
      "Clarification of the relationship between unsafeSubscribe() and doOnUnsubscribe() behavior",
      "Clear distinction between terminal events and manual unsubscription triggers",
      "Accurate documentation about action triggers in unsafe subscription scenarios"
    ]
  },
  {
    "number": 4913,
    "title": "2.x: Misbehavior of BehavoirProcessor when converted to Single",
    "created_at": "2016-12-09T11:25:11Z",
    "closed_at": "2016-12-09T14:04:45Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4913",
    "body": "io.reactivex.rxjava2:rxandroid:2.0.1\r\n\r\nI believe `BehaviorProcessor` does not work correctly with `Single` observable. I am using `BehaviorProcessor` similarly to how I used `BehaviorSubject` with RxJava1, but this time with a `Single` observable.\r\n\r\nEvent producer\r\n```java\r\nBehaviorProcessor<Event> bp = BehaviorProcessor.create();\r\n\r\npublic Single<Event> getEvent() {\r\n    return bp.singleOrError();\r\n}\r\n\r\nvoid onEventReceived(Event event) {\r\n    bp.onEvent(event);\r\n    bp.onComplete();\r\n}\r\n```\r\n\r\nEvent observer\r\n```java\r\n\r\nproducer.getEvent().subscribeWith(\r\n    new DisposableSingleObserver<Event>() {\r\n        @Override public void onSuccess(Event value) {\r\n            Log.e(TAG, \"success\");\r\n        }\r\n\r\n        @Override public void onError(Throwable e) {\r\n            Log.e(TAG, \"error\");\r\n        }\r\n    }\r\n);\r\n```\r\n\r\nObserved behavior:\r\n1. If observers get subscribed **before** `onEventReceived()` is called, then all observers receive their `onSuccess()` callback, which is OK.\r\n2. If observers get subscribe **after** `onEventReceived()` (meaning after `onEvent()` and `onComplete()` are emitted), then `Single` receives `java.util.NoSuchElementException`. I believe this is NOT OK. Expected behavoir would be receiveing `onSuccess()` with the last value. This is what `BehaviorProcessor` should do for downstream observers, isn't it? Otherwise it appears to be useless for `Single` observers.\r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4913/comments",
    "author": "sergejsha",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-12-09T13:05:20Z",
        "body": "This is the correct behavior for `BehaviorProcessor`. It doesn't retain the last value if it gets terminated. This has been so since day 1 with `BehaviorSubject` as well. Use `ReplayProcessor.createWithSize(1)` instead."
      },
      {
        "user": "sergejsha",
        "created_at": "2016-12-09T13:33:45Z",
        "body": "This is true what you say. But if I try to keep it not terminated by not calling `onComplete()`, the `Single` doesn't receive `onSuccess()`, which is also ok. Just out of curiosity, what would be the main use case for `BehavoirProcesser` with `Single` then, if later subscriptions always receive `onError()` instead of the most recent item it has observed?"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-12-09T14:00:08Z",
        "body": "I don't understand what you try to achieve here. If you want a `Single` of the latest of the `BehaviorProcessor`, use `take(1).singleOrError()` so a `SingleObserver` will receive at most one success value and disconnect from the `BehaviorProcessor`."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why BehaviorProcessor terminates subsequent subscriptions with NoSuchElementException after completion",
      "Clarification of valid use cases for BehaviorProcessor with Single",
      "Alternative approach to retain last value for late subscribers after termination",
      "Explanation of termination semantics in RxJava2 reactive streams"
    ]
  },
  {
    "number": 4906,
    "title": "The order of `doOnSubscribe` changed in RxJava 2 without documentation",
    "created_at": "2016-12-06T07:10:35Z",
    "closed_at": "2016-12-06T10:04:30Z",
    "labels": [
      "Question",
      "1.x",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4906",
    "body": "We noticed one of our tests failing because or an ordering issue with `doOnSubscribe`. In RxJava 1 downstream `doOnSubcribe` would be called before upstream but it's the reverse in RxJava 2.\r\n\r\nHere's a code snippet that showcases the problem:\r\n```java\r\nObservable.empty()\r\n\t.doOnSubscribe(() -> System.out.println(\"RX1 upstream\"))\r\n\t.doOnSubscribe(() -> System.out.println(\"RX1 downstream\"))\r\n\t.subscribe();\r\n```\r\nThis will produce the following log statements:\r\n```\r\nRX1 downstream\r\nRX1 upstream\r\n```\r\nwhile the following snippet:\r\n```java\r\nio.reactivex.Observable.empty()\r\n\t.doOnSubscribe(d -> System.out.println(\"RX2 upstream\"))\r\n\t.doOnSubscribe(d -> System.out.println(\"RX2 downstream\"))\r\n\t.subscribe();\r\n```\r\nproduces the following statement:\r\n```\r\nRX2 upstream\r\nRX2 downstream\r\n```\r\n\r\nIs this an intended change?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4906/comments",
    "author": "ansman",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-12-06T09:06:46Z",
        "body": "Yes. The 1.x operator is lift based which executes the downstream operations first. In 2.x, the onSubscribe happens starting from upstream travelling downstream like the onNext events. Why do you have order-dependent doOnSubscribe?"
      },
      {
        "user": "ansman",
        "created_at": "2016-12-06T09:46:22Z",
        "body": "We had a test that tested a retry transformer and we needed to simulate getting different errors on different tries. Here's the code that caused the issue:\r\n```java\r\nAtomicInteger subscribeCount = new AtomicInteger(0);\r\nIOException e = new IOException();\r\nRuntimeException re = new RuntimeException();\r\n\r\nObservable\r\n        .defer(() -> subscribeCount.get() >= 2 ?\r\n                Observable.error(re) :\r\n                Observable.concat(Observable.just(\"1\"), Observable.just(\"2\"), Observable.error(e)))\r\n        .doOnSubscribe(subscribeCount::incrementAndGet)\r\n        .compose(retry())\r\n        .subscribe(subscriber);\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-12-06T09:59:32Z",
        "body": "Relplace `get()` with `incrementAndGet()` and drop the `doOnSubscribe()` call."
      },
      {
        "user": "ansman",
        "created_at": "2016-12-06T10:04:30Z",
        "body": "Ok, great!\r\nJust wanted to make sure this wasn't unexpected."
      }
    ],
    "satisfaction_conditions": [
      "Confirmation of whether the reversed execution order of `doOnSubscribe` in RxJava 2 was intentional",
      "Explanation of the design philosophy behind subscription order changes between RxJava versions",
      "Guidance on avoiding order-dependent side effects in reactive streams"
    ]
  },
  {
    "number": 4888,
    "title": "Should a disposed ConnectableObservable replay() still emit?",
    "created_at": "2016-11-28T10:00:15Z",
    "closed_at": "2016-11-28T12:05:55Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4888",
    "body": "I have this test which passes, but I initially expected it (in particular the 2nd `test`) to fail:\r\n\r\n```java\r\n@Test\r\npublic void connectableReplay() throws Exception {\r\n    ConnectableObservable<Integer> just = Observable.just(1).replay();\r\n\r\n    just.test().assertNoValues();\r\n\r\n    Disposable connect = just.connect();\r\n    connect.dispose();\r\n\r\n    just.test()\r\n            .assertValue(1)\r\n            .assertComplete();\r\n}\r\n```\r\n\r\nSo even after a `replay()` ConnectableObservable was disposed it can still emit it's replayed values? Is that the desired behaviour?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4888/comments",
    "author": "Mauin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-28T10:05:48Z",
        "body": "Yes. `connect.dispose` disconnects from the upstream in case it hasn't yet terminated but consumers still get the events received till then."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of the intended lifecycle behavior for disposed ConnectableObservable with replay",
      "Clarification of how disposal affects cached values vs upstream connections",
      "Confirmation of whether this matches RxJava's specified behavior"
    ]
  },
  {
    "number": 4869,
    "title": "RxJava 1.2.1  retryWhen not working on eclipse\uff0cbut working on Android Studio",
    "created_at": "2016-11-20T13:17:37Z",
    "closed_at": "2016-11-26T11:57:31Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4869",
    "body": "The code is as follows:\r\n\r\n```java\r\nstatic int retryCount = 0;\r\n\tprivate static void test5(){\r\n\t\t\r\n\t\tfinal int maxRetries = 3;\r\n\r\n        Observable.create(new Observable.OnSubscribe<Integer>() {\r\n            @Override\r\n            public void call(Subscriber<? super Integer> subscriber) {\r\n                subscriber.onError(new RuntimeException(\"always fails\"));\r\n            }\r\n        })\r\n        .subscribeOn(Schedulers.immediate())\r\n         .retryWhen(new Func1<Observable<? extends Throwable>, Observable<?>>() {\r\n\r\n                    @Override\r\n                    public Observable<?> call(Observable<? extends Throwable> observable) {\r\n                        return observable.flatMap(new Func1<Throwable, Observable<?>>() {\r\n                            @Override\r\n                            public Observable<?> call(Throwable throwable) {\r\n                                if (++retryCount <= maxRetries) {\r\n                                    // When this Observable calls onNext, the original Observable will be retried (i.e. re-subscribed).\r\n                                    System.out.println(\"get error, it will try after \" + 1000 + \" millisecond, retry count \" + retryCount);\r\n                                    return Observable.timer(1000, TimeUnit.MILLISECONDS);\r\n                                }\r\n                                return Observable.error(throwable);\r\n                            }\r\n                        });\r\n                    }\r\n\r\n\r\n                })\r\n                .subscribe(new Subscriber<Integer>() {\r\n\r\n                    @Override\r\n                    public void onCompleted() {\r\n                        System.out.println(\"onCompleted\");\r\n                    }\r\n\r\n                    @Override\r\n                    public void onNext(Integer value) {\r\n                        System.out.println(\"onSuccess value = \" + value);\r\n                    }\r\n\r\n                    @Override\r\n                    public void onError(Throwable error) {\r\n                        System.out.println(\"onError error = \" + error);\r\n                    }\r\n                });\r\n\t\t\r\n\t}\r\n```\r\n\r\n\r\nThank you\uff01",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4869/comments",
    "author": "jdsjlzx",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-20T15:01:33Z",
        "body": "You mean it doesn't compile? It works for me in Eclipse 4.6.1 and when I add `Thread.sleep(10000)`.\n"
      },
      {
        "user": "jdsjlzx",
        "created_at": "2016-11-21T01:53:34Z",
        "body": "it can compile,but the code execution results are different"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-21T07:11:51Z",
        "body": "What results do you get in each case?"
      },
      {
        "user": "jdsjlzx",
        "created_at": "2016-11-23T16:52:47Z",
        "body": "the code execution on eclipse\uff08Only one time\uff09\uff1a\r\nget error, it will try after 1000 millisecond, retry count 1\r\n\r\nthe code execution Android Studio\uff1a\r\nget error, it will try after 1000 millisecond, retry count 1\r\nget error, it will try after 1000 millisecond, retry count 2\r\nget error, it will try after 1000 millisecond, retry count 3\r\nonError error = java.lang.RuntimeException: always fails\r\n\r\nI don't know what reason is this\uff0cwaiting for your reply\uff0cthank you\uff01"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-23T16:58:12Z",
        "body": "Try this:\r\n\r\n```java\r\n```java\r\nstatic int retryCount = 0;\r\nprivate static void test5() throws Exception {\r\n\r\n    final int maxRetries = 3;\r\n    Observable.create(new Observable.OnSubscribe<Integer>() {\r\n            @Override\r\n            public void call(Subscriber<? super Integer> subscriber) {\r\n                subscriber.onError(new RuntimeException(\"always fails\"));\r\n            }\r\n        })\r\n        .subscribeOn(Schedulers.immediate())\r\n         .retryWhen(new Func1<Observable<? extends Throwable>, Observable<?>>() {\r\n\r\n                    @Override\r\n                    public Observable<?> call(Observable<? extends Throwable> observable) {\r\n                        return observable.flatMap(new Func1<Throwable, Observable<?>>() {\r\n                            @Override\r\n                            public Observable<?> call(Throwable throwable) {\r\n                                if (++retryCount <= maxRetries) {\r\n                                    // When this Observable calls onNext, the original Observable will be retried (i.e. re-subscribed).\r\n                                    System.out.println(\"get error, it will try after \" + 1000 + \" millisecond, retry count \" + retryCount);\r\n                                    return Observable.timer(1000, TimeUnit.MILLISECONDS);\r\n                                }\r\n                                return Observable.error(throwable);\r\n                            }\r\n                        });\r\n                    }\r\n\r\n\r\n                })\r\n        .subscribe(new Subscriber<Integer>() {\r\n\r\n            @Override\r\n            public void onCompleted() {\r\n                System.out.println(\"onCompleted\");\r\n            }\r\n\r\n            @Override\r\n            public void onNext(Integer value) {\r\n                System.out.println(\"onSuccess value = \" + value);\r\n            }\r\n\r\n            @Override\r\n            public void onError(Throwable error) {\r\n                System.out.println(\"onError error = \" + error);\r\n            }\r\n        });\r\n\r\n\t\tThread.sleep(10000);  // <--------------------------------------------- let it wait\r\n\t}\r\n```"
      },
      {
        "user": "jdsjlzx",
        "created_at": "2016-11-24T14:22:30Z",
        "body": "Thank you for your plan, it worked\uff01"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-26T11:57:31Z",
        "body": "Great!"
      },
      {
        "user": "flyfire",
        "created_at": "2018-03-13T10:02:29Z",
        "body": "Why does it work?Can somebody explain?"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-03-13T10:05:33Z",
        "body": "@flyfire You have to have the Java main thread sleep a bit, otherwise it quits before the retry can take effect. Standard RxJava schedulers run on daemon threads that are stopped when all other threads, such as the main thread, end."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why the main thread termination affects retryWhen behavior in RxJava",
      "Clarification of daemon thread behavior in RxJava schedulers",
      "Guidance on ensuring proper execution context for asynchronous operations",
      "Environment-agnostic solution principles for RxJava retry mechanisms"
    ]
  },
  {
    "number": 4847,
    "title": "RxJava 1.x onCompleted is never called?",
    "created_at": "2016-11-14T15:33:28Z",
    "closed_at": "2016-11-15T14:20:43Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4847",
    "body": "Hi, \r\n\r\nI have the following code to demonstrate the problem.\r\n\r\n```Java\r\nCountDownLatch latch = new CountDownLatch(1);\r\n        \r\nObservable<Integer> stream1 = Observable.range(1, 3);\r\nObservable<Integer> stream2 = stream1\r\n        .flatMap(a -> {\r\n            return Observable.fromEmitter(emitter -> {\r\n                Thread t = new Thread(() -> {\r\n                    if (a == 3) {\r\n                        emitter.onCompleted();\r\n                    } else {\r\n                        emitter.onNext(a + 1000);\r\n                    }\r\n                });\r\n                System.out.println(Thread.currentThread().getName() + \" Created a-thread for \" + a);\r\n                t.setName(\"a-thread\");\r\n                t.start();\r\n            }, Emitter.BackpressureMode.NONE);\r\n        });\r\n        stream2\r\n                .doOnUnsubscribe(()-> System.out.println(Thread.currentThread().getName() + \" Unsubscribed.\"))\r\n                .subscribe(a -> {\r\n                    System.out.println(Thread.currentThread().getName() + \" processing: \" + a);\r\n                },\r\n                System.err::println,\r\n                () -> {\r\n                    System.out.println(Thread.currentThread().getName() + \" processed complete.\");\r\n                    latch.countDown();\r\n                });\r\nlatch.await();\r\n```\r\n\r\nI am expecting \" processed complete.\" will be called but it never did. I am using rxJava 1.2.2.\r\nAlso, would the Observer#onCompleted being called if the \"emitter.onCompleted()\" had been commented out from the above?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4847/comments",
    "author": "lawkai",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-14T18:03:03Z",
        "body": "You have to call `emitter.onCompleted()` for all `Observable`s because `flatMap` completes only if both the upstream and all the inner `Observable`s complete. You complete only the `Observable` for `a == 3` and keep the others alive.\n"
      },
      {
        "user": "lawkai",
        "created_at": "2016-11-15T14:20:43Z",
        "body": "Thanks, it did work as expected after I add emitter.onCompleted() for every instance of the Observables from the flatMap.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why Observable completion depends on all inner Observables completing in flatMap",
      "Clarification of completion propagation rules between upstream and inner Observables",
      "Guidance on proper Observable termination requirements"
    ]
  },
  {
    "number": 4840,
    "title": "Why  resubscribe the source observable emit same output when I use retryWhen operator?",
    "created_at": "2016-11-12T09:58:00Z",
    "closed_at": "2016-11-12T21:01:06Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4840",
    "body": "code:\r\n```java\r\nstr = \"aaa\";\r\n        Observable.just(str).map(new Func1<String, String>() {\r\n                    @Override\r\n                    public String call(String s) {\r\n                        Log.i(\"====\", \"s == \" + s);\r\n                        if (\"aaa\".equals(s)) throw new RuntimeException(s);\r\n                        return s + \"123\";\r\n                    }\r\n                }).retryWhen(new Func1<Observable<? extends Throwable>, Observable<?>>() {\r\n                    @Override\r\n                    public Observable<?> call(Observable<? extends Throwable> observable) {\r\n                        return observable.zipWith(Observable.range(1, 4), new Func2<Throwable, Integer, Integer>() {\r\n                            @Override\r\n                            public Integer call(Throwable throwable, Integer i) {\r\n                                str = \"ggg\";\r\n                                return i;\r\n                            }\r\n                        }).flatMap(new Func1<Integer, Observable<? extends Long>>() {\r\n                            @Override\r\n                            public Observable<? extends Long> call(Integer retryCount) {\r\n                                return Observable.timer(1, TimeUnit.SECONDS);\r\n                            }\r\n                        });\r\n                    }\r\n                }).subscribe(new Action1<String>() {\r\n                    @Override\r\n                    public void call(String s) {\r\n                        Log.i(\"====k\", \"s = \" + s);\r\n                    }\r\n                }, new Action1<Throwable>() {\r\n                    @Override\r\n                    public void call(Throwable throwable) {\r\n                        Log.i(\"====\", \"throwable = \" + throwable.getMessage());\r\n                    }\r\n                });\r\n```\r\nIn my opinion\uff0cit should log\r\n```\r\naaa\r\nggg\r\nggg\r\n...\r\n```\r\nbut in fact it always log\r\n```\r\naaa\r\naaa\r\naaa\r\n...\r\n```\r\nwhy?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4840/comments",
    "author": "fanturbo",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-12T11:10:48Z",
        "body": "`Observable.just(str)` captures `str`'s value and is a constant `Observable` in this regard, no matter how `str` changes afterwards. Use `Observable.fromCallable(() -> str)` to get a fresh value each time there is a retry.\n"
      },
      {
        "user": "fanturbo",
        "created_at": "2016-11-12T12:50:26Z",
        "body": "@akarnokd When I use retrofit & rxjava in project,api return type is Observable,is it a constant Observable?I use cookie in request,and when cookie is invalid,i request new cookie(cookie is a String type member variable) in retrywhen and i got same error from server afterwards because the cookie is old cookie.Why is Observable.just(str) a constant Observabl?Is it because of str's String type?or other reasons?Thanks for your reply.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-12T12:59:01Z",
        "body": "Let me illustrate the situation with a classical example program:\n\n``` java\npublic class Example {\n    static String str;\n\n    public static void main(String[] args) {\n        str = \"aaa\";\n\n        String local = str;\n\n        str = \"ggg\";\n\n        System.out.println(local);\n        System.out.println(local);\n        System.out.println(local);\n    }\n}\n```\n\nCan you tell what this program prints to the console?\n"
      },
      {
        "user": "fanturbo",
        "created_at": "2016-11-12T13:09:14Z",
        "body": "@akarnokd I got it.Thanks for your example.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-12T21:01:06Z",
        "body": "Great. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      },
      {
        "user": "fanturbo",
        "created_at": "2016-11-22T01:49:03Z",
        "body": "@akarnokd \r\nI am sorry about  so late to ask this.\r\nI use rxjava&retrofit in my project.\r\n`@GET(\"group/{id}/users\")\r\nObservable<List<User>> groupList(@Path(\"id\") int groupId);`\r\nIs this return Observable also a constant Observable ?"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-22T07:55:47Z",
        "body": "No."
      },
      {
        "user": "fanturbo",
        "created_at": "2016-11-22T09:21:23Z",
        "body": "@akarnokd okay,it's the same question.groupId is member variable,when i first request from server i set groupid 0 and server return 404.and in retrywhen i changed groupId value,but i find in charles that in Request groupId is 0,too.(Now i use OkHttp interceptor to resolve this problem.But i want to know why groupId didn't change in second retry?)"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-22T09:27:49Z",
        "body": "How do you call `groupList()`? If you call it once and resubscribe to the returned Observable, that request path `id` is baked in:\r\n\r\n```java\r\nint groupId = 0;\r\n\r\nObservable<List<User>> obs1 = groupList(groupId);\r\n\r\ngroupId = 1;\r\n\r\nobs1.subscribe(v -> { }, Throwable::printStackTrace);\r\n```\r\n\r\nDo you think the last line will request with `groupId == 1` ?"
      },
      {
        "user": "fanturbo",
        "created_at": "2016-11-22T09:57:42Z",
        "body": "```java\r\nApiClient.groupList(groupId)\r\n                .map(new Func1<List<User>, List<User>>() {\r\n                    @Override\r\n                    public List<User> call(List<User> list) {\r\n                        if (list.size() == 0) {\r\n                            throw new RuntimeException(\"gg\");\r\n                        }\r\n                        return list;\r\n                    }\r\n                })\r\n                .retryWhen(new RetryWithDelay(3, 2000))\r\n                .subscribeOn(Schedulers.io())\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribe(new Action1<List<User>>() {\r\n                    @Override\r\n                    public void call(List<User> response) {\r\n                        fillData(response);\r\n                    }\r\n                }, new Action1<Throwable>() {\r\n                    @Override\r\n                    public void call(Throwable throwable) {\r\n                        Log.i(\"===========k3\", throwable.toString());\r\n                    }\r\n                });\r\n```\r\nthis is my code.I change groupId in RetryWithDelay's call method.what's wrong with the code?\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-22T10:13:55Z",
        "body": "You don't seem to understand how a value read from a variable won't change if you change the variable. Use `defer`:\r\n\r\n```java\r\nObservable.defer(() -> ApiClient.groupList(groupId))\r\n   // ... the rest\r\n```"
      },
      {
        "user": "fanturbo",
        "created_at": "2016-11-22T14:22:29Z",
        "body": "@akarnokd yes,I didn't understand where differences are between Observable.just and Observable.fromCallable.Since you say 'No',I think retrofit's return Observable is like Observable.fromCallable,it is not a constant Observable and it will use fresh value when retry again.\r\nBut i was wrong.retrywhen operator's meaning is resubscribe source Observable,in my code,it is constant because ApiClient.groupList(groupId)) has produced,it is like Observable.just.(I think you should say 'Yes' because I think retrofit's return Observable is like a constant Observable) But when use \r\nObservable.defer,the result is different because defer operator decides the Observable is new(use fresh variable) when subscribe.\r\nThanks for your help!love you!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why Observable.just(str) retains the initial value during retries",
      "Clarification of how variable binding works in Observable creation vs resubscription",
      "Guidance on creating fresh observable sources during retries",
      "Differentiation between eager vs deferred parameter evaluation in Observables",
      "Explanation of Observable lifecycle in retryWhen operator"
    ]
  },
  {
    "number": 4829,
    "title": "subscribeOn (rx.Scheduler) in Observable\u00a0cannot be applied to (io.reactivex.Scheduler) ",
    "created_at": "2016-11-10T07:49:33Z",
    "closed_at": "2016-11-10T15:34:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4829",
    "body": "   Gradle:\r\n    // \u7f16\u8bd1RxJava\r\n    compile 'io.reactivex:rxjava:1.2.2'\r\n    // \u7f16\u8bd1RxAndroid\r\n    compile 'io.reactivex:rxandroid:1.2.1'\r\n    // \u7f16\u8bd1Retrofit\u7f51\u7edc\u52a0\u8f7d\u6846\u67b6\r\n    compile 'com.squareup.retrofit2:retrofit:2.1.0'\r\n    // \u7f16\u8bd1Retrofit\u7f51\u7edc\u52a0\u8f7d\u6846\u67b6\u76f4\u63a5\u89e3\u6790JSON\u6570\u636e\u53d8\u6210JAVA\u5bf9\u8c61\r\n    compile 'com.squareup.retrofit2:converter-gson:2.1.0'\r\n    // \u7f16\u8bd1Retrofit\u5bf9RxJava\u7684\u652f\u6301\r\n    compile 'com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0'",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4829/comments",
    "author": "ljf1172361058",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-10T08:26:37Z",
        "body": "You have the wrong imports:\n\n```\ncompile 'io.reactivex.rxjava2:rxjava:2.0.0'\ncompile 'io.reactivex.rxjava2:rxandroid:2.0.0'\n```\n"
      },
      {
        "user": "ljf1172361058",
        "created_at": "2016-11-10T09:24:37Z",
        "body": "@akarnokd thank you\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-10T15:34:52Z",
        "body": "You are welcome.\n"
      }
    ],
    "satisfaction_conditions": [
      "Resolve version incompatibility between RxJava and Retrofit adapter",
      "Ensure consistent RxJava major version across all dependencies",
      "Maintain functional integration between Retrofit and RxJava"
    ]
  },
  {
    "number": 4821,
    "title": "Question: Observable no longer throwing MissingBackpressureException",
    "created_at": "2016-11-08T09:57:47Z",
    "closed_at": "2016-11-08T10:28:24Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4821",
    "body": "Hello, \r\nI understand as with RxJava2.x that Observable is not backpressure aware by default.\r\nI had a piece of code that I was expecting to throw MissingBackpressureException. It did with RxJava1.x\r\n\r\n```\r\nObservable.create(subscriber -> {\r\n            log.info(\"Started emitting\");\r\n\r\n            for (int i = 0; i < 200; i++) {\r\n                log.info(\"Emitting {}\", i);\r\n                subscriber.onNext(i);\r\n            }\r\n\r\n            subscriber.onComplete();\r\n        });\r\nobservable = observable\r\n                .observeOn(Schedulers.io());\r\n        CountDownLatch latch = new CountDownLatch(1);\r\n        observable.subscribe(slowObserver(latch));\r\n        Helpers.wait(latch);\r\n\r\n\r\n    private <T> Observer<T> slowObserver(CountDownLatch latch) {\r\n        return new Observer<T>() {\r\n            @Override\r\n            public void onSubscribe(Disposable d) {\r\n            }\r\n\r\n            @Override\r\n            public void onNext(Object value) {\r\n                log.info(\"Got {}\", value);\r\n                Helpers.sleepMillis(100);\r\n            }\r\n\r\n            @Override\r\n            public void onError(Throwable err) {\r\n                log.error(\"Subscriber got error\", err);\r\n                latch.countDown();\r\n            }\r\n\r\n            @Override\r\n            public void onComplete() {\r\n                log.info(\"Completed\");\r\n                latch.countDown();\r\n            }\r\n        };\r\n    }\r\n```\r\nI see that the buffer size should be Integer.getInteger(\"rx2.buffer-size\", 128) - and it's 128 in my case, however no exception is thrown.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4821/comments",
    "author": "balamaci",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-08T10:15:15Z",
        "body": "`Observable` operators use unbounded buffers which use linked arrays, of lenght 128 each section by default, to reduce allocation pressure. They are not there to limit the element count travelling through.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of RxJava 2.x buffer management differences compared to 1.x",
      "Identification of conditions that trigger MissingBackpressureException in RxJava 2.x",
      "Clarification of how 'rx2.buffer-size' property affects Observable behavior",
      "Differentiation between bounded vs unbounded buffering strategies in RxJava 2.x"
    ]
  },
  {
    "number": 4814,
    "title": "java.io.InterruptedIOException: thread interrupted ",
    "created_at": "2016-11-06T14:15:01Z",
    "closed_at": "2016-11-12T18:09:14Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4814",
    "body": "when i use retrofit and rxjava download file with progress.\r\n``` java\r\n11-03 22:52:35.048 18649-18699/better.hello W/System.err: java.io.InterruptedIOException: thread interrupted\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okio.Timeout.throwIfReached(Timeout.java:145)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okio.Okio$2.read(Okio.java:137)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okio.AsyncTimeout$2.read(AsyncTimeout.java:238)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okio.RealBufferedSource.read(RealBufferedSource.java:45)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okhttp3.internal.http.Http1xStream$FixedLengthSource.read(Http1xStream.java:381)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okio.RealBufferedSource.read(RealBufferedSource.java:45)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okio.ForwardingSource.read(ForwardingSource.java:35)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at retrofit2.OkHttpCall$ExceptionCatchingRequestBody$1.read(OkHttpCall.java:279)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okio.RealBufferedSource$1.read(RealBufferedSource.java:386)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at java.io.InputStream.read(InputStream.java:162)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at better.hello.util.FileUtils.writeFile(FileUtils.java:120)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at better.hello.common.UiHelper$1$1.call(UiHelper.java:29)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at better.hello.common.UiHelper$1$1.call(UiHelper.java:26)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at rx.Observable.unsafeSubscribe(Observable.java:10200)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:248)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:148)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at rx.internal.operators.OperatorSubscribeOn$1$1.onNext(OperatorSubscribeOn.java:53)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at retrofit2.adapter.rxjava.OperatorMapResponseToBodyOrError$1.onNext(OperatorMapResponseToBodyOrError.java:41)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at retrofit2.adapter.rxjava.OperatorMapResponseToBodyOrError$1.onNext(OperatorMapResponseToBodyOrError.java:38)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at retrofit2.adapter.rxjava.RxJavaCallAdapterFactory$RequestArbiter.request(RxJavaCallAdapterFactory.java:173)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.operators.OperatorSubscribeOn$1$1$1.request(OperatorSubscribeOn.java:80)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.Subscriber.setProducer(Subscriber.java:211)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.operators.OnSubscribeMap$MapSubscriber.setProducer(OnSubscribeMap.java:102)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.operators.OperatorSubscribeOn$1$1.setProducer(OperatorSubscribeOn.java:76)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.Subscriber.setProducer(Subscriber.java:205)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at retrofit2.adapter.rxjava.RxJavaCallAdapterFactory$CallOnSubscribe.call(RxJavaCallAdapterFactory.java:152)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at retrofit2.adapter.rxjava.RxJavaCallAdapterFactory$CallOnSubscribe.call(RxJavaCallAdapterFactory.java:138)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.Observable.unsafeSubscribe(Observable.java:10200)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.operators.OperatorSubscribeOn$1.call(OperatorSubscribeOn.java:94)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.schedulers.CachedThreadScheduler$EventLoopWorker$1.call(CachedThreadScheduler.java:228)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at java.util.concurrent.FutureTask.run(FutureTask.java:237)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at java.lang.Thread.run(Thread.java:818)\r\n```\r\nthere is my snippet:\r\n``` java\r\nHttpUtil.downFile(mp4_url).subscribeOn(Schedulers.io()).flatMap(new Func1<ResponseBody, Observable<DownloadInfo>>() {\r\n            @Override\r\n            public Observable<DownloadInfo> call(final ResponseBody body) {\r\n                return Observable.create(new Observable.OnSubscribe<DownloadInfo>() {\r\n                    @Override\r\n                    public void call(Subscriber<? super DownloadInfo> subscriber) {\r\n                        FileUtils.writeFile(subscriber, body, fileName);\r\n                    }\r\n                });\r\n            }\r\n        }).unsubscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(new Subscriber<DownloadInfo>() {\r\n            @Override\r\n            public void onCompleted() {\r\n                \r\n            }\r\n\r\n            @Override\r\n            public void onError(Throwable e) {\r\n\r\n            }\r\n\r\n            @Override\r\n            public void onNext(DownloadInfo info) {\r\n\r\n            }\r\n        });\r\n```\r\n``` java\r\npublic static void writeFile(Subscriber<? super DownloadInfo> subscriber, ResponseBody body, String fileName) {\r\n        try {\r\n            File file = getFile(fileName);\r\n            long readSize = 0, length = body.contentLength();\r\n            byte buffer[] = new byte[4096];\r\n            FileOutputStream outputStream = new FileOutputStream(file, true);\r\n            InputStream ins = body.byteStream();\r\n            DownloadInfo info = new DownloadInfo(length);\r\n            while (true) {\r\n                int read = ins.read(buffer);\r\n                if (read <= 0) {\r\n                    subscriber.onCompleted();\r\n                    break;\r\n                }\r\n                outputStream.write(buffer, 0, read);\r\n                readSize += read;\r\n                info.setReadFileSize(readSize);\r\n                info.setProgress(readSize / length);\r\n                subscriber.onNext(info);\r\n                Utils.d(\"Better\", \"\u4e0b\u8f7d\u4e86==\" + readSize + \",total=\" + length);\r\n            }\r\n            if (null != outputStream) {\r\n                outputStream.flush();\r\n                outputStream.close();\r\n            }\r\n            if (null != ins) {\r\n                ins.close();\r\n            }\r\n            if (null!=body){\r\n                body.close();\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            subscriber.onError(e);\r\n        }\r\n    }\r\n```\r\nif i do not call subscriber.onNext(info) in the while circle  ,everything will be ok ,and the file will be download correctly.The place where the error can occur is subscribe.onNext().I just do not known why.\r\nsomeone can help me ?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4814/comments",
    "author": "471448446",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-07T08:12:58Z",
        "body": "First, this looks like to be an unreliable network issue that times out. \n\nSecond, you are sending a mutable object downstream from that `onNext` which can lead to all sorts of undefined behavior. You should send a fresh object on every turn:\n\n``` java\n                DownloadInfo info = new DownloadInfo(length);\n                info.setReadFileSize(readSize);\n                info.setProgress(readSize / length);\n                subscriber.onNext(info);\n```\n\nThird, don't use `Observable.create` but use `Observable.fromEmitter`.\n"
      },
      {
        "user": "471448446",
        "created_at": "2016-11-08T14:45:15Z",
        "body": "@akarnokd Thanks for your reply,according to your advice it did work.This problem troubled me a few days.3Q.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-12T18:09:14Z",
        "body": "Great!\n"
      },
      {
        "user": "rafaelcheckapp",
        "created_at": "2018-12-20T00:26:16Z",
        "body": "Thanks @akarnokd this has been driving me crazy for days, someone left a .create hidden XD"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why mutable objects emitted via onNext() cause concurrency issues in RxJava",
      "Guidance on proper Observable creation patterns for file download operations with progress updates",
      "Patterns for safe progress notification without blocking network I/O threads"
    ]
  },
  {
    "number": 4806,
    "title": "Can I force zip opertaer work on AndroidSchedulers.mainThread()",
    "created_at": "2016-11-04T08:47:24Z",
    "closed_at": "2016-11-04T09:01:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4806",
    "body": "zip combine varlues on the Scheduler which last Observable worked on.\r\nI want zip operate work on AndroidSchedulers.mainThread() or anyone of the Observable Schedulers.\r\n\r\nHow could I do?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4806/comments",
    "author": "lengyue524",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-04T08:50:23Z",
        "body": "2 options\n-  apply `observeOn(AndroidSchedulers.mainThread())` on all of its inputs\n- identity map (or pair up) the zipper function's input, apply `observeOn` after the zip then use `map` to work with the pair/array of values.\n"
      },
      {
        "user": "lengyue524",
        "created_at": "2016-11-04T09:00:52Z",
        "body": "Thanks, It works.\n"
      }
    ],
    "satisfaction_conditions": [
      "Ensures zip operator execution occurs on a specified target scheduler (e.g., AndroidSchedulers.mainThread())",
      "Provides a mechanism to override default zip scheduler inheritance behavior",
      "Maintains proper value synchronization between zipped Observables"
    ]
  },
  {
    "number": 4802,
    "title": "Observable depends on other Observable | Needing both values",
    "created_at": "2016-11-03T20:39:01Z",
    "closed_at": "2016-11-04T12:41:48Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4802",
    "body": "I have an Observable whose emitted item I need for the next Observable but I can't use flatMap() because the method I need to call in the Subscriber needs the result of both Observables.\r\n\r\n```java\r\nservice.getToken(code)\r\n          .subscribe(new Action1<Token>() {\r\n                        @Override\r\n                        public void call(Token token) {\r\n                            service.getProfile(token.getAccessToken())\r\n                                    .subscribe(\r\n                                    new Action1<Profile>() {\r\n                                        @Override\r\n                                        public void call(Profile profile) {\r\n                                            createAccount(token, profile);\r\n                                        }\r\n                                    });\r\n                        }\r\n                    });\r\n```\r\n\r\nAny better approach then this?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4802/comments",
    "author": "metp",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-03T20:56:32Z",
        "body": "Use the `flatMap` that takes a second `Func2`:\n\n``` java\nservice.getToken()\n.flatMap(token -> service.getProfile(token.getAccessToken()),\n    (token, profile) -> { createAccount(token, profile); return true; })\n.subscribe(v -> { }, Throwable::printStackTrace)\n```\n"
      }
    ],
    "satisfaction_conditions": [
      "Combine results from both Observables into a single processing step",
      "Avoid nested subscriptions",
      "Maintain Observable chain error handling",
      "Preserve sequential dependency between Observables"
    ]
  },
  {
    "number": 4781,
    "title": "2.x - the code below Subscription.request(long) in onSubscribe() would't be executed until a flowable were completed",
    "created_at": "2016-10-30T03:51:19Z",
    "closed_at": "2016-10-30T13:38:29Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4781",
    "body": "When a flowable works on the main thread, `request(long)` in `onSubscribe(Subscription)` always calls `onNext(T)` and then `onComplete()`.\nTherefore, the code below `request(long)` in `onSubscribe(Subscription)` would be executed after `onNext(T)` and `onComplete()`.\n\n```\nFlowable.just(1, 2, 3).subscribe(new Subscriber<Integer>() {\n\n  @Override\n  public void onSubscribe(Subscription s) {\n    s.request(Long.MAX_VALUE);\n    System.out.println(\"onSubscribe done\");\n  }\n\n  @Override\n  public void onNext(Integer t) {\n    System.out.println(t);\n  }\n  ...\n}\n```\n\nThe result is always like this.\n\n```\n1\n2\n3\nonComplete called\nonSubscribe done\n```\n\nI can avoid this by calling `request(long)` at the end of `onSubscribe()`.\nHowever, this behavior is different from RxJava 1.x.\n\nAlso, there is a problem to override ResourceSubscriber's onStrat().\nSince `request(long)` acts this way, if I want to do something in `onStart()`, I have to put `super.onStart()` on the bottom of `onStart()`.\n\n```\n@Override\nprotected void onStart() {\n  initialize();\n  super.onStart();\n}\n```\n\nIf I write below, `intitalize()` would be called after `onComplete()`.\n\n```\n@Override\nprotected void onStart() {\n  super.onStart();\n  initialize();\n}\n```\n\nI think that this is a problem since developers always have to care about where they writie a request method.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4781/comments",
    "author": "otal1105",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-30T07:34:46Z",
        "body": "Yes, this is a property of how Reactive-Streams request-onNext pair work. You have to do initialization before you call `request(n)` or make sure whatever you do after is thread-safe when looked at from `onNext`.\n\nI'll update the wiki and mention this case.\n"
      },
      {
        "user": "otal1105",
        "created_at": "2016-10-30T13:38:29Z",
        "body": "Thank you! I checked the updated wiki! I really appreciate your hard working!\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of execution order guarantees between Subscription.request() and subsequent onNext/onComplete calls",
      "Guidance on safe initialization patterns when using request() in Subscriber implementations",
      "Clarification of thread-safety requirements for code following request() calls",
      "Comparison of RxJava 1.x vs 2.x subscription lifecycle differences"
    ]
  },
  {
    "number": 4778,
    "title": "Error handling when operate observable",
    "created_at": "2016-10-28T08:44:29Z",
    "closed_at": "2016-11-12T18:19:12Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4778",
    "body": " when i do operator like Map to observable  ,then  function throws exception ,is there a way to let  the subscriber 's onError know error emit?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4778/comments",
    "author": "julist213",
    "comments": [
      {
        "user": "davidmoten",
        "created_at": "2016-10-28T09:02:12Z",
        "body": "If the exception is  a checked exception then rethrow it wrapped in a RuntimeException (or your own class that extends RuntimeException). A non-checked exception will turn up as an onError emission.\n\n\n---\n\nExample:\n\n``` java\nObservable.just(1)\n  .map(x -> {\n      try { \n          return canThrow(x);\n      } catch (IOException e) { \n          throw new RuntimeException(e);}\n    });\n```\n"
      },
      {
        "user": "julist213",
        "created_at": "2016-10-28T09:20:42Z",
        "body": "@davidmoten thanks ,it's helpful!\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-12T18:19:12Z",
        "body": "Sidenote: you could go with 2.x and avoid these try catches almost always. \n\nIf you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ],
    "satisfaction_conditions": [
      "Ensures exceptions thrown during operator execution propagate to the subscriber's onError handler",
      "Handles both checked and unchecked exceptions appropriately",
      "Works within RxJava's error handling paradigm"
    ]
  },
  {
    "number": 4748,
    "title": "[2.x] sequenceEqual should return a Single, not an Observable?",
    "created_at": "2016-10-21T20:05:12Z",
    "closed_at": "2016-10-21T20:38:21Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4748",
    "body": "sequenceEqual should always emit a single boolean, so should its return value be a Single?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4748/comments",
    "author": "DavidMGross",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-21T20:10:41Z",
        "body": "All `sequenceEqual` calls should return `Single` in RC5. Did you find one which doesn't?\n"
      },
      {
        "user": "DavidMGross",
        "created_at": "2016-10-21T20:38:21Z",
        "body": "My bad... I was looking at 1.x by mistake.\n"
      }
    ],
    "satisfaction_conditions": [
      "Clarification of version-specific behavior for sequenceEqual's return type",
      "Confirmation that sequenceEqual emits exactly one boolean value in the specified version"
    ]
  },
  {
    "number": 4704,
    "title": "2.x: Observable.interval() - why doesn't it have backpressure (Flowable) now (after 1.x)?",
    "created_at": "2016-10-14T06:38:02Z",
    "closed_at": "2016-10-14T08:23:19Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4704",
    "body": "I used to use `Observable.interval()` with `Observable.zip()` and deal with `backpressure`. Now then `backpressure` is implemented via `Flowable`, `Observable.interval()` still returns `Observable`, not `Flowable`. \nHow can it be `Observable` when it is a hot source?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4704/comments",
    "author": "Nexen23",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-14T07:04:30Z",
        "body": "You mixed up a few concepts here. In 2.x the backpressure-enabled type is `Flowable`. `Observable` doesn't have any backpressure. Why would `Observable.interval()` return `Flowable`? In addition, `interval` is cold because it only starts to tick when a `Subscriber`/`Observer` subscribes to it.\n"
      },
      {
        "user": "Nexen23",
        "created_at": "2016-10-14T07:57:21Z",
        "body": "@akarnokd, oww well, haven't expected `Flowable.interval()` to exist.\nYeah, you are right, its cold. What I meant is `interval()` will not wait `Subscriber` to be done with its things and emit next value if `intervalMs` is smaller than time needed for `Subscriber.onNext()`.\nSo, in case of long doing `onNext()`, what will `Observable.interval()` do with `Observable.zip()` after that if it has no `backpressure`? Will it drop all except last value or...?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-14T07:59:14Z",
        "body": "There is no drop there but it will fill in the internal buffer of zip(). If zip is delayed too much, you'll get an `OutOfMemoryError`.\n"
      },
      {
        "user": "Nexen23",
        "created_at": "2016-10-14T08:14:31Z",
        "body": "@akarnokd, have I understood it right that  `2.x Observable.zip(source)` now works like `1.x Observable.zip(source.onBackpressureBuffer())`, maintaining all unobserved data in itself?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-14T08:18:54Z",
        "body": "2.x `Observable.zip` uses an unbounded buffer instead of a bounded one. There is no additional buffer like with 1.x zip+onBackpressureBuffer.\n"
      },
      {
        "user": "Nexen23",
        "created_at": "2016-10-14T08:23:12Z",
        "body": "I got it. Thanks for so fast reply :+1: \n"
      }
    ],
    "satisfaction_conditions": [
      "Clarify the distinction between Observable and Flowable types in RxJava 2.x regarding backpressure handling",
      "Explain the behavior of Observable.zip() with unbounded buffering when sources can't keep up",
      "Differentiate cold vs hot observable characteristics in the context of interval()"
    ]
  },
  {
    "number": 4700,
    "title": "Observable.using async resource factory?",
    "created_at": "2016-10-13T08:17:29Z",
    "closed_at": "2016-10-13T15:43:05Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4700",
    "body": "Hello,\n\ni have a use case where i will use a resource that need to be released after usage, so i thought the `Observable.using` fit in these case, but i obtain the resource from a `Observable` that could do a network call if it's not available local.\n\nThe resource is a session identifier with expiration time, so when it's not expired i have it local and it's fast, otherwise i do a network call, but the problem is, the `Observable.using` resourceFactory (first param), is a `Func0`, and i don't want to block inside it with `toBlocking.single`, how could i use it? Is there any alternative?\n\nHere is an example code, i wan't to remove the blocking part\n\n``` java\nreturn Observable.using(\n      // create resource\n      () -> getSession().toBlocking().single(), // i don't want to do that!\n      // use it\n      session -> doWork(session), // returns a observable\n      // release\n      session -> // release session,\n      true)\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4700/comments",
    "author": "kennedyoliveira",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-13T08:25:04Z",
        "body": "FlatMap over it and have it as a constant in using.\n\n``` java\ngetSession()\n.flatMap(session -> Observable.using(() -> session, s-> doWork(s), s -> { }));\n```\n"
      },
      {
        "user": "kennedyoliveira",
        "created_at": "2016-10-13T15:43:05Z",
        "body": "@akarnokd I just thought about this solution when I woke up, maybe I just needed some sleep haha, anyway thank you! \n"
      }
    ],
    "satisfaction_conditions": [
      "Supports asynchronous resource acquisition without blocking",
      "Maintains proper resource lifecycle management (creation, usage, release)",
      "Integrates with existing RxJava operators in a non-blocking way"
    ]
  },
  {
    "number": 4670,
    "title": "Regarding delayed emissions",
    "created_at": "2016-10-05T11:53:45Z",
    "closed_at": "2016-10-25T13:41:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4670",
    "body": "In my code bbaPi.getProductsNextPage makes an http call and returns an observable. I generate a range of page numbers and pass this to the api call. I want to make this call after every n seconds but currently, when I use the zip operator, the call is sent for all the page numbers and then the emission of the call is delayed by 2 minutes. How can I delay this call by n seconds?\n\n```\n@Override\n    public Observable<List<Product>> getBbProducts(String category, String city) {\n        return bbApi.getProductsList(category, readCookie(objectMapper))\n                .map(response -> BbMapper.mapResponse(ProductPage.class, objectMapper, response))\n                .onBackpressureBuffer()\n                .filter(productPage -> productPage != null)\n                .flatMap(productPage -> {\n                    int totalPages = productPage.getResponse().getTab_info().get(0).getProduct_info().getTot_pages();\n                    int totalProducts = productPage.getResponse().getTab_info().get(0).getProduct_info().getP_count();\n\n                    return Observable.range(1, totalPages)\n                            .onBackpressureBuffer()\n                            .flatMap(new Func1<Integer, Observable<List<Product>>>() {\n                                         @Override\n                                         public Observable<List<Product>> call(Integer integer) {\n                                             long startTime = System.currentTimeMillis();\n                                             return Observable.zip(\n                                                     Observable.interval(1, TimeUnit.SECONDS)\n                                                             .onBackpressureDrop(),\n// This. I want to delay it by n seconds.\n                                                     bbApi.getProductsNextPage(category, readCookie(objectMapper), integer)\n                                                             .onBackpressureBuffer()\n                                                             .flatMap(new Func1<Response, Observable<List<Product>>>() {\n                                                                 @Override\n                                                                 public Observable<List<Product>> call(Response response) {\n                                                                     long endTime = System.currentTimeMillis();\n                                                                     System.out.println(\"Time taken: \" + (endTime - startTime) + \"Page: \" + integer);\n                                                                     return Observable\n                                                                             .from(BbMapper.mapToProductList(objectMapper, response))\n                                                                             .map(all -> BbMapper.mapToProduct(all, city))\n                                                                             .toList()\n                                                                             .subscribeOn(Schedulers.computation());\n                                                                 }\n                                                             })\n                                                             .onBackpressureBuffer()\n                                                     ,\n                                                     (aLong, products) -> products);\n                                         }\n                                     }\n                            )\n                            .onBackpressureDrop()\n                            .flatMap(new Func1<List<Product>, Observable<List<Product>>>() {\n                                @Override\n                                public Observable<List<Product>> call(List<Product> products) {\n                                    return Observable.just(products);\n                                }\n                            });\n                });\n    }\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4670/comments",
    "author": "masterlittle",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-05T12:07:55Z",
        "body": "I don't fully understand what you try to achieve. If you want to retrieve the next page after 2 seconds, you can just flatMap an `interval`:\n\n``` java\nObservable.interval(2, TimeUnit.SECONDS)\n.take(maxPages)\n.onBackpressureDrop()\n.concatMap(v -> service.getPage((int)v + 1))\n...\n\n// or \n\nObservable.range(1, maxPages)\n.concatMap(v -> service.getPage(v).delaySubscription(2, TimeUnit.SECONDS))\n...\n```\n"
      },
      {
        "user": "masterlittle",
        "created_at": "2016-10-05T20:11:00Z",
        "body": "I implemented the first suggestion and it works! thanks\nI have one more query. I am iterating over a list using from() and in each emission I am making http calls using the data from the emission. Currently the http calls of different emissions are interleaved. I want to do do something so that until the result of all http calls for the first emission is not returned it should be blocked and after that, second emission should be emitted. Can it be done?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-05T20:26:22Z",
        "body": "See `concatMapEager` which runs async sources at once but relays values from the first one only until it completes, then relays values from the second one, etc.\n"
      },
      {
        "user": "masterlittle",
        "created_at": "2016-10-06T05:39:45Z",
        "body": "Thanks. I had made a hacky solution in which I ran a loop manually and called a new Subscriber every time in onComplete() and then using a subject. Very ugly code. This may just work. Thanks again.\n\n\n---\n\nThanks @akarnokd . Worked like a dream after I tweaked the maxConcurrent. Another query(sorry), I want to limit the rate of emission. Currently every 2 seconds I receive an emission of 20 items. I want to throttle this to 10 items. I thought of using debounce() with buffer() but I am not sure I will not be losing emissions in the process. I mean if I use a debounce of 2 and a buffer of 10, I will receive a list of 10 items but what will happen to the remaining 10 items? Is there ny other way to do it?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-25T13:41:10Z",
        "body": "Buffer it with 10 size and zip it with a interval.\n\n\n---\n\nI'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ],
    "satisfaction_conditions": [
      "Mechanism to delay HTTP calls by a specified interval between each request",
      "Sequential processing of page requests without interleaving",
      "Backpressure management for controlled emission rates",
      "Non-blocking asynchronous execution with configurable concurrency",
      "Batch processing mechanism for grouped emissions"
    ]
  },
  {
    "number": 4664,
    "title": "2x RxJavaPlugins - 1.x RxJavaHooks using TestScheduler::advanceTimeBy",
    "created_at": "2016-10-03T23:53:21Z",
    "closed_at": "2016-10-04T07:05:38Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4664",
    "body": "I have a question regarding the usage of `TestScheduler` and hooks.\n\nThe next text passes using 1.x version:\n\n``` java\n  @Test public void Verify_Test_Scheduler_Rx1() {\n    rx.schedulers.TestScheduler scheduler = new rx.schedulers.TestScheduler();\n    RxJavaHooks.setOnComputationScheduler(current -> scheduler);\n\n    AtomicInteger flag = new AtomicInteger();\n\n    rx.Observable.just(1)\n        .doOnNext(ignored -> flag.getAndIncrement())\n        .delay(3, TimeUnit.SECONDS)\n        .doOnNext(ignored -> flag.getAndIncrement())\n        .subscribe();\n\n    scheduler.advanceTimeBy(4, TimeUnit.SECONDS);\n\n    assertThat(flag.get(), is(2));\n\n    RxJavaHooks.reset();\n  } \n```\n\n But this one fails, being the flag value 1, instead of 2:\n\n``` java\n@Test public void Verify_Test_Scheduler_Rx2() {\n    TestScheduler scheduler = new TestScheduler();\n    RxJavaPlugins.onComputationScheduler(scheduler);\n\n    AtomicInteger flag = new AtomicInteger();\n\n    Observable.just(1)\n        .doOnNext(ignored -> flag.getAndIncrement())\n        .delay(3, TimeUnit.SECONDS)\n        .doOnNext(ignored -> flag.getAndIncrement())\n        .subscribe();\n\n    scheduler.advanceTimeBy(4, TimeUnit.SECONDS);\n\n    assertThat(flag.get(), is(2));\n\n    RxJavaPlugins.reset();\n  }\n```\n\n  What is the correct usage of `TestScheduler` with `RxJavaPlugins` in 2.x to achieve the same effect that the one recreated in 1.x? \n\n  Thanks. \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4664/comments",
    "author": "VictorAlbertos",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-04T07:00:59Z",
        "body": "``` java\nRxJavaPlugins.setComputationSchedulerHandler(current -> scheduler);\n```\n"
      },
      {
        "user": "VictorAlbertos",
        "created_at": "2016-10-04T07:05:38Z",
        "body": "Right. Thanks @akarnokd \n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how to properly override the computation scheduler in RxJava 2.x using TestScheduler",
      "Clarification on differences between RxJava 1.x Hooks and 2.x Plugins API usage",
      "Demonstration of time advancement that processes all scheduled delayed operations",
      "Guidance on resetting plugin configurations after test completion"
    ]
  },
  {
    "number": 4559,
    "title": "2.x: Single.timeout with Callable<SingleSource<? extends T> other>>",
    "created_at": "2016-09-15T08:36:57Z",
    "closed_at": "2016-09-15T09:03:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4559",
    "body": "Basically I'd like to have a lazy timeout so that I only need to construct the other Single source once the original Single source 'timeouts'\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4559/comments",
    "author": "vanniktech",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-15T08:39:15Z",
        "body": "`Single.defer()`\n"
      },
      {
        "user": "vanniktech",
        "created_at": "2016-09-15T09:03:57Z",
        "body": "That's very smart\n"
      }
    ],
    "satisfaction_conditions": [
      "Solution must defer creation of the fallback Single source until the original source actually times out",
      "Mechanism must handle timeout-triggered fallback initialization without premature execution"
    ]
  },
  {
    "number": 4511,
    "title": "skipUntil with \"empty\" observable causes source obs to never complete.",
    "created_at": "2016-09-08T14:31:02Z",
    "closed_at": "2016-09-08T15:31:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4511",
    "body": "Hello,\n\n``` java\nObservable.interval(1, TimeUnit.SECONDS)\n      .doOnNext(n -> Timber.d(\"firstObs %s\", n))\n      .doOnUnsubscribe(() -> Timber.d(\"onUnsubscribe\"))\n      .doOnCompleted(() -> Timber.d(\"onCompleted\"))\n      .skipUntil(Observable.timer(3, TimeUnit.SECONDS)\n        .flatMap(b -> Observable.empty())\n        .doOnCompleted(() -> Timber.d(\"onCompleted2\")))\n      .subscribe(\n        n -> Timber.d(\"Next? %s\",n),\n        e -> Timber.d(e, \"Err\"),\n        () -> Timber.d(\"Completed\")\n      );\n    Timber.d(\"Ciao\");\n```\n\nLooking at this snippet I would expect \"Completed\" to be triggered upon skipUntil observable completion ('after 3 seconds'). \n\nAfter some time of debugging I found out it's not the case and the Source observable does not get \"onCompleted\" or \"onUnsubscribe\" called when the latter `skipUntil` obs completes its execution.\n\nThis means that the first obs is never gonna end and the emitted items are not going to reach the end of the chain\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4511/comments",
    "author": "vekexasia",
    "comments": [
      {
        "user": "JakeWharton",
        "created_at": "2016-09-08T14:34:29Z",
        "body": "flatMap does not propagate completion events\n"
      },
      {
        "user": "vekexasia",
        "created_at": "2016-09-08T14:52:48Z",
        "body": "why do I get the following output \n\n```\n09-08 16:50:05.670 D/MainActivity: onSubscribe2\n09-08 16:50:05.672 D/MainActivity: onSubscribe\n09-08 16:50:05.674 D/MainActivity: Ciao\n09-08 16:50:06.674 D/MainActivity: firstObs 0\n09-08 16:50:07.674 D/MainActivity: firstObs 1\n09-08 16:50:08.672 D/MainActivity: onCompleted2\n09-08 16:50:08.672 D/MainActivity: onUnsubscribe2\n09-08 16:50:08.674 D/MainActivity: firstObs 2\n09-08 16:50:09.674 D/MainActivity: firstObs 3\n09-08 16:50:10.674 D/MainActivity: firstObs 4\n...\n```\n\nwhen using the following code then?\n\n``` java\nObservable.interval(1, TimeUnit.SECONDS)\n      .doOnNext(n -> Timber.d(\"firstObs %s\", n))\n      .doOnSubscribe(() -> Timber.d(\"onSubscribe\"))\n      .doOnUnsubscribe(() -> Timber.d(\"onUnsubscribe\"))\n      .doOnCompleted(() -> Timber.d(\"onCompleted\"))\n      .skipUntil(Observable.timer(3, TimeUnit.SECONDS)\n        .flatMap(b -> Observable.empty())\n        .doOnCompleted(() -> Timber.d(\"onCompleted2\"))\n        .doOnSubscribe(() -> Timber.d(\"onSubscribe2\"))\n        .doOnUnsubscribe(() -> Timber.d(\"onUnsubscribe2\"))\n      )\n      .subscribe(\n        n -> Timber.d(\"Next? %s\", n),\n        e -> Timber.d(e, \"Err\"),\n        () -> Timber.d(\"Completed\")\n      );\n    Timber.d(\"Ciao\");\n```\n"
      },
      {
        "user": "JakeWharton",
        "created_at": "2016-09-08T14:56:57Z",
        "body": "Because timer completes. I guess you're just using that as an `ignoreElements()`?\n"
      },
      {
        "user": "vekexasia",
        "created_at": "2016-09-08T14:59:19Z",
        "body": "Actually I was hoping that when the skipUntil observable completes, then \"parent\".\"unsubscribe\"  is triggered so that no more elements are sent through the pipeline.\n"
      },
      {
        "user": "JakeWharton",
        "created_at": "2016-09-08T15:00:28Z",
        "body": "`skipUntil` is documented to require an emission to unlatch upstream events so all you need to do is remove your `flatMap`.\n\n> Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n"
      },
      {
        "user": "vekexasia",
        "created_at": "2016-09-08T15:11:48Z",
        "body": "the code above is just as \"sample\". Consider an observable that completes after three seconds without emitting any item (used as skipUntil parameter).\n\nIn such case the first obs will just continue emit its elements without ever completing (and without any chance for the items to reach the end of the chain) \n\n\n---\n\nJust to mention that I rewrote the OperatorSkipUntil so that it unsubscribes from `child` when `other` completes without emitting any element.\n\nI figured it would be something to raise here since someone might expect the same behavior ( if `other` completes without emitting any elements then unsubscribe from `child`)\n"
      },
      {
        "user": "JakeWharton",
        "created_at": "2016-09-08T15:17:01Z",
        "body": "Ahhh, I see. That makes sense I think. I thought you were proposing that it become unlatched when the inner observable completes.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-08T15:22:45Z",
        "body": "Yes, `skipUntil` requires the other `Observable` to signal an item in 1.x and just ignores an empty other `Observable`. In 2.x `skipUntil` enables the gate when the source either signals or just completes.\n\nThis signals-or-completes is a common practice in such operators that take auxiliary sources to trigger one-time events. I guess the 1.x `skipUntil` not opening the gate on a plain `onComplete` is a bug.\n"
      },
      {
        "user": "vekexasia",
        "created_at": "2016-09-08T15:31:59Z",
        "body": "Thank you all :)\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why `skipUntil` does not trigger source observable completion when the controlling observable completes without emitting an item",
      "Identification of the relationship between observable completion events and operator-specific requirements",
      "Clarification of how to achieve desired termination behavior when using completion-only control observables",
      "Differentiation between RxJava 1.x and 2.x behaviors for completion propagation in operators",
      "Addressing the expectation that operator completion should trigger upstream unsubscription"
    ]
  },
  {
    "number": 4489,
    "title": "2.x: SerializedEmitter not implementing Disposable",
    "created_at": "2016-09-06T17:47:50Z",
    "closed_at": "2016-09-06T20:30:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4489",
    "body": "While looking at the different `Observable`/`Single`/`Completable` Emitters I noticed that the ObservableCreate `SerializedEmitter` is the only one not implementing `Disposable` and thus `#dispose`.\n\nIs this intended?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4489/comments",
    "author": "Mauin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-06T19:52:33Z",
        "body": "Yes, you are not supposed to dispose it from inside the emitter callback anyway.\n"
      },
      {
        "user": "Mauin",
        "created_at": "2016-09-06T20:30:44Z",
        "body": "Okay, thanks for the clarification @akarnokd \ud83d\udc4d \n"
      }
    ],
    "satisfaction_conditions": [
      "Clarifies the design intent behind SerializedEmitter not implementing Disposable",
      "Explains why disposing via the emitter callback is discouraged or invalid",
      "Confirms alignment with library design principles"
    ]
  },
  {
    "number": 4477,
    "title": "2.x TestObserver and TestSubscriber for unit testing",
    "created_at": "2016-09-05T15:24:36Z",
    "closed_at": "2016-09-06T08:50:41Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4477",
    "body": "In 1.x I was using `TestSubscriber` to perform assertions in unit tests. But it seems that in 2.x is `TestObserver` the class that we need to use for this matter. Is that correct? And if that's correct, when I should use `TestSubscriber`?\n\nThanks. \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4477/comments",
    "author": "VictorAlbertos",
    "comments": [
      {
        "user": "vanniktech",
        "created_at": "2016-09-05T15:27:33Z",
        "body": "All reactive types also have a built in `test` method that can be used.\n"
      },
      {
        "user": "VictorAlbertos",
        "created_at": "2016-09-05T15:41:47Z",
        "body": "Very handy. Thanks @vanniktech  \n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-06T06:57:26Z",
        "body": "You use `TestSubscriber` with `Flowable` and `TestObserver` with `Observable`. You can test `Single`, `Completable` and `Maybe` by converting them to either `Flowable` or `Observable`, but the built-in `test()`s for these three return `TestObserver`.\r\n"
      },
      {
        "user": "VictorAlbertos",
        "created_at": "2016-09-06T08:50:41Z",
        "body": "Thanks @akarnokd \n"
      },
      {
        "user": "andreathacker",
        "created_at": "2018-03-08T23:19:41Z",
        "body": "In 2.x @akarnokd mentioned that the built-in return for `Single`, `Completable` and `Maybe` is `TestSubscriber` but it looks like it actual default for `Completable` is now `TestObserver`\r\n\r\n```\r\n    @CheckReturnValue\r\n    @SchedulerSupport(SchedulerSupport.NONE)\r\n    public final TestObserver<Void> test() {\r\n        TestObserver<Void> ts = new TestObserver<Void>();\r\n        subscribe(ts);\r\n        return ts;\r\n    }\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-03-08T23:41:11Z",
        "body": "@davidargylethacker Thanks, edited my comment to define the correct type."
      },
      {
        "user": "osvalr",
        "created_at": "2018-07-17T15:31:01Z",
        "body": "Thanks @akarnokd "
      }
    ],
    "satisfaction_conditions": [
      "Clarify the relationship between reactive types (Flowable/Observable/Single/Completable/Maybe) and their corresponding test classes in RxJava 2.x",
      "Explain the specific use cases for TestSubscriber in RxJava 2.x",
      "Address the availability of built-in test() methods across different reactive types",
      "Provide accurate version-specific information about RxJava 2.x testing utilities"
    ]
  },
  {
    "number": 4440,
    "title": "Observable invoked twice on single subscription",
    "created_at": "2016-08-30T05:17:19Z",
    "closed_at": "2016-09-01T16:34:32Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4440",
    "body": "Hi,\nI have a simple use case where f1,  f2 and f3 are observable network calls with the dependency order: f2 -> f1 (f2 depends on f1 )and f3 -> f1 (f3 depends on f1). \nWhen I zip f2 and f3 to produce a combined result, f1 is getting called twice but I want it invoked only once otherwise it defeats the purpose. Could you please advise? I am sure I have the wiring wrong but couldn't figure out where and I tried all options on f1 : cache, share, replay \n\nCode:\n\n``` java\npublic static void main(String[] args) {\n    String id = \"abc\";\n    Observable.zip(T2dependency(id ), T3dependency(id ), \n        new Func2<JsonObject, JsonObject, JsonObject>() {\n\n    @Override\n    public JsonObject call(JsonObject t2Response, JsonObject t3Response) {\n\n     // operations on t2 & t3\n\n        return t2Response;\n    }\n\n    })\n    .subscribe(next -> System.out.println(\"final subscribe o/p: \" + new Gson().toJson(next)),\n        error -> error.printStackTrace());\n}\n\n\nprotected Observable<JsonObject> T2dependency(String id) {\n\n    return getT1info(id)\n    .<JsonObject>flatMap(new Func1<JsonObject, Observable<JsonObject>>() {\n\n        @Override\n        public Observable<JsonObject> call(JsonObject t1Response) {\n            System.out.println(\"T2.t1Response\");\n            return Observable.just(t1Response);\n        }\n    });\n}\n\nprotected Observable<JsonObject> T3dependency(String id) {\n\n    return getT1info(id)\n    .<JsonObject>flatMap(new Func1<JsonObject, Observable<JsonObject>>() {\n\n        @Override\n        public Observable<JsonObject> call(JsonObject t1Response) {\n            System.out.println(\"T3.t1Response\");\n            return Observable.just(t1Response);\n        }\n    });\n}\n\nprotected Observable<JsonObject> getT1info(String id) {\n        return ObservableHttp.createGet(url+id, client).toObservable()\n    .<JsonObject>flatMap(\n            response -> {\n\n                System.out.println(\"calling getT1info: \" + count++ );\n                return response.getContent()\n                        .map(s3 ->{\n                            System.out\n                                    .println(new String(s3));\n                            return new JsonParser().parse(new String(s3)).getAsJsonObject();\n                            }\n                        ); \n                    }\n            )\n            .timeout(3000, TimeUnit.MILLISECONDS)\n        .doOnError(throwable ->\n                System.out.println(\"printing throwable (getT1info): \" + throwable.toString())\n        );\n}\n```\n\nAny advise is greatly appreciated,\nThank you.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4440/comments",
    "author": "udayravuri",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-08-30T07:11:07Z",
        "body": "You can use `publish(Func1)` that will share the underlying source for all consumers within the function call:\n\n``` java\nObservable.range(1, 10)\n.doOnSubscribe(() -> System.out.println(\"Subscribed\"))\n.publish(o -> Observable.zip(o.map(v -> v * 10), o.map(v -> v * 20), (a, b) -> a + \"-\" + b))\n.subscribe(System.out::println, Throwable::printStackTrace);\n```\n"
      },
      {
        "user": "udayravuri",
        "created_at": "2016-09-01T16:34:40Z",
        "body": "It worked perfectly. It took me some time to try out all of my wiring scenarios, especially for the observables that made network calls.\nThank you so much.\n\n\n---\n\nThank you\n"
      }
    ],
    "satisfaction_conditions": [
      "Ensures f1 network call is executed only once when used by multiple dependent observables",
      "Shares a single subscription to f1 across all dependent observables",
      "Works with cold observables representing network calls",
      "Maintains dependency order where f2 and f3 require f1's result"
    ]
  },
  {
    "number": 4438,
    "title": "2.x: Best way to unsubscribe/dispose a Subject subscription?",
    "created_at": "2016-08-29T19:41:55Z",
    "closed_at": "2016-08-29T19:53:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4438",
    "body": "Since there is no longer a `Subscription` returned when subscribing a `Subject` to an `Observable`, looking for the best way unsubscribe/dispose.\n\n``` java\nObservable<Long> observableA = Observable.interval(200, TimeUnit.MILLISECONDS).map(value -> value);\nObservable<Long> observableB = Observable.interval(200, TimeUnit.MILLISECONDS).map(value -> value * 100L);\n\nBehaviorSubject<Long> subject = BehaviorSubject.create();\nsubject.subscribe(System.out::println);\n\nSystem.out.println(\"Subscribing to observableA\");\nobservableA.subscribe(subject);\n\nTimeUnit.SECONDS.sleep(3);\n\n// TODO: How to unsubscribe the subject from upstream observableA before subscribing it to upstream observableB?\n\nSystem.out.println(\"Subscribing to observableB\");\nobservableB.subscribe(subject);\n\nTimeUnit.SECONDS.sleep(3);\n```\n\nWhat I've come up with so far is to `subscribeWith` an object that extends `DisposableObserver` that forwards `onNext`, `onError`, `onComplete` to the subject and use that to `dispose()` at the appropriate time.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4438/comments",
    "author": "paulblessing",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-08-29T19:50:07Z",
        "body": "Yes, that works, also `subscribe(subject::onNext)` etc. where you get back a `Disposable` too.\n"
      },
      {
        "user": "paulblessing",
        "created_at": "2016-08-29T19:53:25Z",
        "body": "Works for me, thanks. Was just trying to make sure I wasn't overlooking something obvious.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-08-29T19:58:25Z",
        "body": "In 2.x, exposing the `dispose()` method is the choice of the consumer `Observer`; this saves us a lot of allocation when such feature is not required.\n"
      }
    ],
    "satisfaction_conditions": [
      "Demonstrates proper lifecycle management for switching a Subject's upstream Observable in RxJava 2.x",
      "Utilizes RxJava 2.x's Disposable mechanism for resource cleanup",
      "Maintains proper event forwarding to Subject while managing subscriptions",
      "Avoids unnecessary resource allocation per RxJava 2.x design principles"
    ]
  },
  {
    "number": 4408,
    "title": "CombineLatest and toList combination.",
    "created_at": "2016-08-23T07:28:11Z",
    "closed_at": "2016-08-24T10:40:51Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4408",
    "body": "Hello, \nThe RexactiveX documentation says : \n\n>  CombineLatest emits an item whenever any of the source Observables emits an item (so long as each of the source Observables has emitted at least one item)\n\nbut when I use combineLatest on a stream converted with toList, the output only produces one element even if the other stream (the one not converted with toList) has many values.\n\nGiving this test :\n\n``` java\nimport org.testng.annotations.Test;\nimport rx.Observable;\n\npublic class CombineLastTest {\n\n    @Test\n    public void testZip() {\n        Observable.combineLatest(//\n                Observable.just(1, 2, 3, 4, 5)//\n                     .doOnNext((integerValue) -> System.out.println(\"First stream value  : \" + integerValue))//\n                     .doOnCompleted(() -> System.out.println(\"First stream complete\")),//\n                Observable.just(\"a\", \"b\", \"c\", \"d\", \"e\")//\n                     .doOnNext((stringValue) -> System.out.println(\"Second stream value : \" + stringValue))//\n                     .toList()//\n                     .doOnNext((stringListValues) -> System.out.println(\"Second stream to list : \" + stringListValues))//\n                     .doOnCompleted(() -> System.out.println(\"Second stream complete\")),//\n                (firstStreamLatestStringValue, secondStreamLatestStringListValue) -> firstStreamLatestStringValue + \" \" + secondStreamLatestStringListValue)//\n            .doOnCompleted(() -> System.out.println(\"Stream is completed\")).subscribe(System.out::println);\n    }\n}\n```\n\nI get :\n\n```\nFirst stream value  : 1\nFirst stream value  : 2\nFirst stream value  : 3\nFirst stream value  : 4\nFirst stream value  : 5\nFirst stream complete\nSecond stream value : a\nSecond stream value : b\nSecond stream value : c\nSecond stream value : d\nSecond stream value : e\nSecond stream to list : [a, b, c, d, e]\n5 [a, b, c, d, e]\nSecond stream complete\nStream is completed\n```\n\nI presume I should get : \n\n```\nFirst stream value  : 1\nFirst stream value  : 2\nFirst stream value  : 3\nFirst stream value  : 4\nFirst stream value  : 5\nFirst stream complete\nSecond stream value : a\nSecond stream value : b\nSecond stream value : c\nSecond stream value : d\nSecond stream value : e\nSecond stream to list : [a, b, c, d, e]\n1 [a, b, c, d, e]\n2 [a, b, c, d, e]\n3 [a, b, c, d, e]\n4 [a, b, c, d, e]\n5 [a, b, c, d, e]\nSecond stream complete\nStream is completed\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4408/comments",
    "author": "sdaclin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-08-23T07:43:11Z",
        "body": "`combineLatest` will run through a synchronous source and only keep its last value. You should swap the two parameters that will yield something like you wanted.\n\nIt is an odd operator because it only works as one expects if the sources emit from the same thread and are naturally interleaved or all have exactly one value to combine. All else is subject to either thread scheduling non-determinism or run-to-end like behavior just like this.\n"
      },
      {
        "user": "sdaclin",
        "created_at": "2016-08-23T08:21:08Z",
        "body": "Ok thank you a lot David for being so fast with your answer. :+1: \nI've swapped the two inputs : \n\n``` java\n@Test\n    public void testZipFixed() {\n        Observable.combineLatest(//\n                                 Observable.just(\"a\", \"b\", \"c\", \"d\", \"e\")//\n                                         .doOnNext((stringValue) -> System.out.println(\"Second stream value : \" + stringValue))//\n                                         .toList()//\n                                         .doOnNext((stringListValues) -> System.out.println(\"Second stream to list : \" + stringListValues))//\n                                         .doOnCompleted(() -> System.out.println(\"Second stream complete\")),//\n                                 Observable.just(1, 2, 3, 4, 5)//\n                                         .doOnNext((integerValue) -> System.out.println(\"First stream value  : \" + integerValue))//\n                                         .doOnCompleted(() -> System.out.println(\"First stream complete\")),//\n                                 (secondStreamLatestStringListValue, firstStreamLatestStringValue) -> firstStreamLatestStringValue + \" \" + secondStreamLatestStringListValue)//\n                .doOnCompleted(() -> System.out.println(\"Stream is completed\")).subscribe(System.out::println);\n    }\n```\n\nAnd now it works as expected :\n\n```\nSecond stream value : a\nSecond stream value : b\nSecond stream value : c\nSecond stream value : d\nSecond stream value : e\nSecond stream to list : [a, b, c, d, e]\nSecond stream complete\nFirst stream value  : 1\n1 [a, b, c, d, e]\nFirst stream value  : 2\n2 [a, b, c, d, e]\nFirst stream value  : 3\n3 [a, b, c, d, e]\nFirst stream value  : 4\n4 [a, b, c, d, e]\nFirst stream value  : 5\n5 [a, b, c, d, e]\nFirst stream complete\nStream is completed\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-08-24T10:40:51Z",
        "body": "Great. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how `combineLatest` interacts with synchronous sources and their emission order",
      "Clarification of how `toList` affects the timing of observable completion and value availability",
      "Guidance on observable ordering to ensure `combineLatest` triggers for all relevant values",
      "Description of `combineLatest`'s behavior when one observable completes before the other starts emitting"
    ]
  },
  {
    "number": 4404,
    "title": "RxJavaObservableExecutionHook for only one Observable?",
    "created_at": "2016-08-22T16:37:57Z",
    "closed_at": "2016-08-24T05:57:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4404",
    "body": "If I understand correctly, using `RxJavaObservableExecutionHook` will respond for all observable calls within my app. Is there a way to hook `RxJavaObservableExecutionHook` into only a single observable? I'd like different hooks for different observables throughout my app.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4404/comments",
    "author": "tir38",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-08-22T16:45:22Z",
        "body": "Use the callbacks of `RxJavaHooks` like `setOnObservableCreate` or `setOnObservableStart` but you'll need to identify your `Observable` or `OnSubscribe` implementation in some way.\n"
      }
    ],
    "satisfaction_conditions": [
      "Solution must enable applying different hooks to different Observable instances",
      "Mechanism to identify specific Observable instances for hook targeting",
      "Avoid global hook behavior affecting all Observables"
    ]
  },
  {
    "number": 4247,
    "title": "Question about SyncOnSubscribe / SubscriptionProducer",
    "created_at": "2016-07-27T15:31:51Z",
    "closed_at": "2016-07-28T07:46:15Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4247",
    "body": "Was diving into those two guys and noticed that in the `SubscriptionProducer#onNext` `actualSubscriber.onNext(value);` is called without checking `isUnsubscribed`. Is this wanted behavior and if so could you explain why?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4247/comments",
    "author": "vanniktech",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-07-27T15:46:07Z",
        "body": "There is a `tryUnsubscribe` after an iteration. \n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why SubscriptionProducer#onNext doesn't check isUnsubscribed before calling actualSubscriber.onNext",
      "Clarification of how unsubscription status is managed in this context",
      "Identification of the architectural pattern or concurrency model that makes this approach safe"
    ]
  },
  {
    "number": 4214,
    "title": "BehaviorSubject that emits last item even after completion",
    "created_at": "2016-07-19T12:37:21Z",
    "closed_at": "2016-07-19T13:12:58Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4214",
    "body": "I'm looking for the following functionality: \n1. A subject that initially works like a BehaviorSubject. If I `create` it with no initial value, any subscribers will wait for the first value before `onNext` is called.\n2. Similarly, if `create` is called with an initial value, then any subscribers will be invoked with `onNext` immediately upon subscription, and after that whenever `onNext` is called on the subject.\n3. Upon calling `onComplete` on the subject, it effectively turns into a ReplySubject with the last emitted event and the completion event. As in, any subscriber that subscribes to the subject after `onComplete` is invoked will immediately be invoked with `onNext(lastItem)` followed by `onComplete()`.\n4. If `onComplete()` is called on the subject before an initial/first item is set/emitted, an error is thrown.\n\nDo something like this exist in RxJava? Cause I couldn't find it, and had to create it on my own. And if not, shouldn't this be a thing? It's sort of a computation that emits intermediate values, until when it's done, after that point it only emits the end-result again and again.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4214/comments",
    "author": "Alxandr",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-07-19T12:45:02Z",
        "body": "You can compose this from existing behavior.\n\n``` java\nReplaySubject.<T>create(1)\n.switchIfEmpty(Observable.<T>error(new IllegalStateException(\"Subject is empty\")));\n```\n"
      },
      {
        "user": "Alxandr",
        "created_at": "2016-07-19T13:12:57Z",
        "body": "Great. This seems to be working. I don't really like the `switchIfEmpty` solution, cause it does not actually throw on `onComplete()` call, but rather emits an error through the observable, but I can deal with that.\n"
      }
    ],
    "satisfaction_conditions": [
      "Emulates BehaviorSubject's initial subscription behavior (immediate emission of latest value or wait for first value)",
      "Transitions to ReplaySubject-like behavior after completion, replaying last value and completion event",
      "Enforces error when completion occurs before any value emission",
      "Leverages existing RxJava components without requiring full custom implementation",
      "Tolerates error emission via Observable chain instead of direct exceptions"
    ]
  },
  {
    "number": 4202,
    "title": "Question about takeUntil and Subscription.unsubscribe()",
    "created_at": "2016-07-14T09:17:49Z",
    "closed_at": "2016-08-16T08:38:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4202",
    "body": "in android ,if I use takeUntil for any network and on activity destroy, I use PublishSubject.onNext(null), the relation is gone; if I use CompositeSubscription.add() for any network and on activity destroy, I use CompositeSubscription.unsubscribe(), the relation is gone. what is different ?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4202/comments",
    "author": "caoguodong",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-07-14T10:10:07Z",
        "body": "I'm sorry, I can't understand what you are asking. Could you post some example code?\n"
      },
      {
        "user": "alexandru-calinoiu",
        "created_at": "2016-07-14T11:02:41Z",
        "body": "You will have better luck with this type of questions on stackoverflow, the editing system there allows other people to help out with the actual question.\n\nJust use the rxjava tag.\n"
      },
      {
        "user": "caoguodong",
        "created_at": "2016-07-15T02:20:41Z",
        "body": "@akarnokd \nI'm sorry about my english, and I give some code in android.\n\n``` java\nPublishSubject<Void> detachSignal = PublishSubject.create();\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        Observable<Object> observable = Observable.create(new Observable.OnSubscribe<Object>() {\n            @Override\n            public void call(Subscriber<? super Object> subscriber) {\n                System.out.print(\"this is a network\");\n            }\n        });\n\n        observable.takeUntil(detachSignal)\n                .subscribe(new Action1<Object>() {\n                    @Override\n                    public void call(Object o) {\n\n                    }\n                });\n\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        detachSignal.onNext(null);\n    }\n```\n\n``` java\nprivate CompositeSubscription mSubscription;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        mSubscription.add(Observable.create(new Observable.OnSubscribe<Object>() {\n            @Override\n            public void call(Subscriber<? super Object> subscriber) {\n                System.out.print(\"this is a network\");\n            }\n        }).subscribe(new Action1<Object>() {\n            @Override\n            public void call(Object o) {\n\n            }\n        }));\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        mSubscription.unsubscribe();\n    }\n```\n\nwhat is different for destroy the relation between Observer and  the Observered\n\n\n---\n\n@alexandru-calinoiu \nthank you for you notice\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-07-15T07:07:14Z",
        "body": "They should be functionally identical if there is only a single consumer.\n"
      },
      {
        "user": "caoguodong",
        "created_at": "2016-07-18T02:30:37Z",
        "body": "@akarnokd thank you for your answer and if there are several consumer \uff0c have any different\uff1f\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-07-18T06:51:47Z",
        "body": "The `detach` is shared between all of them so if you signal with it, all the other consumers and any future consumers will be completed.\n"
      },
      {
        "user": "caoguodong",
        "created_at": "2016-07-19T02:38:53Z",
        "body": "@akarnokd thank you so much, I got it.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-08-16T08:38:52Z",
        "body": "I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explain the difference in termination scope between `takeUntil` with a shared signal and `CompositeSubscription.unsubscribe()`",
      "Compare resource management implications of both approaches",
      "Clarify the propagation mechanism for termination in both approaches",
      "Address impact on future subscriptions after termination"
    ]
  },
  {
    "number": 4164,
    "title": "Method for shutdown CachedObservable",
    "created_at": "2016-07-05T07:41:57Z",
    "closed_at": "2016-07-05T08:34:39Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4164",
    "body": "I have endless stream (which is not called onComplete at all). And I cache last value in it:\n\n```\nObservable<T> endlessStream = createStream().cache();\n\nSubscription s1 = endlessStream.subscribe(...)\nSubscription s2 = endlessStream.subscribe(...)\n```\n\nBy some condition endlessStream become not valid and I replace it (with switchMap, but it's not important).\n\n```\ns1.unsubscribe()\ns2.unsubscribe()\n```\n\nBut CachedObservable will always store connection to source stream (returned from createStream()). This leads to memory leak. How to disconnect CachedObservable from source observable?\n\nMore information:\n\nCachedObservable contains field state, which contain SerialSubscription to source observables (connection). If I call next hack, everything becomes OK:\n\n```\nprivate void disconnectCachedObservable(CachedObservable<T> observable) {\n    try {\n        Field fieldState = CachedObservable.class.getDeclaredField(\"state\");\n        fieldState.setAccessible(true);\n        Object state = fieldState.get(observable);\n        Field fieldConnection = state.getClass().getDeclaredField(\"connection\");\n        fieldConnection.setAccessible(true);\n        SerialSubscription subscription = (SerialSubscription) fieldConnection.get(state);\n        subscription.unsubscribe();\n    } catch (NoSuchFieldException e) {\n        e.printStackTrace();\n    } catch (IllegalAccessException e) {\n        e.printStackTrace();\n    }\n}\n```\n\nBut reflection isn't good solution:(\n\nMaybe create public method it?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4164/comments",
    "author": "HotIceCream",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-07-05T08:19:59Z",
        "body": "You can use \n\n``` java\nreplay().autoConnect(1, toStop -> { /* store Subscription to cancel later */ });\n```\n\nwhich let's you stop the upstream by giving you a `Subscription`.\n"
      },
      {
        "user": "HotIceCream",
        "created_at": "2016-07-05T08:34:39Z",
        "body": "Oh yes. It's help. Thank you!\nI tried replay + autoConnect, but didn't know about second argument in autoConnect.\n"
      }
    ],
    "satisfaction_conditions": [
      "Provides a way to terminate the upstream connection of a cached observable without reflection",
      "Uses supported RxJava API mechanisms for subscription management",
      "Allows explicit control over when to stop the source stream",
      "Avoids maintaining dangling subscriptions after unsubscribing all observers"
    ]
  },
  {
    "number": 3976,
    "title": "Only part of chain executed after exception",
    "created_at": "2016-05-31T17:30:20Z",
    "closed_at": "2016-06-05T09:49:33Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3976",
    "body": "Hi. Rx java is pretty new to me and I have one problem that I can't understand. After exception only part of my operator chain is executed for next objects and I don't know why. \nI have kafka consumer that polls server for messages and then turns them in infinitie observable:\n\n<!-- language: lang-java-->\n\n```\npublic Observable<Event> consume() {\n    return Observable.create(subscriber -> {\n        try {\n            consumer.subscribe(Arrays.asList(topic));\n\n            while (running) {\n                ConsumerRecords<String, Event> records = consumer.poll(pollTimeout);\n                for (TopicPartition partition : records.partitions()) {\n                    for (ConsumerRecord<String, Event> record : records.records(partition)) {\n                        Event event= record.value();\n                        subscriber.onNext(event);\n\n                        long offfset = record.offset() + 1;\n                        consumer.commitSync(Collections.singletonMap(partition, new OffsetAndMetadata(offfset)));\n                        LOGGER.info(\"Comitted offset \"+offfset);\n                    }\n                }\n            }\n            subscriber.onCompleted();\n        } catch (Exception ex) {\n            LOGGER.error(\"Exception thrown during events consuming\", ex);\n            subscriber.onError(ex);\n        }\n    });\n}\n```\n\nAnd here is my problem:\n\n```\n    public Observable<ProcessDoneEvent> doSth(Event event) {\n    String vin = event.getVin();\n    return vehicleStateRepository.getState(vin)\n            .filter(state -> shouldProcess(state, event))\n            .flatMap((State state) -> {\n                return backendService.getVehicle(vin)\n                        .map(this::getCarLicense)\n                        .flatMap((CarLicense carLicense) -> api.apiAction(carLicense)\n                                .map((ActionConfirmation confirmation) -> {\n                                    log(carLicense, confirmation, event);\n                                    return confirmation;\n                                })\n                                .flatMap((ActionConfirmation t) -> {\n                                    return vehicleStateRepository.saveState(vin, State.IDLE)\n                                            .map((String sth) -> createProcessDoneEvent(vin));\n                                }));\n            });\n}\n```\n\nIn normal situation all operators are executed, state is fetched from db, api is called and finally vehicle state is saved in db. And this is working fine for any amount of events.\n\nNow lets consider situation that timeout occurred in backendService.getVehicle(vin). Exception is handled in retry operator and we are ready for next events. And now what happens - for next events, only lines above api.apiAction(carLicense)(including) are executed and lines below are skipped. So result is that: vehicle state is fetched, api is called and then control returns to loop in message consumer so it's committing new offset without saving vehicle state to db and logging it. \n\nWhy is this happening? :(\n\nAlso here is code with subscription:\n\n```\n    public void startConsuming() {\n\n    consumer.consume() <- code in first posted snipplet\n            .flatMap(this::doAction)\n            .retry((count, e) -> {\n                LOGGER.error(\"aaaaaaaa\", e);\n                return true;\n            }).subscribe(subscriber);\n}\n\nprivate Observable<ProcessDoneEvent> doAction(Event event) {\n    if (Event.getEventType().equals(EventType.TYPE_ONE)) {\n        return process.doSth(event); <- this is method posted above\n    } else {\n        return process.doSthOther(event);\n    }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3976/comments",
    "author": "slawomirbiernacki",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-05-31T20:12:29Z",
        "body": "For one, you didn't implement unsubscription in your `create`d `Observable` properly. You should check `subscriber.isUnsubscribed()` and quit the method if `true`. Second, many operators have either variants or parameters that allow delaying errors to the end, they should allow you to finish up with good values before failing/retrying.\n"
      },
      {
        "user": "slawomirbiernacki",
        "created_at": "2016-06-05T09:49:03Z",
        "body": "I changed my consumer loop to exit when subscriber.isUnsubscribed() and it looks like it was it! I will make further tests, please don't close issue yet but thank you very very much for now.\n\n\n---\n\nok everything is ok now. Thank you one more time.\n"
      }
    ],
    "satisfaction_conditions": [
      "Proper handling of unsubscription in the custom Observable implementation",
      "Correct Observable lifecycle management for long-running consumers"
    ]
  },
  {
    "number": 3967,
    "title": "error when Zipping 2 publish subjects asynchroneously",
    "created_at": "2016-05-26T09:16:52Z",
    "closed_at": "2016-05-26T09:57:33Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3967",
    "body": "Hi,\n\nI'm having some weird problem I've tried to simplify.\n\nTake for instance the following code:\n\n``` java\n        for (int i = 0; i < 500; i++) {\n            Subject<Integer, Integer> s1 = PublishSubject.<Integer> create().toSerialized();\n            Subject<Integer, Integer> s2 = PublishSubject.<Integer> create().toSerialized();\n\n            Observable.zip(s1.single(), s2.toList(), (a, b) -> null)\n                .subscribeOn(Schedulers.io())\n                .subscribe(\n                    j -> {},\n                    t -> {\n                        t.printStackTrace();\n                    });\n\n            s1.onNext(1);\n            s2.onNext(1);\n            s1.onCompleted();\n            s2.onCompleted();\n        }\n        Thread.sleep(5000);\n```\n\nI'm often getting the following error:\n\n```\njava.util.NoSuchElementException: Sequence contains no elements\n    at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:131)\n    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:140)\n    at rx.subjects.SubjectSubscriptionManager$SubjectObserver.accept(SubjectSubscriptionManager.java:318)\n    at rx.subjects.SubjectSubscriptionManager$SubjectObserver.emitLoop(SubjectSubscriptionManager.java:291)\n    at rx.subjects.SubjectSubscriptionManager$SubjectObserver.emitFirst(SubjectSubscriptionManager.java:270)\n    at rx.subjects.PublishSubject$1.call(PublishSubject.java:66)\n    at rx.subjects.PublishSubject$1.call(PublishSubject.java:62)\n    at rx.subjects.SubjectSubscriptionManager.add(SubjectSubscriptionManager.java:95)\n    at rx.subjects.SubjectSubscriptionManager.call(SubjectSubscriptionManager.java:60)\n    at rx.subjects.SubjectSubscriptionManager.call(SubjectSubscriptionManager.java:35)\n    at rx.Observable.unsafeSubscribe(Observable.java:8172)\n    at rx.subjects.SerializedSubject$1.call(SerializedSubject.java:45)\n    at rx.subjects.SerializedSubject$1.call(SerializedSubject.java:41)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable.unsafeSubscribe(Observable.java:8172)\n    at rx.internal.operators.OperatorZip$Zip.start(OperatorZip.java:209)\n    at rx.internal.operators.OperatorZip$ZipSubscriber.onNext(OperatorZip.java:156)\n    at rx.internal.operators.OperatorZip$ZipSubscriber.onNext(OperatorZip.java:122)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable.unsafeSubscribe(Observable.java:8172)\n    at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\n```\n\nI'm not sure what's going wrong here. It would seem that from time to time, the `s1` subject receives the onCompleted before the onNext.\n\nI saw that removing `.subscribeOn(Schedulers.io())` fixes this but I'd like to understand why.\nDepending on that I could come up with an other solution to what i'm trying to do.\n\nThanks\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3967/comments",
    "author": "Crystark",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-05-26T09:25:37Z",
        "body": "Because you subscribe on a different thread, the two subjects don't have any subscriber yet when you call onXXX on them, dropping the values. Once zip can subscribe, both may end up being completed and thus the first source will signal the `NoSuchElementException`. \n"
      },
      {
        "user": "Crystark",
        "created_at": "2016-05-26T09:50:25Z",
        "body": "Indeed, I can see it now. Thanks for the explanation.\nSo if I understand this well, using a `ReplaySubject` seems to be the way to go if I want to keep this order of code ?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-05-26T09:51:50Z",
        "body": "Yes.\n"
      },
      {
        "user": "Crystark",
        "created_at": "2016-05-26T09:57:33Z",
        "body": "Thanks alot!\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why asynchronous subscription causes dropped values in this scenario",
      "Identification of how completion before subscription leads to NoSuchElementException",
      "Solution strategy that ensures values are preserved for delayed subscribers",
      "Alternative approaches to zip operator usage with async sources"
    ]
  },
  {
    "number": 3962,
    "title": "concatMap and Subject weirdness",
    "created_at": "2016-05-24T13:45:34Z",
    "closed_at": "2016-05-24T14:51:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3962",
    "body": "Hi,\n\nMaybe I just interpret it wrong but I found some unexpected behaviour.\n\n``` java\nObservable.just(1,2,3).concatMap(new Func1<Integer, Observable<String>>() { //flatmap <-- gets called 3 times\n    @Override\n    public Observable<String> call(Integer integer) {\n        return BehaviorSubject.create(\"one\"); //Observable.just(\"one\"); <-- This gets called 3 times\n    }\n}).subscribe(new Action1<String>() {\n    @Override\n    public void call(String s) {\n        //This gets called once... :(\n    }\n});\n```\n\nThe interesting thing is that if I use flatMap instead of concatMap the callback gets called 3 times. also if I don't use the subject but the Observable.just() it also gets called 3 times what I expect. Can someone describe me this outcome?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3962/comments",
    "author": "mateherber",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-05-24T14:23:20Z",
        "body": "You need a source to complete with `concatMap` before it can move to the next. `BehaviorSubject` emits its initial value and just waits there, never completing.\n"
      },
      {
        "user": "mateherber",
        "created_at": "2016-05-24T14:51:10Z",
        "body": "Thanks @akarnokd! That makes sense, should have figured it out myself\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why `concatMap` behaves differently from `flatMap` when used with non-completing sources like `BehaviorSubject`",
      "Clarification of how completion semantics affect `concatMap` behavior",
      "Comparison of finite (`Observable.just()`) vs infinite (`Subject`) observable behavior in this context"
    ]
  },
  {
    "number": 3960,
    "title": "zip(o1, o2) doesn't unsubscribe from o1",
    "created_at": "2016-05-22T14:41:54Z",
    "closed_at": "2016-06-01T08:51:11Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3960",
    "body": "A simple example, looks ok\n\n``` java\nObservable<Integer> o1 = Observable.just(1)\n    .doOnCompleted(() -> System.out.println(\"o1 completed\"));\n\nObservable<Integer> o2 = Observable.just(1, 2, 3, 4)\n    .doOnCompleted(() -> System.out.println(\"o2 completed\"));\n\nObservable.zip(o1, o2, (integer1, integer2) -> null).subscribe();\n```\n\nOutput:\n\n```\no1 completed\n```\n\nNow swap o1 and o2\n\n``` java\nObservable<Integer> o1 = Observable.just(1, 2, 3, 4)\n    .doOnCompleted(() -> System.out.println(\"o1 completed\"));\n\nObservable<Integer> o2 = Observable.just(1)\n    .doOnCompleted(() -> System.out.println(\"o2 completed\"));\n\nObservable.zip(o1, o2, (integer1, integer2) -> null).subscribe();\n```\n\nOutput:\n\n```\no1 completed\no2 completed\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3960/comments",
    "author": "ultimate-deej",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-05-22T15:22:11Z",
        "body": "Zip uses a prefetch of 128 elements by default. Since both sources are synchronous, the second case takes all 4 from the first source, including completion, then moves onto `o2` which first emits 1, then its completion completes the whole sequence. Thus, you see both doOnCompleted executed.\n\nThe first case, `o1` signals 1 and completion, then once `o2` signals its 1, it is known `o2` won't ever signal more values, thus `o2` gets unsubscribed and never allowed to run to completion.\n\nBoth are the expected behavior. If you need resource cleanup associated with a sequence, you can't rely on doOnCompleted as sequences may get unsubscribed before that.\n"
      },
      {
        "user": "ultimate-deej",
        "created_at": "2016-05-22T16:47:53Z",
        "body": "I see, but isn't this implementation details?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-05-22T17:14:05Z",
        "body": "It is the explanation for what you experienced. The `zip` javadoc has this clause:\n\n> The resulting `Observable<R>` returned from `zip` will invoke `Observer#onNext`\n> as many times as the number of `onNext` invocations of the source Observable that emits the fewest\n> items.\n\nSince `zip`'s behavior seems to be confusing, maybe we could add a clause that `zip` completes eagerly if one of the sources emits fewer elements than the others and unsubscribes the rest.\n"
      },
      {
        "user": "ultimate-deej",
        "created_at": "2016-05-22T17:50:36Z",
        "body": "I agree that docs should be updated. Although the new clause you suggested needs to be more accurate:\n1. Examples in this issue contradict it\n2. If source observables emit equal number of elements (and not fewer), some (which? this one really bothers me) are still going to be unsubscribed.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-06-01T08:30:40Z",
        "body": "See the proposed documentation changes in #3981.\n"
      },
      {
        "user": "ultimate-deej",
        "created_at": "2016-06-01T08:51:11Z",
        "body": "Thanks, now I know what to expect from `zip`. The current implementation still feels unpolished to me, though.\n"
      }
    ],
    "satisfaction_conditions": [
      "Clear explanation of zip operator's completion/unsubscription rules",
      "Documentation of zip's eager completion logic independent of implementation details",
      "Rules for when sources are unsubscribed during zip operations"
    ]
  },
  {
    "number": 3955,
    "title": "concatMap not working",
    "created_at": "2016-05-20T10:24:55Z",
    "closed_at": "2016-06-17T08:07:48Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3955",
    "body": "Hello! I'm using a RxJava to login to server. I need to create next logic of login:\n**1. Get version of API from server and create (based on version) server urls\n2. Get tokens from the first server url\n3. If tokens received, I need to check if other servers (that I created in point 1) can be accessed by connecting to them**\n\nI writed next logic: \n\n```\n// getObservable() funcion;\nretrun Observable.create(new Observable.OnSubscribe<Integer>() {\n            @Override\n            public void call(Subscriber<? super Integer> subscriber) {\n                if (subscriber.isUnsubscribed()) return;\n//get version from server\n                int version = ServerAPI.getInstance(mContext).getVersion(User.this);\n                if (version < 5) {\n                    subscriber.onNext(AccountsAdapter.ERROR_OLD_API);\n                    subscriber.onCompleted();                 \n                    return;\n                }\n//get tokens\n                Pair<Integer,Tokens> data = ServerAPI.getInstance(mContext).getTokens(User.this, ServerAPI.GRANT_TYPE_PASSWORD);\n                if (data.first==ServerAPI.CODE_OK&&data.second.isValid()) {\n                    setAccessToken(data.second.getAccessToken());\n                    setRefreshToken(data.second.getRefreshToken());\n                    setUserId(data.second.getUserID());\n                    setApiVersion(data.second.getApiVersion());\n                    setTypeToken(data.second.getTokenType());\n                    setMacAlgorithm(data.second.getMacAlgorithm());\n                    setMacKey(data.second.getMacKey());\n                    setApiServer(createApiLink(version));\n                    setImagesServer(createImagesLink());\n //at this point result retuns to subscriber\n                    subscriber.onNext(data.first);\n                } else if (data.first==ServerAPI.CODE_OK\n                        ||data.first==ServerAPI.CODE_INVALID_RESPONSE_DATA) {\n                    subscriber.onNext(AccountsAdapter.ERROR_LOGIN_OR_PASS_INVALID);\n                } else {\n                    subscriber.onNext(data.first);\n                }\n                subscriber.onCompleted();\n            }\n        })\n               .concatMap(integer -> {\n// this code never called\n                if (integer==ServerAPI.CODE_OK) {\n// checking access to the servers\n                    return Observable.zip(getUserModules(), Observable.just(ServerAPI.getInstance(mContext).checkAccessToImagesServer(User.this)), (strings, aBoolean) -> {\n                        if (SystemUtils.isEmpty(strings)) {\n                            logOut();\n                            return AccountsAdapter.ERROR_INVALID_API_SERVER;\n                        } else if (aBoolean) {\n                            Users.getInstance(mContext).setCurrentUser(User.this);\n                            NotificationsManager.enableAllNotifications(mContext, getUserId());\n                            return ServerAPI.CODE_OK;\n                        } else {\n                            logOut();\n                            return AccountsAdapter.ERROR_INVALID_IMAGES_SERVER;\n                        }\n                    });\n                } else {\n                    return Observable.just(integer);\n                }\n            })\n         .subscribeOn(scheduler);\n```\n\nBut this Observable ignores concatMap and returns result from commented string. How to fix this?\n\nSubscriber is called by `getObservable().observeOn(AndroidSchedulers.mainThread()).subscribe();`\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3955/comments",
    "author": "personshelldon",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-05-20T10:30:04Z",
        "body": "RxJava is not using the builder pattern; each operator returns a new `Observable`. In your example, result won't change by calling `concatMap` on it. You should chain the `subscribeOn` after the application of `concatMap` return the resulting `Observable`.\n"
      },
      {
        "user": "personshelldon",
        "created_at": "2016-05-20T10:38:58Z",
        "body": "I don't understand what You say: I'm returning Observable with already concatMap implemented (I corrected code), but it does not work. Please, explain what I need to do in detailes to get this scheme to work? \nDocumentation says that concatMap will convert emitted items to another Observable, but concatMap ignores that items.\nSorry for my English.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-05-20T10:44:31Z",
        "body": "What do you get as `integer` in the `concatMap`? Did you debug your `OnSubscribe` implementation to see what it does and what it gets from the API calls?\n"
      },
      {
        "user": "personshelldon",
        "created_at": "2016-05-20T10:49:02Z",
        "body": "Ah, sorry, I understood Your words about the \"not builder pattern\" I need to write`result = result.concatmap()` instead of `result.concatMap()`. Thank You a lot. Now it is working fine.\n\nOne more question: there are many articles that that say `Observable.create()`causes memory leaks if do not call `subscriber.unsubscribe()` in `OnSubscribe()` implementation. Is that true? Or `subscriber.onComplete()` is enough?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-06-17T08:07:48Z",
        "body": "Sorry for the late response. If an `Observable` is run to completion, resources are released. Otherwise, if your activity is destroyed before that, you have to call `unsubscribe` manually. The problem with `create` is that people tend to implement it poorly, ignoring backpressure and most importantly, resource management.\n\nIf you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of proper RxJava operator chaining to ensure concatMap is applied",
      "Guidance on handling asynchronous server access checks after token acquisition",
      "Clarification of Observable resource management to prevent leaks",
      "Verification of emitted values triggering downstream operators"
    ]
  },
  {
    "number": 3939,
    "title": "What's the best way to have a side effect of a different type",
    "created_at": "2016-05-13T19:04:23Z",
    "closed_at": "2016-06-17T18:43:42Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3939",
    "body": "I'd like to have an `Observable` that represents some long running action, such as `Observable<ProgressEvent>` where the event holds progress information for the task, such as a status message or percentage completed.\n\nAt the end of the task I'd like to return a value of a different type. A trivial example would be counting the number of mis spelled words in some text. The progress would be processing word X of Y, but the result might be the list of mis-spelled words.\n\nThe first thing I looked at was`Subject`, but that won't work since the thing is really an `Observable` of the events and an `Observable` of the result, rather than an `Observable` an an `Observer` like `Subject`. Then I thought maybe simply extending `Observable` would work; I'd add an extra method `Optional<Result> result()` which would return the result of the computation after `onComplete`. But you \"lose\" the type of the `Observable` if you call other methods on it like a map, then a filter. You can get around that obviously, either extending all of the methods on Observable to return the subtype, or saving the variable, then chaining method calls to it, then finally, getting the result.\n\nI also considered adding the `result` method to the event interface such that the last call to `onNext` would have an event whose `Optional<Result>` is not empty. This seems pretty easy, but did not feel like the cleanest solution.\n\nWondering if there's a mechanism in the framework that I missed, or some best practice for this type of situation that I'm not aware of.\n\nThe reason I don't return an `Observable<Result>` in the first place is I wanted the caller to have the option of subscribing to the event stream to do something like show a progress monitor.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3939/comments",
    "author": "mhgrove",
    "comments": [
      {
        "user": "davidmoten",
        "created_at": "2016-05-14T10:31:48Z",
        "body": "Trying again with formatting fixed.\n\nYou could emit a custom object that has a `ProgressEvent` and `List<String>`\nbeing the list of misspelled words so far (only needs to have real content till the last emission though) and then:\n\n``` java\nobservable\n    .doOnNext(x -> updateProgress(x.event))\n    .last()\n    .map(x -> x.list);\n```\n"
      },
      {
        "user": "mhgrove",
        "created_at": "2016-05-16T15:17:03Z",
        "body": "Yeah, that's similar to what I had stubbed out:\n\n```\n    public interface ProgressEvent<T> {\n\n        public long progress();\n        public long maxProgress();\n\n        public default Optional<T> result() {\n            return Optional.empty();\n        }\n    }\n```\n\nThat's the event that any `Observable` emitted that was a process that reported progress on the creation of a result.\n\nIt had not occurred to me `last().map(ProgressEvent::result).map(Optional::get)` could pretty cleanly get the result of the operation. I had been trying to use `compose`, `extend`, or `lift`, but those couldn't really be provided by the caller since the functions would need the state of the process being observed to potentially build the result. Extending `Observable` didn't feel clean, nor did hacking the builder creating the process to add observers to the resulting `Observable` or having it provide the function needed to get the final result.\n\n`last`/`map` seems like it might be the best option.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-06-17T18:43:42Z",
        "body": "Looks like the question has been answered. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ],
    "satisfaction_conditions": [
      "Supports emitting progress events and a final result of different types through the same Observable chain",
      "Preserves type safety when applying operators like map/filter",
      "Allows subscribers to access both progress updates and final result independently",
      "Avoids requiring custom Observable subclassing or framework modifications",
      "Provides a clear separation between progress streaming and result collection"
    ]
  },
  {
    "number": 3933,
    "title": "BackPressure and nested flatMap",
    "created_at": "2016-05-12T10:28:40Z",
    "closed_at": "2016-05-14T08:26:47Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3933",
    "body": "Hi, can someone explain why the following code (without nested flatmap)\n\n<div class=\"highlight highlight-source-java\"><pre>\nObservable.from(new IterateOverFloat(1))) //\n                .flatMap(__ -> Observable.create(new OnSubscribeFromIterable<>(new IterateOverFloat(10_000_000)))) //\n                .flatMap(Observable::just) //\n                .observeOn(Schedulers.computation()) //\n                .subscribe();\n</pre></div>\n\ngoes through method `slowPath(long)` of `OnSubscribeFromIterable.IterableProducer`,\n\nwhile the following code (with nested flat map)\n\n<div class=\"highlight highlight-source-java\"><pre>\nObservable.from(new IterateOverFloat(1)) //\n                .flatMap(__ -> Observable.create(new OnSubscribeFromIterable<>(new IterateOverFloat(10_000_000))) //\n                        .flatMap(Observable::just)) //\n                .observeOn(Schedulers.computation()) //\n                .subscribe();\n</pre></div>\n\ngoes through method `fastPath()` ?\n\n`IterateOverFloat` is just a basic iterable that produces the asked number of floats.\n\nI've tested with both RxJava-1.1.0 and 1.1.5 with the same results.\n\nEDIT : ok, I have looked around a bit more, and here is what I have found.\nI have created an Observable with backpressure support, which prints the first number of requested items:\n\n<div class=\"highlight highlight-source-java\"><pre>\nObservable<Long> myObsWithBackPressureSupport = Observable.create(subs -> {\n            subs.setProducer(new Producer() {\n\n                AtomicBoolean bool = new AtomicBoolean(true);\n\n                @Override\n                public void request(long n) {\n                    if(bool.getAndSet(false)){\n                        System.out.println(\"request \" + n);\n                    }\n                    \n                    LongStream.range(0, n).forEach(subs::onNext);\n                }\n                \n            });\n        });\n</pre></div>\n\n\nand I used it the following ways: \n\n<div class=\"highlight highlight-source-java\"><pre>\n// case 1\nmyObsWithBackPressureSupport //\n        .observeOn(Schedulers.computation()) //\n        .subscribe();\n\n// case 2\nmyObsWithBackPressureSupport //\n        .flatMap(l -> Observable.just(l)) //\n        .observeOn(Schedulers.computation()) //\n        .subscribe();\n</pre></div>\n\n\nIn case 1, first request of 128 items.\nIn case 2, first request of Long.MAX_VALUE items.\n\nI have concluded that using `flatMap` disables the backpressure support. Can someone tell me if I am right and if it is an intended behavior ?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3933/comments",
    "author": "feneuilflo",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-05-12T17:31:56Z",
        "body": "FlatMap has multiple entry points: one front and any number of inner sequences. \n\nBy default, `flatMap` requests the `Long.MAX_VALUE` - which is called unbounded mode - from its main upstream, which may trigger the fast-paths in sources. \n\nThe inner, mapped sequences, request a fixed amount - default 128 - and keeps requesting as those inner values get consumed and merged into the output sequence. This doesn't trigger the fast-paths in most inner sequences. \n\nYou can restrict the outer unbounded mode by setting the `maxConcurrency` parameter but you can't unbound the inner sequences. \n\nIf you are dealing with inner `Iterable`s, you can avoid the genreal overhead by using `flatMapIterable`.\n"
      },
      {
        "user": "feneuilflo",
        "created_at": "2016-05-14T08:26:27Z",
        "body": "Thanks for this answer. Using the `maxConcurrency` parameter has solved my problem.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how flatMap's default request behavior affects backpressure handling in RxJava",
      "Clarification on the difference between outer sequence and inner sequence request handling in flatMap",
      "Confirmation whether flatMap's unbounded outer requests are intentional design behavior",
      "Description of configuration options to control flatMap's backpressure behavior"
    ]
  },
  {
    "number": 3844,
    "title": "delaySubscription(Observable) breaks upstream unsubscription",
    "created_at": "2016-04-08T18:26:09Z",
    "closed_at": "2016-04-09T08:44:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3844",
    "body": "This test case is failing (tested with 1.1.2):\n\n``` java\n  @Test\n  public void testWithSubjects() {\n    PublishSubject<Integer> delayUntil = PublishSubject.create();\n    PublishSubject<Integer> interrupt = PublishSubject.create();\n    final AtomicBoolean subscribed = new AtomicBoolean(false);\n\n    Observable.just(1)\n        .doOnSubscribe(() -> subscribed.set(true))\n        .delaySubscription(delayUntil)\n        .takeUntil(interrupt)\n        .subscribe();\n\n    interrupt.onNext(9000);\n    delayUntil.onNext(1);\n\n    assertFalse(subscribed.get());\n  }\n\n```\n\nI stumbled upon this using `Completable.andThen` (which delegates to `delaySubscription`).\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3844/comments",
    "author": "hannesstruss",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-04-08T18:31:47Z",
        "body": "TakeUntil subscribes to its source before the subscription to upstream could happen. This is partly due to how `lift` works and partly to allow interrupting a synchronous source as it would otherwise possibly rush through without letting the operator subscribe to the until source.\n"
      },
      {
        "user": "hannesstruss",
        "created_at": "2016-04-08T19:02:22Z",
        "body": "In other words, `takeUntil` only guarantees to suppress emission of items given a condition, but does not guarantee what happens upstream?\n\n(I was confused, as the analogous example with time based `delaySubscription` works:)\n\n``` java\n  @Test\n  public void testWithSubjects() {\n    PublishSubject<Integer> interrupt = PublishSubject.create();\n    final AtomicBoolean subscribed = new AtomicBoolean(false);\n    TestScheduler testScheduler = new TestScheduler();\n\n    Observable.just(1)\n        .doOnSubscribe(() -> subscribed.set(true))\n        .delaySubscription(1, TimeUnit.SECONDS, testScheduler)\n        .takeUntil(interrupt)\n        .subscribe();\n\n    interrupt.onNext(9000);\n    testScheduler.advanceTimeBy(1, TimeUnit.SECONDS);\n\n    assertFalse(subscribed.get());\n  }\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-04-08T19:57:05Z",
        "body": "Interesting. The second case shouldn't pass either. I'll investigate.\n\n\n---\n\nOkay, I was wrong. Both tests should pass because they verify that the subscription doesn't happen - as expected. There is a bug in the non-timed `delaySubscription` that doesn't propagate the unsubscription properly. I'll post a PR to fix that.\n\n\n---\n\nFix posted: #3845\n"
      },
      {
        "user": "hannesstruss",
        "created_at": "2016-04-09T08:44:57Z",
        "body": "This works in 1.1.3, thanks so much! \u2728 \n"
      }
    ],
    "satisfaction_conditions": [
      "Ensure upstream unsubscription propagates correctly when using delaySubscription with an Observable source",
      "Maintain consistent behavior between time-based and Observable-based delaySubscription implementations",
      "Preserve expected operator composition semantics for takeUntil with delayed subscriptions",
      "Handle interruption signals received before delayed subscription activation"
    ]
  },
  {
    "number": 3843,
    "title": "Unexpected behavior",
    "created_at": "2016-04-08T05:57:48Z",
    "closed_at": "2016-04-08T08:57:41Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3843",
    "body": "``` java\nimport rx.Observable;\n\npublic class RxTest {\n\n    public static void main(String[] args) {\n        Observable.<String>create(subscriber -> {\n            subscriber.onNext(\"as\");\n            subscriber.onNext(\"asd\");\n        })\n                .map(s -> {\n                    if (s.length() < 3) {\n                        throw new RuntimeException(\"\");\n                    }\n                    return 1;\n                })\n                .flatMap(o -> {\n                    System.out.println(\"flatMap\");\n                    return Observable.just(true);\n                })\n                .subscribe(System.out::println, t -> {});\n    }\n}\n```\n\nOutput:\n\n```\nflatMap\n```\n\nBut, if we comment line with `throw new RuntimeException(\"\")` output will be:\n\n```\nflatMap\ntrue\nflatMap\ntrue\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3843/comments",
    "author": "nikialeksey",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-04-08T07:11:33Z",
        "body": "This is the expected behavior. `map` crashes and `flatMap` is skipped.\n"
      },
      {
        "user": "nikialeksey",
        "created_at": "2016-04-08T07:56:37Z",
        "body": "Wow! Be careful:\n1. emit \"as\": `throw` -> `flatMap` is skiped\n2. emit \"asd\": go to `flatMap`, output `\"flatMap\"`, but where is output in `subscribe`?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-04-08T08:10:31Z",
        "body": "The problem is that your `create` ignores unsubscription and thus violates the `Observable` contract. If you add \n\n``` java\n     if (subscriber.isUnsubscribed()) return;\n```\n\nin between the two calls to `onNext`, nothing is printed.\n"
      },
      {
        "user": "nikialeksey",
        "created_at": "2016-04-08T08:57:41Z",
        "body": "Oh! Thank you for explanation!\n"
      },
      {
        "user": "adipascu",
        "created_at": "2016-04-08T09:05:50Z",
        "body": "@akarnokd can the observable be unsubscribed on a different thread ? Can it get unsubscribed after the check to isUnsubscribed is done but before calling onNext?\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how unsubscription affects Observable execution flow",
      "Clarification of Observable contract requirements for proper error handling",
      "Demonstration of thread-safe unsubscription handling",
      "Explanation of how upstream errors prevent downstream processing"
    ]
  },
  {
    "number": 3813,
    "title": "OnSubscribeCombineLatest#MultiSourceProducer request method get different result?",
    "created_at": "2016-03-31T09:17:24Z",
    "closed_at": "2016-04-02T23:13:22Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3813",
    "body": "In request method,there is a line code ':o.unsafeSubscribe(s);' and I find the unsafeSubscribe()'s note is 'Subscribes to an Observable and invokes {@link OnSubscribe} function without any contract protection,error handling, unsubscribe, or execution hooks.'.\nThis is my code:\n\n``` java\nObservable<Long> observable1 = Observable.interval(0, 1000, TimeUnit.MILLISECONDS)\n                    .map(new Func1<Long, Long>() {\n                        @Override\n                        public Long call(Long aLong) {\n                            return aLong * 5;\n                        }\n                    }).take(5);\n            Observable<Long> observable2 = Observable.interval(500, 1500, TimeUnit.MILLISECONDS)\n                    .map(new Func1<Long, Long>() {\n                        @Override\n                        public Long call(Long aLong) {\n                            return aLong * 10;\n                        }\n                    }).take(4);\n            Observable.combineLatest(observable2, observable1, new Func2<Long, Long, Long>() {\n                @Override\n                public Long call(Long aLong, Long aLong2) {\n                    Log.i(\"ppppp\", \"combineLatest aLong = \" + aLong + \"   aLong2 =\" + aLong2);\n                    return aLong + aLong2;\n                }\n            }).subscribe(new Subscriber<Long>() {\n                @Override\n                public void onCompleted() {\n                    System.out.println(\"Sequence complete.\");\n                }\n                @Override\n                public void onError(Throwable e) {\n                    System.err.println(\"Error: \" + e.getMessage());\n                }\n                @Override\n                public void onNext(Long aLong) {\n                    System.out.println(\"combineLatest Next: \" + aLong);\n                }\n            });\n```\n\nI run this code and get two different results.\n(1)\n Next: 0\n Next: 5\n Next: 10\n Next: 20\n Next: 25\n Next: 35\n Next: 40\n Next: 50\n(2)\n Next: 0\n Next: 5\n Next: 15\n Next: 20\n Next: 25\n Next: 35\n Next: 40\n Next: 50\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3813/comments",
    "author": "fanturbo",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-03-31T14:23:08Z",
        "body": "You have two intervals which will fire together at t = 2000 ms where there is no guarantee which will arrive first to the sum in combineLatest.\n"
      },
      {
        "user": "fanturbo",
        "created_at": "2016-04-01T01:37:30Z",
        "body": "@akarnokd thanks.I want to ask another question.combineLatest opreator's explanation is 'Combines a collection of source Observables by emitting an item that aggregates the latest values of **each of the source Observables each time an item is received from any of the source Observables**, where this aggregation is defined by a specified function.\u2018.\nWhen observable1 emit the first item,and the observable2 doesn't emit the first item,why the Combines don't emit the result?In my code I think it should print this:\nNext: 0\nNext: 0\nNext: 5\nNext: 15\nNext: 20\nNext: 25\nNext: 35\nNext: 40\nNext: 50\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-04-01T06:54:04Z",
        "body": "By definition, combineLatest emits only when all sources have emitted at least one item. Otherwise you wouldn't have a full row of values to work with.\n"
      },
      {
        "user": "fanturbo",
        "created_at": "2016-04-01T08:00:53Z",
        "body": "In other words, combineLatest emits when all sources have emiited at least one item,and then if one of source Observables emits an item, the Combines will emits their results?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-04-01T08:08:24Z",
        "body": "If you have a full row, that is the first time the combiner function is called.\n\n``` java\nPublishSubject<String> a = PublishSubject.create();\nPublishSubject<String> b = PublishSubject.create();\nPublishSubject<String> c = PublishSubject.create();\n\nObservable.combineLatest(a, b, c, (u, v, w) -> u + v + w).subscribe(System.out::println);\n\na.onNext(\"1\");\nb.onNext(\"1\");\na.onNext(\"2\");\nb.onNext(\"2\");\nb.onNext(\"3\");\nSystem.out.println(\"Full row:\");\nc.onNext(\"1\");\n```\n\nIt will print\n\n```\nFull row:\n231\n```\n"
      },
      {
        "user": "fanturbo",
        "created_at": "2016-04-01T08:39:22Z",
        "body": "@akarnokd thanks for your reply.Your sample is awesome.(ps:Did you find my english is very poor? )\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-04-02T23:13:22Z",
        "body": "It was readable.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of combineLatest's emission rules when sources have incomplete initial values",
      "Clarification of timing dependencies between interval-based Observables",
      "Description of combineLatest's value aggregation logic after initial emission",
      "Differentiation between theoretical documentation and actual implementation behavior"
    ]
  },
  {
    "number": 3811,
    "title": "About Subscriber",
    "created_at": "2016-03-30T10:25:44Z",
    "closed_at": "2016-04-02T23:13:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3811",
    "body": "When I watch the source code of operators, I found that in order to keep the unsubscribe chain, the parent subscriber always created by two way:\n\n```\nSubscriber<T> parent = new Subscriber(child){ ... };\n```\n\nor\n\n```\nSubscriber<T> parent = new Subscriber{ ... };\nchild.add(parent);\n```\n\nI know that the first one can pass through the producer.\nAnd, What else can decide the choosing? \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3811/comments",
    "author": "dieyidezui",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-03-30T10:36:31Z",
        "body": "If the parent may issue `unsubscribe` on its own, you have to chose the second pattern because otherwise the call may go downstream and cause trouble.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of scenarios where parent-initiated unsubscription affects pattern choice",
      "Clarification of subscription chain management implications",
      "Identification of design considerations for custom operator implementation"
    ]
  },
  {
    "number": 3801,
    "title": "PublishSubject: OnNext Not delivered or OnNext delivered on wrong Thread",
    "created_at": "2016-03-27T20:58:37Z",
    "closed_at": "2016-03-27T21:36:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3801",
    "body": "I was writing some automated test to verify the behaviour of PublishSubject and I noticed strange and unexpected behaviour when the subject is subscribed on a Scheduler. If I do not put a sleep after the subscriber, I will not get the onNext items but the onCompleted is called on the correct Thread. If I put a sleep after subscribing, the subscriber receives the onNext items but on the wrong thread. It receives the onNext items on the thread that called the subject.onNext.\n\nI wrote some unit test to show the behaviour. Both tests will fail with rxjava 1.1.2. Is this a bug or is this expected behavior and where can I find this in the documentation? \n\n``` java\nimport org.junit.Test;\nimport rx.observers.TestSubscriber;\nimport rx.subjects.PublishSubject;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static rx.schedulers.Schedulers.newThread;\n\npublic class PublishSubjectTest {\n\n    @Test\n    public void subscribeOn_WhenNoSleep_ThenNoOnNextReceived() throws InterruptedException {\n\n        // GIVEN\n        PublishSubject<String> subject = PublishSubject.create();\n        Thread currentThread = Thread.currentThread();\n        TestSubscriber<String> subscriber = new TestSubscriber<>();\n\n        // WHEN\n        subject.subscribeOn(newThread()).subscribe(subscriber);\n        subject.onNext(\"one\");\n        subject.onCompleted();\n\n        // THEN\n        subscriber.awaitTerminalEvent();\n        assertThat(subscriber.getLastSeenThread()).isNotSameAs(currentThread);\n        assertThat(subscriber.getOnNextEvents()).containsOnly(\"one\");\n\n    }\n\n    @Test\n    public void subscribeOn_WhenSleep_ThenOnNextReceivedButOnWrongThread() throws InterruptedException {\n\n        // GIVEN\n        PublishSubject<String> subject = PublishSubject.create();\n        Thread currentThread = Thread.currentThread();\n        TestSubscriber<String> subscriber = new TestSubscriber<>();\n\n        // WHEN\n        subject.subscribeOn(newThread()).subscribe(subscriber);\n        Thread.sleep(2000);\n        subject.onNext(\"one\");\n        subject.onCompleted();\n\n        // THEN\n        subscriber.awaitTerminalEvent();\n        assertThat(subscriber.getOnNextEvents()).containsOnly(\"one\");\n        assertThat(subscriber.getLastSeenThread()).isNotSameAs(currentThread);\n\n    }\n\n}\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3801/comments",
    "author": "bdeneuter",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-03-27T21:14:05Z",
        "body": "The problem is that you use `subscribeOn` instead of `observeOn` to move the delivery of events to another thread. When you `subscribeOn`, that delays the real subscription to `PublishSubject` by some amount, giving enough time to `onNext` to be observed by no one. You see only `onCompleted` because `PublishSubject` replays the terminal event to late `Subscriber`s.\n"
      },
      {
        "user": "bdeneuter",
        "created_at": "2016-03-27T21:30:20Z",
        "body": "Thx David,\n\nIndeed, observeOn seems to solve the behaviour I was seeing. With subsribeOn and waiting long enough for the subscription to succeed, can you also explain why the terminal event is delivered on the main thread and not on the scheduler thread?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-27T21:35:01Z",
        "body": "You are racing with the subscription and by chance, it is possible the subscription happens in time for onComplete to pass through directly to the Subscriber.\n"
      },
      {
        "user": "bdelville",
        "created_at": "2018-07-17T00:52:10Z",
        "body": "Hi\r\n\r\nI am not sure about the racing condition explanation, because I can reproduce it with a BehaviorSubject too (with onNext() called after subscription and timer before it)\r\n\r\n```\r\n@Test\r\n  public void testSubjectThreadFollowSubscribeOn() {\r\n    TestObserver<String> tester = new TestObserver<>();\r\n    BehaviorSubject<Integer> source = BehaviorSubject.create();\r\n    String currentThread = Thread.currentThread().getName();\r\n\r\n    source\r\n        .subscribeOn(Schedulers.io())\r\n        .take(1)\r\n        .map(o -> Thread.currentThread().getName())\r\n        .subscribe(tester);\r\n    source.onNext(1);\r\n\r\n    tester.awaitCount(1);\r\n    tester.assertValue(threadAfterSubscribeOn -> !threadAfterSubscribeOn.equals(currentThread));\r\n}\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-07-17T06:37:04Z",
        "body": "You still have a race where onNext could find an already subscribed observer and signal the first item on the test thread."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why subscribeOn causes delayed/missed onNext events but allows onCompleted delivery",
      "Clarification of thread assignment rules for PublishSubject events",
      "Identification of race condition between subscription and event emission",
      "Differentiation between subscribeOn and observeOn semantics for subjects"
    ]
  },
  {
    "number": 3788,
    "title": "toList() does not work",
    "created_at": "2016-03-22T07:48:05Z",
    "closed_at": "2016-03-22T10:36:26Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3788",
    "body": "I have one Observable below . \n\n```\nComApi.getInstance().getRegionList().compose(RxUtil.background())\n                .filter(resRegionModel -> resRegionModel != null)\n                .map(ResRegionsModel::getData)\n                .flatMap(Observable::from)\n                .filter(dataEntity -> dataEntity != null)\n                .map(this::convert)\n                .doOnNext(adapter::replaceWith)  // this can work, it will receive data one by one.\n                .toList()\n                .doOnNext(adapter::replaceWith) // but this callback will not be called .while after toList()..it can \n                                                                      // not receive data by once. \n                .doOnError(Throwable::printStackTrace)\n                .subscribe();\n```\n\nthis is my first catch problem while I using toList(). I don't know how to fix this issue.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3788/comments",
    "author": "sharyuke",
    "comments": [
      {
        "user": "sharyuke",
        "created_at": "2016-03-22T08:01:00Z",
        "body": "```\n\n    /**\n     * \u83b7\u53d6\u533a\u57df\u5217\u8868\n     *\n     * @return \u533a\u57df\u5217\u8868\n     */\n    public Observable<ResRegionsModel> getRegionList() {\n        return Observable.create(subscriber -> subscriber.add(mComInterface.getRegionList(IndoorunSDKDataCenter.APP_KEY_VALUE,\n                IndoorunSDKDataCenter.getInstance().getPhoneUUID(), IndoorunSDKDataCenter.SESSION_KEY_VALUE, \"1\")\n                .doOnNext(resRegionModel -> {\n                    if (resRegionModel != null && resRegionModel.isSuccess()) {\n                        subscriber.add(Observable.just(resRegionModel.getData())\n                                .doOnNext(TableRegionDao.getInstance()::syncInsert)\n                                .flatMap(Observable::from)\n                                .filter(dataEntity -> dataEntity.getFloorList() != null)\n                                .flatMap(dataEntity2 -> Observable.from(dataEntity2.getFloorList()))\n                                .toList()\n                                .flatMap(TableRegionFloorDao.getInstance()::insert)\n                                .onErrorResumeNext(Observable.empty())\n                                .compose(background())\n                                .subscribe());\n                    }\n                })\n                .doOnNext(subscriber::onNext)\n                .compose(background())\n                .subscribe()));\n    }\n\n```\n\nthis is ComApi.getInstance().getRegionList() method. \n\n\n---\n\nwhen I change  ComApi.getInstance().getRegionList()  to this , and toList() worked. I want to know why\n\n```\n\n    /**\n     * \u83b7\u53d6\u533a\u57df\u5217\u8868\n     *\n     * @return \u533a\u57df\u5217\u8868\n     */\n    public Observable<ResRegionsModel> getRegionList() {\n        return mComInterface.getRegionList(IndoorunSDKDataCenter.APP_KEY_VALUE,\n                IndoorunSDKDataCenter.getInstance().getPhoneUUID(), IndoorunSDKDataCenter.SESSION_KEY_VALUE, \"1\")\n                .doOnNext(resRegionModel -> {\n                    if (resRegionModel != null && resRegionModel.isSuccess()) {\n                        Observable.just(resRegionModel.getData())\n                                .doOnNext(TableRegionDao.getInstance()::syncInsert)\n                                .flatMap(Observable::from)\n                                .filter(dataEntity -> dataEntity.getFloorList() != null)\n                                .flatMap(dataEntity2 -> Observable.from(dataEntity2.getFloorList()))\n                                .toList()\n                                .flatMap(TableRegionFloorDao.getInstance()::insert)\n                                .onErrorResumeNext(Observable.empty())\n                                .compose(background())\n                                .subscribe();\n                    }\n                })\n                .compose(background());\n    }\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-22T09:22:56Z",
        "body": "Something doesn't call `onCompleted`, but I can't tell what because you are using some unconventional dataflow structure.\n"
      },
      {
        "user": "sharyuke",
        "created_at": "2016-03-22T09:34:55Z",
        "body": "@akarnokd yes, it is custom Observable ,created by Observable.create(OnSubscriber subscriber), but I think it should work, and it worked actually until toList() method.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-22T10:10:53Z",
        "body": "If you are using `create()`, you are at your own and you have to honor the contracts and expectations of operators. Operators can't know if you just forgot to call `onCompleted` or you never intended to do so. See `just`, `fromCallable` and `from` as alternatives to `create()`.\n"
      },
      {
        "user": "sharyuke",
        "created_at": "2016-03-22T10:21:56Z",
        "body": "Did You meaning I must call subscriber.onComplete() method? let me have a try.\n\n\n---\n\n@akarnokd yes! You are right! it worked!!! thanks a lot !!!! \n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why the Observable sequence must emit an onCompleted event for toList() to work",
      "Clarification of Observable contract requirements for stateful operators like toList()",
      "Guidance on proper Observable creation patterns instead of manual Observable.create()",
      "Identification of completion signal propagation through operator chains"
    ]
  },
  {
    "number": 3776,
    "title": "Why does affect not calling subsciber.onCompleted() when applying operator observable.toList()?",
    "created_at": "2016-03-17T10:54:04Z",
    "closed_at": "2016-03-17T11:45:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3776",
    "body": "Hi!\n\nIf I create an observable using `Observable.create()` and I don\u2019t call onCompleted on its `subscriber`, following chaining operation `toList()` does not get executed.\n\n``` java\nprivate Observable<List<String>> createObservable() {\n        return Observable.create(subscriber -> {\n                subscriber.onNext(\"\");\n                subscriber.onCompleted(); //if onCompleted is not called the operations chained after calling flatMapIterable() -> toList() do not execute\n            })\n            .map(string -> Arrays.asList(\"1\", \"2\", \"3\"));\n    }\n```\n\n``` java\ncreateObservable()\n                .flatMapIterable(strings -> strings)\n                .map(string -> string)\n                .toList()\n                .map(strings -> strings); //this line is not executed if the source observable does not call onCompleted()\n```\n\nIs this the expected behaviour?\n\nThanks!\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3776/comments",
    "author": "VictorAlbertos",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-03-17T10:57:12Z",
        "body": "Yes. `toList` gives you the complete list of all values, but it has to know when there are no more values. Without `onCompleted()` it can't know you forgot it or it got just delayed a bit.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why Observable.toList() requires an onCompleted() signal to trigger downstream operations",
      "Confirmation whether this behavior aligns with RxJava's design principles",
      "Clarification about operators that require completion signals to emit results"
    ]
  },
  {
    "number": 3748,
    "title": "replay().connect() does not complete on current thread",
    "created_at": "2016-03-11T13:10:57Z",
    "closed_at": "2016-03-11T14:14:19Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3748",
    "body": "This test case:\n\n``` java\n  @Test\n  public void test() {\n    final AtomicBoolean onNext = new AtomicBoolean(false);\n    final AtomicBoolean onCompleted = new AtomicBoolean(false);\n\n    Observable<String> o = Observable.just(\"Hallo\")\n        .doOnNext(new Action1<String>() {\n          @Override\n          public void call(String s) {\n            onNext.set(true);\n          }\n        })\n        .doOnCompleted(new Action0() {\n          @Override\n          public void call() {\n            onCompleted.set(true);\n          }\n        });\n\n    ConnectableObservable<String> connectable = o.replay();\n    connectable.connect();\n\n    assertTrue(onNext.get());\n    assertTrue(onCompleted.get());\n  }\n```\n\nstarted failing for me on the latest snapshot. `git bisect` says c925e860c01c30edc15c59c592c1d5e9b9777a90 is the first bad commit. `.publish()` is not affected.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3748/comments",
    "author": "hannesstruss",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-03-11T13:28:32Z",
        "body": "Previously, `just()` didn't support backpressure and emitted its value immediately after subscription. Now it waits for a proper downstream request which doesn't happen because `replay()` requests upstream only when there is a downstream request. Just add `connectable.subscribe()` to trigger `just()`.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why replay().connect() doesn't trigger emission without subscribers",
      "Clarification of interaction between replay() operator and cold observables in current RxJava version"
    ]
  },
  {
    "number": 3736,
    "title": "How to get filtered POJO when used getXXX()?",
    "created_at": "2016-02-27T03:44:59Z",
    "closed_at": "2016-04-11T08:05:13Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3736",
    "body": "```\n.flatMap(new Func1<Area, Observable<Store>>() {\n    @Override\n     public Observable<Store> call(Area area) {\n        return Observable.from(area.getStores());\n     }\n})\n.filter(new Func1<Store, Boolean>() {\n    @Override\n    public Boolean call(Store store) {\n        return store.getName().contains(text);\n    }\n})\n```\n\n> i want to get the filtered **Area**\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3736/comments",
    "author": "deviltsw",
    "comments": [
      {
        "user": "davidmoten",
        "created_at": "2016-02-27T10:16:25Z",
        "body": "One way is to wrap every instance of Store with its Area:\n\n``` java\n.flatMap(area -> \n    Observable.from(area.getStores())\n        .map(store -> new Wrapper(area, store)))\n.filter(wrapper -> wrapper.store().getName().contains(text))\n.map(wrapper ->wrapper.area());\n```\n"
      },
      {
        "user": "kotucz",
        "created_at": "2016-02-27T10:20:16Z",
        "body": "or you could use this trick\n\n```\noa.flatMap(new Func1<Area, Observable<Area>>() {\n        @Override\n        public Observable<Area> call(final Area area) {\n            return Observable.from(area.getStores())\n                    .filter(new Func1<Store, Boolean>() {\n                        @Override\n                        public Boolean call(Store store) {\n                            return store.getName().contains(text);\n                        }\n                    })\n                    .map(new Func1<Store, Area>() {\n                        @Override\n                        public Area call(Store store) {\n                            return area;\n                        }\n                    });\n        }\n    });\n```\n\nbut you maybe do not need to wrap Stores in the `Observable` so this should be fine too\n\n```\noa.filter(new Func1<Area, Boolean>() {\n        @Override\n        public Boolean call(Area area) {\n            return areaHasStoreWithText(area, text);\n        }\n    });\n```\n"
      },
      {
        "user": "davidmoten",
        "created_at": "2016-02-27T10:42:16Z",
        "body": "One thing to note is that my suggestion and @kotucz first suggestion both potentially produce multiple copies of `Area` so you might want to use `.distinct()`.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-04-02T23:22:53Z",
        "body": "@deviltsw Are the answers satisfactory?\n"
      },
      {
        "user": "deviltsw",
        "created_at": "2016-04-11T08:05:13Z",
        "body": "@akarnokd yes.\n"
      }
    ],
    "satisfaction_conditions": [
      "Retain parent Area association when filtering child Stores",
      "Avoid data duplication in final result",
      "Maintain Observable chain compatibility",
      "Filter logic based on Store properties while returning Areas"
    ]
  },
  {
    "number": 3723,
    "title": "SerializedBehaviorSubject",
    "created_at": "2016-02-19T20:33:24Z",
    "closed_at": "2016-02-23T08:19:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3723",
    "body": "Looking at the changes in #2470, a useful `getValue()` method was added to `BehaviorSubject`. This goes away though if you want to serialize it. Would there be feasible to have something like a `SerializedBehaviorSubject` that maintains the API of `BehaviorSubject`?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3723/comments",
    "author": "ZacSweers",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-02-19T20:39:01Z",
        "body": "You can keep a reference to the original BehaviorSubject; the method is threadsafe by itself.\n"
      },
      {
        "user": "ZacSweers",
        "created_at": "2016-02-23T08:19:16Z",
        "body": "Ah! Good to know, thanks!\n"
      }
    ],
    "satisfaction_conditions": [
      "Maintains the full BehaviorSubject API (including getValue()) when serialized",
      "Ensures thread-safe access to subject state",
      "Avoids breaking existing serialization/deserialization workflows",
      "Provides equivalent functionality to BehaviorSubject without API regressions"
    ]
  },
  {
    "number": 3716,
    "title": "flatMapIterable and toList combination issue",
    "created_at": "2016-02-16T08:42:14Z",
    "closed_at": "2016-02-17T06:22:43Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3716",
    "body": "In the following code the \"three\" and \"done\" never appears in the output. Looks like the problem is in `toList` call. Am i using it wrong?\n\n```\nPublishSubject<Boolean> mBooleanPublishSubject = PublishSubject.create();\nObservable<Boolean> observable = mBooleanPublishSubject.asObservable().share();\nobservable\n        .doOnNext(__ -> System.out.println(\"one\"))\n        .flatMap(__ -> Observable.just(Arrays.asList(1, 2, 3, 4)))\n        .flatMapIterable(number -> number)\n        .doOnNext(v -> System.out.println(\"two \" + v))\n        .toList()\n        .doOnNext(v -> System.out.println(\"three \" + v))\n        .subscribe(v -> System.out.println(\"done\"));\nmBooleanPublishSubject.onNext(true);\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3716/comments",
    "author": "httpdispatch",
    "comments": [
      {
        "user": "MyDogTom",
        "created_at": "2016-02-16T14:09:30Z",
        "body": "`toList` waits for `onCompleted` event. In your case there is no `onCompleted` event. Add `mBooleanPublishSubject.onCompleted();` and you will see others outputs.\n"
      },
      {
        "user": "httpdispatch",
        "created_at": "2016-02-17T06:22:43Z",
        "body": "Thanks for the explanation. It works like this\n\n```\nPublishSubject<Boolean> mBooleanPublishSubject = PublishSubject.create();\n        Observable<Boolean> observable = mBooleanPublishSubject.asObservable().share();\n        observable\n                .doOnNext(__ -> System.out.println(\"one\"))\n                .flatMap(__ -> Observable.just(Arrays.asList(1, 2, 3, 4))\n                        .flatMapIterable(number -> number)\n                        .doOnNext(v -> System.out.println(\"two \" + v))\n                        .toList()\n                        .doOnNext(v -> System.out.println(\"three \" + v)))\n                .doOnNext(v -> System.out.println(\"four \" + v))\n                .subscribe(v -> System.out.println(\"done\"));\n        mBooleanPublishSubject.onNext(true);\n        mBooleanPublishSubject.onNext(true);\n```\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why toList() operator requires completion before emitting",
      "Clarification about Observable completion requirements in RxJava operators",
      "Guidance on proper Observable termination for stateful operators",
      "Demonstration of Observable chain restructuring to enable completion"
    ]
  },
  {
    "number": 3656,
    "title": "Take and debounce usage",
    "created_at": "2016-01-29T10:30:55Z",
    "closed_at": "2016-01-29T12:20:44Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3656",
    "body": "I have the next test case\n\n``` @Test\n    public void testLimitAndPublishSubject() throws InterruptedException {\n        PublishSubject<Boolean> mBooleanPublishSubject = PublishSubject.create();\n        mBooleanPublishSubject.asObservable()\n                .doOnEach(__ -> System.out.println(\"on value emitted \"+System.currentTimeMillis()))\n                .take(1)\n                .doOnEach(__ -> System.out.println(\"on value emitted 2 \"+System.currentTimeMillis()))\n                .debounce(1000, TimeUnit.MILLISECONDS)\n                .doOnEach(__ -> System.out.println(\"on value emitted 3 \"+System.currentTimeMillis()))\n                .subscribe(__ -> System.out.println(\"done \"+System.currentTimeMillis()));\n        mBooleanPublishSubject.onNext(true);\n        Thread.sleep(1000);\n        mBooleanPublishSubject.onNext(true);\n        Thread.sleep(2000);\n    }\n```\n\nand the output is\n\n```\non value emitted 1454063289770\non value emitted 2 1454063289770\non value emitted 2 1454063289779\non value emitted 3 1454063289780\ndone 1454063289780\non value emitted 3 1454063289780\n```\n\nI can't figure out why the `on value emitted 2` and `on value emitted 3` appears in the log twice and why the debounce delay doesn't work. Can somebody please help?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3656/comments",
    "author": "httpdispatch",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-01-29T11:47:03Z",
        "body": "Hi. The debounce doesn't work because with `take(1)` you immediately complete the stream which forces debounce to emit (because no further value will come thus it's safe to emit the last value).\n\nAs for why the duplication, doesn't look to me right either so I'll investigate it further.\n"
      },
      {
        "user": "httpdispatch",
        "created_at": "2016-01-29T11:49:54Z",
        "body": "Thank You for the help. Should i use flatMap or defer to overcome the debounce issue?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-01-29T11:50:54Z",
        "body": "The reason you see the duplication because you peek via `doOnEach` which is get called for `onNext` and `onCompleted` in your test. You can see this if you append the `__` to the output:\n\n``` java\n.doOnEach(__ -> System.out.println(\"on value emitted \"+System.currentTimeMillis() + __))\n```\n\nwhich prints:\n\n```\non value emitted 1454068146563[rx.Notification@1e307009 OnNext true]\non value emitted 2 1454068146563[rx.Notification@1e307009 OnNext true]\non value emitted 2 1454068146565[rx.Notification@4edde6e5 OnCompleted]\non value emitted 3 1454068146565[rx.Notification@1e307009 OnNext true]\ndone 1454068146565\non value emitted 3 1454068146565[rx.Notification@4edde6e5 OnCompleted]\n```\n\nIf you are not interested in all the event types, use `doOnNext` instead.\n"
      },
      {
        "user": "httpdispatch",
        "created_at": "2016-01-29T11:52:26Z",
        "body": "Oh, thank you very much for explanation\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-01-29T11:53:30Z",
        "body": "> Thank You for the help. Should i use flatMap or defer to overcome the debounce issue?\n\nThat do you want to achieve in the first place? Using `take(1).debounce()` is pointless because there won't be more values for debounce to work on.\n"
      },
      {
        "user": "httpdispatch",
        "created_at": "2016-01-29T11:55:02Z",
        "body": "I want the subscription to work like a replacement for CountDownTimer. When first event arrives - timer starts. All next events should be ignored\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-01-29T11:57:03Z",
        "body": "In this case, you can use delay instead:\n\n``` java\nsource.take(1).delay(1, TimeUnit.SECONDS)...\n```\n"
      },
      {
        "user": "httpdispatch",
        "created_at": "2016-01-29T12:20:44Z",
        "body": "Looks like flatMap also works, but your solution is much better. Thank You very much for your help\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why `take(1)` causes `debounce` to emit immediately",
      "Clarification about event types captured by `doOnEach` vs `doOnNext`",
      "Alternative approach to implement timer-like behavior after first emission",
      "Explanation of operator ordering effects in RxJava chains"
    ]
  },
  {
    "number": 3611,
    "title": "GroupedObservable -> toBlocking() - hang forever",
    "created_at": "2016-01-11T13:31:57Z",
    "closed_at": "2016-01-11T20:42:51Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3611",
    "body": "Found an issue where `groupObservable.toBlocking()` hangs.\n\n`rxjava:1.1.0`\n\n```\nObservable\n            .just(1, 1, 2, 3, 4, 4, 5)\n            .groupBy(new Func1<Integer, Boolean>() {\n                @Override\n                public Boolean call(Integer integer) {\n                    return integer % 2 == 0;\n                }\n            }).subscribe(new Action1<GroupedObservable<Boolean, Integer>>() {\n            @Override\n            public void call(GroupedObservable<Boolean, Integer> grouped) {\n                List<Integer> first = grouped.toList().toBlocking().first();\n                Timber.d(first.size() + \" (Even: \" + grouped.getKey() + \")\");\n            }\n        });\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3611/comments",
    "author": "palaima",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-01-11T15:47:43Z",
        "body": "Hi. This is expected as the `toBlocking` gives access to blocking functions that may block the sequence. In this case, the problem is that `toList` expects a complete stream and won't emit until it receives an `onCompleted` event, Since you applied `toBlocking().first()`, that will block the current thread until it receives a single element which `toList` can't ever produce; the whole chain up to the producing `just` is blocked. The usual solution is to use `flatMap` and do some non-blocking processing with `GroupedObservable`:\n\n``` java\nObservable.just(1, 1, 2, 3, 4, 4, 5)\n.groupBy(v -> v % 2 == 0)\n.flatMap(g -> g.toList().doOnNext(first ->\n    Timber.d(first.size() + \" (Even: \" + g.getKey() + \")\")).ignoreElements())\n.subscribe(v -> { }, Throwable::printStackTrace);\n```\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why the blocking call causes a deadlock in grouped observable processing",
      "Demonstration of non-blocking stream completion handling for GroupedObservable",
      "Use of appropriate RxJava operators for merging/flattening grouped streams"
    ]
  },
  {
    "number": 3608,
    "title": "Computation Scheduler stopping/slowing items from processing",
    "created_at": "2016-01-07T16:02:33Z",
    "closed_at": "2016-01-07T20:03:19Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3608",
    "body": "I am having a problem with trying to multi-thread my application to improve performance. My actual application follows a similar structure to the code below (except using real data and doing real work). I am using a flatMap so that I can simultaneously process the items on mutliple threads since the map work can potentially take a lot of time. \n\nWhat I am seeing, is when an item takes a long time to process in the map, it stops the items from being processed by other threads in the pool. In this example, I am seeing 11 items waiting till after the \"Done Sleeping...\" to be processed. The point of the multi-threading is for those items to be all processed in parallel with the item that is processing slowly.\n\nI noticed by switching to a FixedThreadPool Scheduler, it works as expected and the other threads pick up all the items remaining to be processed. \n\nWhy does the computation scheduler act like this? Is it a bug, or is there something I am not understanding?\n\nThe code snippet is in Groovy and I am using RxJava 1.1.0.\n\n```\nimport rx.Observable\nimport rx.Scheduler\nimport rx.schedulers.Schedulers\n\nimport java.util.concurrent.CountDownLatch\nimport java.util.concurrent.Executors\n\ndef threadpool = Executors.newFixedThreadPool(8)\ndef latch = new CountDownLatch(1)\n\n// Using a fixed thread pool works\n//Scheduler scheduler = Schedulers.from(threadpool)\n\n// Using the computation thread pool doesn't\nScheduler scheduler = Schedulers.computation()\n\nObservable.from(1..100).flatMap {\n    Observable.just(it).subscribeOn(scheduler).map {\n        if (it == 5) {\n            println \"${Thread.currentThread().name} - Sleeping... ${it}\"\n            // simulate long work here - only on certain items\n            Thread.sleep(15_000)\n            println \"${Thread.currentThread().name} - Done Sleeping... ${it}\"\n        }\n        return it\n    }\n}.subscribe ({\n    println \"${Thread.currentThread().name} - Got a num: ${it}\"\n}, {\n    println \"Error\"\n    it.printStackTrace()\n    threadpool.shutdown()\n    latch.countDown()\n}, {\n    println 'Complete'\n    threadpool.shutdown()\n    latch.countDown()\n})\nlatch.await()\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3608/comments",
    "author": "ottboy4",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-01-07T17:30:24Z",
        "body": "Hi. This code doesn't exhibit any unexpected delays: it emits all but one value and waits for the 15s sleep. I get a bunch of thread prints on my i7 4770K (4 core, 8 threads)\n\n``` java\nObservable.range(1, 100)\n    .flatMap(v -> Observable.just(v)\n            .subscribeOn(Schedulers.computation())\n            .map(u -> {\n                System.out.printf(\"P | %s: %s%n\", Thread.currentThread(), u);\n                if (u == 5) {\n                    try {\n                        Thread.sleep(15_000);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n                return u;\n            }))\n    .doOnNext(v -> {\n        System.out.printf(\"  | %s: %s%n\", Thread.currentThread(), v);\n    }).toBlocking().subscribe();\n```\n\nBecause `flatMap` routes to a single thread, it may get stuck with one particular thread when merged, but it shouldn't block of the other threads.\n"
      },
      {
        "user": "ottboy4",
        "created_at": "2016-01-07T17:50:46Z",
        "body": "akarnokd,\n\nHere is the exact output when I run the java code from your comment (I added in a timestamp on the print outs).\n\nNotice how 13, 21, 29, 37, etc do not get processed till After 5 prints out in the doOnNext? So you are seeing different results than this?\n\nI am using java 8u45.\n\n```\nP | 11:47:47:333 Thread[RxComputationThreadPool-6,5,main]: 4\n  | 11:47:47:336 Thread[RxComputationThreadPool-6,5,main]: 4\nP | 11:47:47:337 Thread[RxComputationThreadPool-6,5,main]: 12\nP | 11:47:47:337 Thread[RxComputationThreadPool-8,5,main]: 6\nP | 11:47:47:337 Thread[RxComputationThreadPool-4,5,main]: 2\nP | 11:47:47:337 Thread[RxComputationThreadPool-2,5,main]: 8\nP | 11:47:47:337 Thread[RxComputationThreadPool-1,5,main]: 7\nP | 11:47:47:337 Thread[RxComputationThreadPool-3,5,main]: 1\nP | 11:47:47:337 Thread[RxComputationThreadPool-5,5,main]: 3\n  | 11:47:47:337 Thread[RxComputationThreadPool-6,5,main]: 12\nP | 11:47:47:337 Thread[RxComputationThreadPool-7,5,main]: 5\nP | 11:47:47:339 Thread[RxComputationThreadPool-6,5,main]: 20\n  | 11:47:47:339 Thread[RxComputationThreadPool-6,5,main]: 20\nP | 11:47:47:340 Thread[RxComputationThreadPool-6,5,main]: 28\n  | 11:47:47:340 Thread[RxComputationThreadPool-6,5,main]: 28\nP | 11:47:47:340 Thread[RxComputationThreadPool-6,5,main]: 36\n  | 11:47:47:341 Thread[RxComputationThreadPool-6,5,main]: 36\nP | 11:47:47:344 Thread[RxComputationThreadPool-6,5,main]: 44\n  | 11:47:47:344 Thread[RxComputationThreadPool-6,5,main]: 44\nP | 11:47:47:344 Thread[RxComputationThreadPool-1,5,main]: 15\nP | 11:47:47:344 Thread[RxComputationThreadPool-5,5,main]: 11\nP | 11:47:47:344 Thread[RxComputationThreadPool-8,5,main]: 14\nP | 11:47:47:345 Thread[RxComputationThreadPool-5,5,main]: 19\nP | 11:47:47:345 Thread[RxComputationThreadPool-5,5,main]: 27\nP | 11:47:47:346 Thread[RxComputationThreadPool-5,5,main]: 35\nP | 11:47:47:346 Thread[RxComputationThreadPool-5,5,main]: 43\nP | 11:47:47:346 Thread[RxComputationThreadPool-5,5,main]: 51\nP | 11:47:47:346 Thread[RxComputationThreadPool-5,5,main]: 59\nP | 11:47:47:347 Thread[RxComputationThreadPool-5,5,main]: 67\nP | 11:47:47:347 Thread[RxComputationThreadPool-5,5,main]: 75\nP | 11:47:47:345 Thread[RxComputationThreadPool-1,5,main]: 23\n  | 11:47:47:345 Thread[RxComputationThreadPool-6,5,main]: 1\nP | 11:47:47:345 Thread[RxComputationThreadPool-3,5,main]: 9\nP | 11:47:47:345 Thread[RxComputationThreadPool-2,5,main]: 16\nP | 11:47:47:345 Thread[RxComputationThreadPool-4,5,main]: 10\nP | 11:47:47:348 Thread[RxComputationThreadPool-2,5,main]: 24\nP | 11:47:47:348 Thread[RxComputationThreadPool-3,5,main]: 17\n  | 11:47:47:348 Thread[RxComputationThreadPool-6,5,main]: 2\nP | 11:47:47:348 Thread[RxComputationThreadPool-2,5,main]: 32\nP | 11:47:47:347 Thread[RxComputationThreadPool-1,5,main]: 31\nP | 11:47:47:347 Thread[RxComputationThreadPool-5,5,main]: 83\nP | 11:47:47:349 Thread[RxComputationThreadPool-5,5,main]: 91\nP | 11:47:47:349 Thread[RxComputationThreadPool-5,5,main]: 99\nP | 11:47:47:345 Thread[RxComputationThreadPool-8,5,main]: 22\nP | 11:47:47:349 Thread[RxComputationThreadPool-1,5,main]: 39\nP | 11:47:47:349 Thread[RxComputationThreadPool-2,5,main]: 40\nP | 11:47:47:350 Thread[RxComputationThreadPool-1,5,main]: 47\nP | 11:47:47:350 Thread[RxComputationThreadPool-2,5,main]: 48\n  | 11:47:47:348 Thread[RxComputationThreadPool-6,5,main]: 3\nP | 11:47:47:348 Thread[RxComputationThreadPool-3,5,main]: 25\nP | 11:47:47:348 Thread[RxComputationThreadPool-4,5,main]: 18\nP | 11:47:47:351 Thread[RxComputationThreadPool-4,5,main]: 26\nP | 11:47:47:351 Thread[RxComputationThreadPool-4,5,main]: 34\nP | 11:47:47:351 Thread[RxComputationThreadPool-3,5,main]: 33\nP | 11:47:47:351 Thread[RxComputationThreadPool-3,5,main]: 41\nP | 11:47:47:352 Thread[RxComputationThreadPool-3,5,main]: 49\nP | 11:47:47:352 Thread[RxComputationThreadPool-3,5,main]: 57\nP | 11:47:47:352 Thread[RxComputationThreadPool-3,5,main]: 65\n  | 11:47:47:350 Thread[RxComputationThreadPool-6,5,main]: 6\nP | 11:47:47:350 Thread[RxComputationThreadPool-2,5,main]: 56\nP | 11:47:47:350 Thread[RxComputationThreadPool-1,5,main]: 55\nP | 11:47:47:350 Thread[RxComputationThreadPool-8,5,main]: 30\nP | 11:47:47:353 Thread[RxComputationThreadPool-2,5,main]: 64\nP | 11:47:47:352 Thread[RxComputationThreadPool-3,5,main]: 73\n  | 11:47:47:353 Thread[RxComputationThreadPool-6,5,main]: 7\nP | 11:47:47:351 Thread[RxComputationThreadPool-4,5,main]: 42\n  | 11:47:47:354 Thread[RxComputationThreadPool-6,5,main]: 8\nP | 11:47:47:354 Thread[RxComputationThreadPool-3,5,main]: 81\nP | 11:47:47:354 Thread[RxComputationThreadPool-2,5,main]: 72\nP | 11:47:47:353 Thread[RxComputationThreadPool-8,5,main]: 38\nP | 11:47:47:353 Thread[RxComputationThreadPool-1,5,main]: 63\nP | 11:47:47:355 Thread[RxComputationThreadPool-8,5,main]: 46\nP | 11:47:47:354 Thread[RxComputationThreadPool-2,5,main]: 80\nP | 11:47:47:354 Thread[RxComputationThreadPool-3,5,main]: 89\n  | 11:47:47:354 Thread[RxComputationThreadPool-6,5,main]: 9\nP | 11:47:47:354 Thread[RxComputationThreadPool-4,5,main]: 50\n  | 11:47:47:355 Thread[RxComputationThreadPool-6,5,main]: 10\nP | 11:47:47:355 Thread[RxComputationThreadPool-3,5,main]: 97\n  | 11:47:47:356 Thread[RxComputationThreadPool-6,5,main]: 11\nP | 11:47:47:355 Thread[RxComputationThreadPool-2,5,main]: 88\nP | 11:47:47:356 Thread[RxComputationThreadPool-2,5,main]: 96\nP | 11:47:47:355 Thread[RxComputationThreadPool-8,5,main]: 54\nP | 11:47:47:355 Thread[RxComputationThreadPool-1,5,main]: 71\nP | 11:47:47:357 Thread[RxComputationThreadPool-8,5,main]: 62\n  | 11:47:47:356 Thread[RxComputationThreadPool-6,5,main]: 14\nP | 11:47:47:356 Thread[RxComputationThreadPool-4,5,main]: 58\n  | 11:47:47:357 Thread[RxComputationThreadPool-6,5,main]: 15\nP | 11:47:47:357 Thread[RxComputationThreadPool-8,5,main]: 70\nP | 11:47:47:357 Thread[RxComputationThreadPool-1,5,main]: 79\nP | 11:47:47:357 Thread[RxComputationThreadPool-8,5,main]: 78\n  | 11:47:47:357 Thread[RxComputationThreadPool-6,5,main]: 16\nP | 11:47:47:357 Thread[RxComputationThreadPool-4,5,main]: 66\n  | 11:47:47:358 Thread[RxComputationThreadPool-6,5,main]: 17\nP | 11:47:47:358 Thread[RxComputationThreadPool-8,5,main]: 86\nP | 11:47:47:358 Thread[RxComputationThreadPool-1,5,main]: 87\nP | 11:47:47:358 Thread[RxComputationThreadPool-8,5,main]: 94\n  | 11:47:47:358 Thread[RxComputationThreadPool-6,5,main]: 18\nP | 11:47:47:358 Thread[RxComputationThreadPool-4,5,main]: 74\nP | 11:47:47:359 Thread[RxComputationThreadPool-4,5,main]: 82\nP | 11:47:47:359 Thread[RxComputationThreadPool-4,5,main]: 90\nP | 11:47:47:358 Thread[RxComputationThreadPool-1,5,main]: 95\n  | 11:47:47:359 Thread[RxComputationThreadPool-6,5,main]: 19\nP | 11:47:47:363 Thread[RxComputationThreadPool-4,5,main]: 98\n  | 11:47:47:363 Thread[RxComputationThreadPool-6,5,main]: 22\n  | 11:47:47:364 Thread[RxComputationThreadPool-6,5,main]: 23\n  | 11:47:47:364 Thread[RxComputationThreadPool-6,5,main]: 24\n  | 11:47:47:364 Thread[RxComputationThreadPool-6,5,main]: 25\n  | 11:47:47:364 Thread[RxComputationThreadPool-6,5,main]: 26\n  | 11:47:47:364 Thread[RxComputationThreadPool-6,5,main]: 27\n  | 11:47:47:364 Thread[RxComputationThreadPool-6,5,main]: 30\n  | 11:47:47:364 Thread[RxComputationThreadPool-6,5,main]: 31\n  | 11:47:47:365 Thread[RxComputationThreadPool-6,5,main]: 32\n  | 11:47:47:365 Thread[RxComputationThreadPool-6,5,main]: 33\n  | 11:47:47:365 Thread[RxComputationThreadPool-6,5,main]: 34\n  | 11:47:47:365 Thread[RxComputationThreadPool-6,5,main]: 35\n  | 11:47:47:365 Thread[RxComputationThreadPool-6,5,main]: 38\n  | 11:47:47:365 Thread[RxComputationThreadPool-6,5,main]: 39\n  | 11:47:47:365 Thread[RxComputationThreadPool-6,5,main]: 40\n  | 11:47:47:366 Thread[RxComputationThreadPool-6,5,main]: 41\n  | 11:47:47:366 Thread[RxComputationThreadPool-6,5,main]: 42\n  | 11:47:47:366 Thread[RxComputationThreadPool-6,5,main]: 43\n  | 11:47:47:366 Thread[RxComputationThreadPool-6,5,main]: 46\n  | 11:47:47:366 Thread[RxComputationThreadPool-6,5,main]: 47\n  | 11:47:47:366 Thread[RxComputationThreadPool-6,5,main]: 48\n  | 11:47:47:366 Thread[RxComputationThreadPool-6,5,main]: 49\n  | 11:47:47:367 Thread[RxComputationThreadPool-6,5,main]: 50\n  | 11:47:47:367 Thread[RxComputationThreadPool-6,5,main]: 51\n  | 11:47:47:367 Thread[RxComputationThreadPool-6,5,main]: 54\n  | 11:47:47:367 Thread[RxComputationThreadPool-6,5,main]: 55\n  | 11:47:47:368 Thread[RxComputationThreadPool-6,5,main]: 56\n  | 11:47:47:368 Thread[RxComputationThreadPool-6,5,main]: 57\n  | 11:47:47:368 Thread[RxComputationThreadPool-6,5,main]: 58\n  | 11:47:47:368 Thread[RxComputationThreadPool-6,5,main]: 59\n  | 11:47:47:368 Thread[RxComputationThreadPool-6,5,main]: 62\n  | 11:47:47:368 Thread[RxComputationThreadPool-6,5,main]: 63\n  | 11:47:47:369 Thread[RxComputationThreadPool-6,5,main]: 64\n  | 11:47:47:370 Thread[RxComputationThreadPool-6,5,main]: 65\n  | 11:47:47:370 Thread[RxComputationThreadPool-6,5,main]: 66\n  | 11:47:47:370 Thread[RxComputationThreadPool-6,5,main]: 67\n  | 11:47:47:370 Thread[RxComputationThreadPool-6,5,main]: 70\n  | 11:47:47:370 Thread[RxComputationThreadPool-6,5,main]: 71\n  | 11:47:47:374 Thread[RxComputationThreadPool-6,5,main]: 72\n  | 11:47:47:375 Thread[RxComputationThreadPool-6,5,main]: 73\n  | 11:47:47:375 Thread[RxComputationThreadPool-6,5,main]: 74\n  | 11:47:47:375 Thread[RxComputationThreadPool-6,5,main]: 75\n  | 11:47:47:375 Thread[RxComputationThreadPool-6,5,main]: 78\n  | 11:47:47:375 Thread[RxComputationThreadPool-6,5,main]: 79\n  | 11:47:47:375 Thread[RxComputationThreadPool-6,5,main]: 80\n  | 11:47:47:375 Thread[RxComputationThreadPool-6,5,main]: 81\n  | 11:47:47:376 Thread[RxComputationThreadPool-6,5,main]: 82\n  | 11:47:47:376 Thread[RxComputationThreadPool-6,5,main]: 83\n  | 11:47:47:376 Thread[RxComputationThreadPool-6,5,main]: 86\n  | 11:47:47:376 Thread[RxComputationThreadPool-6,5,main]: 87\n  | 11:47:47:376 Thread[RxComputationThreadPool-6,5,main]: 88\n  | 11:47:47:376 Thread[RxComputationThreadPool-6,5,main]: 89\n  | 11:47:47:376 Thread[RxComputationThreadPool-6,5,main]: 90\n  | 11:47:47:377 Thread[RxComputationThreadPool-6,5,main]: 91\n  | 11:47:47:377 Thread[RxComputationThreadPool-6,5,main]: 94\n  | 11:47:47:377 Thread[RxComputationThreadPool-6,5,main]: 95\n  | 11:47:47:377 Thread[RxComputationThreadPool-6,5,main]: 96\n  | 11:47:47:377 Thread[RxComputationThreadPool-6,5,main]: 97\n  | 11:47:47:377 Thread[RxComputationThreadPool-6,5,main]: 98\n  | 11:47:47:378 Thread[RxComputationThreadPool-6,5,main]: 99\nP | 11:47:47:378 Thread[RxComputationThreadPool-6,5,main]: 52\n  | 11:47:47:378 Thread[RxComputationThreadPool-6,5,main]: 52\nP | 11:47:47:378 Thread[RxComputationThreadPool-6,5,main]: 60\n  | 11:47:47:378 Thread[RxComputationThreadPool-6,5,main]: 60\nP | 11:47:47:379 Thread[RxComputationThreadPool-6,5,main]: 68\n  | 11:47:47:379 Thread[RxComputationThreadPool-6,5,main]: 68\nP | 11:47:47:379 Thread[RxComputationThreadPool-6,5,main]: 76\n  | 11:47:47:379 Thread[RxComputationThreadPool-6,5,main]: 76\nP | 11:47:47:379 Thread[RxComputationThreadPool-6,5,main]: 84\n  | 11:47:47:379 Thread[RxComputationThreadPool-6,5,main]: 84\nP | 11:47:47:380 Thread[RxComputationThreadPool-6,5,main]: 92\n  | 11:47:47:380 Thread[RxComputationThreadPool-6,5,main]: 92\nP | 11:47:47:380 Thread[RxComputationThreadPool-6,5,main]: 100\n  | 11:47:47:380 Thread[RxComputationThreadPool-6,5,main]: 100\n  | 11:48:02:339 Thread[RxComputationThreadPool-7,5,main]: 5\nP | 11:48:02:339 Thread[RxComputationThreadPool-7,5,main]: 13\n  | 11:48:02:339 Thread[RxComputationThreadPool-7,5,main]: 13\nP | 11:48:02:339 Thread[RxComputationThreadPool-7,5,main]: 21\n  | 11:48:02:340 Thread[RxComputationThreadPool-7,5,main]: 21\nP | 11:48:02:340 Thread[RxComputationThreadPool-7,5,main]: 29\n  | 11:48:02:340 Thread[RxComputationThreadPool-7,5,main]: 29\nP | 11:48:02:340 Thread[RxComputationThreadPool-7,5,main]: 37\n  | 11:48:02:340 Thread[RxComputationThreadPool-7,5,main]: 37\nP | 11:48:02:340 Thread[RxComputationThreadPool-7,5,main]: 45\n  | 11:48:02:340 Thread[RxComputationThreadPool-7,5,main]: 45\nP | 11:48:02:340 Thread[RxComputationThreadPool-7,5,main]: 53\n  | 11:48:02:340 Thread[RxComputationThreadPool-7,5,main]: 53\nP | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 61\n  | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 61\nP | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 69\n  | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 69\nP | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 77\n  | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 77\nP | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 85\n  | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 85\nP | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 93\n  | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 93\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-01-07T18:32:26Z",
        "body": "Okay, now I see it. What happens is that the threads of the computation scheduler get assigned to in a round-robin fashion, the 13th, 21th, etc value will queue up behind 5 and won't get executed until the sleep runs out.\n\nThe reason the fixed threadpool works is because it doesn't have value-to-thread pinning like the computation scheduler. Since each value runs individually, a pool thread can pick it any time and execute it; nobody has to wait on a sleeping thread if there are enough available threads.\n"
      },
      {
        "user": "ottboy4",
        "created_at": "2016-01-07T19:21:11Z",
        "body": "Great explanation. I believe I understand it now.\n\nHowever, why is it that the computation scheduler performs like that? Is there a benefit of doing it that way?\nFrom what I can see in this example I would rather have the functionality of the fixed thread pool over using the computation scheduler. \n\nThe main reason this is an issue is I specify maxConcurrent in the flatMap (since my producer produces items faster than my threads can process the items). Which this now causes the rest of the items to not be processed till my slow thread finishes.\n\nTry this code now, with the maxConcurrent specified. Now you should see that it processes about half the items and stops (waiting on the slow thread), then after the slow thread picks up the rest of the items are processed.\n\n```\nObservable.range(1, 100)\n        .flatMap(v -> Observable.just(v)\n                .subscribeOn(Schedulers.computation())\n                .map(u -> {\n                    System.out.printf(\"P | %s: %s%n\", Thread.currentThread(), u);\n                    if (u == 5) {\n                        try {\n                            Thread.sleep(15_000);\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    return u;\n                }), 8)\n        .doOnNext(v -> {\n            System.out.printf(\"  | %s: %s%n\", Thread.currentThread(), v);\n        }).toBlocking().subscribe();\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-01-07T19:45:51Z",
        "body": "> Is there a benefit of doing it that way?\n\nYes, schedulers create workers, which are practically threads, that execute the work sequentially in respect of each other. This is in line with the sequential requirement of subscribers thus there is no need and overhead of making every inner component fully thread safe. In addition, this pinning gives cache locality. In summary, it has performance benefits.\n\nUsing `Scheduler.from` doesn't have this same-thread guarantee (although it is sequential still) and hops threads at random. This is generally slower but can handle your blocking situation much better.\n\n> Which this now causes the rest of the items to not be processed till my slow thread finishes.\n\nthreads are round robin assigned to values but this time you can have only 8 concurrent subscriptions. After a dozen elements, all that remains are those who have been assigned the thread that is blocked.\n"
      },
      {
        "user": "ottboy4",
        "created_at": "2016-01-07T20:03:19Z",
        "body": "Perfect. Thank you for the explanation.\n\nFor my case, I will probably switch over to `Scheduler.from` with a fixed thread pool since that will give me better performance for what I am trying to achieve. \n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why the computation scheduler exhibits thread pinning behavior",
      "Comparison of computation scheduler vs fixed thread pool threading models",
      "Guidance on scheduler selection for blocking operations",
      "Clarification of RxJava's worker thread allocation strategy",
      "Explanation of tradeoffs between thread pinning and free thread allocation"
    ]
  },
  {
    "number": 3598,
    "title": "BehaviorSubject deadlocks when using subject.single().toBlocking().single()",
    "created_at": "2016-01-05T00:31:43Z",
    "closed_at": "2016-01-05T16:50:35Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3598",
    "body": "When I use `.single().toBlocking().single()` on a `BehaviorSubject` (where a default item has been set), it will deadlock the following test. When `.take(1).toBlocking().single()` is used, the test completes successfully.\n\n``` java\nSystem.out.println(\"take(1) started\");\nBehaviorSubject.create(\"Item\").take(1).toBlocking().single();\nSystem.out.println(\"take(1) finished\");\n\nSystem.out.println(\"single() started\");\nBehaviorSubject.create(\"Item\").single().toBlocking().single(); // Deadlocks here\nSystem.out.println(\"single() finished\");\n```\n\nAm I doing something wrong here?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3598/comments",
    "author": "austynmahoney",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-01-05T08:12:51Z",
        "body": "`Observable.single` requires 1 element and 1 completion signal to emit a single item or 2 elements to emit an overflow error. Since there is no more item, the second stream will hang indefinitely. This is the expected behavior.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why `single()` causes a deadlock while `take(1)` works",
      "Clarification of the completion signal requirements for `single()`",
      "Guidance on when to use `single()` vs `take(1)` with BehaviorSubject",
      "Explanation of BehaviorSubject's lifecycle in relation to terminal events"
    ]
  },
  {
    "number": 3594,
    "title": "Why the executors only use one thread?",
    "created_at": "2015-12-30T11:27:23Z",
    "closed_at": "2015-12-31T10:09:02Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3594",
    "body": "I have created a fixed thread-pool to process an event emit per 300 milliseconds and assume the process need 1000 millisecond. Suppose the multi-thread will work but only one thread reused.\n\nIf i set the sleepTime smaller than 300ms, the processing thread change, but that is useless.\n\nQuestions: What can I do to make it concurrent? Why the program reuse the thread?\n\nThank you in advance\n\n``` java\npublic static void main(String[] args) throws InterruptedException {\n    long sleepTime = 1000;\n    ExecutorService e = Executors.newFixedThreadPool(3);\n\n    Observable.interval(300, TimeUnit.MILLISECONDS)\n    .subscribeOn(Schedulers.computation())\n    .flatMap(new Func1<Long, Observable<Long>>() {\n        @Override\n        public Observable<Long> call(Long pT) {\n            return Observable.just(pT).subscribeOn(Schedulers.from(e));\n        }\n    })\n    .doOnNext(new Action1<Long>() {\n\n        @Override\n        public void call(Long pT) {\n            try {\n                Thread.sleep(sleepTime);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n        }\n    })\n    .subscribe(new Action1<Long>() {\n\n        @Override\n        public void call(Long pT) {\n            System.out.println(\"i am \" + pT + \"in thread:\" + Thread.currentThread().getName());\n\n        }\n    });\n\n\n    Thread.sleep(50000);\n    e.shutdownNow();\n\n}\n\n\n\ni am 0in thread:pool-1-thread-1\ni am 1in thread:pool-1-thread-1\ni am 2in thread:pool-1-thread-1\ni am 3in thread:pool-1-thread-1\ni am 4in thread:pool-1-thread-1\ni am 5in thread:pool-1-thread-1\ni am 6in thread:pool-1-thread-1\ni am 7in thread:pool-1-thread-1\ni am 8in thread:pool-1-thread-1\ni am 9in thread:pool-1-thread-1\ni am 10in thread:pool-1-thread-1\ni am 11in thread:pool-1-thread-1\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3594/comments",
    "author": "rockman12352",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-12-30T12:09:59Z",
        "body": "Its a thread pool and if you don't have high enough throughput, it won't even create new threads. That single thread can serve all tasks easily.\n"
      },
      {
        "user": "rockman12352",
        "created_at": "2015-12-30T14:46:33Z",
        "body": "@akarnokd Thank you for your reply. I have set sleep time, it doesn't count?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-12-30T14:53:51Z",
        "body": "What happens is that the first `just` value runs on the other scheduler and gets blocked by sleep so that the other values have plenty of time to run and get queued up in flatMap. Once the first thread unblocks it finds a ton of values available and resumes emitting on the same thread. Thus, on the output side, only one thread shows up but inside, just execute on the rest of the thread. put doOnNext on those inner sequences and see where they run.\n"
      },
      {
        "user": "rockman12352",
        "created_at": "2015-12-31T02:40:19Z",
        "body": "@akarnokd With your advice, i modify the code. just and sleep are not in the same thread. So it should not effect each other\n\n\n---\n\n@akarnokd Finally, i got what you mean, you are right!  Million thanks!\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-12-31T10:09:02Z",
        "body": "Great!\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why the thread pool isn't utilizing multiple threads despite configuration",
      "Clarification of how task scheduling interacts with thread pool management in RxJava",
      "Identification of throughput requirements for thread pool thread creation",
      "Explanation of task queuing behavior in flatMap with schedulers"
    ]
  },
  {
    "number": 3557,
    "title": "onErrorResumeNext/OperatorOnErrorResumeNextViaFunction ignoring unsubscription?",
    "created_at": "2015-12-04T09:45:35Z",
    "closed_at": "2015-12-04T13:54:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3557",
    "body": "I first wanted to ask, just in case, to check if the behavior I'm going to describe is the expected.\n\nIt happens that using the operator `OperatorOnErrorResumeNextViaFunction` seems to ignore the **unsubscription** event.\n\nI had this code for testing it.\n\n``` java\n        final AtomicBoolean readyToUnsubscribe = new AtomicBoolean(false);\n        final AtomicBoolean readyToFail = new AtomicBoolean(false);\n        final ReentrantLock lock = new ReentrantLock();\n        final Condition rtuCond = lock.newCondition();\n        final Condition rtfCond = lock.newCondition();\n\n\n        Subscription subscribe = Observable.create(\n                new Observable.OnSubscribe<String>() {\n                    @Override\n                    public void call(Subscriber<? super String> subscriber) {\n                        lock.lock();\n                        System.out.println(\"Subscription started: \" + !subscriber.isUnsubscribed());\n                        readyToUnsubscribe.set(true);\n                        rtuCond.signal();\n                        try {\n                            while (!readyToFail.get()) {\n                                rtfCond.await();\n                            }\n                        } catch (InterruptedException e) {\n                            Exceptions.throwIfFatal(e);\n                        } finally {\n                            lock.unlock();\n                        }\n                        System.out.println(\"Gonna fail\");\n                        throw new RuntimeException(\"Yup Crashing Bad!\");\n                    }\n                }\n        )\n                .onErrorResumeNext(\n                        new Func1<Throwable, Observable<? extends String>>() {\n                            @Override\n                            public Observable<? extends String> call(Throwable throwable) {\n                                return Observable.just(\"Recovered from: \" + throwable.getMessage());\n                            }\n                        }\n                )\n                .subscribeOn(Schedulers.io())\n                .subscribe(\n                        new Action1<String>() {\n                            @Override\n                            public void call(String s) {\n                                System.out.println(\"Got message: \" + s);\n                            }\n                        },\n                        new Action1<Throwable>() {\n                            @Override\n                            public void call(Throwable throwable) {\n                                throwable.printStackTrace(System.err);\n                            }\n                        },\n                        new Action0() {\n                            @Override\n                            public void call() {\n                                System.out.println(\"Completed\");\n                            }\n                        }\n                );\n\n        lock.lock();\n        while (!readyToUnsubscribe.get()) {\n            rtuCond.await();\n        }\n        subscribe.unsubscribe();\n        System.out.println(\"Now this is unsubscribed\");\n        readyToFail.set(false);\n        rtfCond.signal();\n        lock.unlock();\n```\n\nWhich gives the output\n\n```\nSubscription started: true\nNow this is unsubscribed\nGonna fail\nGot message: Recovered from: Yup Crashing Bad!\nCompleted\n```\n\nAnd I would have expected none of the Obsever's methods to be called indeed, that is last two lines of output should't be there. But this is my understanding, can somebody confirm if this should be considered a bug, or is it expected behavior of the onErrorResumeNext operator?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3557/comments",
    "author": "davidgarciaanton",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-12-04T10:16:14Z",
        "body": "Unsubscription is best effort so events may still slip through. In particular, `just` ignores backpressure and unsubscription completely. If you use `just(\"Recovered from: \" + throwable.getMessage(), \"\")`, it won't emit anything because that overload is more eager with unsubscription.\n"
      },
      {
        "user": "davidgarciaanton",
        "created_at": "2015-12-04T13:54:44Z",
        "body": "OK!\n\nThanks a lot @akarnokd for the clarification, so the problem was somewhere else I didn't just imagine. Thanks for pointing that out.\n\nJust closing this, as for me it's now clear.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how unsubscription interacts with error recovery operators in RxJava",
      "Clarification of RxJava's best-effort unsubscription behavior",
      "Identification of operator-specific behavior regarding unsubscription handling",
      "Differentiation between eager vs lazy error recovery strategies"
    ]
  },
  {
    "number": 3554,
    "title": "Observable.combineLatest ignores onCompleted?",
    "created_at": "2015-12-03T07:23:10Z",
    "closed_at": "2016-02-09T14:13:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3554",
    "body": "Hello. This is the code:\n\n``` java\nimport rx.Observable;\nimport rx.subjects.PublishSubject;\n\nfinal class OnNextIngored {\n\n   public static void main(final String[] args) {\n\n      final PublishSubject<Integer> publisher = PublishSubject.create();\n\n      // pass any arg to fail the day!\n      final boolean doFail = args.length != 0;\n\n      final Observable<Integer> possiblyFail\n         = Observable.<Integer>create(subscriber\n                                      -> {\n\n                                         if (doFail) {\n                                            subscriber.onError(new RuntimeException(\"blah\"));\n                                         } else {\n                                            subscriber.onNext(2);\n                                            subscriber.onCompleted();\n                                         }\n                                      });\n\n      publisher\n         .startWith(// combine latest ignores onCompleted ?\n                    Observable.combineLatest(possiblyFail ,\n                                             Observable.just(1),\n                                             (l, r) -> r + l)\n                    .take(2))\n         .onErrorResumeNext(Observable.just(4))\n         .subscribe(i -> {\n               log(\"i is: \" + i);\n            },\n            e -> {\n               log(\"error is: \" + e);\n            },\n            () -> {\n               log(\"completed\");\n            } );\n\n      publisher.onNext(5);\n      publisher.onNext( 6 );\n      publisher.onNext(7);\n   }\n\n   private static void log(final String s) {\n      System.out.println(s);\n   }\n}\n```\n\nDepending on value of doFail (which can be changed by passing arg to test app) the conveyor receives or does not receive onCompleted and thus it does or does not ignore onNext:\n\n```\n[elk@qulix-elktop java-rxjava]$ java -cp rxjava-1.0.16.jar:. OnNextIngored 4\ni is: 4\ncompleted\n[elk@qulix-elktop java-rxjava]$ java -cp rxjava-1.0.16.jar:. OnNextIngored \ni is: 3\ni is: 5\ni is: 6\ni is: 7\n```\n\nIs it expected behavior? If yes, why?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3554/comments",
    "author": "alosich",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-12-03T09:09:46Z",
        "body": "You don't call `publisher.onCompleted()` so the Subscriber won't receive it. If you start it to make error, it completes because the `onErrorResumeNext` receives the error before `publisher` is subscribed by `startWith`.\n"
      },
      {
        "user": "alosich",
        "created_at": "2015-12-03T09:26:32Z",
        "body": "@akarnokd ok, it seems I got it, thanks.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how Observable.combineLatest handles completion events from source Observables in RxJava",
      "Clarification of how startWith and onErrorResumeNext affect completion/error propagation in the observable chain",
      "Reasoning about why publisher.onNext() calls are processed/ignored in different scenarios",
      "Confirmation of whether this behavior aligns with RxJava's design principles"
    ]
  },
  {
    "number": 3541,
    "title": "Recommended way of applying operators to items in sequence of collections?",
    "created_at": "2015-11-26T12:11:41Z",
    "closed_at": "2015-11-26T17:00:04Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3541",
    "body": "When I want to transform the items in collections emitted in a stream, I find myself doing something like this:\n\n``` java\nObservable<List<Integer>> integerLists = \u2026\n// Emits [1, 2, 3], [4, 5, 6]\n\nintegerLists.concatMap(list -> Observable.from(list).map(x -> x * 2).toList())\n// Emits  [2, 4, 6], [8, 10,12]\n```\n\nIs there are cleaner/recommended way to achieve the same that doesn't require the 'Observable.from \u2026 toList' bit?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3541/comments",
    "author": "danhawkes",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-11-26T12:20:52Z",
        "body": "If you want to avoid in-place mutation, you can use Java Streams which looks almost the same:\n\n``` java\nObservable<List<Integer>> source = Observable.just(\n    Arrays.asList(1, 2, 3), Arrays.asList(4, 5, 6));\n\nsource.map(list -> list.stream().map(i -> i * 2).collect(Collectors.toList()))\n.subscribe(System.out::println);\n```\n\nSo essentially the pattern stays the same.\n"
      }
    ],
    "satisfaction_conditions": [
      "Avoids explicit conversion between List and Observable streams",
      "Preserves the original list emission structure",
      "Uses built-in operators/framework features rather than manual stream manipulation",
      "Provides equivalent transformation logic without nested Observable creation"
    ]
  },
  {
    "number": 3522,
    "title": "Why does the scan operator only emit the initialValue when receiving the first value from the observable (or on completion)?",
    "created_at": "2015-11-13T14:20:11Z",
    "closed_at": "2015-11-13T14:56:50Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3522",
    "body": "Hello, I am wondering why the scan() method with an initialValue only emits the initialValue when the first value from the observable arrives. I had expected this to happen instantly upon subscription. \n\nFor now, I worked around this issue by NOT providing an initialValue, and adding \".startWith()\" to the observable I am scanning. \n\nIn the `OperatorScan` class:\n\n``` java\n\n        return new Subscriber<T>(child) {\n            ...\n\n            @Override\n            public void onNext(T currentValue) {\n                emitInitialValueIfNeeded(child);\n                ...\n                child.onNext(this.value);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                child.onError(e);\n            }\n\n            @Override\n            public void onCompleted() {\n                emitInitialValueIfNeeded(child);\n                child.onCompleted();\n            }\n        }\n```\n\nExample scenario: scan an observable that counts from 0 to 4, emitting a number every second.\n\n``` java\nObservable\n    .create(new Observable.OnSubscribe<Integer>() {\n        @Override\n        public void call(Subscriber<? super Integer> subscriber) {\n            for (int i = 0; i < 5; i++) {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    subscriber.onError(e);\n                }\n                subscriber.onNext(i);\n            }\n            subscriber.onCompleted();\n        }\n    })\n    .scan(0, new Func2<Integer, Integer, Integer>() {\n        @Override\n        public Integer call(Integer sum, Integer nextNumber) {\n            return sum + nextNumber;\n        }\n    })\n```\n\nThe timeline of this observable would be:\n\n0ms : subscribe()\n1000ms: 0 <- the initial value\n1001ms: 0 <- the acummulated result of 0 + the initial value\n2000ms: 1 <- the accumulated result of 1 + 0\n3000ms: 3 <- the accumulated result of 2 + 1\n4000ms: 6 <- the accumulated result of 3 + 2\n5000ms: 10 <- the accumulated result of 4 + 6\n\nMy question is: why does this happen lazily. Why not immediately call `child.onNext(initialValue)` when the subscription starts? Why does the given example not produce value 0 at 1 ms? \n\nThank you in advance.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3522/comments",
    "author": "amoerie",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-11-13T14:38:30Z",
        "body": "This was a bug with 1.0.14 and has been fixed in 1.0.15. You should, however, switch to 1.0.16 instead as 1.0.15 had a regression bug with null initial value.\n"
      },
      {
        "user": "amoerie",
        "created_at": "2015-11-13T14:56:50Z",
        "body": "Ah ok, I was indeed not running on the latest version, my apologies. That seems to have fixed the problem! Thanks for the quick response.\n"
      }
    ],
    "satisfaction_conditions": [
      "Acknowledges the observed behavior is unintended and caused by a library bug",
      "Specifies which library version fixes the issue",
      "Explains the expected timing of initial value emission after the fix"
    ]
  },
  {
    "number": 3446,
    "title": "How can I use OperatorConcat<T>?",
    "created_at": "2015-10-14T16:31:52Z",
    "closed_at": "2016-02-09T13:56:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3446",
    "body": "I'm trying to write an operator `then<R,T>` which ignores all emissions from the source (except errors), and continues with a second Observable when completed.\n\nSomething like:\n\n```\n// Typical Case\nObservable.just(1, 2, 3, 4, 5)\n   .lift(new then<String, Integer>(Observable.just(\"Hello\")))\n   .subscribe(new Action1<String>() {\n      @Override\n      public void call(String s) {\n         // Called once with \"Hello\"\n      });\n\n// Source Errors\nObservable.<Integer>error(new RuntimeException())\n   .lift(new then<String, Integer>(Observable.just(\"Hello\")))  // <-- the second observable should never be subscribed to since the source error'd\n   .subscribe(new Action1<String>() {\n      @Override\n      public void call(String s) {\n         // Not Called\n\n      }, new Action1<Throwable>() {\n      @Override\n      public void call(Throwable e) {\n        System.out.println(\"Error: \"+e); // Should be called with the RuntimeException from above\n\n      }\n   });\n```\n\nI've come up with an implementation using `ignoreElements` + `map` + `concatWith`:\n\n```\n    public static <R, T> Observable<? extends R> then(Observable<T> source, Observable<R> other) {\n        return source\n                .ignoreElements()\n                .map(new Func1<T, R>() {\n                    @Override\n                    public R call(T integer) {\n                        return null;\n                    }\n                }).concatWith(other);\n    }\n```\n\nI'm quite new to writing custom operators, and I can't quite figure out how to translate that static function into an operator. I've written a few operators by composing the provided Operator\\* types, but I'm having trouble with this one.\n\nAny help would be greatly appreciated :)\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3446/comments",
    "author": "fougere-mike",
    "comments": [
      {
        "user": "JakeWharton",
        "created_at": "2015-10-14T16:32:53Z",
        "body": "This is discussed in #3113 and implemented awaiting merge in #3443.\n"
      },
      {
        "user": "fougere-mike",
        "created_at": "2015-10-14T17:12:48Z",
        "body": "Ok, well that eliminates the need for my operator, but I'm still interested in how it could be correctly implemented using lift(). I'm sure I'll be writing more operators in the future so I'd like to have a better understanding of how they work. \n\nThis is what I've come up with:\n\n```\n/**\n * Ignores all emissions from the source observable. Once the source completes, the provided\n * observable will be subscribed to. If the source errors, the error will terminate the stream and\n * the provided observable will not be subscribed to.\n *\n * @param <T> The type of objects emitted by the source observable.\n * @param <R> The type of objects emitted by the provided `next` observable.\n */\npublic class then<R, T> implements Observable.Operator<R, T> {\n    private final OperatorIgnoreElements<T> mIgnoreElements;\n    private final OperatorMap<T, R> mMap;\n    private final OperatorConcat<R> mConcat;\n\n    private final Observable<R> mNextObservable;\n\n    public then(Observable<R> nextObservable) {\n        assert( nextObservable != null );\n        mNextObservable = nextObservable;\n        mIgnoreElements = OperatorIgnoreElements.instance();\n        mMap = new OperatorMap<>(new Func1<T, R>() {\n            @Override\n            public R call(T t) {\n                return null;\n            }\n        });\n        mConcat = OperatorConcat.instance();\n    }\n\n    @Override\n    public Subscriber<? super T> call(final Subscriber<? super R> subscriber) {\n        // TODO: Compose operators...\n    }\n}\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-10-14T18:29:46Z",
        "body": "This is \"super easy\" to implement as an `Operator`:\n\n``` java\npublic final class Then<T, R> implements Operator<R, T> {\n    final Observable<R> other;\n\n    public Then(Observable<R> other) {\n        this.other = other;\n    }\n\n    @Override\n    public Subscriber<? super T> call(final Subscriber<? super R> t) {\n        MultipleAssignmentSubscription mas = new MultipleAssignmentSubscription();\n        t.add(mas);\n\n        Subscriber<T> parent = new Subscriber<T>() {\n            @Override\n            public void onNext(T t) {\n                // ignored\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                t.onError(e);\n            }\n\n            @Override\n            public void onCompleted() {\n                Subscriber<R> tr = Subscribers.wrap(t);\n                mas.set(tr);\n                other.subscribe(tr);\n            }\n        };\n\n        mas.set(parent);\n\n        return parent;\n    }\n}\n```\n"
      },
      {
        "user": "fougere-mike",
        "created_at": "2015-10-14T20:04:05Z",
        "body": "Awesome, thanks! \n\nI have a few questions about your solution:\n1. Shouldn't it check if the subscriber has unsubscribed before calling `t.onError(e)`?\n2. Why is the MultipleAssignmentSubscription needed? I'm a bit of an rx newbie, so it's not clear to me why you can't just return the `parent` subscriber directly.\n\nCheers!\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-02-09T13:56:28Z",
        "body": "1) unnecessary\n2) so the unsubscription from the child can target both the first parent and the second subscriber.\n"
      }
    ],
    "satisfaction_conditions": [
      "Handles source emissions by ignoring them while preserving errors",
      "Subscribes to second observable only after successful source completion",
      "Properly manages subscription lifecycle and unsubscription",
      "Avoids premature termination when source errors occur",
      "Demonstrates operator composition without relying on deprecated/internal RxJava components"
    ]
  },
  {
    "number": 3375,
    "title": "2.x: Merge and Queue Pooling",
    "created_at": "2015-09-25T03:28:18Z",
    "closed_at": "2015-09-25T19:17:48Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3375",
    "body": "@akarnokd Reading through the `merge` code in 2.x, it appears to not use pooling any longer. As soon as contention happens, it allocates a new array. We have proven previously as we've iterated on `merge` that we can't allocate arrays for every `InnerSubscriber`. What new data or evidence suggests that we can ignore past findings and do without pooling?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3375/comments",
    "author": "benjchristensen",
    "comments": [
      {
        "user": "benjchristensen",
        "created_at": "2015-09-25T03:35:50Z",
        "body": "Is it perhaps that the only time they are allocated is when contention occurs, and contention is already costly enough that the extra allocation no longer matters?\n\nTrying to match this design up with past efforts on `merge` ...\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-09-25T07:26:01Z",
        "body": "> it appears to not use pooling any longer\n\nThat's right.\n\n> As soon as contention happens, it allocates a new array\n\nIt's a Queue but yes.\n\n> We have proven previously as we've iterated on merge that we can't allocate arrays for every InnerSubscriber\n\nTrue, doesn't happen until contention.\n\n> What new data or evidence suggests that we can ignore past findings and do without pooling?\n\n#3352. Async performance improved over 1.x. Synchronous tests don't allocate any queue.\n\n> contention is already costly enough that the extra allocation no longer matters?\n\nIn 1.x the pooling and the inner synchronization of the RxRingBuffer contributed even more to the contention. If there are multiple async sources and all but one encounter a contention, they all start to contend on the pool. This is a transient event and if the sequences are long-running, doesn't appear on measurements. However, short lived sequences encounter this much more frequently.\n"
      },
      {
        "user": "benjchristensen",
        "created_at": "2015-09-25T19:17:48Z",
        "body": "Great, thanks for confirming my understanding and clarifying more. \n"
      }
    ],
    "satisfaction_conditions": [
      "Evidence that removing pooling reduces overall contention compared to the previous pooled implementation",
      "Demonstration that allocations during contention are infrequent enough to be negligible in real-world scenarios",
      "Explanation of how synchronous operations avoid queue allocations entirely",
      "Analysis showing improved async performance offsets potential allocation costs"
    ]
  },
  {
    "number": 3367,
    "title": "propagating request when using flatMap",
    "created_at": "2015-09-20T09:50:42Z",
    "closed_at": "2015-09-25T18:16:58Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3367",
    "body": "Hi, \n\nI ve this piece of code : \n\n```\nObservable\n    .from(IntStream.range(1, 20).boxed().collect(Collectors.toList()))\n    .map(i -> {\n                System.out.println(\"Step :\"+i);\n                return i;\n            })\n    .flatMap(elt ->\n                            Observable\n                                    .just(elt).observeOn(Schedulers.io())\n                                    .map(String::valueOf)\n\n            )\n    .subscribe(new Subscriber<String>() {\n\n                @Override\n                public void onStart() {\n                    request(1);\n                }\n\n                @Override\n                public void onCompleted() {}\n\n                @Override\n                public void onError(Throwable throwable) {}\n\n                @Override\n                public void onNext(String s) {\n                    System.out.println(\"Next : \" + s);\n                }\n            });\n```\n\nI expect this on the logs : \n\nStep : 1\nNext : 1\n\nBut Instead I've this : \n\nStep :1\nStep :2\nNext : 1\nStep :3\nStep :4\nStep :5\nStep :6\nStep :7\n...\n\nWhy does the request is not propagating to the source when I use flatMap ?\n\nThanks for your help! \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3367/comments",
    "author": "larousso",
    "comments": [
      {
        "user": "davidmoten",
        "created_at": "2015-09-20T22:06:12Z",
        "body": "You've only requested one so that is all you get arriving to the subscriber. The other log lines are because `flatMap` requests 128 (or 16 on Android) regardless of how many were requested of it and then buffers. When you request more `flatMap` will empty its buffer.\n\nIf you put a `request(1)` just after  `System.out.println(\"Next : \" + s);` then your stream will report all to the subscriber.\n"
      },
      {
        "user": "larousso",
        "created_at": "2015-09-21T06:22:29Z",
        "body": "Ok thanks. \nI didn't know that flatMap was buffering. It was the missing information :) \n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-09-25T18:16:58Z",
        "body": "@davidmoten :+1:\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how `flatMap` handles backpressure and request propagation",
      "Identification of the relationship between downstream requests and `flatMap`'s internal buffering",
      "Guidance on controlling upstream flow when using `flatMap`"
    ]
  },
  {
    "number": 3344,
    "title": "subscribe vs unsafeSubscribe",
    "created_at": "2015-09-14T15:56:04Z",
    "closed_at": "2015-09-14T18:19:06Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3344",
    "body": "What's the difference between `subscribe` and `unsafeSubscribe`?\n\nThe javadoc mentions that `unsafeSubscribe` should only be used for `Observable.Operator`, I'm assuming that includes `Observable.OnSubscribe`. Also, it briefly mentions nested subscriptions but it doesn't explain the difference in behavior of `subscribe` and `unsafeSubscribe`.\n\nAlso, is there guidance on when `Subscribers.wrap` should be used?\n\nHere's a snippet that I thought would behave the same, however `unsafeSubscribe` is working and `subscribe` is timing out.\n\n``` java\n  public static Observable<Long> foo() {\n    return Observable.create(subscriber -> {\n      Observable.timer(1, TimeUnit.MILLISECONDS)\n          .unsafeSubscribe(Subscribers.wrap(subscriber));\n    });\n  }\n\n  public static Observable<Long> foo2() {\n    return Observable.create(subscriber -> {\n      Observable.timer(1, TimeUnit.MILLISECONDS)\n          .subscribe(Subscribers.wrap(subscriber));\n    });\n  }\n\n  public static void main(String[] args) {\n    long result = foo().flatMap(value -> foo())\n        .timeout(1, TimeUnit.SECONDS)\n        .toBlocking().single();\n    System.out.println(\"result = \" + result);\n\n\n    long result2 = foo2().flatMap(value -> foo2())\n        .timeout(1, TimeUnit.SECONDS)\n        .toBlocking().single();\n    System.out.println(\"result2 = \" + result2);\n  }\n```\n\n```\nresult = 0\nException in thread \"main\" java.lang.RuntimeException: java.util.concurrent.TimeoutException\n    at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:455)\n    at rx.observables.BlockingObservable.single(BlockingObservable.java:331)\n    at Foo.main(Foo.java:39)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:483)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)\nCaused by: java.util.concurrent.TimeoutException\n    at rx.internal.operators.OperatorTimeoutBase$TimeoutSubscriber.onTimeout(OperatorTimeoutBase.java:169)\n    at rx.internal.operators.OperatorTimeout$1$1.call(OperatorTimeout.java:42)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3344/comments",
    "author": "vadims",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-09-14T16:53:43Z",
        "body": "Hello,\n\nthe difference is that `subscribe` wraps the `Subscriber` into a `SafeSubscriber` which captures exceptions thrown from the wrapped Subscriber's `onXXX` methods and unsubscribes both the upstream and downstream on a terminal event. `unsafeSubscribe` doesn't do this and is mainly there to avoid the wrapping overhead as much as possible.\n\nWhat happens here with `foo2` is that this downstream-directed unsubscription from `SafeSubscriber` cancels the merge operation which then cancels the inner `foo2` call and simply stops emitting anything (not even terminal events) and the next operator - timeout - will time out.\n\nGenerally, I'd warn against using `create` to roll your own source because there are subtle and less-subtle things that can go wrong.\n"
      },
      {
        "user": "vadims",
        "created_at": "2015-09-14T18:19:06Z",
        "body": "Thanks for the explanation, I think the javadoc could be improved to mention this.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explain the behavioral difference between subscribe and unsafeSubscribe regarding error handling and subscription management",
      "Clarify when Subscribers.wrap should be used in relation to subscription safety",
      "Describe how subscription wrapping affects operator interactions like timeout",
      "Explain implications of nested subscriptions in observable chains"
    ]
  },
  {
    "number": 3343,
    "title": " Equivalent with CompletableFuture.complete",
    "created_at": "2015-09-14T06:10:07Z",
    "closed_at": "2015-09-25T18:18:00Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3343",
    "body": "Hi,\nDose Rxjava Observable has equivalent with CompletableFuture.complete?\nlike: CompletableFuture future=new CompletableFuture();\n       ...do  something...\n       future.complete(xxx)\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3343/comments",
    "author": "GrapeBaBa",
    "comments": [
      {
        "user": "benjchristensen",
        "created_at": "2015-09-14T06:25:12Z",
        "body": "You can use a Subject for that type of 'promise' usage. \n\nSubject s = ReplaySubject.create()\n... do something ...\ns.onCompleted()\n\nOr for the more idiomatic approach, create a lazy Observable:\n\nreturn Observable.create(s -> {\n  ... do something ...\n  s.onCompleted()\n});\n\n> On Sep 13, 2015, at 11:10 PM, Chen Kai notifications@github.com wrote:\n> \n> Hi,\n> Dose Rxjava Observable has equivalent with CompletableFuture.complete?\n> like: CompletableFuture future=new CompletableFuture();\n> ...do something...\n> future.complete(xxx)\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n"
      },
      {
        "user": "GrapeBaBa",
        "created_at": "2015-09-14T10:06:31Z",
        "body": "Awesome.\n\n\u53d1\u81ea\u6211\u7684 iPhone\n\n> \u5728 2015\u5e749\u670814\u65e5\uff0c\u4e0b\u53482:25\uff0cBen Christensen notifications@github.com \u5199\u9053\uff1a\n> \n> You can use a Subject for that type of 'promise' usage. \n> \n> Subject s = ReplaySubject.create()\n> ... do something ...\n> s.onCompleted()\n> \n> Or for the more idiomatic approach, create a lazy Observable:\n> \n> return Observable.create(s -> {\n> ... do something ...\n> s.onCompleted()\n> });\n> \n> > On Sep 13, 2015, at 11:10 PM, Chen Kai notifications@github.com wrote:\n> > \n> > Hi,\n> > Dose Rxjava Observable has equivalent with CompletableFuture.complete?\n> > like: CompletableFuture future=new CompletableFuture();\n> > ...do something...\n> > future.complete(xxx)\n> > \n> > \u2014\n> > Reply to this email directly or view it on GitHub.\n> > \n> > \u2014\n> > Reply to this email directly or view it on GitHub.\n"
      }
    ],
    "satisfaction_conditions": [
      "A mechanism to manually trigger the emission of a value and completion of an Observable",
      "Support for deferred execution where the Observable's behavior can be defined after its creation"
    ]
  },
  {
    "number": 3338,
    "title": "Should withLatestFrom behave like zip in terms of buffering?",
    "created_at": "2015-09-11T08:44:00Z",
    "closed_at": "2015-09-11T09:06:37Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3338",
    "body": "I've just picked up withLatestFrom and I expected it to behave a bit like zip in terms of buffering source1 until source2 initially emits.  Am I missing something?  Is there something in the pipeline (for what I appreciate is an experimental operator) or could/ should it be enhanced to behave more like zip?\n\nUsing 1.0.13\n\nExamples of both below:\n# Zip Example Test\n\n```\n        testScenario\n                .given()\n                .theStreamUnderTest((s1, s2) -> s1.zipWith(s2, (z, n) -> z + n))\n\n                .when()\n                .theSubscriber().subscribes()\n                .source1().emits(\"a\")\n                .source1().emits(\"b\")\n                .source1().emits(\"c\")\n                .source2().emits(1)\n                .source2().emits(2)\n                .source2().emits(3)\n                .source1().completes()\n\n                .then()\n                .theSubscribers()\n                .renderedStream().isEqualTo(\"[a1]-[b2]-[c3]-|\");\n\n```\n# WithLatestFrom Test\n\n```\n       testScenario\n                .given()\n                .theStreamUnderTest((s1, s2) -> s1.withLatestFrom(s2, (z, n) -> z + n))\n                .theRenderer(s -> s)\n\n                .when()\n                .theSubscriber().subscribes()\n                .source1().emits(\"a\")\n                .source2().emits(1)\n                .source1().emits(\"b\")\n                .source2().emits(2)\n                .source1().emits(\"c\")\n                .source1().completes()\n\n                .then()\n                .theSubscribers()\n                .renderedStream().isEqualTo(\"[a1]-[b1]-[c2]-|\");\n```\n\nActually emits [b1]-[c2]-|\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3338/comments",
    "author": "leonjones1974",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-09-11T08:53:38Z",
        "body": "This is by design and matches how combineLatest doesn't combine until all sources have produced at least one value.\n"
      },
      {
        "user": "leonjones1974",
        "created_at": "2015-09-11T09:06:37Z",
        "body": "OK, TY\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-09-11T09:15:05Z",
        "body": "You can achieve this via the following construct:\n\n``` java\nObservable<Integer> source = Observable.range(1, 10);\n\nPublishSubject<Integer> other = PublishSubject.create();\n\nsource\n.delaySubscription(() -> other)\n.withLatestFrom(other, (a, b) -> a + b)\n.subscribe(System.out::println);\n\nother.onNext(10);\n```\n\nIf you excuse me, now I have to file a bugfix against 2.x :)\n"
      },
      {
        "user": "leonjones1974",
        "created_at": "2015-09-11T09:17:16Z",
        "body": "Ah, it's nicer than my solution - thanks again\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of the fundamental behavioral difference between withLatestFrom and zip regarding initial emission requirements",
      "Clarification of how source synchronization works in withLatestFrom compared to zip",
      "Demonstration of a pattern to achieve zip-like initial synchronization using existing operators",
      "Confirmation of whether the observed behavior was intentional design or a potential enhancement area"
    ]
  },
  {
    "number": 3046,
    "title": "NullPointerException at rx.exceptions.CompositeException.getListOfCauses(CompositeException.java:245)",
    "created_at": "2015-06-23T12:54:15Z",
    "closed_at": "2015-08-12T23:50:50Z",
    "labels": [
      "Bug",
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3046",
    "body": "I use RxAndroid library in my project and I have next exception :\n\nE/AndroidRuntime(27849): Error reporting crash\nE/AndroidRuntime(27849): java.lang.NullPointerException\nE/AndroidRuntime(27849): at rx.exceptions.CompositeException.getListOfCauses(CompositeException.java:245)\nE/AndroidRuntime(27849): at rx.exceptions.CompositeException.getCause(CompositeException.java:100)\nE/AndroidRuntime(27849): at android.util.Log.getStackTraceString(Log.java:454)\nE/AndroidRuntime(27849): at android.util.Slog.e(Slog.java:151)\nE/AndroidRuntime(27849): at com.android.internal.os.RuntimeInit$UncaughtHandler.uncaughtException(RuntimeInit.java:109)\nE/AndroidRuntime(27849): at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:693)\nE/AndroidRuntime(27849): at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:690)\nE/AndroidRuntime(27849): at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:66)\nE/AndroidRuntime(27849): at android.os.Handler.handleCallback(Handler.java:733)\nE/AndroidRuntime(27849): at android.os.Handler.dispatchMessage(Handler.java:95)\nE/AndroidRuntime(27849): at android.os.Looper.loop(Looper.java:146)\nE/AndroidRuntime(27849): at android.app.ActivityThread.main(ActivityThread.java:5653)\nE/AndroidRuntime(27849): at java.lang.reflect.Method.invokeNative(Native Method)\nE/AndroidRuntime(27849): at java.lang.reflect.Method.invoke(Method.java:515)\nE/AndroidRuntime(27849): at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1291)\nE/AndroidRuntime(27849): at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1107)\nE/AndroidRuntime(27849): at dalvik.system.NativeStart.main(Native Method)\n\nSomebody know how can I fix it ?\nThank you\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3046/comments",
    "author": "sgonchar",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-06-23T15:54:01Z",
        "body": "It appears you have a `null` exception added to a composite somewhere. What operators are you using. Do you call `onError(null)` somewhere by accident? \n"
      },
      {
        "user": "sgonchar",
        "created_at": "2015-06-24T07:01:58Z",
        "body": "I try to get throwable.getMessage callback and have this null pointer.\nI already find the reason. I make mistake at URL and try to connect to non-existent URL. I changed it and all is fine.\nI think you need handle this null pointer in other way, because currently I can't normally find the reason of exception.\nThank you\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-08-12T23:50:50Z",
        "body": "Fix already delivered. Thank you for reporting.\n"
      }
    ],
    "satisfaction_conditions": [
      "The solution must prevent NullPointerExceptions in RxAndroid's CompositeException error handling when exceptions contain null values",
      "The answer should ensure proper error propagation when handling exceptions with null messages or null exceptions",
      "The fix must maintain error reporting integrity while handling edge cases with invalid exceptions"
    ]
  },
  {
    "number": 2947,
    "title": "TestObserver thread-safety",
    "created_at": "2015-05-14T01:18:16Z",
    "closed_at": "2015-05-14T14:45:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2947",
    "body": "Disclaimer: I understand, that `TestObserver` and `TestSubscriber` were made for Unit testing purposes, but they are pretty convenient because you can record received notifications and emissions, make assertions and so on, so we used them it in our Integration test and faced problem with thread-safety of `TestObserver`.\n\nThe problem is that `TestObserver` uses `ArrayList` to store notifications and received items, in case of multi-threaded `Observable` `ArrayList` may be corrupted and tests can fail randomly.\n\nWhat do you think about using thread-safe list implementation in `TestObserver`? It should not break public API. I can prepare PR for that.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2947/comments",
    "author": "artem-zinnatullin",
    "comments": [
      {
        "user": "benjchristensen",
        "created_at": "2015-05-14T05:21:53Z",
        "body": "None of these types are thread safe and are not supposed to be as Observables are single threaded. We do not serialize by default for performance reasons. \n\nIf you need to serialize a Subject, use the toSerialized() method. An Observer should never need to be thread safe unless an Observable is breaking the contract, in which case use Observable.serialize()\n"
      },
      {
        "user": "artem-zinnatullin",
        "created_at": "2015-05-14T12:41:49Z",
        "body": "Oh.. Dived in sources for couple hours, wrote several questions and then deleted them, now I understand more. Thanks.\n\nOne question left: am I correct that there is no need to serialize `PublishSubject` because it's already serialized per each `Observer`, because each `Observer` wrapped into `SubjectSubscriptionManager.SubjectObserver` which is serialized?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-05-14T13:09:34Z",
        "body": "No. You need to front-serialize a `PublishSubject` via `toSerialized()`. Technically, a concurrent `onNext()` call doesn't break `PublishSubject` itself but observers don't and shouldn't anticipate concurrent calls to their `onXXX` methods.\n"
      },
      {
        "user": "artem-zinnatullin",
        "created_at": "2015-05-14T14:45:16Z",
        "body": "Checked sources again, now I see. Thanks! Issue solved.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how to ensure thread-safety when using TestObserver with multi-threaded Observables",
      "Clarification of the Observable contract requirements regarding threading",
      "Guidance on proper use of serialization mechanisms like Observable.serialize() or toSerialized()",
      "Confirmation that modifying TestObserver's internal list implementation isn't necessary when following Observable contracts"
    ]
  },
  {
    "number": 2805,
    "title": "PublishSubject does not honour subscribeOn",
    "created_at": "2015-03-05T12:23:53Z",
    "closed_at": "2015-03-12T23:11:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2805",
    "body": "In the code below, the subscriber gets called in main thread itself. If we remove the sleep, subscriber is not even called. Tried version 1.0.7, 1.0.6 and 1.0.4. My understanding is that the subscriber will be called in the passed executor.\n\n``` java\n  public static void main(String[] args) {\n        ExecutorService executor = Executors.newFixedThreadPool(2);\n        Scheduler scheduler = Schedulers.from(executor);\n\n        Subject<Integer, Integer> sub = PublishSubject.create();\n        // BufferUntilSubscriber.create();\n        sub.subscribeOn(scheduler).subscribe(new Action1<Integer>() {\n            @Override\n            public void call(Integer t1) {\n                // This prints 'main'\n                System.out.println(Thread.currentThread());\n            }\n        });\n\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e1) {\n            e1.printStackTrace();\n        }\n\n        sub.onNext(1);\n    }\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2805/comments",
    "author": "ashish-tyagi",
    "comments": [
      {
        "user": "ashish-tyagi",
        "created_at": "2015-03-05T12:31:50Z",
        "body": "If we use BufferUntilSubscriber, the behavior is even more puzzling. If there is no sleep, the subscriber gets called in the executor thread. If we put some sleep, the subscriber gets called in main thread.  Should not the behavior be consistent, sleep or no sleep?\n\n``` java\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newFixedThreadPool(2);\n        Scheduler scheduler = Schedulers.from(executor);\n\n        Subject<Integer, Integer> sub = BufferUntilSubscriber.create();\n        sub.subscribeOn(scheduler).subscribe(new Action1<Integer>() {\n            @Override\n            public void call(Integer t1) {\n                System.out.println(Thread.currentThread());\n            }\n        });\n\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e1) {\n            e1.printStackTrace();\n        }\n\n        sub.onNext(1);\n    }\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-03-05T15:45:20Z",
        "body": "Your first example subscribes on the given thread but receives values from the same thread your PublishSubject is emitting. You need `observeOn` to put those values to the desired thread.\n"
      },
      {
        "user": "ashish-tyagi",
        "created_at": "2015-03-05T20:48:21Z",
        "body": "Yes, observeOn works fine.\n\nThe behavior in second example is still inconsistent.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-03-05T21:24:38Z",
        "body": "In the second example, there is a race between the main thread emission and when the BufferUntilSubscriber starts to replay any buffered value. If the main thread is slow, the BufferUntilSubscriber wins but is empty at that point and just relays any value. If the main thread is fast, the BufferUntilSubscriber receives the value first, then it is subscribed to on the specified thread and immediately replays this buffered value.\n"
      },
      {
        "user": "ashish-tyagi",
        "created_at": "2015-03-12T23:11:10Z",
        "body": "Thanks for the info. I had a misunderstanding on how onSubscribe() should work.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how RxJava schedulers interact with Subject implementations like PublishSubject and BufferUntilSubscriber",
      "Clear distinction between subscribeOn and observeOn semantics in RxJava",
      "Analysis of race conditions in asynchronous subscription scenarios",
      "Behavior consistency expectations for different Subject types under varying timing conditions"
    ]
  },
  {
    "number": 2653,
    "title": "onBackpressureBlock() blocks forever when subscribe and observe on newThread",
    "created_at": "2015-02-13T03:24:35Z",
    "closed_at": "2015-02-13T21:14:36Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2653",
    "body": "``` Java\n        Observable<Integer> source = Observable.range(0,1000)\n                .onBackpressureBlock()\n                .subscribeOn(Schedulers.newThread())\n                .observeOn(Schedulers.newThread());\n\n        source.subscribe(new Action1<Integer>() {\n            @Override\n            public void call(Integer i) {\n                try {\n                    Thread.sleep(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(i);\n            }\n        });\n\n        try {\n            Thread.sleep(2000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n```\n\nThe output gives only 0 to 127, where I expected it to be 0 to 999.\nThis behavior exists in both 1.0.6 and master. Is this a bug or I used it incorrectly?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2653/comments",
    "author": "FinalVersion",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-02-13T07:35:00Z",
        "body": "Hi. What's happening is that subscribeOn routes all backpressure requests to the same thread doing the range emission which blocks. You need to move the `subscribeOn` before the `onBackpressureBlock`.\n"
      },
      {
        "user": "FinalVersion",
        "created_at": "2015-02-13T08:30:57Z",
        "body": "Wow, I didn't notice such subtle difference. Though I haven't quite understood what really happens under the hood, it works anyway. Thank you!\n"
      }
    ],
    "satisfaction_conditions": [
      "Explains why operator order affects backpressure handling in RxJava",
      "Clarifies the relationship between concurrency schedulers and backpressure strategies",
      "Provides guidance on proper operator chaining for backpressure scenarios",
      "Identifies thread coordination requirements in backpressure mechanisms"
    ]
  },
  {
    "number": 2608,
    "title": "Run two observables sequentially, using result from first observable in second observable (question)",
    "created_at": "2015-02-05T10:47:15Z",
    "closed_at": "2015-03-11T13:59:21Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2608",
    "body": "I'm probably overlooking something basic (sorry for that), this seems like it should be easy to do.\n\nI have an Identifier class:\n\n```\nclass Identifier {\n    int id;\n    String value;\n    Ticket[] tickets;\n\n    void setTickets(Ticket[] tickets) { this.tickets = tickets; }\n}\n```\n\nAnd two separate API calls, (1) one for retrieving an identifier based on the identifier value (not the id), and (2) one for retrieving the tickets for an identifier using the identifier id:\n1. `Observable<Identifier> getIdentifier(String identifierValue);`\n2. `Observable<Ticket[]> getTickets(int identifierId);`\n\nI want to create a method with the following signature:\n`Observable<Identifier> getIdentifierWithTickets(String identifierValue);`\n\nthat combines the two observables to create an `Observable<Identifier>` that:\n1. Retrieves the identifier based on the identifierValue.\n2. Retrieves the tickets for that identifier and assigns them to that identifier.\n\nI've tried several operators but I can't find the right one. The `zipWith` operator runs the two observables in parallel so that didn't work. I can perhaps use `flatMap` but then I have to create a new observable that transforms `Observable<Ticket[]>` into `Observable<Identifier>`.\n\nLike I said, I feel that I'm missing something very basic here, anyone please help.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2608/comments",
    "author": "riley-van-hengstum",
    "comments": [
      {
        "user": "riley-van-hengstum",
        "created_at": "2015-02-05T11:29:16Z",
        "body": "**Update**\n\nThis is what I have so far:\n\n``` java\npublic Observable<Identifier> getIdentifierWithTickets(String identifierValue) {\n    return service.getIdentifier(identifierValue)\n            .flatMap(new Func1<Identifier, Observable<Identifier>>() {\n                @Override\n                public Observable<Identifier> call(final Identifier identifier) {\n                    return service.getTickets(identifier.getId())\n                            .flatMap(new Func1<Ticket[], Observable<Identifier>>() {\n                                @Override\n                                public Observable<Identifier> call(Ticket[] tickets) {\n                                    identifier.setTickets(tickets);\n                                    return Observable.just(identifier);\n                                }\n                            });\n                }\n            });\n}\n```\n\nThis works, but it seems a bit convoluted. Is there any way to simplify this?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-02-05T11:51:44Z",
        "body": "I think you don't need the second `flatMap`s since you return a single value for each; `map` should do it.\n"
      },
      {
        "user": "riley-van-hengstum",
        "created_at": "2015-02-05T12:58:58Z",
        "body": "@akarnokd Thanks, I overlooked that. This simplifies things:\n\n``` java\npublic Observable<Identifier> getIdentifierWithTickets(String identifierValue) {\n    return service.getIdentifier(identifierValue)\n            .flatMap(new Func1<Identifier, Observable<Identifier>>() {\n                @Override\n                public Observable<Identifier> call(final Identifier identifier) {\n                    return service.getTickets(identifier.getId())\n                            .map(new Func1<Ticket[], Identifier>() {\n                                @Override\n                                public Identifier call(Ticket[] tickets) {\n                                    identifier.setTickets(tickets);\n                                    return identifier;\n                                }\n                            });\n                }\n            });\n}\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-03-11T13:59:21Z",
        "body": "I'm closing this due to lack of activity. If you have further questions, don't hesitate to reopen this issue or post a new one.\n"
      },
      {
        "user": "madnotdead",
        "created_at": "2017-08-16T15:14:48Z",
        "body": "Wow! This is what i was looking for. In my case i have to login in and with the retrieved User save the token value. Then make a call to another api to get a date based on the user token. So my case was similar to this, mainly because i need to chain api call. Thanks for sharing!"
      },
      {
        "user": "yterletskyi",
        "created_at": "2017-08-27T13:46:12Z",
        "body": "Thanks for solution, `flatMap` worked for me too!"
      },
      {
        "user": "parikshitdutta",
        "created_at": "2018-07-12T12:25:42Z",
        "body": "Probably we can make it a bit less convoluted, besides using map for obvious reason:\r\n\r\n```\r\npublic Observable<Identifier> getIdentifierWithTickets(String identifierValue) {\r\n     return service.getIdentifier(identifierValue)\r\n          .flatMap(identifier -> {\r\n               return service.getTickets(identifier.getId())\r\n                    .map(tickets -> identifier.setTickets(tickets));\r\n          });\r\n}\r\n```\r\n\r\n"
      },
      {
        "user": "scamexdotexe",
        "created_at": "2018-09-20T21:15:49Z",
        "body": "@madnotdead how did you go about that login? My case is quite similar, I have to get the time first from the server and convert it to timestamp and use it as one of the parameters for login (second api call)."
      }
    ],
    "satisfaction_conditions": [
      "Sequential execution of API calls where the second depends on the result of the first",
      "Preservation of the original Identifier instance with tickets added",
      "Type-safe Observable<Identifier> return type",
      "Avoidance of unnecessary nesting or complexity",
      "Proper handling of Observable streams between dependent operations"
    ]
  },
  {
    "number": 2597,
    "title": "scan with retry",
    "created_at": "2015-02-04T09:33:07Z",
    "closed_at": "2015-05-20T09:09:03Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2597",
    "body": "Hi, let's say for example I have this code:\n\n``` java\nObservable.range(1,100)\n        .scan(1, (p, i) -> {\n            if (i == 10 && start) {\n                start = false;\n                throw OnErrorThrowable.from(new Exception(\"wow\"));\n            }\n            return p * i;\n        })\n        .retry()\n        .doOnNext(System.out::println)\n        .subscribe();\n```\n\nIts output is:\n\n```\n1\n1\n2\n6\n24\n120\n720\n5040\n40320\n362880\n362880\n1\n1\n2\n6\n24\n120\n720\n5040\n40320\n362880\n3628800\n39916800\n479001600\n1932053504\n...\n```\n\nI want the `retry` operator to cause the observable to start from where it stopped (10 in this case). Is there a way to do this purely, without saving the state etc.?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2597/comments",
    "author": "david-hoze",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-02-04T09:48:47Z",
        "body": "You could use `distinct()` to skip over or don't throw in the function:\n\n``` java\n(p, i) -> {\n    while (true) {\n        try {\n            if (i == 10 && start) {\n                start = false;\n                throw OnErrorThrowable.from(new Exception(\"wow\"));\n            }\n            break;\n        } catch (Throwable t) {\n        }\n    }\n    return p * i;\n}\n```\n"
      },
      {
        "user": "david-hoze",
        "created_at": "2015-02-04T10:11:56Z",
        "body": "Hi, in my use case I actually need to handle the error in the subscriber, so I need to throw..\nUsing `distinct` like this:\n\n``` java\nObservable.range(1,100)\n        .scan(1, (p, i) -> {\n            if (i == 10 && start) {\n                start = false;\n                throw OnErrorThrowable.from(new Exception(\"wow\"));\n            }\n            return p * i;\n        })\n        .distinct()\n        .retry()\n        .doOnNext(System.out::println)\n        .subscribe();\n```\n\nyields the same behavior, as the first run and the second run of the `interval`+`scan` do not emit consequent non-distinct values (the repetition only happens after 10 cycles).\n\nHowever, for some reason using `distinct` like this (after the `retry`):\n\n``` java\nObservable.range(1,100)\n        .scan(1, (p, i) -> {\n            if (i == 10 && start) {\n                start = false;\n                throw OnErrorThrowable.from(new Exception(\"wow\"));\n            }\n            return p * i;\n        })\n        .retry()\n        .distinct()\n        .doOnNext(System.out::println)\n        .subscribe();\n```\n\noutputs:\n\n```\n1\n2\n6\n24\n120\n720\n5040\n40320\n362880\n```\n\nand stops there.. Couldn't figure out why, is this the desired behavior?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-02-04T10:17:49Z",
        "body": "The latter works for me with 1.0.5 and prints:\n\n```\n1\n2\n6\n24\n120\n720\n5040\n40320\n362880\n3628800\n39916800\n479001600\n1932053504\n1278945280\n2004310016\n2004189184\n-288522240\n-898433024\n109641728\n-2102132736\n-1195114496\n-522715136\n862453760\n-775946240\n2076180480\n-1853882368\n1484783616\n-1375731712\n-1241513984\n1409286144\n738197504\n-2147483648\n0\n```\n"
      },
      {
        "user": "david-hoze",
        "created_at": "2015-02-04T13:57:43Z",
        "body": "Thanks, you're right, after I upgraded it's working.\nI just realized though that the example I gave didn't model the problem I'm trying to solve very well, so I'll try to give a better one:\n\n``` java\nObservable.interval(1, TimeUnit.SECONDS)\n        .map(i -> { Calendar cal = Calendar.getInstance();\n            cal.getTime();\n            SimpleDateFormat sdf = new SimpleDateFormat(\"HH:mm:ss\");\n            return sdf.format(cal.getTime());})\n        .scan(\"\", (times, time) -> {\n            if (time.endsWith(\"5\")) {\n                throw OnErrorThrowable.from(new Exception(\"wow\"));\n            }\n            return times + \",\" + time;\n        })\n        .retry()\n        .doOnNext(System.out::println)\n        .subscribe();\n```\n\nSo now I'm trying to aggregate the emitted times. The output is:\n\n```\n,13:42:40\n,13:42:40,13:42:41\n,13:42:40,13:42:41,13:42:42\n,13:42:40,13:42:41,13:42:42,13:42:43\n,13:42:40,13:42:41,13:42:42,13:42:43,13:42:44\n,13:42:40,13:42:41,13:42:42,13:42:43,13:42:44\n,13:42:46\n,13:42:46,13:42:47\n,13:42:46,13:42:47,13:42:48\n,13:42:46,13:42:47,13:42:48,13:42:49\n,13:42:46,13:42:47,13:42:48,13:42:49,13:42:50\n,13:42:46,13:42:47,13:42:48,13:42:49,13:42:50,13:42:51\n,13:42:46,13:42:47,13:42:48,13:42:49,13:42:50,13:42:51,13:42:52\n,13:42:46,13:42:47,13:42:48,13:42:49,13:42:50,13:42:51,13:42:52,13:42:53\n,13:42:46,13:42:47,13:42:48,13:42:49,13:42:50,13:42:51,13:42:52,13:42:53,13:42:54\n,13:42:46,13:42:47,13:42:48,13:42:49,13:42:50,13:42:51,13:42:52,13:42:53,13:42:54\n,13:42:56\n,13:42:56,13:42:57\n,13:42:56,13:42:57,13:42:58\n,13:42:56,13:42:57,13:42:58,13:42:59\n,13:42:56,13:42:57,13:42:58,13:42:59,13:43:00\n,13:42:56,13:42:57,13:42:58,13:42:59,13:43:00,13:43:01\n...\n```\n\nSo I'm losing the numbers I already got. Can I gracefully handle the error and get the correct aggregation without using state?\n"
      },
      {
        "user": "benjchristensen",
        "created_at": "2015-02-04T18:06:31Z",
        "body": "Generally I'd recommend doing the data validation before the `scan` so that you're filtering out bad data. Especially since your validation does not depend on the accumulated state.\n\nIf you want to be aware of the errors, do a side-effect where you pass the error events off to a logger or different Observable sequence but prevent the terminal state from propagating. This would remove the need for `retry` and error handling inside `scan`.\n\n\n---\n\nHere are a variety of approaches:\n\n``` java\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.concurrent.TimeUnit;\n\nimport rx.Observable;\nimport rx.exceptions.OnErrorThrowable;\nimport rx.subjects.PublishSubject;\n\npublic class ScanErrorExample {\n\n    public static void main(String... args) {\n        System.out.println(\"scanWithErrorThrownAndDropped -------------------------------\");\n        scanWithErrorThrownAndDropped();\n        System.out.println(\"scanWithErrorThrownAndLogged -------------------------------\");\n        scanWithErrorThrownAndLogged();\n        System.out.println(\"scanWithErrorEvent -------------------------------\");\n        scanWithErrorEvent();\n        System.out.println(\"scanWithFilteredData -------------------------------\");\n        scanWithFilteredData();\n        System.out.println(\"-------------------------------\");\n    }\n\n    public static void scanWithErrorThrownAndDropped() {\n        data()\n                .map(time -> {\n                    if (time.endsWith(\"5\")) {\n                        throw OnErrorThrowable.from(new Exception(\"wow\"));\n                    } else {\n                        return time;\n                    }\n                })\n                .retry()\n                .scan(\"\", (times, time) -> {\n                    return times + \",\" + time;\n                })\n                .take(15)\n                .toBlocking().forEach(System.out::println);\n    }\n\n    public static void scanWithErrorThrownAndLogged() {\n        data()\n                .map(time -> {\n                    if (time.endsWith(\"5\")) {\n                        throw OnErrorThrowable.from(new Exception(\"wow\"));\n                    } else {\n                        return time;\n                    }\n                })\n                .doOnError(e -> System.out.println(\"Error: \" + e))\n                .retry()\n                .scan(\"\", (times, time) -> {\n                    return times + \",\" + time;\n                })\n                .take(15)\n                .toBlocking().forEach(System.out::println);\n    }\n\n    public static void scanWithErrorEvent() {\n        PublishSubject<Exception> errors = PublishSubject.create();\n        errors.forEach(e -> System.out.println(\"Error: \" + e));\n\n        data()\n                .doOnNext(time -> {\n                    if (time.endsWith(\"5\")) {\n                        errors.onNext(new Exception(\"wow\"));\n                        // or just log them\n                    }\n                })\n                .filter(time -> !time.endsWith(\"5\"))\n                .retry()\n                .scan(\"\", (times, time) -> {\n                    return times + \",\" + time;\n                })\n                .take(15)\n                .toBlocking().forEach(System.out::println);\n    }\n\n    public static void scanWithFilteredData() {\n        data()\n                .filter(time -> !time.endsWith(\"5\"))\n                .scan(\"\", (times, time) -> {\n                    return times + \",\" + time;\n                })\n                .take(15)\n                .toBlocking().forEach(System.out::println);\n    }\n\n    public static Observable<String> data() {\n        return Observable.interval(1, TimeUnit.SECONDS)\n                .map(i -> {\n                    Calendar cal = Calendar.getInstance();\n                    cal.getTime();\n                    SimpleDateFormat sdf = new SimpleDateFormat(\"HH:mm:ss\");\n                    return sdf.format(cal.getTime());\n                });\n    }\n\n}\n```\n\nIf you need the error data inside the scan as well, then instead of throwing, convert it to a type that you treat as an event that your scan logic can understand. \n"
      },
      {
        "user": "david-hoze",
        "created_at": "2015-02-04T23:26:12Z",
        "body": "Hi, thanks a lot :+1:, I think the `scanWithErrorEvent` solves my problem.\nAre subjects considered hacky?\nHow about this approach instead:\n\n``` java\n    public static void scanWithErrorObservable() {\n        Observable<String> dataObservable = data();\n\n        dataObservable\n                .filter(time -> !time.endsWith(\"5\"))\n                .scan(\"\", (times, time) -> {\n                    return times + \",\" + time;\n                })\n                .take(15)\n                .toBlocking().forEach(System.out::println);\n\n        dataObservable\n                .filter(time -> time.endsWith(\"5\"))\n                .map(time -> new Exception(\"wow\"))\n                .take(15)\n                .toBlocking().forEach(e -> System.out.println(\"Error: \" + e));\n    }\n```\n\nAlso, on a general note, the fact that error propagation always unsubscribes and the only way to gracefully handle it is to resubscribe seems to limit the fluency of RxJava in a lot of use cases. The solutions suggested here show that there is no fluent way of propagating errors without disrupting the normal flow of events. I think a more straightforward solution will be:\n\n``` java\n    private static class AccumulatedState {\n        private AccumulatedState() {\n            times = \"\";\n        }\n\n        String times;\n        Throwable throwable;\n    }\n\n    public static void scanWithErrorContext() {\n        data()\n                .scan(new AccumulatedState(), (accumulatedState, time) -> {\n                    if (time.endsWith(\"5\"))\n                        accumulatedState.throwable = new Exception(\"wow\");\n                    else {\n                        accumulatedState.throwable = null;\n                        accumulatedState.times = accumulatedState.times + \",\" + time;\n                    }\n                    return accumulatedState;\n                })\n                .take(15)\n                .toBlocking()\n                .forEach(accumulatedState -> {\n                    if (accumulatedState.throwable != null) {\n                        System.out.println(\"Error: \" + accumulatedState.throwable);\n                    } else {\n                        System.out.println(accumulatedState.times);\n                    }\n                });\n    }\n```\n\nBut it seems so generic that it should be part of the framework (something like `subscriber.onSilentError`).\nThanks, Amitai.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-05-20T09:09:03Z",
        "body": "I'm closing this due to inactivity. If you have further questions, don't hesitate to reopen this issue or post a new one.\n"
      }
    ],
    "satisfaction_conditions": [
      "Solution must allow resuming scan operation from the point of failure after retry",
      "Must handle errors without terminating the observable sequence",
      "Solution should avoid external state management",
      "Must preserve accumulated values across retries",
      "Should provide fluent error handling within RxJava patterns"
    ]
  },
  {
    "number": 2525,
    "title": "How to stop observable execution",
    "created_at": "2015-01-23T18:45:15Z",
    "closed_at": "2015-01-23T20:07:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2525",
    "body": "Hi,\n\nI have some set of observable which I am executing in parallel. I need to get the value of observable who is completing first. If the return value meets my requirement then i need to stop the execution of other observables. I couldn't find the example for that. \n\nI could do this scenario through Callable interface and CompletionService interface from concurrent package.\n\nsample code using concurrent package\n\n```\n@Autowired\nprivate CompletionService<Result> cService;\n\nList<Future<Result>> statusList = new ArrayList<Future<Result>>();\ntry{\nfor(String str: strLst){\n        statusList.add(cService.submit(new GetItemOnCallable(msg)));\n    }\n\n    for(int i =0; i < statusList.size(); i++){\n        Result status = cService.take().get();\n        if(null != status){\n         if(staus.equals(Result.SUCCESS))\n         break;\n    }\n}finally{\nfor(Future<Result> statusFuture: statusList){\n    statusFuture.cancel(true);\n}\n}\n```\n\nIs there any way to achieve this using observable?\nCan someone please help on this.\n\nRegards\nPranesh\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2525/comments",
    "author": "pradhakrishnan",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-01-23T19:07:13Z",
        "body": "We have the `amb` operator which streams the first responding source observable. You could filter your sources then amb them to get the first matching value:\n\n``` java\namb(source1.filter(predicate), source2.filter(predicate))\n```\n"
      },
      {
        "user": "pradhakrishnan",
        "created_at": "2015-01-23T20:01:29Z",
        "body": "Thanks Akarnokd. \n\n\n---\n\nIt works fine. Thanks Akarnokd. \nI have one question on this. What will happen if none of my source observable meets my filter.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-01-23T20:04:19Z",
        "body": "You get an empty sequence which just calls onCompleted.\n"
      },
      {
        "user": "pradhakrishnan",
        "created_at": "2015-01-23T20:05:29Z",
        "body": "Got it!!! Thanks Akarnokd.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-01-23T20:07:01Z",
        "body": "You are welcome.\n"
      }
    ],
    "satisfaction_conditions": [
      "Solution must select the first completed observable that meets a specified condition",
      "Mechanism to automatically cancel remaining observables when a satisfactory result is found",
      "Handling of empty scenarios where no observable meets the condition",
      "Maintains parallel execution of source observables"
    ]
  },
  {
    "number": 1939,
    "title": "How to chain calls, depending on result ?",
    "created_at": "2014-12-08T14:33:32Z",
    "closed_at": "2015-03-11T14:14:42Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/1939",
    "body": "Hello,\n\nIn my webapp, I have to chain two async calls : \nThe first call gives me a list of dog ids. \nThe second call gives me a Dog (found by its id).\n\nIn my code, i'd like to write something like :\n\n```\nfinal Observable<RxMessage<String>> observable1 = asyncCallForDogIds(..);\n\nfinal List<Dog> dogs = new ArrayList<>();\nobservable1.subscribe(\n    // onNext\n    (RxMessage<String> message) -> {\n        final String id = readId(message);\n\n        final Observable<RxMessage<String>> observable2 = someAsyncCallForOneDogId(id, ..);\n\n        final Dog dog = readFromSomeMessage2(...);\n        dogs.add(dog);\n    },\n\n    // onError\n    (Throwable err) -> error(err, ..),\n\n    // onCompleted\n    () -> resume(dogs, ..));\n```\n\nWhat would be the best way to do that ?\nTh.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/1939/comments",
    "author": "thierryler",
    "comments": [
      {
        "user": "hamidp",
        "created_at": "2014-12-08T14:55:25Z",
        "body": "You want `flatMap` so roughly:\n\n```\nasyncCallForDogIds(..)\n    .map(this::readId)\n    .flatMap(dogId -> someAsyncCallForOneDogId(id, ..))\n    .map(this::readFromSomeMessage2)\n```\n"
      },
      {
        "user": "thierryler",
        "created_at": "2014-12-09T09:18:49Z",
        "body": "Yes that looks what I need. Thx. But how do I process the onError and onCompleted ? for each async call\n"
      },
      {
        "user": "hamidp",
        "created_at": "2014-12-09T13:06:38Z",
        "body": "Those will propagate down the chain. If any Observable emits an error it will be sent down to your subscriber.\n"
      },
      {
        "user": "benjchristensen",
        "created_at": "2014-12-09T17:54:06Z",
        "body": "If you want to handle errors for each call you put the `onErrorResumeNext` or similar handlers on each of the async calls. \n\n``` java\nasyncCallForDogIds(..)\n    .map(this::readId)\n    .flatMap(dogId -> {\n             return someAsyncCallForOneDogId(id, ..)\n                             .onErrorResumeNext(errorHandlingHere)\n    })\n    .map(this::readFromSomeMessage2)\n```\n"
      },
      {
        "user": "thierryler",
        "created_at": "2014-12-10T09:47:01Z",
        "body": "Thx for those great answers.\n\nI'm getting a little confused. What about if my first call returns an object that contains many ids, and I have to process the second call for each id :\n\nI was thinking about something like this :\n\n```\nfinal Observable<RxMessage<String>> observable1 = doCallThatReturnBoxes(userId);\n\nBox box = null;\nobservable1\n    .flatMap(new Func1<RxMessage<String>, Observable<RxMessage<String>>>() \n        public Observable<RxMessage<String>> call(RxMessage<String> message) {\n            box = readBoxFromMessage(message);\n\n            final List<String> ids = box.getItemIds();\n\n            // Here I need to call doCallThatReturnOneItemDetails for each id\n            // How do I create an Observable from the ids list ?\n\n        }\n        .subscribe(\n            // onNext\n            (RxMessage<String> message) -> {\n                final BoxItem boxItem = readBoxItemFromMessage(message);\n\n                box.getItems.add(boxItem);\n            },\n\n            // onError\n            (Throwable err) -> error(err, response, resp),\n\n            // onCompleted\n            () -> resume(response, resp)\n        );\n```\n\nAnd if my first call returns a list of boxies ? like this ? \n\n```\nfinal List<Box> boxies = new ArrayList<>();\nobservable1\n    .flatMap(new Func1<RxMessage<String>, Observable<RxMessage<String>>>() \n        public Observable<RxMessage<String>> call(RxMessage<String> message) {\n            final Box box = readBoxFromMessage(message);\n            boxies.add(box);\n\n            final List<String> ids = box.getItemIds();\n\n            // Here I need to call doCallThatReturnOneItemDetails for each id\n            // How do I create an Observable from the ids list ?\n\n        }\n        .subscribe(\n            // onNext\n            (RxMessage<String> message) -> {\n                final BoxItem boxItem = readBoxItemFromMessage(message);\n\n                // Here how to specify the good box ?\n                box.getItems.add(boxItem);\n            },\n\n            // onError\n            (Throwable err) -> error(err, response, resp),\n\n            // onCompleted\n            () -> resume(response, resp)\n        );\n\n```\n\nHow do I associate the item details with the good box ?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-03-11T14:14:42Z",
        "body": "I'm closing this due to inactivity. If you have further questions, please don't hesitate to reopen this issue or post a new one.\n"
      }
    ],
    "satisfaction_conditions": [
      "Handle nested asynchronous operations where subsequent calls depend on previous results",
      "Support error handling at individual operation level",
      "Process multiple items from a single emitted value",
      "Maintain context between parent and child operations",
      "Collect all results before final completion"
    ]
  },
  {
    "number": 1636,
    "title": "How to properly terminal Observable sequences",
    "created_at": "2014-08-27T21:59:04Z",
    "closed_at": "2014-08-29T23:00:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/1636",
    "body": "``` java\nObservable<Boolean> obs1;\nObservable<Boolean> obs2;\n\nresult = obs1\n.flatmap(value -> {\n   if (value) {\n      // terminate result observable\n      // the only way i see right now is to do\n      BehaviorSubject<Boolean> terminator = BehaviorSubject.create();\n      terminator.onNext(new TerminateException());\n      return terminator;\n   } else {\n       return obs2;\n   }\n});\n\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/1636/comments",
    "author": "buildbreaker",
    "comments": [
      {
        "user": "headinthebox",
        "created_at": "2014-08-27T22:17:48Z",
        "body": "You just return `Observable.empty()` if you want to terminate successfully, or `Observable.error(new TerminateException())` if you want to terminate unsuccessfully (probably not). \n"
      },
      {
        "user": "buildbreaker",
        "created_at": "2014-08-28T17:33:41Z",
        "body": "Thank you for your response @headinthebox!\n\nI believe I do want to terminate unsuccessfully since at the end of my flatmap as I would like to have an action regardless of what value was originally. I actually have a flatmap chain of similar flatmaps that was mentioned above:\n\n``` java\nresult = obs1\n.flatmap(value -> {\n   if (value) {\n      return Observable.error(new TerminateException());\n   } else {\n       return obs2;\n   }\n})\n.flatmap(value -> {\n  if (value) {\n    return Observable.from(new Object());\n  } else {\n    return Observable.error(newTerminateException());\n  }\n})\n.doOnEach( value -> {\n  // Always do something\n})\n.subscribe(...); \n```\n\nI have tried and having an Observable.error(new TerminateException()) works for this case but I'm not sure if this is the best way to go about the problem.\n"
      },
      {
        "user": "headinthebox",
        "created_at": "2014-08-28T17:42:23Z",
        "body": "It is the best way; if you find yourself using subjects, typically you are _wrong_. \n"
      },
      {
        "user": "benjchristensen",
        "created_at": "2014-08-28T19:08:34Z",
        "body": "You can also use `takeUntil` or `takeWhile` to terminate the source when a condition or event occurs instead of forcing an artificial `onError` event. In other words, unsubscribing is the \"clean shutdown\" approach and `takeUntil` and `takeWhile` are typical approaches to shutting down.\n"
      },
      {
        "user": "buildbreaker",
        "created_at": "2014-08-29T16:42:24Z",
        "body": "@headinthebox\nI finally switched to using Observable.empty() and it has worked for me!\n\n@benjchristensen \nUnfortunately, \"takeWhile\" doesn't terminate on false for me. I needed to terminate on false.\n"
      }
    ],
    "satisfaction_conditions": [
      "Provide a method to immediately terminate the Observable sequence when a specific condition is met",
      "Support both successful and unsuccessful termination scenarios",
      "Ensure termination propagates through the entire Observable chain",
      "Avoid manual Subject manipulation for termination",
      "Handle termination while preserving post-termination actions"
    ]
  }
]