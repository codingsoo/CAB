[
  {
    "number": 1028,
    "title": "Decreasing of pool size in runtime",
    "created_at": "2017-11-27T18:01:21Z",
    "closed_at": "2017-11-28T13:41:10Z",
    "labels": [
      "question",
      "not-a-bug"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/1028",
    "body": "#### Environment\r\n```\r\nHikariCP version: 2.2.5\r\nJDK version       : 1.8.0_144\r\nDatabase           : MySQL\r\nDriver version    : 5.1.43\r\nHibernate           : 4.3.6\r\n```\r\n-----------------------------------------------------------------------------------------\r\nI'm trying to investigate problem:\r\n\r\n`org.springframework.transaction.CannotCreateTransactionException: Could not open JPA EntityManager for transaction; nested exception is javax.persistence.PersistenceException: org.hibernate.exception.GenericJDBCException: Could not open connection \r\n    at org.springframework.orm.jpa.JpaTransactionManager.doBegin(JpaTransactionManager.java:431) \r\n    at org.springframework.transaction.support.AbstractPlatformTransactionManager.getTransaction(AbstractPlatformTransactionManager.java:373) \r\n    at org.springframework.transaction.interceptor.TransactionAspectSupport.createTransactionIfNecessary(TransactionAspectSupport.java:427) \r\n    at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:276) \r\n    at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96) \r\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) \r\n    at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:655) \r\n    at de.bcg.xchange.requests.rest.RequestResource$$EnhancerBySpringCGLIB$$3bf285f1.fetchConversationByRequest(<generated>) \r\n    at sun.reflect.GeneratedMethodAccessor554.invoke(Unknown Source) \r\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) \r\n    at java.lang.reflect.Method.invoke(Method.java:498) \r\n    at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:221) \r\n    at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:136) \r\n    at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:110) \r\n    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:817) \r\n    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:731) \r\n    at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85) \r\n    at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:959) \r\n    at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:893) \r\n    at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:968) \r\n    at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:859) \r\n    at javax.servlet.http.HttpServlet.service(HttpServlet.java:624) \r\n    at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:844) \r\n    at javax.servlet.http.HttpServlet.service(HttpServlet.java:731) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:303) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at de.bcg.xchange.platform.filters.gzip.GZipServletFilter.doFilter(GZipServletFilter.java:46) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at de.bcg.xchange.platform.filters.MDCUserInfoServletFilter.doFilter(MDCUserInfoServletFilter.java:52) \r\n    at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:346) \r\n    at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:262) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at ch.qos.logback.classic.helpers.MDCInsertingServletFilter.doFilter(MDCInsertingServletFilter.java:51) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at de.bcg.xchange.platform.filters.MDCInvocationFilter.doFilter(MDCInvocationFilter.java:25) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at com.codahale.metrics.servlet.AbstractInstrumentedFilter.doFilter(AbstractInstrumentedFilter.java:104) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at org.springframework.boot.actuate.autoconfigure.EndpointWebMvcAutoConfiguration$ApplicationContextHeaderFilter.doFilterInternal(EndpointWebMvcAutoConfiguration.java:237) \r\n    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at de.bcg.xchange.platform.filters.MDCUserInfoServletFilter.doFilter(MDCUserInfoServletFilter.java:52) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at org.springframework.boot.actuate.trace.WebRequestTraceFilter.doFilterInternal(WebRequestTraceFilter.java:112) \r\n    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:316) \r\n    at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:126) \r\n    at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:90) \r\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) \r\n    at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:114) \r\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) \r\n    at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:122) \r\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) \r\n    at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:169) \r\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) \r\n    at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:48) \r\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) \r\n    at de.bcg.xchange.platform.filters.AcceptedTermsOfUseFilter.doFilterInternal(AcceptedTermsOfUseFilter.java:45) \r\n    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) \r\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) \r\n    at de.bcg.xchange.platform.filters.AgentLoginFilter.doFilterInternal(AgentLoginFilter.java:94) \r\n    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) \r\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) \r\n    at de.bcg.xchange.platform.filters.ImpersonateUserFilter.doFilterInternal(ImpersonateUserFilter.java:78) \r\n    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) \r\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) \r\n    at org.springframework.security.oauth2.provider.authentication.OAuth2AuthenticationProcessingFilter.doFilter(OAuth2AuthenticationProcessingFilter.java:140) \r\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) \r\n    at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:120) \r\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) \r\n    at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:64) \r\n    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) \r\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) \r\n    at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:91) \r\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) \r\n    at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:53) \r\n    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) \r\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) \r\n    at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:213) \r\n    at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:176) \r\n    at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:346) \r\n    at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:262) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) \r\n    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:87) \r\n    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:77) \r\n    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:121) \r\n    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) \r\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) \r\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) \r\n    at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:218) \r\n    at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:110) \r\n    at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:506) \r\n    at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:169) \r\n    at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:103) \r\n    at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:962) \r\n    at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:116) \r\n    at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:445) \r\n    at org.apache.coyote.ajp.AjpProcessor.process(AjpProcessor.java:190) \r\n    at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:637) \r\n    at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:316) \r\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) \r\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) \r\n    at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) \r\n    at java.lang.Thread.run(Thread.java:748) \r\nCaused by: javax.persistence.PersistenceException: org.hibernate.exception.GenericJDBCException: Could not open connection \r\n    at org.hibernate.jpa.spi.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1763) \r\n    at org.hibernate.jpa.spi.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1677) \r\n    at org.hibernate.jpa.spi.AbstractEntityManagerImpl.throwPersistenceException(AbstractEntityManagerImpl.java:1771) \r\n    at org.hibernate.jpa.internal.TransactionImpl.begin(TransactionImpl.java:64) \r\n    at org.springframework.orm.jpa.vendor.HibernateJpaDialect.beginTransaction(HibernateJpaDialect.java:170) \r\n    at org.springframework.orm.jpa.JpaTransactionManager.doBegin(JpaTransactionManager.java:380) \r\n     ... 126 common frames omitted \r\nCaused by: org.hibernate.exception.GenericJDBCException: Could not open connection \r\n    at org.hibernate.exception.internal.StandardSQLExceptionConverter.convert(StandardSQLExceptionConverter.java:54) \r\n    at org.hibernate.engine.jdbc.spi.SqlExceptionHelper.convert(SqlExceptionHelper.java:126) \r\n    at org.hibernate.engine.jdbc.spi.SqlExceptionHelper.convert(SqlExceptionHelper.java:112) \r\n    at org.hibernate.engine.jdbc.internal.LogicalConnectionImpl.obtainConnection(LogicalConnectionImpl.java:235) \r\n    at org.hibernate.engine.jdbc.internal.LogicalConnectionImpl.getConnection(LogicalConnectionImpl.java:171) \r\n    at org.hibernate.engine.transaction.internal.jdbc.JdbcTransaction.doBegin(JdbcTransaction.java:67) \r\n    at org.hibernate.engine.transaction.spi.AbstractTransactionImpl.begin(AbstractTransactionImpl.java:162) \r\n    at org.hibernate.internal.SessionImpl.beginTransaction(SessionImpl.java:1435) \r\n    at org.hibernate.jpa.internal.TransactionImpl.begin(TransactionImpl.java:61) \r\n     ... 128 common frames omitted \r\nCaused by: java.sql.SQLException: Timeout after 34877ms of waiting for a connection. \r\n    at com.zaxxer.hikari.pool.HikariPool.getConnection(HikariPool.java:205) \r\n    at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:91) \r\n    at org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection(DatasourceConnectionProviderImpl.java:139) \r\n    at org.hibernate.internal.AbstractSessionImpl$NonContextualJdbcConnectionAccess.obtainConnection(AbstractSessionImpl.java:380) \r\n    at org.hibernate.engine.jdbc.internal.LogicalConnectionImpl.obtainConnection(LogicalConnectionImpl.java:228) \r\n     ... 133 common frames omitted`\r\n\r\nI've enabled logging and found out one strange thing, could you please help to understand that:\r\nI'm using default maxPoolSize and minimumIdle and typical state of connections is:\r\n\r\n2017-11-27 15:27:00,352 [DEBUG] com.zaxxer.hikari.pool.HikariPool - Before cleanup pool stats HikariPool-0 (**total=10**, inUse=3, avail=7, waiting=0)\r\n2017-11-27 15:27:00,353 [DEBUG] com.zaxxer.hikari.pool.HikariPool - After cleanup pool stats HikariPool-0 (**total=10**, inUse=3, avail=7, waiting=0)\r\n\r\nAs I get from the documentation for minimumIdle \"we recommend not setting this value and instead allowing HikariCP to act as a **fixed size connection pool**\", so I expect that total connections should always be equal to maxPoolSize.\r\nBut I see sometimes such cases:\r\n\r\n2017-11-27 15:35:30,351 [DEBUG] com.zaxxer.hikari.pool.HikariPool - Before cleanup pool stats HikariPool-0 (total=10, inUse=4, avail=6, waiting=0)\r\n2017-11-27 15:35:30,353 [DEBUG] com.zaxxer.hikari.pool.HikariPool - After cleanup pool stats HikariPool-0 (**total=5**, inUse=4, avail=1, waiting=0)\r\n\r\n2017-11-27 16:11:07,255 [DEBUG] com.zaxxer.hikari.pool.HikariPool - Before cleanup pool stats HikariPool-0 (total=10, inUse=3, avail=7, waiting=0)\r\n2017-11-27 16:11:07,259 [DEBUG] com.zaxxer.hikari.pool.HikariPool - After cleanup pool stats HikariPool-0 (**total=3**, inUse=3, avail=0, waiting=0)\r\n\r\nAnd thinking why it's changing and could it be a reason for the problem with java.sql.SQLException: Timeout after 34877ms of waiting for a connection that time-to-time there's fewer connections in the pool that is needed (this error appears pretty rarely)? Can minimumIdle help with the problem?",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/1028/comments",
    "author": "OksanaMykhalets",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2017-11-28T11:51:31Z",
        "body": "Before trying to diagnose what is happening, I strongly recommend updating HikariCP to v2.7.4.  Version 2.2.5 is *extremely* old and many bugs have been fixed since then, including bugs related to connection retirement and pool repopulation.\r\n\r\nIf you still encounter these errors on the latest version, let us know (and provide v2.7.4 logs).\r\n"
      },
      {
        "user": "OksanaMykhalets",
        "created_at": "2017-11-28T12:15:24Z",
        "body": "Thanks a lot for a fast response. I'll try to upgrade."
      },
      {
        "user": "brettwooldridge",
        "created_at": "2017-11-28T13:42:26Z",
        "body": "@OksanaMykhalets I assume it worked?  If so, great! \ud83c\udf89 \r\n"
      },
      {
        "user": "OksanaMykhalets",
        "created_at": "2017-11-28T13:49:45Z",
        "body": "@brettwooldridge I don't see anymore those decreasing of pool size after upgrade, so I think this issue can be closed. \r\n\r\nCan't say if it also will help with:\r\n`java.sql.SQLException: Timeout after 34877ms of waiting for a connection. at com.zaxxer.hikari.pool.HikariPool.getConnection(HikariPool.java:205)`\r\ncause I'm facing this issue once in a week or so, but I've also enabled leakDetectionThreshold, so it should be easy to find the cause of the problem if it'll appear again.\r\n\r\nThanks a lot for your help and incredibly cool library!"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2017-11-28T14:08:22Z",
        "body": "@OksanaMykhalets You're very welcome.  My guess is that the pool exhaustion issue in v2.2.5 was the cause of the timeout that you observed, so hopefully it will not appear again.\r\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why the connection pool size decreases unexpectedly during runtime",
      "Identification of conditions that lead to connection pool exhaustion",
      "Guidance on maintaining stable connection pool availability",
      "Verification that resolved pool size instability addresses timeout exceptions",
      "Diagnosis of version-specific bugs affecting connection retention"
    ]
  },
  {
    "number": 557,
    "title": "Connection.setNetworkTimeout() is not supported (Redshift)",
    "created_at": "2016-01-25T22:16:36Z",
    "closed_at": "2016-01-26T15:35:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/557",
    "body": "Hello Brett.\n\nIs there a config to avoid making this call?  Its preventing Hikari from init'ing a data source to a Redshift backend.  We're using HikariCP 2.4.0.\n\nThanks.\n\n```\n2016-01-25 21:19:59.124  INFO 1653 [WrapperJarAppMain] --- com.zaxxer.hikari.HikariDataSource       : Hikari pool HikariPool-7 is starting.\n2016-01-25 21:19:59.202 DEBUG 1653 [WrapperJarAppMain] --- com.zaxxer.hikari.pool.PoolElf           : HikariPool-7 - Connection.setNetworkTimeout() is not supported ([Amazon][JDBC](10220) Driver not capable.)\n2016-01-25 21:19:59.215 DEBUG 1653 [WrapperJarAppMain] --- com.zaxxer.hikari.pool.HikariPool        : HikariPool-7 - Connection attempt to database failed\n\njava.sql.SQLException: [JDBC Driver]String index out of range: 0\n        at java.lang.String.charAt(String.java:658)\n        at com.amazon.redshift.core.PGJDBCConnection.toNativeSQL(Unknown Source)\n        at com.amazon.jdbc.common.SConnection.nativeSQL(Unknown Source)\n        at com.amazon.jdbc.common.SStatement.executeNoParams(Unknown Source)\n        at com.amazon.jdbc.common.SStatement.execute(Unknown Source)\n        at com.zaxxer.hikari.pool.PoolElf.executeSql(PoolElf.java:441)\n        at com.zaxxer.hikari.pool.PoolElf.setupConnection(PoolElf.java:183)\n        at com.zaxxer.hikari.pool.HikariPool.addConnection(HikariPool.java:496)\n        at com.zaxxer.hikari.pool.HikariPool.initializeConnections(HikariPool.java:564)\n        at com.zaxxer.hikari.pool.HikariPool.<init>(HikariPool.java:150)\n        at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:96)\n        at org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection(DatasourceConnectionProviderImpl.java:139)\n        at org.hibernate.engine.jdbc.internal.JdbcServicesImpl$ConnectionProviderJdbcConnectionAccess.obtainConnection(JdbcServicesImpl.java:279)\n        at org.hibernate.engine.jdbc.internal.JdbcServicesImpl.configure(JdbcServicesImpl.java:124)\n        at org.hibernate.boot.registry.internal.StandardServiceRegistryImpl.configureService(StandardServiceRegistryImpl.java:111)\n        at org.hibernate.service.internal.AbstractServiceRegistryImpl.initializeService(AbstractServiceRegistryImpl.java:234)\n        at org.hibernate.service.internal.AbstractServiceRegistryImpl.getService(AbstractServiceRegistryImpl.java:206)\n        at org.hibernate.cfg.Configuration.buildTypeRegistrations(Configuration.java:1887)\n        at org.hibernate.cfg.Configuration.buildSessionFactory(Configuration.java:1845)\n        at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl$4.perform(EntityManagerFactoryBuilderImpl.java:852)\n        at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl$4.perform(EntityManagerFactoryBuilderImpl.java:845)\n        at org.hibernate.boot.registry.classloading.internal.ClassLoaderServiceImpl.withTccl(ClassLoaderServiceImpl.java:398)\n        at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build(EntityManagerFactoryBuilderImpl.java:844)\n```\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/557/comments",
    "author": "vmorales",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2016-01-25T23:51:43Z",
        "body": "Which call?  The redshift driver is failing in _Statement.execute()_.  HikariCP is calling this because your configuration defines _connectionInitSql_ .  Whatever that SQL is, it appears to be causing the problem.\n"
      },
      {
        "user": "vmorales",
        "created_at": "2016-01-26T14:38:47Z",
        "body": "Brett....thank you SO much.  That was it.  Things are working awesomely.\n"
      },
      {
        "user": "Danilo-Araujo-Silva",
        "created_at": "2018-04-30T17:13:51Z",
        "body": "I'm having the same problem. Can you share how did you solve it?"
      }
    ],
    "satisfaction_conditions": [
      "A solution that addresses the root cause of the connection initialization SQL error with the Redshift driver",
      "A configuration approach that avoids unsupported JDBC operations in the Redshift driver",
      "A method to initialize connections without triggering driver-specific exceptions",
      "A way to maintain connection pooling functionality while working with Redshift's JDBC limitations"
    ]
  },
  {
    "number": 447,
    "title": "Why does Hikari depend on hibernate-core?",
    "created_at": "2015-10-07T20:20:28Z",
    "closed_at": "2015-10-08T13:02:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/447",
    "body": "That's a heavy dependency to pull in when a project just wants to use JDBC with a pooling impl. I'm curious why it is necessary. If it's only there to aid Hibernate projects, couldn't it be split into a separate library?\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/447/comments",
    "author": "donaldquixote",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-10-08T13:02:56Z",
        "body": "I just built a project that depends on HikariCP and it did not pull in Hibernate as a dependency.  The dependency in the HikariCP _pom.xml_ is declared as:\n\n``` xml\n      <dependency>\n         <groupId>org.hibernate</groupId>\n         <artifactId>hibernate-core</artifactId>\n         <version>${hibernate.version}</version>\n         <scope>provided</scope>\n         <optional>true</optional>\n      </dependency>\n```\n\nWhich should not result in it being pulled in, unless you are building HikariCP itself.\n"
      },
      {
        "user": "donaldquixote",
        "created_at": "2015-10-08T14:49:47Z",
        "body": "Apologies for the noise, missed the scope piece. Thanks for your reply.\n"
      }
    ],
    "satisfaction_conditions": [
      "Clarification of why HikariCP's dependency on hibernate-core does not impose a runtime dependency for users",
      "Explanation of Maven dependency scoping mechanisms (provided/optional) in the context of library design",
      "Demonstration that HikariCP's design avoids forcing dependencies on non-Hibernate users"
    ]
  },
  {
    "number": 391,
    "title": "Impossible to pass connection specific properties",
    "created_at": "2015-08-20T16:38:01Z",
    "closed_at": "2015-08-20T21:28:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/391",
    "body": "On my particular Oracle CP on HikariCP (ds) theres no way to pass specific Connection parameters:\n\n```\n    HikariConfig conf = new HikariConfig(\"testCpConnection.properties\");\n    HikariDataSource ds = new HikariDataSource(conf);\n    Properties pp = new Properties();\n    pp.put(\"connectionProperties.defaultRowPrefetch\", \"10000\");\n    ds.setDataSourceProperties(pp);\n```\n\nwith Orcle DataSource is possible to do this:\n\n```\n    OracleDataSource ds = new OracleDataSource();\n    ds.setURL(\"jdbc:oracle:thin:@xxxxxxxxx\");\n    ds.setUser(\"user\");\n    ds.setPassword(\"password\");\n\n    Properties pp = new Properties();\n    pp.put(\"defaultRowPrefetch\", \"10000\");\n\n    ds.setConnectionProperties(pp);\n```\n\nperhaps I'm wrong also because in some previous version was possible to implement an IConnectionCustomizer that isn't supported anymore.\n\nRegards\n    Antonio\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/391/comments",
    "author": "aconte76",
    "comments": [
      {
        "user": "jnehlmeier",
        "created_at": "2015-08-20T19:20:22Z",
        "body": "I guess you can use \n\n``` java\nOracleDataSource oracleDs = new OracleDataSource();\nProperties pp = new Properties();\npp.put(\"defaultRowPrefetch\", \"10000\");\noracleDs.setConnectionProperties(pp);\n\nHikariConfig conf = new HikariConfig(\"testCpConnection.properties\");\nconf.setDatasource(oracleDs);\nHikariDataSource ds = new HikariDataSource(conf);\n```\n\nThen HikariCP should use the OracleDataSource for creating connections to fill the Hikari pool.\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2015-08-20T21:28:41Z",
        "body": "@jnehlmeier That is correct.\n"
      },
      {
        "user": "aconte76",
        "created_at": "2015-08-21T09:20:14Z",
        "body": "Right, it works correctly, sorry for my mistake.\n\nThx a lot\n   Antonio\n"
      }
    ],
    "satisfaction_conditions": [
      "Ability to configure vendor-specific connection properties through HikariCP",
      "Integration with native DataSource implementations",
      "Avoidance of deprecated customization mechanisms"
    ]
  },
  {
    "number": 364,
    "title": "Any possibility of seeing a java-6/7 port for v 2.4.0 ",
    "created_at": "2015-08-03T13:17:07Z",
    "closed_at": "2015-08-03T13:31:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/364",
    "body": "Hi Brett, \n $subject. I only see 2.4.0 for java 8. \n- Ramith\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/364/comments",
    "author": "ramith",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-08-03T13:31:39Z",
        "body": "The 2.4.0 JAR supports both Java 7 and Java 8.  Java 6 has entered maintenance mode and will continue to receive bug fixes and releases from the 2.3.x branch.\n"
      }
    ],
    "satisfaction_conditions": [
      "Clarification of Java 7 compatibility in version 2.4.0",
      "Explanation of Java 6 maintenance plans",
      "Differentiation between version branches for different Java versions"
    ]
  },
  {
    "number": 327,
    "title": "I configurate the `poolName`, but throw Exception",
    "created_at": "2015-06-17T06:46:43Z",
    "closed_at": "2015-06-17T06:50:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/327",
    "body": "I first use HikariCP. And my configuration file is as follows:\n\n```\ndataSourceClassName=com.mysql.jdbc.jdbc2.optional.MysqlDataSource\ndataSource.url=${dataSource.url}\ndataSource.user=${dataSource.user}\ndataSource.password=${dataSource.password}\ndataSource.poolName=${dataSource.poolName}\ndataSource.cachePrepStmts=${dataSource.cachePrepStmts}\ndataSource.prepStmtCacheSize=${dataSource.prepStmtCacheSize}\ndataSource.prepStmtCacheSqlLimit=${dataSource.prepStmtCacheSqlLimit}\n```\n\nBut the code throws exception as follows:\n\n```\nException in thread \"main\" java.lang.RuntimeException: java.beans.IntrospectionException: Method not found: setPoolName\n    at com.zaxxer.hikari.util.PropertyBeanSetter.setProperty(PropertyBeanSetter.java:134)\n    at com.zaxxer.hikari.util.PropertyBeanSetter.setTargetFromProperties(PropertyBeanSetter.java:63)\n    at com.zaxxer.hikari.pool.PoolUtilities.initializeDataSource(PoolUtilities.java:103)\n    at com.zaxxer.hikari.pool.BaseHikariPool.<init>(BaseHikariPool.java:156)\n    at com.zaxxer.hikari.pool.HikariPool.<init>(HikariPool.java:60)\n    at com.zaxxer.hikari.pool.HikariPool.<init>(HikariPool.java:48)\n    at com.zaxxer.hikari.HikariDataSource.<init>(HikariDataSource.java:80)\n    at com.abc.main(DataAddressServer.java:40)\nCaused by: java.beans.IntrospectionException: Method not found: setPoolName\n    at java.beans.PropertyDescriptor.<init>(PropertyDescriptor.java:110)\n    at com.zaxxer.hikari.util.PropertyBeanSetter.setProperty(PropertyBeanSetter.java:125)\n    ... 7 more\n\n```\n\nThen I configurate it in the code as follows:\n\n``` java\nHikariConfig hikariConfig = new HikariConfig(\"/database.properties\");\nhikariConfig.setMetricRegistry(MetricUtils.METRICS);\nHikariDataSource dataSource = new HikariDataSource(hikariConfig);\ndataSource.setPoolName(\"MyPool\");\n\n```\n\nBad luck. It do not work.\n\nThe option `maxLifetime` is as the `poolName`.\n\nHow do I configurate it ?\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/327/comments",
    "author": "diguage",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-06-17T06:50:55Z",
        "body": "`poolName` and `maxLifetime` are not DataSource properties, they are HikariCP properties.  So this:\n\n``` ini\ndataSourceClassName=com.mysql.jdbc.jdbc2.optional.MysqlDataSource\npoolName=${dataSource.poolName}\nmaxLifetime=900000\ndataSource.url=${dataSource.url}\ndataSource.user=${dataSource.user}\ndataSource.password=${dataSource.password}\n...\n```\n"
      },
      {
        "user": "diguage",
        "created_at": "2015-06-17T09:43:20Z",
        "body": "Thanks.\n"
      }
    ],
    "satisfaction_conditions": [
      "Clarify the distinction between HikariCP pool configuration properties and DataSource implementation properties",
      "Identify valid configuration scopes for HikariCP-specific parameters",
      "Provide guidance on proper property hierarchy in configuration files",
      "Explain programmatic configuration requirements for pool-level settings"
    ]
  },
  {
    "number": 283,
    "title": "Why is setConnectionInitSql deprecated?",
    "created_at": "2015-03-13T10:11:35Z",
    "closed_at": "2015-03-13T10:20:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/283",
    "body": "We are using this setting to change Oracle's default sorting behavior for a certain application:\n\nALTER SESSION SET NLS_SORT = XGERMAN_DIN\n\nShouldn't such use cases be supported in future, too?\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/283/comments",
    "author": "fdummert",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2015-03-13T10:20:26Z",
        "body": "The _connectionInit_ property will be un-@deprecated in the next release.  You can read the thread in the Google Group if you want to.\n"
      },
      {
        "user": "fdummert",
        "created_at": "2015-03-13T10:30:48Z",
        "body": "Thanks for the info and sorry, I should have checked the discussion before...\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2015-03-13T12:19:35Z",
        "body": "@fdummert No problem, I don't expect such a deep search.  Perfectly valid issue to open (and close :smile: )\n"
      }
    ],
    "satisfaction_conditions": [
      "Confirmation that Oracle session configuration use cases (like NLS_SORT) will remain supported",
      "Clarity on deprecation status resolution for required functionality"
    ]
  },
  {
    "number": 155,
    "title": "Passing useLegacyDatetimeCode without using jdbcUrl",
    "created_at": "2014-10-04T12:19:40Z",
    "closed_at": "2014-10-04T13:28:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/155",
    "body": "When using bonecp I passed with jdbc url ...:3306/DBNAME?useLegacyDatetimeCode=false\n\nHow can I pass it using the new HikariCP DataSource?\n\nIs this ok?\nconfig.addDataSourceProperty(\"useLegacyDatetimeCode\", \"false\");\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/155/comments",
    "author": "chook",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2014-10-04T13:28:49Z",
        "body": "Set Hikari's initializationFailFast=true, If it doesn't throw an Exception, it's working.  The best way to check what is available is to look at the JavaDoc for the MySQL DataSource.  If there is a setter like setUseLegacyDatetimeCode() then that will work fine.\n"
      },
      {
        "user": "chook",
        "created_at": "2014-10-05T07:06:16Z",
        "body": "Thanks!\n"
      }
    ],
    "satisfaction_conditions": [
      "Confirmation that the method for setting MySQL connection properties in HikariCP is valid",
      "Verification mechanism to confirm the configuration is applied successfully",
      "Reference to official documentation or JavaDoc for property validation",
      "Avoidance of JDBC URL modification requirement"
    ]
  },
  {
    "number": 151,
    "title": "HikariConfig username property?",
    "created_at": "2014-09-29T16:48:10Z",
    "closed_at": "2014-10-03T09:23:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/151",
    "body": "HikariConfig has a property which represents  the default authentication username.\nHowever, what's the property name: username or user?\nThe home page's introduction is conflict.\nI'm from China. Sorry for my terrible English.\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/151/comments",
    "author": "CodePlayer",
    "comments": [
      {
        "user": "brettwooldridge",
        "created_at": "2014-09-30T13:35:28Z",
        "body": "If you use a DataSource-class, HikariCP will call dataSource.getConnection(username, password).  If you use a Driver-class and JDBC URL, HikariCP will set a `user` property from the HikariConfig username, like this:\n\n``` java\nif (username != null) {\n   driverProperties.put(\"user\", driverProperties.getProperty(\"user\", username));\n}\n...\nreturn DriverManager.getConnection(jdbcUrl, driverProperties);\n```\n\nIf your driver expects a `username` property instead of `user`, then ignore the `HikariConfig.setUsername()` method and call `HikariCP.addDataSourceProperty(\"username\", ...)` instead.  Or put the username in the JDBC URL (eg. `jdbc:mysql://localhost/db?username=...`).\n"
      },
      {
        "user": "CodePlayer",
        "created_at": "2014-10-03T09:23:57Z",
        "body": "Oh, I see! It's pretty clear. Many thanks!\n"
      }
    ],
    "satisfaction_conditions": [
      "Clarifies when to use 'user' vs. 'username' property based on configuration type",
      "Explains how to handle driver-specific property expectations",
      "Provides workaround methods for non-standard driver requirements",
      "Distinguishes between HikariConfig properties and driver-specific properties"
    ]
  },
  {
    "number": 120,
    "title": "HikariCP API?",
    "created_at": "2014-07-25T20:34:59Z",
    "closed_at": "2014-07-26T01:18:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/brettwooldridge/HikariCP/issues/120",
    "body": "HikariCP is my first experience with connection pooling for MySQL. Is there any kind of documentation that details the API for HikariCP usage? Or should I just read through the source?\n\nThank you!\n",
    "comments_url": "https://api.github.com/repos/brettwooldridge/HikariCP/issues/120/comments",
    "author": "vagupta",
    "comments": [
      {
        "user": "vagupta",
        "created_at": "2014-07-25T20:43:02Z",
        "body": "I understand how to configure and set up the data source, but I'm just wondering how I should properly manage a connection. \n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2014-07-26T01:18:10Z",
        "body": "Generally, you want to get a connection from the pool, use it for a query or queries and then close() the connection (returning it to the pool).  For most applications, such as web applications, the typically out-of-pool time for a connection is typically on the order of milliseconds or maybe a few seconds.  So, for highly-available applications, you want to get a connection, use it, and close() it as quickly as possible so that it becomes available to other threads in the system.\n\nIn the case of a data warehouse application, where reports and queries may run for hours, obviously the connection is out of the pool for as long as it takes a query to run.\n"
      },
      {
        "user": "vagupta",
        "created_at": "2014-07-28T17:02:37Z",
        "body": "Thanks for the response!\n\nOne follow-up question: If I have a Connection connection, do I call connection.close() to close() that connection and return it to the connection pool?\n\nIf so, why? I was under the impression that calling close() on a Connection actually deletes the underlying resources for that Connection. How does the connection pool know when I call close() on a pooled Connection? Is that where the delegation comes into play? What does isClosed() check?\n\nI hope my question makes sense. I'm really trying to understand the difference between closing a Connection and returning it the connection pool.\n"
      },
      {
        "user": "brettwooldridge",
        "created_at": "2014-07-30T05:10:39Z",
        "body": "You are correct.  HikariCP (and all JDBC connection pools) wrap the _real_ `Connection` in a _delegating proxy_.  This proxy intercepts (overrides) calls to `close()`, and instead of closing the underlying `Connection` instead returns it to the pool.  In terms of the JDBC specification, this proxy is called a _Logical Connection_ and the real connection to the database is called a _Physical Connection_.\n\nMostly, the application code should not need to know whether it is running against a pooled connections or real connections.  The access pattern is the same; call `DataSource.getConnection()` and after executing queries call `Connection.close()`.\n\nIf you obtain a `Connection` from the pool, then call `close()`, if you then call `isClosed()` you will receive a value of `true`.  From the perspective of the application, the `Connection` _is_ closed.  If you try to call methods on the `Connection` after closing, you will receive a `SQLException` (just like a non-pooled `Connection`).  In reality, however, the _Physical Connection_ is _not_ closed, but the _Logical Connection_ _is_ closed.\n\nAgain, the goal of every pool (and in accordance with the JDBC specification) is to provide identical API behavior from the perspective of an application.\n\n\n---\n\nJust to add a little more detail.  There is no way for an application to force a close of the _Physical Connection_.  The pool controls the life-cycle of the _Physical Connection_.  By setting the `maximumPoolSize`, `idleTimeout`, and `maxLifetime` properties you can control the life-cycle of _Physical Connections_ in a very general way.\n"
      },
      {
        "user": "vagupta",
        "created_at": "2014-07-30T17:33:08Z",
        "body": "Wow, okay. I appreciate your explanation. Now, I've got a much better idea of how the pooling works. I just realized that \"Connection\" is an interface and not the actual object. \n\nThank you for your help, and thank you for making HikariCP.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how connection lifecycle management works in HikariCP",
      "Clarification of the proxy/delegation pattern used for pooled connections",
      "Description of the relationship between logical and physical connections",
      "Guidance on proper connection handling patterns according to JDBC specifications"
    ]
  }
]