[
  {
    "number": 60535,
    "title": "language services: If tsconfig.json under the ConguredProject project ignores some files, such as d.ts, opening these d.ts will create a new InferredProject. Is it designed like this?",
    "created_at": "2024-11-19T06:35:16Z",
    "closed_at": "2024-12-04T06:06:21Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/60535",
    "body": "### \ud83d\udd0e Search Terms\n\nIf tsconfig.json under the ConguredProject project ignores some files, such as d.ts, opening these d.ts will create a new InferredProject. Is it designed like this?\n\n### \ud83d\udd57 Version & Regression Information\n\nversion: 5.6.3\n\n### \u23ef Playground Link\n\n_No response_\n\n### \ud83d\udcbb Code\n\n```ts\n// Your code here\n```\n\n\n### \ud83d\ude41 Actual behavior\n\nThe two project paths are the same, but the ProjectKind is different\n\n### \ud83d\ude42 Expected behavior\n\nExpect not to create a new project\n\n### Additional information about the issue\n\n_No response_",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/60535/comments",
    "author": "schizobulia",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2024-12-02T07:08:08Z",
        "body": "Yes - why wouldn't it?"
      },
      {
        "user": "schizobulia",
        "created_at": "2024-12-03T07:01:08Z",
        "body": "> Yes - why wouldn't it?\n\nCan I ask why it is designed this way? \ud83d\ude00  @RyanCavanaugh "
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2024-12-03T18:59:02Z",
        "body": "The most likely scenario of opening a `.d.ts` file that wasn't part of a configured project is that it's the *output* of that configured project, so merging it into the same project context as the tsconfig would result in many \"duplicate identifier\" errors"
      },
      {
        "user": "schizobulia",
        "created_at": "2024-12-04T06:06:21Z",
        "body": "Got it. Thank you @RyanCavanaugh "
      }
    ],
    "satisfaction_conditions": [
      "Explains why TypeScript creates a separate InferredProject for excluded .d.ts files",
      "Identifies the problem this design solves (e.g., preventing duplicate identifier errors)",
      "Clarifies the relationship between ConfiguredProjects and InferredProjects for excluded declaration files"
    ]
  },
  {
    "number": 57789,
    "title": "TypeScript only find types",
    "created_at": "2024-03-15T10:37:46Z",
    "closed_at": "2024-03-15T17:45:00Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/57789",
    "body": "### \ud83d\udd0e Search Terms\n\nTS18042, TS2693, import, exports, types\n\n### \ud83d\udd57 Version & Regression Information\n\n- This is the behavior in every version I tried (_5.4.2_ and _5.0.2_), and I reviewed the FAQ for entries about _exports_.\n\n### \u23ef Playground Link\n\n_No response_\n\n### \ud83d\udcbb Code\n\n- `package.json`\r\n\r\n  ```JSON\r\n  {\r\n    \"name\": \"testcase\",\r\n    \"version\": \"1.0.0\",\r\n    \"type\": \"module\",\r\n    \"dependencies\": {\r\n      \"subproject\": \"./subproject/\",\r\n      \"typescript\": \"5.4.2\"\r\n    }\r\n  }\r\n  ```\r\n\r\n- `index.js`\r\n\r\n  ```JavaScript\r\n  import sub from \"subproject\";\r\n\r\n  console.log(sub.foo);\r\n  ```\r\n\r\n- `subproject/`\r\n  - `package.json`\r\n\r\n    ```JSON\r\n    {\r\n      \"name\": \"subproject\",\r\n      \"version\": \"1.0.0\",\r\n      \"type\": \"module\",\r\n      \"exports\": {\r\n        \".\": {\r\n          \"types\": \"./sub.d.ts\",\r\n          \"default\": \"./sub.js\"\r\n        }\r\n      }\r\n    }\r\n    ```\r\n\r\n  - `sub.js`\r\n\r\n    ```JavaScript\r\n    export default {\r\n      foo: \"bar\",\r\n      baz: 42,\r\n    };\r\n    ```\r\n\r\n  - `sub.d.ts`\r\n\r\n    ```TypeScript\r\n    declare type _default = {\r\n      foo: string;\r\n      baz: number;\r\n    };\r\n\r\n    export default _default;\r\n    ```\r\n\r\n1. `npm install`\r\n2. `npx tsc --noEmit --checkJs --module nodenext index.js`\r\n   or `npx tsc --noEmit --checkJs --module nodenext --moduleResolution nodenext index.js`\n\n### \ud83d\ude41 Actual behavior\n\n```\r\nindex.js:1:8 - error TS18042: 'sub' is a type and cannot be imported in JavaScript files. Use 'import(\"subproject\").sub' in a JSDoc type annotation.\r\n\r\n1 import sub from \"subproject\";\r\n         ~~~\r\n\r\nindex.js:3:13 - error TS2693: 'sub' only refers to a type, but is being used as a value here.\r\n\r\n3 console.log(sub.foo);\r\n              ~~~\r\n\r\n\r\nFound 2 errors in the same file, starting at: index.js:1\r\n```\n\n### \ud83d\ude42 Expected behavior\n\nNo error.\n\n### Additional information about the issue\n\nI also reproduce the bug with `npm pack` and:\r\n\r\n```JSON\r\n{\r\n  \"dependencies\": {\r\n    \"subproject\": \"./subproject/subproject-1.0.0.tgz\",\r\n  }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/57789/comments",
    "author": "regseb",
    "comments": [
      {
        "user": "regseb",
        "created_at": "2024-03-15T10:58:23Z",
        "body": "I'm having the same problem with a TypeScript file:\r\n\r\n```TypeScript\r\n// index.ts\r\nimport type subType from \"subproject\";\r\nimport sub from \"subproject\";\r\n\r\nconst a: subType = {\r\n    foo: \"bar\",\r\n    baz: \"Not a Number\",\r\n};\r\nconst b: sub = {\r\n    foo: \"bar\",\r\n    baz: \"Not a Number\",\r\n};\r\n\r\nconsole.log(sub.foo);\r\n```\r\n\r\n`npx tsc --noEmit --module nodenext index.ts`\r\n\r\n```\r\nindex.ts:7:5 - error TS2322: Type 'string' is not assignable to type 'number'.\r\n\r\n7     baz: \"Not a Number\",\r\n      ~~~\r\n\r\n  node_modules/subproject/sub.d.ts:3:5\r\n    3     baz: number;\r\n          ~~~\r\n    The expected type comes from property 'baz' which is declared here on type '_default'\r\n\r\nindex.ts:11:5 - error TS2322: Type 'string' is not assignable to type 'number'.\r\n\r\n11     baz: \"Not a Number\",\r\n       ~~~\r\n\r\n  node_modules/subproject/sub.d.ts:3:5\r\n    3     baz: number;\r\n          ~~~\r\n    The expected type comes from property 'baz' which is declared here on type '_default'\r\n\r\nindex.ts:14:13 - error TS2693: 'sub' only refers to a type, but is being used as a value here.\r\n\r\n14 console.log(sub.foo);\r\n               ~~~\r\n\r\n\r\nFound 3 errors in the same file, starting at: index.ts:7\r\n```"
      },
      {
        "user": "IllusionMH",
        "created_at": "2024-03-15T11:59:37Z",
        "body": "`types` in `exports` section override/shadow `import`/`require` and in your declarations you only export type.\n\nTo export value you need to declare const and export it as default IIRC"
      },
      {
        "user": "jakebailey",
        "created_at": "2024-03-15T14:45:32Z",
        "body": "```ts\r\ndeclare const _default: {\r\n  foo: string;\r\n  baz: number;\r\n};\r\n\r\nexport default _default;\r\n```\n\n---\n\nIf you're already using TypeScript, you'd be better of using it to produce your declaration files instead of doing it by hand; it would have done the right thing."
      },
      {
        "user": "regseb",
        "created_at": "2024-03-15T17:45:01Z",
        "body": "Thank you for your feedback. I understood the association between _.js_ and _.d.ts_ files. The _.d.ts_ file:\r\n\r\n- must **not** export the type of JavaScript objects.\r\n- must export typed JavaScript objects.\r\n\r\n---\r\n\r\nI want to add typing to a JavaScript project. That's why I'm writing the declaration file by hand. And then I use TypeScript and JSDoc to validate the types in the JavaScript files."
      }
    ],
    "satisfaction_conditions": [
      "Declaration files must export both type information and runtime value representations",
      "Package.json exports configuration must support dual-type/value imports",
      "Solution must maintain JSDoc validation capabilities",
      "Approach must work for both JavaScript and TypeScript entry files"
    ]
  },
  {
    "number": 56224,
    "title": "Types not generated/working with AMD module",
    "created_at": "2023-10-26T10:08:53Z",
    "closed_at": "2023-10-27T18:26:56Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/56224",
    "body": "### Acknowledgement\n\n- [X] I acknowledge that issues using this template may be closed without further explanation at the maintainer's discretion.\n\n### Comment\n\nWhen using AMD modules and working in VSCode, type declarations are not being picked up for modules that load dependencies using an array passed to the define function, but they are working for modules that load dependencies using `require('./module-path')`\r\n\r\nIn a simple project structured like this:\r\n\r\n```\r\napp\r\n    |app.js\r\n    |lib.js\r\n    |lib.d.ts\r\n```\r\nThe file `lib.js` contains this:\r\n\r\n```\r\ndefine('lib', function() {\r\n    return {\r\n        libTest: (msg) => {\r\n            console.log('lib is working!', msg);\r\n            return true;\r\n        },\r\n    }\r\n});\r\n```\r\nThe file `lib.d.ts` looks like this:\r\n\r\n```\r\n/** @name declaration test */\r\nexport module './lib';\r\n/** @name libTest */\r\nexport function libTest(msg: string): boolean;\r\n```\r\nThe declarations from `lib.d.ts` are correctly picked up in `app.js` with this and Intellisense works as expected, pulling info from `lib.d.ts`:\r\n\r\n```\r\nconst lib = require('./lib');\r\nlib.libTest(); // hovering pointer on 'libTest' shows \"function libTest(msg: string): boolean \\n @name -- libTest\" and hovering on 'lib' shows \"@name -- declaration test\"\r\n```\r\nThe declarations also work as expected if `app.js` looks like this instead:\r\n\r\n```\r\ndefine(function() {\r\n    const lib = require('./lib');\r\n    lib.libTest(); // hovering pointer on 'libTest' shows \"function libTest(msg: string): boolean \\n @name -- libTest\" and hovering on 'lib' shows \"@name -- declaration test\"\r\n});\r\n```\r\nHowever, the declarations **do not work** at all when the code in `app.js` looks like this:\r\n\r\n```\r\ndefine(['lib'], function(lib) {\r\n    lib.libTest(); // hovering pointer on either 'lib' or 'libTest' just shows \"any\"\r\n});\r\n```\r\nWhy are the declarations from the `lib.d.ts` file working as expected for the first two variations of `app.js`, but not the third variation which uses an array of dependencies?\r\n\r\nAdditionally, if I delete the `lib.d.ts` file and try to have the compiler generate the declarations automatically (using `\"declaration\": true, \"emitDeclarationOnly\": true` in tsconfig) the tsc command completes successfully, but the generated d.ts file is completely empty",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/56224/comments",
    "author": "ts-lover",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2023-10-26T16:31:23Z",
        "body": "JS module inference only works for calls to the `require` function; it doesn't support AMD `define` calls."
      },
      {
        "user": "ts-lover",
        "created_at": "2023-10-27T10:08:56Z",
        "body": "Ok, thanks for the quick response Ryan :)\r\n\r\nWhat about if the app file was a TypeScript file instead of a JS file, would that make any difference?"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2023-10-27T16:53:19Z",
        "body": "You'd have to write it with \"normal\" TS syntax and transpile to AMD format for it to be recognized"
      },
      {
        "user": "ts-lover",
        "created_at": "2023-10-27T18:26:56Z",
        "body": "Got it, thanks so much!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why TypeScript's module resolution works differently for AMD array-style dependencies vs require calls",
      "Documentation of TypeScript's limitations with AMD module type generation",
      "Workflow for mixing AMD modules with TypeScript's type system",
      "Explanation of transpilation requirements for AMD compatibility"
    ]
  },
  {
    "number": 56160,
    "title": "tsc target did not work expectedly when compile ES2022 to ES2015",
    "created_at": "2023-10-20T07:59:04Z",
    "closed_at": "2023-10-23T01:26:29Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/56160",
    "body": "### \ud83d\udd0e Search Terms\n\ntarget  ES2022  ES2015\n\n### \ud83d\udd57 Version & Regression Information\n\nTS 4.5\r\n\n\n### \u23ef Playground Link\n\n_No response_\n\n### \ud83d\udcbb Code\n\nnpx tsc --target es5 index.ts --outFile indexout.js\r\n\r\n\r\nindex.ts:\r\nconst arr = [1, 2, 3, 4, 5];\r\narr.at(1); // 2\n\n### \ud83d\ude41 Actual behavior\n\nindexout.js:\r\n\r\nconst arr = [1, 2, 3, 4, 5];\r\narr.at(1); // 2\n\n### \ud83d\ude42 Expected behavior\n\nArray.at is a new feature in ES2022\r\nThe target is ES5, the output js should not include Array.at\r\nso the indexout.js can not work on the old browser.\n\n### Additional information about the issue\n\n_No response_",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/56160/comments",
    "author": "turtleinspace1",
    "comments": [
      {
        "user": "MartinJohns",
        "created_at": "2023-10-20T08:07:34Z",
        "body": "TypeScript will only downlevel newer syntax. If the function you're trying to call does not exist at your runtime it's your responsibility to polyfill it."
      },
      {
        "user": "turtleinspace1",
        "created_at": "2023-10-20T09:05:00Z",
        "body": "Thanks I understand"
      },
      {
        "user": "typescript-bot",
        "created_at": "2023-10-23T01:26:29Z",
        "body": "This issue has been marked as \"Question\" and has seen no recent activity. It has been automatically closed for house-keeping purposes."
      }
    ],
    "satisfaction_conditions": [
      "Clarify TypeScript's responsibility regarding ECMAScript API polyfilling vs syntax transpilation",
      "Identify required developer action for API backward compatibility",
      "Differentiate between language features and standard library additions"
    ]
  },
  {
    "number": 54189,
    "title": "Uncaught SyntaxError \":\" in recursive function signature",
    "created_at": "2023-05-08T23:45:10Z",
    "closed_at": "2023-05-09T16:47:56Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/54189",
    "body": "Uncaught SyntaxError C:\\Users\\Owner\\Documents\\TS\\HelloWorlds\\HelloHanoi\\hanoi.ts:19\r\n  height: number,\r\n        ^\r\n\r\nfunction moveTower(\r\n  height: number,\r\n  fromPole: string,\r\n  toPole: string,\r\n  withPole: string\r\n): void {\r\n  if (height >= 1) {\r\n    // Move tower of height-1 to an intermediate pole, using the destination pole.\r\n    moveTower(height - 1, fromPole, withPole, toPole);\r\n\r\n    // Move the remaining disk to the destination pole.\r\n    console.log(`Move disk from ${fromPole} to ${toPole}`);\r\n\r\n    // Move the tower of height-1 from the intermediate pole to the destination pole using the source pole.\r\n    moveTower(height - 1, withPole, toPole, fromPole);\r\n  }\r\n}\r\n\r\n// Call the function with the initial parameters.\r\nmoveTower(3, \"A\", \"C\", \"B\");",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/54189/comments",
    "author": "peternroth",
    "comments": [
      {
        "user": "jakebailey",
        "created_at": "2023-05-09T04:13:14Z",
        "body": "You are attemping to execute TypeScript without compiling it to JavaScript, hence the error on the `:` token. You'll need to run `tsc` and then execute its output, or use a tool such as `ts-node` or `tsx` to run your script directly."
      },
      {
        "user": "peternroth",
        "created_at": "2023-05-09T16:47:56Z",
        "body": "Thanks, jakebailey! "
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why TypeScript code cannot be directly executed like JavaScript",
      "Identification of the need for a TypeScript execution workflow",
      "Solution must address runtime environment limitations"
    ]
  },
  {
    "number": 50564,
    "title": "Allow to use value as type in some cases",
    "created_at": "2022-08-31T12:13:10Z",
    "closed_at": "2022-09-02T04:35:24Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/50564",
    "body": "## \ud83d\udd0d Search Terms\r\nts2747, Allow to use value as type\r\n\r\n## \u2b50 Suggestion\r\n\r\nAllow to use value as type in some cases\r\n\r\n## \ud83d\udcbb Use Cases\r\n\r\nSometimes it would be nice to have ability to use value as type:\r\n```\r\nclass A {\r\n    public static classname = 'A';\r\n    public a: number = 2;\r\n    classname = 'A';\r\n    constructor (v: number) {\r\n        this.a = v;\r\n    }\r\n}\r\n\r\nclass B {\r\n    public static classname = 'B';\r\n    public b: number = 2;\r\n    classname = 'B';\r\n    constructor (v: number) {\r\n        this.b = v;\r\n    }\r\n}\r\n\r\nconst list = [new A(1), new A(2), new B(3), new A(4), new B(5)];\r\n\r\n// first case\r\nfunction findByType<T> (source: T[], type: Function): type { // 'type' refers to a value, but is being used as a type here.\r\n    return source.find(e => e instanceof type);\r\n}\r\nconsole.log(findByType(list, A).a + findByType(list, B).b);\r\n\r\n\r\n// second case\r\nfunction isTypeOf<T> (source: T, type: Function): source is type { // 'type' refers to a value, but is being used as a type here.\r\n    return (source as any).classname === (type as any).classname;\r\n}\r\nif (isTypeOf(list[0], A)) console.log(list[0].a);\r\n```\r\nThis is a highly simplified example, but it shows how this feature can be used in real application.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/50564/comments",
    "author": "buryndin",
    "comments": [
      {
        "user": "IllusionMH",
        "created_at": "2022-08-31T13:13:00Z",
        "body": "You should follow issue template.\r\n\r\nThere may be intersection between identifiers in types \"scope\" and values \"scope\", therefore it's not easier to get problems when values are used as types and vice versa.\r\n\r\nError message suggests correct fix - just write `typeof type` instead of plain `type`. Why it's problem to add explicit `typeof`?\r\n\r\nTS would then report proper errors in your code In your code (after adding requested `typeof`)."
      },
      {
        "user": "buryndin",
        "created_at": "2022-08-31T13:31:35Z",
        "body": "I need not a 'typeof'. I pass type as parameter and I want to use this type.\r\ntypeof A === 'function' - it is useless.\r\nI understand that we cannot use type as value, because some kind of types ('type' or 'interface') does not exist in runtime(compiled js-code). But It seems using value as type is quite possible."
      },
      {
        "user": "IllusionMH",
        "created_at": "2022-08-31T13:52:37Z",
        "body": "Because you have explicit type `Function`. You should make that type generic (with constraint).\r\n\r\nAlso type of `type` is constructor type as you expect function and pass class constructor.\r\nYou should use `InstanceType<typeof type>` to get type you are looking for."
      },
      {
        "user": "fatcerberus",
        "created_at": "2022-08-31T13:55:53Z",
        "body": "> typeof A === 'function' - it is useless.\r\n\r\nWe're not talking about runtime `typeof`, we're talking about type-level `typeof`, which means \"get the compile-time type of this variable\":\r\n\r\n```ts\r\nlet x: number = 42;\r\nlet y: typeof x = 812;\r\n//  ^?\r\n//  (number)\r\n```\n\n---\n\n```ts\r\nfunction isTypeOf<T extends Function>(source: Function, type: T): source is typeof type {\r\n    return (source as any).classname === (type as any).classname;\r\n}\r\n```\r\n\r\nThis works.  But of course at this point you might as well just write `source is T`."
      },
      {
        "user": "buryndin",
        "created_at": "2022-08-31T14:29:51Z",
        "body": "> You should use `InstanceType<typeof type>`\r\nIt is not working:\r\n```ts\r\nfunction findByType<T> (source: T[], type: Function): InstanceType<typeof type> { // error Type 'Function' does not satisfy the constraint ...\r\n    return source.find(e => e instanceof type);\r\n}\r\n```\r\n> ```ts\r\n> function isTypeOf<T extends Function>(source: Function, type: T): source is typeof type {\r\n>     return (source as any).classname === (type as any).classname;\r\n> }\r\n> ```\r\n\r\nThis is does not work also\r\n```ts\r\nfunction isTypeOf<T extends {}>(source: {}, type: T): source is typeof type {\r\n    return (source as any).classname === (type as any).classname;\r\n}\r\nif (isTypeOf(list[0], A)) console.log(list[0].a); // Property 'a' does not exist on type 'B & typeof A'.\r\n```\r\n\r\nPlease see my suggestion carefully: if predicate isTypeOf is true I expect that on the line \r\n```\r\nif (isTypeOf(list[0], A)) console.log(list[0].a); \r\n```\r\ntypeof list[0]  = A"
      },
      {
        "user": "MartinJohns",
        "created_at": "2022-08-31T14:34:27Z",
        "body": "```typescript\r\nfunction isTypeOf<T extends new (...args: any) => any>(source: {}, type: T): source is InstanceType<T> {\r\n    return (source as any).classname === (type as any).classname;\r\n}\r\n```"
      },
      {
        "user": "IllusionMH",
        "created_at": "2022-08-31T14:35:50Z",
        "body": "> You should use InstanceType<typeof type>\r\n> It is not working:\r\n\r\nYou've skipped first part where it should be generic, but as **wisecerberus** mentioned, in that case you can just use generic `T` type instead of `typeof type`. Or as posted above by **MartinJohns**"
      },
      {
        "user": "fatcerberus",
        "created_at": "2022-08-31T14:38:54Z",
        "body": "> if predicate isTypeOf is true I expect that ... typeof list[0] = A\r\n\r\nThat's literally just `list[0] instanceof A`.  Martin's version is the correct way to implement your custom version."
      },
      {
        "user": "buryndin",
        "created_at": "2022-09-02T04:35:24Z",
        "body": "Sorry guys, I forgot about generic. Thank's a lot for your help. Issue can be closed."
      }
    ],
    "satisfaction_conditions": [
      "Allow passing class constructors as parameters while preserving type information",
      "Enable type narrowing through custom type guards using class references",
      "Maintain type safety when working with class instances and static properties",
      "Support generic type resolution for class constructor parameters",
      "Avoid explicit type assertions while preserving type relationships"
    ]
  },
  {
    "number": 48404,
    "title": "Update from 4.6.0-Beta to 4.6.1-RC introduced bug with Electron 12",
    "created_at": "2022-03-24T18:50:48Z",
    "closed_at": "2022-03-24T19:39:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/48404",
    "body": "# Bug Report\r\n\r\nAfter updating and compiling the project, the Electron-App (Runniing on Electron v12.0.2) does not load the resulting javascript file but reports an error just a view lines into the code.\r\n`Uncaught SyntaxError: Unexpected token '{'`\r\n\r\n### \ud83d\udd0e Search Terms\r\n\r\n`Uncaught SyntaxError: Unexpected token '{'` Electron 4.6.1-RC\r\n\r\n### \ud83d\udd57 Version & Regression Information\r\n\r\nAfter update from 4.5.0-Beta to 4.6.2, did some research to find it was introduced with 4.6.1-RC\r\n\r\n- This is a crash\r\n- This changed between versions 4.6.0-Beta and 4.6.1-RC\r\n\r\n\r\n### \ud83d\udcbb Code\r\n\r\n<!-- Please post the relevant code sample here as well-->\r\n```ts\r\n    class DebugConsole extends FudgeCore.DebugTarget {\r\n        static { this.delegates = {                                                    // error thrown from this line\r\n            [FudgeCore.DEBUG_FILTER.INFO]: console.info,\r\n            [FudgeCore.DEBUG_FILTER.LOG]: console.log,\r\n            [FudgeCore.DEBUG_FILTER.WARN]: console.warn,\r\n            [FudgeCore.DEBUG_FILTER.ERROR]: console.error,\r\n            [FudgeCore.DEBUG_FILTER.FUDGE]: DebugConsole.fudge,\r\n            [FudgeCore.DEBUG_FILTER.CLEAR]: console.clear,\r\n            [FudgeCore.DEBUG_FILTER.GROUP]: console.group,\r\n            [FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED]: console.groupCollapsed,\r\n            [FudgeCore.DEBUG_FILTER.GROUPEND]: console.groupEnd,\r\n            [FudgeCore.DEBUG_FILTER.SOURCE]: DebugConsole.source\r\n        }; }\r\n```\r\n\r\nPrevious output, which Electron12 was able to run, was\r\n```ts\r\n    class DebugConsole extends FudgeCore.DebugTarget {\r\n          ....\r\n    }\r\n    DebugConsole.delegates = {\r\n            [FudgeCore.DEBUG_FILTER.INFO]: console.info,\r\n             ....\r\n```\r\n\r\n### \ud83d\ude41 Actual behavior\r\n\r\nElectron aborts loading the compiled Javascript file and throws the error \r\n\r\n### \ud83d\ude42 Expected behavior\r\n\r\nLoad the compiled file and run it\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/48404/comments",
    "author": "JirkaDellOro",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2022-03-24T19:17:20Z",
        "body": "Hmm, are you using `--target esnext`? If so, that isn't a stable output target across different versions of TypeScript, and will emit syntax that may be newer than what your engine expects. In this case, I would expect `--target es2020` would be good enough. Otherwise, we need more info about what went wrong (e.g. compiler options and new output)."
      },
      {
        "user": "JirkaDellOro",
        "created_at": "2022-03-24T19:39:22Z",
        "body": "Wow, didn't expect that quick of an answer. Correct, I used `esnext` to target whatever the newest is, but until I find the time to port the project to a newer Electron version, I just figured I can even use `es2021` with typescript@next. It's better this way round.\r\n\r\nThanks a lot!"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2022-03-24T21:12:55Z",
        "body": "No problem, glad the workaround was simple!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why static class blocks would be incompatible with Electron 12's JavaScript engine",
      "Guidance on configuring TypeScript to avoid emitting unsupported syntax for specific runtime environments",
      "Clarification of TypeScript version compatibility with ECMAScript targets",
      "Identification of minimum ECMAScript version supported by Electron 12"
    ]
  },
  {
    "number": 47084,
    "title": "warning: Experimental support for decorators is a feature that is subject to change in a future release",
    "created_at": "2021-12-09T09:29:46Z",
    "closed_at": "2021-12-10T08:45:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/47084",
    "body": "# Bug Report\r\n\r\n<!--\r\n  Please fill in each section completely. Thank you!\r\n-->\r\n\r\n### \ud83d\udd0e Search Terms\r\n\r\nExperimental  decorators\r\n\r\n### \ud83d\udd57 Version & Regression Information\r\n\r\nmonaco: v0.30.1\r\ntypescript: 3.2.4\r\n\r\n\r\n### \ud83d\udcbb Code\r\nplaygroud code:\r\nmonaco.languages.typescript.javascriptDefaults.setDiagnosticsOptions({\r\n\tnoSemanticValidation: true,\r\n\tnoSyntaxValidation: false\r\n});\r\n\r\n// compiler options\r\nmonaco.languages.typescript.javascriptDefaults.setCompilerOptions({\r\n\ttarget: monaco.languages.typescript.ScriptTarget.ES2015,\r\n        experimentalDecorators: true,\r\n\tallowNonTsExtensions: true\r\n});\r\n\r\n\r\nvar jsCode = [\r\n    'import { Injectable } from \\'@angular/core\\';',\r\n    'import { ApplicationParamService } from \\'@farris/command-services\\';',\r\n    'import { HttpClient, HttpHeaders } from \\'@angular/common/http\\';',\r\n    '@Injectable()',\r\n    'export class List1FrmWebcmpService {',\r\n        'constructor(private obj: ApplicationParamService, private http:HttpClient) {',\r\n            'this.obj.parseParams;',\r\n        '}',\r\n        'private get() { }',\r\n        'set() { }',\r\n    '}'\r\n].join('\\n');\r\n\r\nmonaco.editor.create(document.getElementById('container'), {\r\n\tvalue: jsCode,\r\n\tlanguage: 'typescript'\r\n});\r\n\r\n### \ud83d\ude41 Actual behavior\r\n\r\n'List1FrmWebcmpService' has underline&warning ' Experimental support for decorators is a feature that is subject to change in a future release. Set the 'experimentalDecorators' option in your 'tsconfig' or 'jsconfig' to remove this warning '\r\n\r\n### \ud83d\ude42 Expected behavior\r\n'experimentalDecorators: true' option not wok,how to remove this warning?\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/47084/comments",
    "author": "chenqiangkobe",
    "comments": [
      {
        "user": "MartinJohns",
        "created_at": "2021-12-09T09:57:20Z",
        "body": "Did you mean to set `typescriptDefaults` instead of `javascriptDefaults`? Regardless, this doesn't seem to be an issue with TypeScript itself.\r\n\r\n> typescript: 3.2.4\r\n\r\nAre you really using a version released on 3. January **2019**? The latest version is 4.5.2."
      },
      {
        "user": "chenqiangkobe",
        "created_at": "2021-12-10T08:45:57Z",
        "body": "@MartinJohns  I use **typescriptDefaults** instead of **javascriptDefaults**, the option **experimentalDecorators: true** works. Thanks a lot. "
      }
    ],
    "satisfaction_conditions": [
      "Configuration must target TypeScript language service settings in Monaco Editor",
      "Proper activation of experimentalDecorators compiler option",
      "Compatibility with Monaco Editor's TypeScript integration"
    ]
  },
  {
    "number": 42326,
    "title": "Question: where can one find all possible TSC errors?",
    "created_at": "2021-01-14T02:37:42Z",
    "closed_at": "2021-01-14T18:58:58Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/42326",
    "body": "# Question #\r\n\r\nFirst, my apologies for not asking on SO, I doubt that questions like this are relevant to their platform.\r\n\r\nAre any TSC errors documented (outside of the source code)?\r\nDoes an exhaustive list containing every possible error exist?\r\nIs there a documented rationale behind why a compiler error is introduced?\r\n\r\nIf so, where might I find this documentation?\r\nIf not, why isn't there? Could this be introduced?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/42326/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2021-01-14T18:44:39Z",
        "body": "We don't have specific documentation for each error, no.\r\n\r\nOur experience has been that it's very, very difficult to write meaningful per-error documentation (plus there are literally thousands of them); we prefer to document the system more holistically."
      },
      {
        "user": "ghost",
        "created_at": "2021-01-14T18:52:07Z",
        "body": "@RyanCavanaugh I can understand, documenting ~20k different compiler errors wouldn't be easy, but is there anywhere that I can easily find the errors and their associated messages, maybe in the source code? Or are they scattered across the codebase?"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2021-01-14T18:53:27Z",
        "body": "See `src/compiler/diagnosticMessages.json`"
      }
    ],
    "satisfaction_conditions": [
      "Identifies a centralized location within the TypeScript codebase where error messages are defined",
      "Confirms the existence of an exhaustive list of all possible TSC error codes/messages",
      "Addresses whether official documentation exists explaining the rationale behind specific compiler errors"
    ]
  },
  {
    "number": 40326,
    "title": "[Question or Bug]: is the way of using ParsingContext intended in Parser.ts?",
    "created_at": "2020-08-31T08:48:31Z",
    "closed_at": "2020-09-01T02:06:14Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/40326",
    "body": "> these happens in typescript repository itself.\r\n\r\nHi, I found an enum `ParsingContext` which is not defined as flags. Here are the code copy:\r\n``` ts\r\n        const enum ParsingContext {\r\n            SourceElements,            // Elements in source file\r\n            BlockStatements,           // Statements in block\r\n            SwitchClauses,             // Clauses in switch statement\r\n            SwitchClauseStatements,    // Statements in switch clause\r\n            TypeMembers,               // Members in interface or type literal\r\n            ClassMembers,              // Members in class declaration\r\n            EnumMembers,               // Members in enum declaration\r\n            HeritageClauseElement,     // Elements in a heritage clause\r\n            VariableDeclarations,      // Variable declarations in variable statement\r\n            ObjectBindingElements,     // Binding elements in object binding list\r\n            ArrayBindingElements,      // Binding elements in array binding list\r\n            ArgumentExpressions,       // Expressions in argument list\r\n            ObjectLiteralMembers,      // Members in object literal\r\n            JsxAttributes,             // Attributes in jsx element\r\n            JsxChildren,               // Things between opening and closing JSX tags\r\n            ArrayLiteralMembers,       // Members in array literal\r\n            Parameters,                // Parameters in parameter list\r\n            JSDocParameters,           // JSDoc parameters in parameter list of JSDoc function type\r\n            RestProperties,            // Property names in a rest type list\r\n            TypeParameters,            // Type parameters in type parameter list\r\n            TypeArguments,             // Type arguments in type argument list\r\n            TupleElementTypes,         // Element types in tuple element type list\r\n            HeritageClauses,           // Heritage clauses for a class or interface declaration.\r\n            ImportOrExportSpecifiers,  // Named import clause's import specifier list\r\n            Count                      // Number of parsing contexts\r\n        }\r\n```\r\n`as flags` means something like\r\n```ts\r\nenum Example{\r\nA = 1<<0;\r\nB = 1<<1;\r\n}\r\n```\r\n\r\nBut I see a strange use of it, which makes me feel they are used like flags.\r\n\r\n```ts\r\n            const saveParsingContext = parsingContext;\r\n            parsingContext |= 1 << kind;   // `Line 1`\r\n```\r\n```ts\r\n            switch (parsingContext) {\r\n                case ParsingContext.ClassMembers:\r\n                case ParsingContext.SwitchClauses:\r\n                case ParsingContext.SourceElements:\r\n                case ParsingContext.BlockStatements:\r\n                case ParsingContext.SwitchClauseStatements:\r\n                case ParsingContext.EnumMembers:\r\n                case ParsingContext.TypeMembers:\r\n                case ParsingContext.VariableDeclarations:\r\n                case ParsingContext.JSDocParameters:\r\n                case ParsingContext.Parameters:\r\n                    return true;\r\n            }\r\n            return false;\r\n```\r\n```ts\r\n        function isInSomeParsingContext(): boolean {\r\n            for (let kind = 0; kind < ParsingContext.Count; kind++) {\r\n                if (parsingContext & (1 << kind)) {    // `Line 2`\r\n                    if (isListElement(kind, /*inErrorRecovery*/ true) || isListTerminator(kind)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n```\r\nFrom the for-loop, it seems the enum is not used as flag, but `Line 1` would make most condition out of range, and let switch clause loss of use.\r\n`Line 2` is also strange, it seems some enum kind are very special in the condition and only take them as parameter (I means 1\uff0c2,4,8,16). \r\n\r\nI feel someone confused the types, sometimes he treats the enum as flags and sometimes not.\r\n\r\nFeel free to close this if it is intended. And it would be sweet to give a simple reason.\r\n\r\nIf it is really a bug, I would be glad to fix it. (or maybe it is more proper to be fixed by core team?)",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/40326/comments",
    "author": "ShuiRuTian",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2020-08-31T15:21:47Z",
        "body": "The enum gets used both ways. The `switch` there refers to the `parsingContext` parameter that takes a plain `ParsingContext` value, whereas `isInSomeParsingContext` operates on a bitfield. I'm not entirely sure why we didn't just define this as a flags from the get-go, but it's not a bug."
      },
      {
        "user": "ShuiRuTian",
        "created_at": "2020-09-01T02:06:14Z",
        "body": "Thanks for the detailed reason, glad to know how it works!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why ParsingContext is used both as bitfield and plain enum values",
      "Confirmation that the implementation is intentional rather than accidental",
      "Clarification of how different code paths interact with ParsingContext values",
      "Reconciliation of apparent inconsistency between bitwise operations and enum checks"
    ]
  },
  {
    "number": 37795,
    "title": "Better type inference for Frozen const arrays ",
    "created_at": "2020-04-05T01:01:08Z",
    "closed_at": "2020-04-23T22:02:26Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/37795",
    "body": "Search Terms: Object.freeze, Readonly\r\n\r\nI think typescript should have better type inference when object freeze is used on arrays and The type used is readonly array of the given type, instead the type should be readonly tuple that has the types used in the array.\r\n\r\nExample:\r\n``` javaScript\r\n// The type of the array is: \r\n// readonly Array<string | number>\r\n\r\n// What the type should be:\r\n// readonly [\"Abra\", \"Isma\", 0]\r\nconst b = Object.freeze([\"Abra\", \"Isma\", 0]);\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/37795/comments",
    "author": "joseDaKing",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2020-04-17T20:59:07Z",
        "body": "You can use `as const` if this is your intent"
      },
      {
        "user": "joseDaKing",
        "created_at": "2020-04-19T21:12:31Z",
        "body": "what do you mean exactly? "
      },
      {
        "user": "RyanLamansky",
        "created_at": "2020-04-23T20:42:30Z",
        "body": "He means this:\r\n```TS\r\nconst b = Object.freeze([\"Abra\", \"Isma\", 0] as const);\r\n```"
      },
      {
        "user": "joseDaKing",
        "created_at": "2020-04-23T22:02:22Z",
        "body": "Aha did not that existed thanks"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how to make TypeScript infer literal tuple types rather than generic array types when using Object.freeze",
      "Identification of a TypeScript feature that preserves literal types in frozen arrays",
      "Clarification on combining Object.freeze with type assertion mechanisms"
    ]
  },
  {
    "number": 33203,
    "title": "Compiler API: getConstantValue() can't get a real value from enum's PropertyAccessExpression",
    "created_at": "2019-09-03T03:48:37Z",
    "closed_at": "2019-09-04T01:43:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/33203",
    "body": "<!-- Please try to reproduce the issue with `typescript@next`. It may have already been fixed. -->\r\n**TypeScript Version:**  3.5.3\r\n\r\n<!-- Search terms you tried before logging this (so others can find this issue more easily) -->\r\n**Search Terms:**\r\n\r\nCompiler API, getConstantValue, PropertyAccessExpression\r\n\r\n**Code**\r\n\r\n```ts\r\nimport * as ts from \"typescript\";\r\n\r\n\r\nlet program = ts.createProgram(['/src/sandbox/test.ts'], {});\r\nlet checker = program.getTypeChecker();\r\n\r\nlet source = program.getSourceFile('/src/sandbox/test.ts')!;\r\n\r\nsource.forEachChild(node => {\r\n  switch (node.kind) {\r\n    case ts.SyntaxKind.EnumDeclaration:\r\n      (() => {\r\n        const real = node as ts.EnumDeclaration;\r\n        real.members.forEach(item => {\r\n          console.log(item.name.getText(), checker.getConstantValue(item))\r\n        })\r\n      })()\r\n      break;\r\n    case ts.SyntaxKind.ExpressionStatement:\r\n      (() => {\r\n        const a = node as ts.ExpressionStatement;\r\n        const real = a.expression as ts.PropertyAccessExpression;\r\n        console.log(checker.getConstantValue(real)) // ------------------------> Undefined\r\n      })()\r\n      break\r\n  }\r\n});\r\n```\r\n\r\nThe '/src/sandbox/test.ts':\r\n```ts\r\nenum Test {\r\n    A = 100,\r\n    B,\r\n}\r\n\r\nTest.A;\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nTell me `100`\r\n\r\n**Actual behavior:**\r\n\r\nReturns `undefined`\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/33203/comments",
    "author": "mohanson",
    "comments": [
      {
        "user": "sandersn",
        "created_at": "2019-09-03T23:08:50Z",
        "body": "getConstantValue doesn't follow references back to their declaration. You have to do that yourself by looking at the symbol's declaration. Something like\r\n\r\n`checker.getConstantValue(checker.getSymbolAtLocation(real))`"
      },
      {
        "user": "mohanson",
        "created_at": "2019-09-04T01:43:49Z",
        "body": "Got it!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how to resolve enum member references through PropertyAccessExpression nodes",
      "Clarification that getConstantValue requires working with declaration nodes rather than reference sites",
      "Demonstration of symbol resolution workflow for enum member accesses"
    ]
  },
  {
    "number": 32043,
    "title": "Support 'as const' together with type restriction",
    "created_at": "2019-06-22T19:32:41Z",
    "closed_at": "2019-07-13T00:00:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/32043",
    "body": "Would be nice to be able to apply type checking to 'as const' types, currently I have to use the silly trick of using type checks when writing them, then switch to 'as const' afterwards.\r\n\r\n```\r\ntype MyType = {name: string};\r\n\r\nconst x:MyType = {\r\n    name: 'test' // Autocompleted, typesafe. But Type is {name: string}, not \r\n                 // what I want, I want {readonly name: 'test'}\r\n} as const;\r\n\r\nconst x = { name: 'test' } as const; // Gives correct type, but no type check for MyType...\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/32043/comments",
    "author": "KnutRyagerInmeta",
    "comments": [
      {
        "user": "MartinJohns",
        "created_at": "2019-06-22T22:24:35Z",
        "body": "Your type `MyType` clearly says that `name` is a mutable property. If you want it read-only, then you can just use `Readonly<MyType>`."
      },
      {
        "user": "jcalz",
        "created_at": "2019-06-23T00:59:09Z",
        "body": "Helper function to the rescue!\r\n\r\n```ts\r\ntype MyType = { name: string };\r\nconst asMyType = <T extends MyType>(x: T) => x; // helper function\r\nconst x = asMyType({ name: \"test\" } as const); // \ud83d\ude03\r\n```"
      },
      {
        "user": "KnutRyagerInmeta",
        "created_at": "2019-06-23T15:56:16Z",
        "body": "@jcalz this does the trick.\r\n\r\n@MartinJohns readonly was not originally of my concern, but emerged with 'as const'. Seems with jcalz's solution readony does not emerge. Now a single string literal type should be readonly by implication though... well you are allowed to overwrite with the same string I guess."
      },
      {
        "user": "MartinJohns",
        "created_at": "2019-06-23T16:15:47Z",
        "body": "@KnutRyagerInmeta You mean a string literal type, e.g. `'fixed'` instead of `string`. In that case the same logic applies: Your type `MyType` explicitly says the property `name` can be of **any** string.\r\n\r\nWith jcalz solution you will have the same issue when you use the wrong type:\r\n\r\n    const x: MyType = asMyType({ name: \"test\" } as const); // x.name is of type string again\r\n\r\nBut I likely misunderstand you, and you want something like \"make sure this object matches SomeType, then make it a const context\", in which case jcalz solution is probably the best."
      }
    ],
    "satisfaction_conditions": [
      "Solution must enable type checking against a specified interface while preserving literal type inference from 'as const'",
      "Must avoid manual type assertion switching between declaration and assignment",
      "Should maintain IDE autocompletion and type safety during object creation",
      "Must validate object structure against a type definition before applying literal type preservation"
    ]
  },
  {
    "number": 31176,
    "title": "Type checking of extended mapped type",
    "created_at": "2019-04-30T18:49:06Z",
    "closed_at": "2019-05-01T12:14:48Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/31176",
    "body": "**Typescript version:** 3.4.5.\r\n\r\nI'm writing the boilerplate code for type-safe Express routes in my projects, possibly even create a npm library, if it works as expected.\r\nThe idea is to make sure all the API responses have the shape\r\n```ts\r\n{result: T, error?: any}\r\n```\r\nwhere T is the Response type of the route, or\r\n```ts\r\n{error: any}\r\n```\r\nif there is an error and declare the type of each routes' request and response types in a declarative way.\r\n\r\nThe API is routed under the `/api` route. I'm accomplishing this with `app.use('/api', indexRouter.router)`, where `indexRouter` is an instance of `WrappedRouter` (which is defined at the end of this bug report) which is imported from the file `routes/index.ts`.\r\n\r\n**Contents of `routes/index.ts`**:\r\n```ts\r\nimport authRouter from './auth';\r\nimport makeRouter from \"../utils/RestRoute\";\r\n\r\nconst router = makeRouter();\r\n\r\nrouter.makeSubRoute('/auth',authRouter);\r\n\r\nexport default router;\r\n```\r\n\r\n**Contents of `routes/auth/types.ts`**:\r\n```ts\r\nimport {ITypes} from '../../utils/RestRoute';\r\n\r\nexport interface Types extends ITypes {\r\n    '/sayHello': {\r\n        request: void,\r\n        response: string\r\n    }\r\n}\r\n```\r\n\r\nThe idea is that I can now write this:\r\n**Contents of `routes/auth/index.ts`**:\r\n```ts\r\nimport makeRouter from '../../utils/RestRoute';\r\nimport {Types} from \"./types\";\r\n\r\nconst router = makeRouter<Types>();\r\n\r\nrouter.route('/sayHello',args => ({\r\n    result: 'Hello World!'\r\n}));\r\n\r\nexport default router.router;\r\n```\r\n____________________________________________________________\r\n\r\n**Contents of `RestRoute.ts`** (which contains the wrapper around Express.JS's Route and most of the boilerplate logic):\r\n\r\n```ts\r\nimport express from 'express';\r\n\r\nexport interface ITypes {\r\n    [key: string]: {\r\n        request: any,\r\n        response: any\r\n    }\r\n}\r\n\r\ninterface HandlerFuncionArgs<Req> {\r\n    cookies: express.Request[\"cookies\"],\r\n    hostname: express.Request[\"hostname\"],\r\n    ip: express.Request[\"ip\"],\r\n    clearCookie: express.Response[\"clearCookie\"],\r\n    cookie: express.Response[\"cookie\"],\r\n    secure: express.Request[\"secure\"],\r\n    body: Req,\r\n    params: express.Request[\"params\"]\r\n}\r\n\r\nexport type APIResultType<T> = {result: T, error?: any} | {error: any};\r\n\r\nexport type HandlerFunction<Req,Res> = (args: HandlerFuncionArgs<Req>)=>APIResultType<Res> & {status?: number};\r\n\r\nclass WrappedRouter<Types extends ITypes> {\r\n    public constructor(public readonly router: express.Router) {}\r\n\r\n    private static proxyFunction<Req,Res>(handlerFunction: HandlerFunction<Req,Res>): express.RequestHandler {\r\n        return (req, res, next) => {\r\n            res.type('application/json');\r\n            try {\r\n                const ret = handlerFunction({\r\n                    cookies: req.cookies,\r\n                    hostname: req.hostname,\r\n                    ip: req.ip,\r\n                    clearCookie: res.clearCookie,\r\n                    cookie: res.cookie,\r\n                    secure: req.secure,\r\n                    body: req.body,\r\n                    params: req.params\r\n                });\r\n                res.status(ret.status || 200);\r\n                delete ret.status;\r\n                res.json(ret as APIResultType<Res>);\r\n            } catch(e) {\r\n                res.status(500);\r\n                res.json({error: e} as APIResultType<Res>);\r\n            } finally {\r\n                res.end();\r\n            }\r\n        };\r\n    }\r\n\r\n    public route<Path extends keyof Types>(path: Path, handlerFunction: HandlerFunction<Types[Path][\"request\"],Types[Path][\"response\"]>):void {\r\n        this.router.post(path as string,WrappedRouter.proxyFunction(handlerFunction));\r\n    }\r\n\r\n    public makeSubRoute(path: string, subRouter: express.Router): void;\r\n\r\n    public makeSubRoute<SubRouterTypes extends ITypes>(path: string, subRouter: WrappedRouter<SubRouterTypes>): void;\r\n\r\n    public makeSubRoute<SubRouterTypes extends ITypes>(path: string, subRouter: express.Router|WrappedRouter<SubRouterTypes>) {\r\n        if(subRouter instanceof WrappedRouter) {\r\n            this.router.use(path,subRouter.router);\r\n        } else {\r\n            this.router.use(path,subRouter);\r\n        }\r\n    }\r\n}\r\n\r\nexport function wrapRouter<Types extends ITypes>(router: express.Router) {\r\n    return new WrappedRouter<Types>(router);\r\n}\r\n\r\nexport function makeRouter<Types extends ITypes>() {\r\n    return new WrappedRouter<Types>(express.Router({caseSensitive: true, mergeParams: true}));\r\n}\r\n\r\nexport default makeRouter;\r\n```\r\n(`ITypes` is supposed to be the generic shape of every route's type: each key, representing a route, should contain an object with \"response\" and \"request\" as its only keys. `ITypes` isn't supposed to be instantiated, only extended by other types)\r\n\r\n**Expected behavior:**\r\nCorrectly checks the types of the request and response of each route **AND** doesn't allow routes which aren't defined in that sub-route's `Type`.\r\n\r\n**Actual behaviour:**\r\nIt works well in checking the types of the route: ie. if I try to return `result: 1` in the `/api/auth/sayHello` route, the compiler fails and says that number isn't compatible with string.\r\nThe problem is when I mistype `/sayHello` for, say, `/sayHelo`. There is no error reported from the compiler _even though_ `WrappedRouter.route`'s first argument is of type `Path extends keyof Types`. It just simply accepts any type in the request and any type in the response... It should be an error because `/sayHelo` __**is not**__ in `keyof Type`, which is equal to `/sayHelo`.\r\n\r\nI'm guessing the problem is in extending the interface because it is first declared as having string keys but doesn't specify the keys' type when it is extended. I think `keyof Types` computes to `\"/sayHello\" | string`.\r\n\r\nI've tried to change the generic type of the `route` function to `<Path extends Exclude<keyof Types, string>>` but it doesn't work because it also deletes `\"/sayHello\"` from the union type. Then the `router.route('/sayHello' (...)` line in the `auth/index.ts` file reports the error `TS2345: Argument of type '\"/sayHello\"' is not assignable to parameter of type 'number'`.\r\n\r\nIs there any workaround or a hacky way of accomplishing this while this isn't fix this in a future version of TS?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/31176/comments",
    "author": "TheDSCPL",
    "comments": [
      {
        "user": "dragomirtitian",
        "created_at": "2019-04-30T21:29:50Z",
        "body": "That is one long question, might I suggest in the future: \r\n\r\n1. Isolating a smaller code snippet illustrating your issue.\r\n2. Trying stackoverflow first. This forum is generally reserved for bugs, or questions that SO didn't or can't answer (you will probably get answers there just as fast here and by the same people)\r\n\r\nThat being said, your root cause is that you force `Types` to have an index signature. If `Types` has an index signature, `keyof Types` will be `string` allowing any string in path.\r\n\r\nYou can change the definitions a bit, you actually want to constrain `ITypes` to have only properties of type `{ request: any, response: any }` regardless of if they have an index signature.\r\n\r\nA solution that seems to work (although I have not tested it a lot) would be: \r\n\r\n```ts\r\n//RestRoute.ts\r\nimport express from 'express';\r\n\r\nexport type ITypes<K extends PropertyKey> = Record<K, { request: any, response: any }>\r\n\r\ninterface HandlerFuncionArgs<Req> {\r\n    cookies: express.Request[\"cookies\"],\r\n    hostname: express.Request[\"hostname\"],\r\n    ip: express.Request[\"ip\"],\r\n    clearCookie: express.Response[\"clearCookie\"],\r\n    cookie: express.Response[\"cookie\"],\r\n    secure: express.Request[\"secure\"],\r\n    body: Req,\r\n    params: express.Request[\"params\"]\r\n}\r\n\r\nexport type APIResultType<T> = {result: T, error?: any} | {error: any};\r\n\r\nexport type HandlerFunction<Req,Res> = (args: HandlerFuncionArgs<Req>)=>APIResultType<Res> & {status?: number};\r\n\r\nclass WrappedRouter<Types extends ITypes<keyof Types>> {\r\n    public constructor(public readonly router: express.Router) {}\r\n\r\n    private static proxyFunction<Req,Res>(handlerFunction: HandlerFunction<Req,Res>): express.RequestHandler {\r\n        return (req, res, next) => {\r\n            res.type('application/json');\r\n            try {\r\n                const ret = handlerFunction({\r\n                    cookies: req.cookies,\r\n                    hostname: req.hostname,\r\n                    ip: req.ip,\r\n                    clearCookie: res.clearCookie,\r\n                    cookie: res.cookie,\r\n                    secure: req.secure,\r\n                    body: req.body,\r\n                    params: req.params\r\n                });\r\n                res.status(ret.status || 200);\r\n                delete ret.status;\r\n                res.json(ret as APIResultType<Res>);\r\n            } catch(e) {\r\n                res.status(500);\r\n                res.json({error: e} as APIResultType<Res>);\r\n            } finally {\r\n                res.end();\r\n            }\r\n        };\r\n    }\r\n\r\n    public route<Path extends keyof Types>(path: Path, handlerFunction: HandlerFunction<Types[Path][\"request\"],Types[Path][\"response\"]>):void {\r\n        this.router.post(path as string,WrappedRouter.proxyFunction(handlerFunction));\r\n    }\r\n\r\n    public makeSubRoute(path: string, subRouter: express.Router): void;\r\n\r\n    public makeSubRoute<SubRouterTypes extends ITypes<keyof SubRouterTypes>>(path: string, subRouter: WrappedRouter<SubRouterTypes>): void;\r\n\r\n    public makeSubRoute<SubRouterTypes extends ITypes<keyof SubRouterTypes>>(path: string, subRouter: express.Router|WrappedRouter<SubRouterTypes>) {\r\n        if(subRouter instanceof WrappedRouter) {\r\n            this.router.use(path,subRouter.router);\r\n        } else {\r\n            this.router.use(path,subRouter);\r\n        }\r\n    }\r\n}\r\n\r\nexport function wrapRouter<Types extends ITypes<keyof Types>>(router: express.Router) {\r\n    return new WrappedRouter<Types>(router);\r\n}\r\n\r\nexport function makeRouter<Types extends ITypes<keyof Types>>() {\r\n    return new WrappedRouter<Types>(express.Router({caseSensitive: true, mergeParams: true}));\r\n}\r\n\r\nexport default makeRouter;\r\n\r\n// types.ts\r\n\r\nimport {ITypes} from '../../utils/RestRoute';\r\n\r\nexport interface Types extends ITypes<keyof Types> { // ensures all properties have the correct shape\r\n    '/sayHello': {\r\n        request: void,\r\n        response: string\r\n    }\r\n}\r\n\r\n//auth/index.ts\r\nimport makeRouter from '../../utils/RestRoute';\r\n\r\nimport {Types} from \"./types\";\r\n\r\nconst router = makeRouter<Types>();\r\n\r\n//ok\r\nrouter.route('/sayHello',args => ({\r\n    result: 'Hello World!'\r\n}));\r\n\r\n//err\r\nrouter.route('/sayHelloo',args => ({\r\n    result: 'Hello World!'\r\n}));\r\n\r\nexport default router.router;"
      },
      {
        "user": "TheDSCPL",
        "created_at": "2019-05-01T12:14:48Z",
        "body": "Uhm, ok! I didn't know you could do this kind of recursive operations in the types definition!\r\nI thought this was a bug because I dind't know `<Types extends ITypes<keyof Types>>` was valid syntax.\r\nThank you very much!"
      }
    ],
    "satisfaction_conditions": [
      "Ensure type system enforces exact route path matches in mapped types",
      "Maintain strict keyof Types constraints without string index signature leakage",
      "Preserve type checking for request/response shapes while allowing route composition",
      "Enable declarative route type definitions without index signatures"
    ]
  },
  {
    "number": 30707,
    "title": "weird type relationship",
    "created_at": "2019-04-02T16:07:01Z",
    "closed_at": "2019-04-02T17:13:42Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/30707",
    "body": "problem:\r\n\r\n```ts\r\ndeclare function sureNever<_T extends never>(): void;\r\ntype NeverDifferent<L, R> = L extends R ? R extends L ? never : 'right does not extend left' : 'left does not extend right';\r\nsureNever<NeverDifferent<'a', 'a'>>(); // works\r\nsureNever<NeverDifferent<{}, {}>>(); // works\r\nsureNever<NeverDifferent<'a' | 'b', 'a' | 'b'>>(); // breaks: Type '\"right does not extend left\"' does not satisfy the constraint 'never'\r\n```\r\n\r\nnasty workaround:\r\n\r\n```ts\r\ndeclare function sureIdentical<L, R>(\r\n    asRight: (left: L) => R,\r\n    asLeft: (right: R) => L,\r\n): void;\r\nsureIdentical<'a' | 'b', 'a'>(x => x, x => x); // breaks as expected\r\nsureIdentical<'a', 'a' | 'b'>(x => x, x => x); // breaks as expected\r\nsureIdentical<'a' | 'b', 'a' | 'b'>(x => x, x => x); // works as expected\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/30707/comments",
    "author": "zpdDG4gta8XKpMCd",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-04-02T17:07:49Z",
        "body": "Conditional type distributivity (yr fav) is what's causing this. This produces the behavior desired by the example:\r\n```ts\r\ntype NeverDifferent<L, R> = [L] extends [R] ? R extends L ? never : 'right does not extend left' : 'left does not extend right';\r\n```"
      },
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2019-04-02T17:13:40Z",
        "body": "that pesky distributivity again, ok, noted"
      }
    ],
    "satisfaction_conditions": [
      "Explains why union types trigger different behavior in the type check",
      "Provides a way to check mutual type equivalence without distributivity side effects",
      "Addresses conditional type distribution mechanics"
    ]
  },
  {
    "number": 30641,
    "title": "defaultProps in HOC when use React.ComponentType<M>",
    "created_at": "2019-03-29T07:59:37Z",
    "closed_at": "2019-07-13T00:00:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/30641",
    "body": "I have a problem of HOC .  when pass a component with a defaultProps to HOC, the props of component exposed to user become optional as the defaultProps is Partial. see example below\r\n\r\nthe property df1 and df2 is not optional after wrapper by HOC!\r\n\r\nbecause \r\n\r\n```js\r\nconst TabRCT = Tab as React.ComponentType<Props & WithProps>\r\ntype DpProps = typeof TabRCT.defaultProps\r\ntype DpProps1 = typeof Tab.defaultProps\r\n```\r\nDpProps is Partial<Props & WithProps> | undefined\r\nDpProps1 is DefaultTabProps\r\n\r\n\r\nthe complete example\r\n \r\n```js\r\nimport * as React from 'react'\r\n\r\ninterface DefaultTabProps {\r\n  df1: number,\r\n  df2: string\r\n}\r\n\r\ninterface Props extends DefaultTabProps {\r\n  pp1?: number\r\n  pp2: number\r\n}\r\n\r\ninterface WithProps {\r\n  wp: string\r\n}\r\n\r\ninterface InjectProps {\r\n  ij: number\r\n}\r\n\r\nclass Tab extends React.Component<Props & WithProps, any> {\r\n  static defaultProps: DefaultTabProps = {\r\n    df1: 11,\r\n    df2: '12'\r\n  }\r\n  render() {\r\n    return <div />\r\n  }\r\n}\r\n\r\n\r\ntype Merge<M, T> = Pick<M, Exclude<keyof M, keyof T>> & T\r\n\r\n\r\n// \u5e0c\u671bM\u662f\u5904\u7406\u540e\u7684 \uff0c\u5373\u6700\u521dM\u662fProps\uff0c\u6700\u540e\u7ec4\u4ef6\u66b4\u9732\u51fa\u6765\u7684props\u662f{...Props, ...DefaultProps }\uff0c\u800cWithProps\u540e\u66b4\u9732\u51fa\u6765\u7684\u8fd8\u662fProps\uff0c\u5e0c\u671b\u52a0\u4e0aWithProps\r\nfunction WithTest<M>(Cp: React.ComponentType<M & WithProps>) {\r\n  return (props: Merge<M, typeof Cp.defaultProps> & InjectProps) => {\r\n    let params = omit(props, ['ij']) as M\r\n    let wp = (props.ij * 100) + '%'\r\n    return <Cp {...params} wp={wp}/>\r\n  }\r\n}\r\n\r\nconst TabWith = WithTest(Tab)\r\n\r\n\r\nfunction omit<T, K extends keyof T>(obj: T, keys: K[]) {\r\n  const newObj: { [key in keyof OmitType<T, K>]?: T[key] } = {}\r\n\r\n  return (Object.keys(obj) as (keyof OmitType<T, K>)[])\r\n    .filter((curr: any) => !keys.includes(curr))\r\n    .reduce((acc: { [key in keyof OmitType<T, K>]?: T[key] }, curr: (keyof OmitType<T, K>)) => (\r\n      acc[curr] = obj[curr],\r\n      acc\r\n    ), newObj)\r\n}\r\n \r\n\r\nconst obj = {\r\n  A: <TabWith ij={12} pp2={1} /> \r\n}\r\n\r\n```\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/30641/comments",
    "author": "luckhpy",
    "comments": [
      {
        "user": "dragomirtitian",
        "created_at": "2019-03-29T08:23:44Z",
        "body": "Might I suggest asking this sort of question on SO first. There is a dedicated comunity there just wating to help. GitHub is for bugs or questions that SO can't answer or need an official position (IMO)\r\n\r\nThere is no magic reason for the default props to be preserved in the wrapped component. The returned function does not have a defaultProps. If you want to preserve default props you need to add them to the returned function type. This will work as you expect it: \r\n\r\n```ts\r\nfunction WithTest<M, DF>(Cp: React.ComponentType<M & WithProps> & { defaultProps : DF}) : { // Explicit return annotation not required, just for clarity \r\n  (props: Merge<M, typeof Cp.defaultProps> & InjectProps) : JSX.Element\r\n  defaultProps : DF\r\n} {\r\n  function wrapped (props: Merge<M, typeof Cp.defaultProps> & InjectProps) {\r\n    let params = omit(props, ['ij']) as M\r\n    let wp = (props.ij * 100) + '%'\r\n    return <Cp {...params as any} wp={wp}/> // The conditional types that handle the defaults make this assertion necessary unfortunately \r\n  }\r\n  wrapped.defaultProps = Cp.defaultProps\r\n  return wrapped\r\n}\r\n```"
      },
      {
        "user": "luckhpy",
        "created_at": "2019-03-31T02:24:04Z",
        "body": "thank you very much! you've saved me a lot of time! and thank you for your kind remind and i will asking this sort of question in SO in the future"
      }
    ],
    "satisfaction_conditions": [
      "Preserve defaultProps behavior when wrapping components with HOC",
      "Handle TypeScript type merging for HOC-wrapped components",
      "Maintain required prop enforcement after HOC wrapping",
      "Support React's defaultProps typing in HOC patterns"
    ]
  },
  {
    "number": 30202,
    "title": "Get type of variable over the course of lifetime from TypeChecker",
    "created_at": "2019-03-03T15:17:29Z",
    "closed_at": "2019-07-13T00:00:56Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/30202",
    "body": "Calling `getTypeAtLocation().getFlags()` on  the identifier `b` at its declaration in the following example returns `ts.TypeFlags.Number` however the type (to me) should be `ts.TypeFlags.Number` or `ts.TypeFlags.Any` since it is later reassigned to a variable of unknown type.\r\n\r\n```\r\nfunction a(c) { // c is implicit any\r\n  let b = 1; // getTypeAtLocation(b).getFlags() is ts.TypeFlags.Number\r\n  b = c; // getTypeAtLocation(b = c).getFlags() is no longer ts.TypeFlags.Number\r\n}\r\n```\r\n\r\nIs it possible to get this information at the declaration of `b` or do I need to accumulate this type information myself?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/30202/comments",
    "author": "eatonphil",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-03-04T03:04:08Z",
        "body": "I'm not totally clear on the intent but if you're asking about the type of `b = c`, that's because the `=` operator always returns the right-hand side."
      },
      {
        "user": "eatonphil",
        "created_at": "2019-03-04T13:25:22Z",
        "body": "I'm going to change the example slightly but the intent is still the same. The inferred type of `b` in this example should be `number | string` (or `any`, I guess):\r\n\r\n```javascript\r\nfunction a(c: string) {\r\n  let b = 1;\r\n  b = c;\r\n}\r\n```\r\n\r\nBecause the following would be right:\r\n\r\n```javascript\r\nfunction a(c: string) {\r\n  let b: number | string = 1;\r\n  b = c;\r\n}\r\n```\r\n\r\nAnd the following would be wrong:\r\n\r\n```javascript\r\nfunction a(c: string) {\r\n  let b: number = 1;\r\n  b = c;\r\n}\r\n```\r\n\r\nBut whether I explicitly annotate the type of `b` as `b: string | number` at the declaration or not, I cannot seem to get that information from the TypeChecker via `getTypeAtLocation()`. Around the declaration of `b`, all the nodes just seem to be ts.TypeFlags.Number.\r\n\r\nDoes that make sense?"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-03-04T17:35:11Z",
        "body": "There isn't an API that's going to give you answer you want there, because TypeScript's inference algorithm doesn't work like that. You'd have to accumulate the RHSes of all assignments yourself to get the `number | string` result."
      },
      {
        "user": "eatonphil",
        "created_at": "2019-03-04T17:42:28Z",
        "body": "Got it, thank you!"
      }
    ],
    "satisfaction_conditions": [
      "Clarification of TypeChecker API capabilities regarding variable type tracking across reassignments",
      "Explanation of TypeScript's type inference behavior for mutable variables",
      "Guidance on implementing type accumulation logic",
      "Differentiation between declaration-time type and usage-time type information"
    ]
  },
  {
    "number": 30127,
    "title": "Is it possible to define a universal default generic type parameter so that a bottom object like `new None()`, can type check any type of None, such as None<number>, None< ()=>any >?",
    "created_at": "2019-02-27T14:33:11Z",
    "closed_at": "2019-07-13T00:01:00Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/30127",
    "body": "**In short, TypeScripts uses type {} for default generic type parameter, when T is not provided for `new ClassA<T>(...)`** so Applicative data structure would require developers more concious with types, which is a barrier for more advanced data structure.\r\n\r\nIs it possible to define an universal default generic type so that a bottom datastructure like `new None()`, can type check any type of None, such as `None<number>`, `None< ()=>any >`?\r\n\r\n**Details:**\r\n\r\nI was trying to implement an Applicative data structure in TS as the Applicative of Haskell:\r\n\r\n```\r\n(Some f) <*> (Some x) = Some (f x)\r\n(None) <*>(Some x) = None\r\n```\r\n\r\nFirst try is to implement functor/applicative  on Option and subclass Some and None.\r\nBelow is the type and class definition:\r\n\r\n\r\n```\r\nexport const id = (a: any) => a\r\n\r\nexport interface Functor<T> {\r\n  fmap(f: (a: T) => any): Functor<any>\r\n}\r\n\r\nexport interface Applicative<T> extends Functor<T> {\r\n  ffmap(af: Applicative<(a: T) => any>): Applicative<any>\r\n}\r\n\r\nexport abstract class Option<T> implements Functor<T> {\r\n  abstract _a: T | undefined\r\n\r\n  abstract fmap(f: (a: T) => any): Functor<any>\r\n\r\n  *[Symbol.iterator]() {\r\n    yield this._a\r\n  }\r\n}\r\n\r\nexport class Some<T> extends Option<T> {\r\n  _a: T\r\n\r\n  constructor(a: T) {\r\n    super()\r\n    this._a = a\r\n  }\r\n\r\n  fmap(f: (a: T) => any): Option<any> {\r\n    return new Some(f(this._a))\r\n  }\r\n\r\n  ffmap(a: Option<(a: T) => any>): Option<any> {\r\n    if (a instanceof None) return new None()\r\n\r\n    const f = a._a\r\n\r\n    if (f === undefined || f === null) return new None()\r\n    else return new Some(f!(this._a))\r\n  }\r\n}\r\n\r\nexport class None<T> extends Option<T> {\r\n  _a: T | undefined\r\n  constructor() {\r\n    super()\r\n    this._a = undefined\r\n  }\r\n\r\n  fmap(f: (a: T) => any): Option<any> {\r\n    return new None()\r\n  }\r\n\r\n  ffmap(a: Option<(a: T) => any>): Option<any> {\r\n    return new None()\r\n  }\r\n}\r\n\r\n```\r\nI have written some test cases and most work. However when test the case :\r\n\r\n```\r\n  test(' Some.ffmap(None) === None', () => {\r\n    const a = new Some(33)\r\n\r\n    const af = new None()\r\n\r\n    expect(a.ffmap(af)).toEqual(new None())\r\n  })\r\n```\r\n\r\nFollowing error is reported:\r\n```\r\n    src/index.test.ts:116:20 - error TS2345: Argument of type 'None<{}>' is not assignable to parameter of type 'Option<(a: number) => any>'.\r\n      Types of property '_a' are incompatible.\r\n        Type '{} | undefined' is not assignable to type '((a: number) => any) | undefined'.\r\n          Type '{}' is not assignable to type '(a: number) => any'.\r\n            Type '{}' provides no match for the signature '(a: number): any'.\r\n\r\n    116     expect(a.ffmap(af)).toEqual(new None())\r\n```\r\n\r\nSpcifically, TS consider new None() has the type of new None<{}>(), which is no match with applicative parameter, new None< ()=>any>()\r\n\r\nWhen I change the test case to the following, it works:\r\n\r\n```\r\n  test(' Some.fmap(None) = None', () => {\r\n    const a = new None<number>()\r\n\r\n    const f = (a: number) => a + 2\r\n\r\n    expect(a.fmap(f)).toEqual(a)\r\n  })\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/30127/comments",
    "author": "reactma",
    "comments": [
      {
        "user": "jack-williams",
        "created_at": "2019-02-27T14:39:57Z",
        "body": "Did you try:\r\n```ts\r\nexport class None extends Option<never> {\r\n    \u2026\r\n}\r\n```"
      },
      {
        "user": "j-oliveras",
        "created_at": "2019-02-27T14:42:07Z",
        "body": "You can defined a default type parameter as:\r\n```ts\r\n// Change any with the type you want to be the default.\r\nexport interface Functor<T = any> {\r\n  fmap(f: (a: T) => any): Functor<any>\r\n}\r\n```"
      },
      {
        "user": "reactma",
        "created_at": "2019-02-27T14:47:33Z",
        "body": "@jack-williams It doesn't work for my case as I need a type parameter.\r\n@j-oliveras Your solution type checks. I didn't know generic type parameter could have default type as well. Thanks."
      }
    ],
    "satisfaction_conditions": [
      "Solution must allow None instances to be compatible with any generic type parameterization without explicit type specification",
      "Must preserve Applicative type structure requirements",
      "Should enable default generic type parameterization that works as universal bottom type"
    ]
  },
  {
    "number": 30116,
    "title": "The type definition read by ts does not match the types",
    "created_at": "2019-02-27T04:00:16Z",
    "closed_at": "2019-03-01T18:21:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/30116",
    "body": "My code\r\n\r\n```ts\r\nexport default function (name: string, defaultValue = {}, adapter = 'memory', extractSetStateFunc: Function) {\r\n  const Context = React.createContext(name);\r\n  const { Provider } = Context;\r\n\r\n  class ContextHoc extends React.Component {\r\n    constructor(props: any) {\r\n      super(props);\r\n\r\n      if (!adapters[adapter]) {\r\n        throw new Error(`KV Store:\\n Uncaught ReferenceError: ${adapter} Adapter is not defined.`);\r\n      }\r\n\r\n      this.state = {\r\n        ...defaultValue,\r\n        ...adapters[adapter].get(name),\r\n      };\r\n\r\n      extractSetStateFunc(name, (store: any, callback: Function) => {\r\n        this.setState(store, () => {\r\n          adapters[adapter].set(name, this.state);\r\n          if (typeof callback === 'function') {\r\n            callback();\r\n          }\r\n        });\r\n      });\r\n    }\r\n\r\n    render() {\r\n      return (\r\n        <Provider value={this.state}>\r\n          { this.props.children }\r\n        </Provider>\r\n      );\r\n    }\r\n  }\r\n\r\n  class Factory {\r\n    get ctx() {\r\n      return Context;\r\n    }\r\n\r\n    get component() {\r\n      return ContextHoc;\r\n    }\r\n  }\r\n\r\n  return new Factory();\r\n}\r\n```\r\n\r\nBut i get a error: Can't assign type \"ReadOnly<{}>\" to type \"string\" of .ts (2322) \r\nfor this line:\r\n```ts\r\n<Provider value={this.state}>\r\n```\r\n\r\nConfusingly, when I looked at @types/react, I found that the definition of ProviderProps is generic:\r\n\r\nProviderProps<T>{ value: T }\r\ninstead of ProviderProps<string>{ value: string }",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/30116/comments",
    "author": "NanWu5522",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-02-27T20:21:40Z",
        "body": "You created a context with default value `name` (a string), then tried to provide a different value via the `Provider` with something that wasn't a string."
      },
      {
        "user": "NanWu5522",
        "created_at": "2019-03-01T09:56:57Z",
        "body": "> You created a context with default value `name` (a string), then tried to provide a different value via the `Provider` with something that wasn't a string.\r\n\r\nThank you for your answer, I have solved this problem."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of type consistency between React context creation and Provider value",
      "Clarification of React's generic type requirements for Context"
    ]
  },
  {
    "number": 29411,
    "title": "Function return value types not inferred in some cases",
    "created_at": "2019-01-14T20:52:32Z",
    "closed_at": "2019-01-15T17:54:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/29411",
    "body": "**TypeScript Version:**  3.3.0-dev.20190112\r\n\r\n**Search Terms:** function return type\r\n\r\n**Code**\r\n See code below which has a function returning a Promise<HelloInterface | undefined>\r\nThe calling code only infers the type to be HelloInterface.\r\n\r\n```ts\r\nclass Example1 {\r\n  public testFunction1(): void {\r\n    this.getResponse().then((value: HelloInterface) => {  // Expected tsc to infer this to be value: HelloInterface | undefined \r\n\r\n      console.log(value.property1);  // Potential runtime error as value can be undefined.\r\n    });\r\n  }\r\n\r\n  private getResponse(): Promise<HelloInterface | undefined> {\r\n    return Promise.resolve({ \"property1\": \"value1\" });\r\n  }\r\n}\r\n\r\ninterface HelloInterface {\r\n  \"property1\": string;\r\n}\r\n\r\n```\r\n\r\n**Expected behavior:**\r\n1) value should have inferred type as HelloInterface | undefined. \r\nThis will force me to handle the case where it is undefined in the caller.\r\n\r\n**Actual behavior:**\r\nvalue has type HelloInterface\r\nThere will be a runtime error when we access say value.property1 when value is undefined.\r\n\r\n**Playground Link:** \r\nPaste above code in vscode editor. \r\nI would expect vscode editor to indicate an error for value possibly being undefined.\r\n\r\n** Other Observations **\r\n The same works if the function return type is say Promise<HelloInterface | string>\r\n It appears this is seen when we have 'undefined' as one of the return value types.\r\n\r\n**Related Issues:**\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/29411/comments",
    "author": "psavur",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-01-14T21:53:26Z",
        "body": "Sounds like you have `strictNullChecks` off - enable this option to have TS check for `null` / `undefined` values"
      },
      {
        "user": "psavur",
        "created_at": "2019-01-14T23:26:34Z",
        "body": "@RyanCavanaugh  strictNullChecks are on.\r\nI updated the code example above to be more clear.\r\n\r\n"
      },
      {
        "user": "ajafff",
        "created_at": "2019-01-15T07:42:24Z",
        "body": "And do you have `strictFunctionTypes` enabled?"
      },
      {
        "user": "psavur",
        "created_at": "2019-01-15T17:54:18Z",
        "body": "@ajafff  Yes, it was `strictFunctionTypes`. Thanks, closing this."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why TypeScript isn't inferring the union type with 'undefined' in Promise resolution",
      "Identification of required compiler options for proper type checking in Promise chains",
      "Solution ensuring type safety when accessing resolved Promise values",
      "Clarification of TypeScript's type inference behavior with union types in asynchronous code"
    ]
  },
  {
    "number": 29295,
    "title": "Extract<keyof T, string> is not assignable to K extends Extract<keyof T, string> when used as K[]",
    "created_at": "2019-01-07T20:06:40Z",
    "closed_at": "2019-01-08T00:11:45Z",
    "labels": [
      "Question",
      "Domain: lib.d.ts"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/29295",
    "body": "**TypeScript Version:**  3.3.0-dev.20190105\r\n\r\n<!-- Search terms you tried before logging this (so others can find this issue more easily) -->\r\n**Search Terms:** keyof string array, K extends Extract<keyof T, string>\r\n\r\n**Code**\r\n\r\nUsing a generic `K extends Extract<keyof T, string>` generic definition does not work:\r\n\r\n```ts\r\nfunction copyAllExcept<T, K extends Extract<keyof T, string>>(target: any, source: T, skip: K[]) {\r\n    for (const key in source) {\r\n        if (source[key] != null && !skip.includes(key)) {\r\n            target[key] = source[key];\r\n        }\r\n    }\r\n}\r\n```\r\nError at the `!skip.includes(key)` part:\r\n\r\nArgument of type 'Extract<keyof T, string>' is not assignable to parameter of type 'K'.\r\n  Type 'string & keyof T' is not assignable to type 'K'.\r\n    Type 'string' is not assignable to type 'K'.\r\n      Type 'string' is not assignable to type 'K'.\r\n\r\n\r\nUsing `Array<Extract<keyof T, string>>` directly as the argument definition does work though:\r\n\r\n```ts\r\nfunction copyAllExcept<T>(target: any, source: T, skip: Array<Extract<keyof T, string>>) {\r\n    for (const key in source) {\r\n        if (source[key] != null && !skip.includes(key)) {\r\n            target[key] = source[key];\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/29295/comments",
    "author": "manigandham",
    "comments": [
      {
        "user": "weswigham",
        "created_at": "2019-01-07T23:56:18Z",
        "body": "You don't need the `K` type parameter - you're overconstraining your input a bit:\r\n```ts\r\nfunction copyAllExcept<T>(target: any, source: T, skip: (Extract<keyof T, string>)[]) {\r\n  for (const key in source) {\r\n      if (source[key] != null && !skip.includes(key)) {\r\n          target[key] = source[key];\r\n      }\r\n  }\r\n}\r\n```\r\nand that seems to work fine.\r\n\r\nNow, the type parameter doesn't work because you're saying that you're searching through a `K[]` for a `Extract<keyof T, string>` - while `K extends Extract<keyof T, string>`, `Extract<keyof T, string>` is a less specific type and so doesn't satisfy the argument type. `includes` is going to be OK with this at runtime anyway - the parameter type is actually meaningless, you define its type as `unknown` and be fine, which is what's unfortunate here - the `lib` definition of `Array.prototype.includes` constrains its argument to the type of only things in the array - meaning you can't pass less specific types that might still be the same as things in the array."
      },
      {
        "user": "manigandham",
        "created_at": "2019-01-08T00:11:45Z",
        "body": "Ah ok, didn't realize that the `extends` keyword made it more specific. Seems like it would fit since they are both from a limited set of strings coming from `keyof` but the direct argument definition works.\r\n\r\nThanks for the info."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why K extends Extract<keyof T, string> creates type incompatibility with keyof T in array operations",
      "Validation that removing unnecessary generic parameters is type-safe",
      "Clarification of Array.prototype.includes type limitations in TypeScript"
    ]
  },
  {
    "number": 28593,
    "title": "Classes cannot satisfy Constructor<Itself> bound",
    "created_at": "2018-11-18T21:28:08Z",
    "closed_at": "2018-11-19T18:41:55Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/28593",
    "body": "<!-- Please try to reproduce the issue with `typescript@next`. It may have already been fixed. -->\r\n**TypeScript Version:**  3.2.0-dev.201xxxxx\r\n\r\n<!-- Search terms you tried before logging this (so others can find this issue more easily) -->\r\n**Search Terms:** generics mixin classes interfaces constructor\r\n\r\n**Code**\r\n\r\n```ts\r\ntype Constructor<T> = new(...args: any[]) => T;\r\n\r\ninterface XInterface {}\r\nfunction make<T extends Constructor<XInterface>>(Base: T) {\r\n    return class extends Base implements XInterface {}\r\n}\r\n\r\n// This is ok.\r\nclass X extends make(Function) { }\r\n\r\n// But this fails.\r\nclass X2 extends make(Function) implements Constructor<XInterface> { }\r\n```\r\n\r\n**Expected behavior:** \r\nCode should compile\r\n\r\n**Actual behavior:**\r\nCompiler error: X2 provides no match for signature `new(...args: any[]) => XInterface`\r\n\r\n\r\n--- \r\n\r\n**Edit 1:**\r\nLooks like even something more basic like \r\n\r\n```ts\r\nclass Y implements XInterface, Constructor<XInterface> {}\r\n```\r\n\r\nfails to compile. This makes it difficult to chain together a set of mixin extending through another mixin function. \r\n\r\n**Edit 2**\r\n\r\nLooks like even the simplest case of\r\n\r\n```ts\r\nclass Y implements Constructor<Y>\r\n```\r\n\r\nfails.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/28593/comments",
    "author": "prasannavl",
    "comments": [
      {
        "user": "weswigham",
        "created_at": "2018-11-19T18:29:30Z",
        "body": "@prasannavl the `implements` clause constrains the instance shape of a class - the constructor signature of a class is associate with its static side (it returns the instance), therefore isn't constrainable via `implements`.\r\n\r\n```ts\r\nclass X2 extends make(Function) implements Constructor<XInterface> { }\r\n```\r\nis saying the class X2 extends a `Constructor<XInterface>` and its instance is a `Constructor<XInterface>` - meaning that when you say `new X2()`, the result is something you can use `new` on and get an `XInterface`, which is, ofc, not the case here."
      },
      {
        "user": "prasannavl",
        "created_at": "2018-11-19T18:41:55Z",
        "body": "Thank you @weswigham  -- That makes a lot of sense. I feel rather silly now after reading the reply. Thanks again for taking the time to explain this! :) "
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why classes cannot implement constructor interfaces via `implements` clause",
      "Clarification of the difference between instance interfaces and constructor interfaces",
      "Explanation of TypeScript's static vs instance type checking mechanisms"
    ]
  },
  {
    "number": 28191,
    "title": "Spread operator with one union-typed key gives type error?",
    "created_at": "2018-10-28T18:43:19Z",
    "closed_at": "2018-10-29T19:27:03Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/28191",
    "body": "I'm not sure if the following code should be filed as a bug, or it's just me not completely understanding the Typescript type-system.\r\n\r\nIn the following code (testing the playground V3.1), the function `fails` gives a type error, complaining that `Type 'Tag.BAR' is not assignable to type 'Tag.FOO'`.\r\n\r\nHowever, this function just returns the `x` object again, it's just that the `id` key is copied explicitly.\r\n\r\nCan someone explain why this doesn't work, and/or if this is a bug or by design?\r\n\r\n```ts\r\n// Dummy _tag_ key to avoid passing identifiers as plain numbers\r\ntype Identifier<TAG> = number & { readonly _tag_: TAG };\r\n\r\ninterface Entity<TAG> {\r\n  readonly tag: TAG;\r\n  readonly id: Identifier<TAG>;\r\n}\r\n\r\nenum Tag {\r\n  FOO = 0,\r\n  BAR = 1\r\n}\r\n\r\ninterface Foo extends Entity<Tag.FOO> {\r\n    foo: string;\r\n}\r\n\r\ninterface Bar extends Entity<Tag.BAR> {\r\n    bar: boolean;\r\n}\r\n\r\nfunction works(x: Foo | Bar): Foo | Bar {\r\n    return { ...x };\r\n}\r\n\r\nfunction fails(x: Foo | Bar): Foo | Bar {\r\n    return { ...x, id: x.id };\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/28191/comments",
    "author": "ziriax",
    "comments": [
      {
        "user": "weswigham",
        "created_at": "2018-10-29T18:22:04Z",
        "body": "When you say `x.id`, you get the type of the `id` field on both `Foo` and `Bar` - so `Identifier<Tag.FOO> | Identifier<Tag.BAR>`. The assignment doesn't retain a dependency relationship on `x`'s type, so what happens is in both of the union elements you spread over, you assign this combined type to both members, causing the problem."
      },
      {
        "user": "ziriax",
        "created_at": "2018-10-29T19:27:03Z",
        "body": "Thanks for clarifying. Coming from C# and C++, this is very peculiar :-) But it does make perfect sense if you look at it this way. \r\n\r\nThanks, closing this then, since it is by design.\r\n\r\n\r\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why explicitly copying a union-typed property breaks type relationships",
      "Clarification of TypeScript's type system behavior with spread operators and union types",
      "Demonstration of how type dependencies are lost during property access in unions"
    ]
  },
  {
    "number": 26934,
    "title": "Can i declare an Object properties must contain a or b ?",
    "created_at": "2018-09-06T06:36:10Z",
    "closed_at": "2018-09-06T22:53:40Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/26934",
    "body": "when i declare an Object like this:\r\n`interface obj {\r\n a?:string,\r\n b?string\r\n}\r\n`\r\nbut i want the attribute a not to exist, the attribute b must exist.\r\n`let obj:obj={}`  It is allowed ,i want it is not allowed\r\n`let obj:obj={a:'a'}` or `let obj:obj={b:'b'}`  if i want It is allowed. what should I do?\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/26934/comments",
    "author": "Zane0816",
    "comments": [
      {
        "user": "markusjohnsson",
        "created_at": "2018-09-06T12:48:26Z",
        "body": "Yes, but not using an interface. Instead, use `type`:\r\n\r\n```ts\r\ntype obj = { a: string } | { b: string };\r\n```\r\n\r\nif you want both properties:\r\n\r\n```ts\r\ntype obj = { a: string } | { b: string } | { a: string; b: string; };\r\n```"
      },
      {
        "user": "Zane0816",
        "created_at": "2018-09-06T13:42:44Z",
        "body": "thanks! I think it should be simple @markusjohnsson "
      }
    ],
    "satisfaction_conditions": [
      "Ensure TypeScript type definition requires at least one of properties 'a' or 'b' to be present",
      "Solution must work with TypeScript's type system without runtime checks",
      "Allow flexible combinations of properties while maintaining type safety"
    ]
  },
  {
    "number": 25768,
    "title": "Stringify like in \"c\" ",
    "created_at": "2018-07-18T14:12:27Z",
    "closed_at": "2018-07-19T05:56:50Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/25768",
    "body": "Hi ,\r\nHow do we convert object dot walking into string signature.\r\n``` typescript\r\nlet person = {\r\n\tcompany: {\r\n\t\tdepartment: {\r\n\t\t\tmsging: {\r\n\t\t\t\tphone: \"xyz\",\r\n\t\t\t\tfax: \"abc\"\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\tage: 34\r\n}\r\n\r\nfunction evaluateObject(val: string) {\r\n // some logic to evalute\r\n}\r\nevaluateObject(`${person.company.department.msging.phone}`);\r\n```\r\nthis will emit \r\n``` javascript\r\nevaluateObject('xyz');\r\n```\r\nbut I want to emit something like this.\r\n``` javascript\r\nevaluateObject('person.company.department.msging.phone');\r\n```\r\nIs there anyway to achieve this? Any Custom syntax like in \"C\" macros\r\n```typescript\r\nevaluateObject(`#{person.company.department.msging.phone}`);\r\n```\r\n\r\nIs it possible to achieve with any plugin kind of thing?.\r\n-thanks",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/25768/comments",
    "author": "yln99517",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2018-07-18T15:32:40Z",
        "body": "I think this is possible like so:\r\n```ts\r\nfunction path<K0 extends string>(obj: Record<K0, unknown>, k0: K0): string;\r\nfunction path<K0 extends string, K1 extends string>(obj: Record<K0, Record<K1, unknown>>, k0: K0, k1: K1): string;\r\nfunction path<K0 extends string, K1 extends string, K2 extends string>(obj: Record<K0, Record<K1, Record<K2, unknown>>>, k0: K0, k1: K1, k2: K2): string;\r\nfunction path(_: any, ...keys: string[]): string {\r\n    return keys.join(\".\");\r\n}\r\n\r\nconst obj = {\r\n    a: {\r\n        b: {\r\n            c: 0,\r\n        },\r\n    },\r\n};\r\n\r\nconsole.log(path(obj, \"a\")); // \"a\"\r\nconsole.log(path(obj, \"a\", \"b\")); // \"a.b\"\r\nconsole.log(path(obj, \"a\", \"b\", \"c\")); // \"a.b.c\"\r\npath(obj, \"a\", \"b\", \"x\"); // Compile error\r\n```\r\n\r\nSee also #1579.\n\n---\n\n@sandersn Pointed out that this can be done without overloads:\r\n\r\n```ts\r\nfunction dive<T>(obj: T): Diver<T> {\r\n    return new Diver(obj, \"\");\r\n}\r\nclass Diver<T> {\r\n    constructor(readonly obj: T, readonly str: string) {}\r\n\r\n    p<K extends string, TT extends Record<K, unknown>>(this: Diver<TT>, k: K): Diver<TT[K]> {\r\n        return new Diver(this.obj[k], this.str === \"\" ? k : this.str + \".\" + k);\r\n    }\r\n}\r\n\r\nconst obj = {\r\n    a: {\r\n        b: {\r\n            c: 0,\r\n        },\r\n    },\r\n};\r\n\r\nconsole.log(dive(obj).p(\"a\").p(\"b\").p(\"c\").str);\r\n```"
      }
    ],
    "satisfaction_conditions": [
      "Solution must convert object property access paths into string representations at compile time",
      "Type safety for valid property paths must be enforced",
      "Solution must work with nested object structures",
      "Must avoid runtime string manipulation/concatenation",
      "Solution should provide developer-friendly syntax"
    ]
  },
  {
    "number": 24216,
    "title": "Strict keys in HashMap",
    "created_at": "2018-05-17T19:45:02Z",
    "closed_at": "2018-06-02T19:56:07Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/24216",
    "body": "It's very powerful feature in typescript by strict value type in HashMap declaration. However looks like the same feature is missing for key values. I tried defined as type of string or enums but getting errors.\r\n\r\n\r\n```\r\ntype Keys1 = \"key1\" | \"key2\";\r\nenum Keys2 {key1, key2}\r\nconst map1: {[key: string]: Keys1 | null} = {\r\n    \"key1\": \"key1\",\r\n    \"key2\": \"key2\",\r\n    \"key3\": \"key3\"  //That is working!!!\r\n                    // Property '\"key3\"' is incompatible with index signature.\r\n                    // Type '\"key3\"' is not assignable to type '\"key1\" | \"key2\" | null'.\r\n};\r\n\r\nconst map2: {[key: string]: Keys1 | null} = {\r\n    \"key1\": \"key1\",\r\n    \"key2\": \"key2\",\r\n    \"key3\": null //I would like to strct and get error\r\n};\r\n\r\nconst map3: {[key: Keys1]: boolean} = {  //[ts] An index signature parameter type cannot be a union type. \r\n                                        //Consider using a mapped object type instead.\r\n                                        //(parameter) key: \"key1\" | \"key2\"\r\n    \"key3\": true\r\n};\r\n\r\nconst map4: {[key: Keys2]: boolean} = {  //[ts] An index signature parameter type must be 'string' or 'number'.\r\n                                        //(parameter) key: Keys2\r\n    \"key3\": true\r\n};\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/24216/comments",
    "author": "dgofman-equinix",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-05-17T19:51:22Z",
        "body": "Use mapped types:\r\n\r\n```ts\r\nconst map3: { [key in Keys1]: boolean } = {\r\n    \"key3\": true\r\n};\r\n\r\nconst map4: { [key in Keys2]?: boolean } = {  \r\n    [Keys2.key1]: true\r\n};\r\n```"
      },
      {
        "user": "dgofman-equinix",
        "created_at": "2018-05-17T23:56:06Z",
        "body": "Thank you! I didn't know we can use \"in\" as data type declaration."
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-06-02T19:56:07Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ],
    "satisfaction_conditions": [
      "Demonstrate how to enforce strict key constraints in TypeScript object types",
      "Show a TypeScript-compatible way to use union types/enums as object keys",
      "Provide a solution that works with both literal types and enums",
      "Explain TypeScript's index signature limitations and alternatives",
      "Use TypeScript features that maintain type safety for both keys and values"
    ]
  },
  {
    "number": 22857,
    "title": "Union type in JSX IntrinsicElements seems like a bug",
    "created_at": "2018-03-24T14:14:24Z",
    "closed_at": "2018-03-24T15:30:53Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/22857",
    "body": "```typescript\r\ndeclare namespace JSX {\r\n  interface IntrinsicElements {\r\n    foo: { bar: boolean } | { baz: boolean };\r\n  }\r\n}\r\n\r\nconst one = <foo bar baz />; // ok\r\n```\r\n\r\nHi. Is this a bug? I was expecting this to not compile but it does. \r\n\r\nIn the IntrinsicElements interface the type for `foo` is defined as having a boolean attribute of `foo` **or** `baz` but it compiles when both are set.\r\n\r\nI'm new to typescript so apologies if the issue is just my understanding of the type system.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/22857/comments",
    "author": "mikelnrd",
    "comments": [
      {
        "user": "MartinJohns",
        "created_at": "2018-03-24T14:57:39Z",
        "body": "Union types are **or**, but not **xor**. **or** means **any** of the types is provided. If all are provided it's fine. **xor** means **one** of the types is provided, not more. Currently it's not directly supported to have a **xor** union type beyond having a discriminated union. See also #14094."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how TypeScript union types work in JSX attribute validation",
      "Clarification of OR vs XOR behavior in TypeScript type system",
      "Guidance on achieving mutually exclusive attribute requirements",
      "Confirmation of whether this is expected behavior vs a TypeScript bug"
    ]
  },
  {
    "number": 22372,
    "title": "Using createVariableStatement in a compiler transformer breaks the compiler",
    "created_at": "2018-03-07T11:15:49Z",
    "closed_at": "2018-03-07T19:16:36Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/22372",
    "body": "**TypeScript Version:**  2.8.0-dev.20180307\r\n\r\n**Search Terms:** createVariableStatement const\r\n\r\n**Code (compiler)**\r\n\r\n```ts\r\n// A *self-contained* demonstration of the problem follows...\r\nimport * as ts from 'typescript';\r\n\r\nfunction transformer(program: ts.Program): ts.TransformerFactory<ts.SourceFile> {\r\n    return (context: ts.TransformationContext) => (file: ts.SourceFile) => transformFile(program, context, file);\r\n}\r\n\r\nfunction transformFile(program: ts.Program, context: ts.TransformationContext, file: ts.SourceFile): ts.SourceFile {\r\n    const transformedFile = ts.visitEachChild(file, child => visit(child, context, file), context);\r\n    return transformedFile;\r\n}\r\nfunction visit(node: ts.Node, context: ts.TransformationContext, file: ts.SourceFile): ts.Node {\r\n    if (ts.isMethodDeclaration(node)) {\r\n        const newNode = ts.createMethod(\r\n            [ts.createToken(ts.SyntaxKind.StaticKeyword)], \r\n            [], \r\n            null, \r\n            node.name, \r\n            null, \r\n            [], \r\n            node.parameters, \r\n            node.type, \r\n            ts.createBlock([ \r\n                ts.createVariableStatement(\r\n                    [ts.createToken(ts.SyntaxKind.ConstKeyword)], \r\n                    [ts.createVariableDeclaration('myConst', null, ts.createLiteral('value'))]\r\n                ),\r\n                ...(node.body ? node.body.statements : [])\r\n            ])\r\n        );\r\n        console.log(ts.createPrinter().printNode(ts.EmitHint.Unspecified, newNode, file));\r\n        return newNode;\r\n    }\r\n    return ts.visitEachChild(node, child => visit(child, context, file), context);\r\n}\r\n\r\nconst program = ts.createProgram([\r\n  '../transformer-issue-src/src/A.ts'\r\n], {\r\n    target: ts.ScriptTarget.ES5,\r\n    module: ts.ModuleKind.CommonJS,\r\n    moduleResolution: ts.ModuleResolutionKind.NodeJs,\r\n    importHelpers: true,\r\n    alwaysStrict: true,\r\n    noImplicitAny: true,\r\n    noImplicitThis: true,\r\n    removeComments: true,\r\n    sourceMap: true,\r\n    outDir: \"../transformer-issue-src/lib\",\r\n    declaration: true,\r\n    declarationDir: \"../transformer-issue-src/lib\",\r\n    lib: [\r\n      \"lib.es2017.d.ts\",\r\n    ],\r\n    experimentalDecorators: true,\r\n    noEmitOnError: true,\r\n});\r\n\r\nconst transformers = {\r\n  before: [\r\n    transformer(program),\r\n  ]\r\n}\r\nconst result = program.emit(undefined, undefined, undefined, false, transformers);\r\n```\r\n\r\n**Code (test program, ../transformer-issue-src/src/A.ts)**\r\n\r\n```ts\r\nexport class A {\r\n    static myMethod() {\r\n        return 'value';\r\n    }\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nThe .js file should be emitted.\r\nThe `console.log` statement should print the following:\r\n\r\n```ts\r\nstatic myMethod() { const myConst = \"value\"; return 'value'; }\r\n```\r\n\r\n**Actual behavior:**\r\nThe .js file is not emitted due to a compiler exception. Message and stack trace:\r\n\r\n```\r\nTypeError: Cannot read property 'transformFlags' of null\r\n    at aggregateTransformFlagsForNode (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:54626:18)\r\n    at Object.aggregateTransformFlags (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:54611:9)\r\n    at visitNode (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:53754:12)\r\n    at Object.visitEachChild (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:54053:108)\r\n    at visitVariableDeclaration (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:61625:30)\r\n    at Object.flatMap (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:2047:25)\r\n    at visitVariableDeclarationList (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:61510:39)\r\n    at visitJavaScript (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:60282:28)\r\n    at visitor (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:60243:24)\r\n    at visitNode (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:53755:23)\r\n```\r\n\r\nEven if I remove the `ts.createToken(ts.SyntaxKind.ConstKeyword)` token, this exception is still thrown.\r\n\r\nAlso, the `console.log` statement prints the following (the var keyword is left there):\r\n\r\n```ts\r\nstatic myMethod() { const var myConst = \"value\"; return 'value'; }\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/22372/comments",
    "author": "pedro-pedrosa",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-03-07T17:43:02Z",
        "body": "80% sure the problem is that you're passing `null` instead of `undefined` for some of those parameters. The TS API basically never uses `null` and will behave badly if given it because it's only ever checking for ` === undefined`"
      },
      {
        "user": "pedro-pedrosa",
        "created_at": "2018-03-07T18:33:44Z",
        "body": "Replacing the `null` in `createVariableDeclaration` with `undefined` made the exception go away (wasn't needed on createMethod), however it still prints `const var`."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-03-07T18:56:58Z",
        "body": "Pass `NodeFlags.Const` to `createVariableDeclarationList` rather than trying to push in a `const` keyword in the array.\r\n\r\nThere are lots of examples in the TypeScript codebase that show calling this function correctly."
      },
      {
        "user": "pedro-pedrosa",
        "created_at": "2018-03-07T19:16:36Z",
        "body": "That worked, I have a correct output now.\r\n\r\nThank you."
      }
    ],
    "satisfaction_conditions": [
      "Proper handling of TypeScript transformer API parameters to avoid null/undefined errors",
      "Correct implementation of variable declaration modifiers using NodeFlags rather than token arrays",
      "Successful emission of transformed code without compiler exceptions",
      "Accurate representation of variable declaration keywords in output"
    ]
  },
  {
    "number": 21723,
    "title": "Export `with` as a property within declaration file",
    "created_at": "2018-02-07T16:28:41Z",
    "closed_at": "2018-02-08T16:39:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/21723",
    "body": "I got a CommonJS module that exports a function by default. The function has a property named `with`, which is a reserved word in JavaScript. JavaScript allows this kind of usage (`with` as a property name), but unfortunately, I can't get it working in TS declaration file.\r\n\r\n## Code\r\n**a.js**\r\n```javascript\r\nmodule.exports = () => 1;\r\nmodule.exports.with = (n: number) => 1 + n;\r\n```\r\n\r\n**a.d.ts**\r\n```ts\r\nexport = GetNumber;\r\n\r\ndeclare function GetNumber(): number;\r\n\r\ndeclare namespace GetNumber {\r\n\texport function with(n: number): number;\r\n}\r\n```\r\n\r\n**b.ts**\r\n```ts\r\nimport * as getNumber from './a';\r\n\r\nconsole.log(getNumber()); // => 1\r\nconsole.log(getNumber.with(2)); // => 3\r\n```\r\n\r\n## Expected behavior:\r\n\r\nDeclaration should be valid for both `getNumber` and `getNumber.with`.\r\n\r\n## Actual behavior:\r\n\r\nGetting an error in compilation:\r\n```\r\n$ tsc a.d.ts\r\na.d.ts(6,19): error TS1003: Identifier expected.\r\na.d.ts(6,25): error TS1005: ')' expected.\r\na.d.ts(6,33): error TS1005: ';' expected.\r\na.d.ts(6,34): error TS1128: Declaration or statement expected.\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/21723/comments",
    "author": "yardnsm",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-02-07T17:44:56Z",
        "body": "use `export { ... as with }` instead:\r\n\r\n```ts\r\nexport = GetNumber;\r\n\r\ndeclare function GetNumber(): number;\r\n\r\ndeclare namespace GetNumber {\r\n    function _with(n: number): number;\r\n    export { _with as with}\r\n}\r\n```"
      },
      {
        "user": "yardnsm",
        "created_at": "2018-02-08T16:39:59Z",
        "body": "Awesome, it works!\r\nThanks :)"
      }
    ],
    "satisfaction_conditions": [
      "Handle reserved keywords as property names in TypeScript declaration files",
      "Maintain original property name in public API surface",
      "Preserve function+namespace declaration pattern",
      "Ensure declaration file validity"
    ]
  },
  {
    "number": 21428,
    "title": "Variable resolution in abstract classes",
    "created_at": "2018-01-26T22:31:45Z",
    "closed_at": "2018-01-29T18:24:11Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/21428",
    "body": "Hi,\r\n\r\nWhile setting up a Linked List pattern, I've noticed that, when it comes to abstract classes, I can use a `as this['opt']` trick to resolve a variable with its actual type:\r\n\r\n```\r\nabstract class oAbstract {\r\n    public opt: any;\r\n\r\n    test() {\r\n        // without the 'as this[\"opt\"]', the opt at the bottom of the code would be type \"any\"\r\n        return this.opt as this[\"opt\"];    \r\n    }\r\n}\r\n\r\nclass oConcrete extends oAbstract {\r\n    opt = { 'concreteOpt': true }\r\n}\r\n\r\nlet opt = (new oConcrete).test();   // type: {'concreteOpt': boolean;}\r\n```\r\n\r\nIt also seems to preserve the generics:\r\n\r\n```\r\nclass Option<T> {\r\n    constructor(public opt: T) {}\r\n\r\n    getValue() {\r\n        return this.opt;\r\n    }\r\n}\r\n\r\nabstract class oAbstract2 {\r\n    public opt: any;\r\n\r\n    test() {\r\n        return this.opt as this[\"opt\"];\r\n    }\r\n}\r\n\r\nclass oConcrete2 extends oAbstract2 {\r\n    opt = new Option(\"hop\");\r\n}\r\n\r\nlet o2 = new oConcrete2;\r\nlet opt2 = o2.test();  // Type: Option<string>\r\n```\r\n\r\nIt's powerful, and actually saving my life, when I need accurate typings over classical OOP patterns such as linked lists, abstract factories, decorators and so on...\r\n\r\nI why just wondering, since TS keeps the current type, why such a behavior is not the default. I can't think of a case when a developer would want a method from an object inheritance chain not to return the typings corresponding to the current variable. Are there side-effects to that?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/21428/comments",
    "author": "degardinn",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-01-29T18:24:11Z",
        "body": "`this`-bound types have fairly heavy performance implications as far as things go; this was briefly the default when we were writing `this` types and it was found that many real-world codebases became unbearably slow to typecheck."
      },
      {
        "user": "degardinn",
        "created_at": "2018-01-29T20:04:41Z",
        "body": "It makes perfect sense. Thanks for the explanation."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of TypeScript's design trade-offs regarding type inference in inheritance hierarchies",
      "Identification of practical implications for real-world codebases",
      "Clarification of type system behavior boundaries in OOP patterns"
    ]
  },
  {
    "number": 21421,
    "title": "Mapped type should take a function form as well",
    "created_at": "2018-01-26T06:02:30Z",
    "closed_at": "2018-01-30T04:32:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/21421",
    "body": "According to #12114 mapped types currently support following forms:\r\n\r\n```ts\r\n{ [ P in K ] : T }\r\n{ [ P in K ] ? : T }\r\n{ readonly [ P in K ] : T }\r\n{ readonly [ P in K ] ? : T }\r\n```\r\n\r\nI think it shall also at least support a function form:\r\n\r\n```ts\r\n{ ([ P in K ]) : T }\r\n{ ([ P in K ]) ? : T }\r\n{ ([ P in K])(entities: P[], someBoolean: boolean) ? : T }\r\n```\r\n\r\nCurrently Im trying to implement a `Functionize<T>` interface which forces implementors to implement any property of the T, but make it a function with maybe additional arguments. Example:\r\n\r\n```ts\r\ninterface User {\r\n     name: string;\r\n     age: number\r\n}\r\n```\r\n\r\nI want to do Functionize<User> which I want to give me:\r\n\r\n```ts\r\n{\r\n       name(names: string[]): string;\r\n       age(ages: number[]): number;\r\n}\r\n```\r\n\r\nAnd I'm asking about following method signature:\r\n\r\n```ts\r\ntype Functionize<T> = {\r\n   [P in keyof T](values: T[])?: T[P];\r\n};\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/21421/comments",
    "author": "pleerock",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-01-26T06:04:57Z",
        "body": "Someone suggested to do:\r\n\r\n```ts\r\ntype Functionize <T> = {\r\n   [P in keyof T]: () => T[P];\r\n};\r\n```\r\n\r\nhowever it does not work with extra function parameters, e.g.\r\n\r\n```ts\r\ntype Functionize <T> = {\r\n   [P in keyof T]: (values: T[]) => T[P];\r\n};\r\n```\r\n\r\ncompiler have no errors when values argument is not defined in the implementor of Functionize interface.\r\n\r\nEDIT: it appears to work partially, if I define lets say `name(names: boolean[])` instead of `name(names: string[])` it will give me a compiler error, however if I do simply `name()` its not telling me that names is required parameter."
      },
      {
        "user": "jack-williams",
        "created_at": "2018-01-26T14:14:10Z",
        "body": "> however if I do simply name() its not telling me that names is required parameter.\r\n\r\nI believe the issue is that a signature that accepts fewer inputs is assignable to one that accepts more (provided they agree on matching parameters and output). So the following is acceptable:\r\n\r\n```typescript\r\nlet f: () => number = () => 42;\r\nlet g: (x: number[]) => number = f;\r\n```\r\n\r\nIn your specific example, the type `{ name: () => string }` is assignable to the type `{ name: (names: string[]) => string }`.\r\n\r\nYou get a compiler error when using `boolean[]` because they disagree on a shared parameter.\r\n\r\nAlso, from your requirements I think the definition of `Functionize` should be: \r\n```typescript\r\ntype Functionize <T> = {\r\n   [P in keyof T]: (values: (T[P])[]) => T[P]; // or [P in keyof T]?: (values: (T[P])[]) => T[P] if you want optional properties \r\n};\r\n```\r\n(added a lookup on the type of `values`."
      },
      {
        "user": "pleerock",
        "created_at": "2018-01-29T09:16:02Z",
        "body": "> Also, from your requirements I think the definition of Functionize should be:\r\n\r\ncorrect, sorry Im using a bit different code, I just wanted to provide an example and make this mistake.\r\n\r\n> In your specific example, the type { name: () => string } is assignable to the type { name: (names: string[]) => string }.\r\n\r\ncorrect, that's exactly issue I have. Is it tracked, or is it by design? "
      },
      {
        "user": "jack-williams",
        "created_at": "2018-01-29T10:21:52Z",
        "body": "I believe it's by design. From the spec:\r\n\r\n> M has a rest parameter or the number of non-optional parameters in N is less than or equal to the total number of parameters in M.\r\n\r\nwhen defining whether call-signature N is a subtype of call-signature M.\r\n\r\nIntuitively if a user writes a function of type `() => number`, then it can always ignore extra arguments given and still return a number. So it also works when used as the type `(x: boolean) => number` or `(names: number[]) => number`.\r\n\r\nThe only way I could see this being something you *don't* want is if the output of the function *must* come from the input of the function. So in the type:\r\n```\r\n{\r\n       name(names: string[]): string;\r\n       age(ages: number[]): number;\r\n}\r\n```\r\n\r\nthe output of `name` always comes from an element in `names`, and the output of `age` always comes from an element in `ages`. If this is something you want, then I think the most likely solution will be parametricity and generics. Instead, would the follow types for you work?\r\n```\r\n{\r\n       name<X>(names: X[]): X;\r\n       age<X>(ages: X[]): X;\r\n}\r\n```\r\nThe rules about adding extra inputs to a function signature still apply, but in this case it's impossible to create something of type `X` out of nothing (unless you cheat and use `any`). An implementor of the function will not be able to write a function with the type: `<X>() => X`; the only way to return an `X` is to use one that is given to you from the input."
      },
      {
        "user": "mhegazy",
        "created_at": "2018-01-30T00:33:10Z",
        "body": "here is the syntax for definitnon a mapped type with function typed properties:\r\n\r\n```ts\r\ntype Funcs<T> = {[P in keyof T]?: (entities: P[], someBoolean: boolean) => T };\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2018-01-30T04:32:28Z",
        "body": "okay thank you guys, I think this issue can be closed."
      }
    ],
    "satisfaction_conditions": [
      "Support for function signatures in mapped type properties with parameters",
      "Enforcement of required function parameters in implementations",
      "Type safety between function parameters and return types",
      "Compatibility with TypeScript's function subtyping rules"
    ]
  },
  {
    "number": 21096,
    "title": "Issue with generic extension of object with index signature that returns functions",
    "created_at": "2018-01-09T17:19:58Z",
    "closed_at": "2018-01-09T21:03:58Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/21096",
    "body": "**TypeScript Version:**  2.7.0-dev.20180109\r\n\r\nHi. I ran into this issue trying to assign a class to a generic type that takes in T which extends an index signature type [s:string]:Function. The same issue happens with index sig [s:string]:new(..._)=>any\r\n\r\n**Code**\r\n\r\n```ts\r\nclass C {\r\n}\r\n\r\ntype Test<T extends {[s:string]:Function}> = {};\r\n\r\nconst t:Test<{c:C}> = { //error\r\n\tc:C,\r\n};\r\n\r\ntype Test2 = {\r\n\t[s:string]:Function\r\n}\r\n\r\nconst f:Test2 = {c:C}; //fine\r\n```\r\n\r\n**Expected behavior:**\r\nI should be able to assign {c:C} to the generic type\r\n\r\n**Actual behavior:**\r\n\r\nerror: \r\n\r\nError:(6, 14) TS2344: Type '{ c: C; }' does not satisfy the constraint '{ [s: string]: Function; }'.\r\n  Property 'c' is incompatible with index signature.\r\n    Type 'C' is not assignable to type 'Function'.\r\n      Property 'apply' is missing in type 'C'.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/21096/comments",
    "author": "dontsave",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-01-09T18:26:10Z",
        "body": "i think you meant `Test<{c:typeof C}>` there. `C` refers to the instance type of `C`, `typeof C` refers to the type of the constructor function for `C`."
      },
      {
        "user": "dontsave",
        "created_at": "2018-01-09T18:45:01Z",
        "body": "that makes sense now thanks. Took a minute to wrap my head around. "
      }
    ],
    "satisfaction_conditions": [
      "Clarify the distinction between class instance types and constructor function types in TypeScript",
      "Ensure generic type parameters properly match index signature requirements for functions/constructors",
      "Provide guidance on working with index signatures that require function/constructor types"
    ]
  },
  {
    "number": 20747,
    "title": "TS doesn't merge members for Window interface",
    "created_at": "2017-12-18T08:26:09Z",
    "closed_at": "2018-01-02T18:40:08Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/20747",
    "body": "I've tried to add a new property `counter` to the `Window` interface like this in the `main.ts` file:\r\n\r\n```\r\n// main.ts\r\n\r\ninterface Window {\r\n    counter;\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nI expected the property to be available on the `window` object:\r\n\r\n```\r\nwindow.counter;\r\n```\r\n\r\n**Actual behavior:**\r\n\r\nHowever, I got the error:\r\n\r\n```\r\nError:(19, 16) TS2339: Property 'counter' does not exist on type 'Window'.\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/20747/comments",
    "author": "maxkoretskyi",
    "comments": [
      {
        "user": "yortus",
        "created_at": "2017-12-18T14:39:51Z",
        "body": "Try this:\r\n\r\n```ts\r\n// main.ts\r\n\r\ndeclare global {\r\n    interface Window {\r\n        counter;\r\n    }\r\n}\r\n```\r\n"
      },
      {
        "user": "maxkoretskyi",
        "created_at": "2017-12-18T16:19:44Z",
        "body": "@yortus, thanks a lot, works this way. Can you elaborate a bit, why is `declare global` required?"
      },
      {
        "user": "kitsonk",
        "created_at": "2017-12-18T16:39:50Z",
        "body": "Because TypeScript is assuming you are in a module, likely because of the way you have your `tsconfig.json` configured (or the way you are compiling via `tsc`).  It therefore interfaces by default are scoped locally, instead of globally.  `declare global` indicates you are a module attempting to modify the global interfaces."
      },
      {
        "user": "maxkoretskyi",
        "created_at": "2017-12-19T16:41:26Z",
        "body": "@kitsonk , got it, thanks a lot!"
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-01-02T18:40:07Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why global declaration scope is required for modifying built-in interfaces",
      "Demonstration of proper global type augmentation in module contexts",
      "Clarification of TypeScript's module vs script file behavior"
    ]
  },
  {
    "number": 20637,
    "title": "Cannot use index signature of default export from wildcard module",
    "created_at": "2017-12-11T22:43:11Z",
    "closed_at": "2017-12-13T05:53:07Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/20637",
    "body": "**TypeScript Version:**  2.6.2\r\n\r\n**Code**\r\n\r\n***json-module.d.ts***\r\n```ts\r\n// Allows json files to be imported as a module\r\ndeclare module \"*.json\" {\r\n    import {JSONObject} from \"src/json\";\r\n    const value: JSONObject;\r\n    export default value;\r\n}\r\n```\r\n\r\n***json.ts***\r\n```ts\r\n/**\r\n * Type declarations and utilities for working with JSON-compatible data structures.\r\n * @module\r\n */\r\n\r\n/**\r\n * Any primitive data type that is allowed in JSON.\r\n */\r\nexport type JSONPrimitive = string | number | boolean | null;\r\n\r\n/**\r\n * Any value data type allowed in JSON (primitives, arrays, and objects).\r\n */\r\nexport type JSONValue = JSONPrimitive | JSONArray | JSONObject;\r\n\r\n/**\r\n * An array of data types allowed in JSON.\r\n */\r\nexport interface JSONArray extends Array<JSONValue> {\r\n}\r\n\r\n/**\r\n * An object whose properties are of types allowed in JSON.\r\n */\r\nexport interface JSONObject {\r\n    [name: string]: JSONValue;\r\n}\r\n```\r\n\r\nExample usage:\r\n```ts\r\nimport * as jsonData from \"someFile.json\";\r\n\r\n// compiler error on the following line\r\nconst someValue = jsonData[\"aPropertyName\"]; \r\n```\r\n\r\n**Expected behavior:**\r\nI should be able to use the imported value from my JSON file as a `JSONObject`, indexing into its properties without compiler errors.\r\n\r\n**Actual behavior:**\r\nCompiler error where I attempt to index into the properties of my JSONObject:\r\n`error TS7017: Element implicitly has an 'any' type because type 'typeof \"*.json\"' has no index signature.`",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/20637/comments",
    "author": "UselessPickles",
    "comments": [
      {
        "user": "UselessPickles",
        "created_at": "2017-12-11T22:47:27Z",
        "body": "The following hack allows me to use the imported JSON as desired:\r\n\r\n```ts\r\nimport * as jsonData_ from \"someFile.json\";\r\n\r\n// Assigning the import to an explicitly typed const is fine; so the compiler understands\r\n// here that the import value is of type JSONData.\r\nconst jsonData: JSONObject = jsonData_;\r\n\r\n// Now this works without compiler errors.\r\nconst someValue = jsonData[\"aPropertyName\"]; \r\n```"
      },
      {
        "user": "Jessidhia",
        "created_at": "2017-12-12T01:18:48Z",
        "body": "That is because, on your declaration, you were very specific that the only export is a `default` export. There is no index signature on ES Module exports.\r\n\r\nYou need to change your import from `import * as jsonData from` into `import jsonData from`."
      },
      {
        "user": "ghost",
        "created_at": "2017-12-12T01:39:27Z",
        "body": "Alternatively, use `export =` instead of `export default`, and `import jsonData = require(\"someFile.json\")`."
      },
      {
        "user": "UselessPickles",
        "created_at": "2017-12-12T02:38:24Z",
        "body": "Thanks for the responses. It seems so obvious now that the way I'm importing `*`, but exporting a single default, is inconsistent.\r\n\r\nBut can anyone explain why my `jsonData` import in my example seems to have an identity crisis? Why does the compiler believe it *is* of type JSONObject (which has an index signature), but that it also does *not* have an index signature because of the way it was imported? In every other way that I use `jsonData`, it works as type JSONObject... as long as I don't try to use the index operator.\r\n\r\nRegardless of the fact that I was doing it wrong, it still seems like there's an inconsistency in the behavior of my example."
      },
      {
        "user": "ghost",
        "created_at": "2017-12-12T15:46:11Z",
        "body": "The compiler doesn't actually believe that `jsonData` is of type `JSONObject`. If you write `const x = jsonData;` and hover over `x` you'll see it says `typeof jsonData`. If you try writing `jsonData.` you'll only get completions for `default`.\r\nIt is *assignable* to a `JSONObject` variable though, because the type `{ default: JSONObject }` is assignable to `JSONObject`, since every property value in that type is a `JSONValue`."
      },
      {
        "user": "UselessPickles",
        "created_at": "2017-12-12T21:59:05Z",
        "body": "I figured it out!\r\n\r\nThe key was to start by looking at how webpack (what I'm using for module loading, etc.) generates modules for JSON files, declare my \"*.json\" module to match, and use an import style that matches. \r\n\r\nThe built-in JSON loader for webpack creates a module in the form of:\r\n```js\r\nmodule.exports = {/* the JSON object from the file */};\r\n```\r\n\r\nTo match the way the webpack loader generates the module, I declare my \"*.json\" module as:\r\n\r\n```ts\r\ndeclare module \"*.json\" {\r\n    import {JSONObject} from \"src/json\";\r\n    const value: JSONObject;\r\n    export = value;\r\n}\r\n```\r\n\r\nAnd then import JSON like this:\r\n```ts\r\nimport * as jsonData from \"someFile.json\";\r\n```\r\n\r\nI guess this is a good lesson that the structure of an external non-typescript module is what dictates how corresponding TS declarations must be defined, and therefore dictates how the module must be imported.\n\n---\n\n@andy-ms \r\n> It is assignable to a JSONObject variable though, because the type { default: JSONObject } is assignable to JSONObject, since every property value in that type is a JSONValue.\r\n\r\nThanks for the clarification. I see now where I got confused :)\r\n\n\n---\n\nPart of my confusion was that my initial setup was working correctly at runtime. Now I understand that it's because the style of my import matched the structure of the actual module that was being generated by webpack. It was only my TS declaration that didn't match, and was causing compile-time confusion under certain conditions. \r\n\r\nThe fact that the incorrect TS declaration of the module combined with my import style to produce something that was *assignable* to JSONObject (unfortunate coincidence) was an additional red herring. The end result was that it seemed to \"mostly work\", unless I tried to directly use the import as a JSONObject."
      }
    ],
    "satisfaction_conditions": [
      "Module declaration must match the actual structure of JSON modules generated by the build system",
      "Import syntax must be compatible with the module's export type",
      "JSON imports must be recognized as indexable objects without type assertions",
      "Solution must explain relationship between module declaration format and import syntax"
    ]
  },
  {
    "number": 20280,
    "title": "Wrong type inferred for nested union",
    "created_at": "2017-11-27T18:11:05Z",
    "closed_at": "2018-10-05T19:06:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/20280",
    "body": "**TypeScript Version:**  2.7.0-dev.20171126\r\n\r\nContext: a method for ember.js which extracts the value from some path, e.g.\r\n```ts\r\nget({ foo: { bar: { baz: 'hello' }}}, 'foo', 'bar', 'baz') // returns \"hello\"\r\n```\r\n\r\nEach value in the path might be some plain object `T` or a `Wrapped<T>` (in which case we return the underlying `T`)\r\n\r\n**Code**\r\n\r\nTypescript can infer the returned type using a union:\r\n\r\n```ts\r\n// working example\r\ninterface Wrapped<T> { value: T }\r\n\r\ntype Props1<T> = {\r\n    [K in keyof T]: Wrapped<T[K]> | T[K];\r\n}\r\n\r\ndeclare function get1<T, K1 extends keyof T>(obj: Props1<T>, k1: K1): T[K1];\r\n\r\ndeclare const obj1: { a: string };\r\nconst v1: string = get1(obj1, 'a'); // works\r\n\r\ndeclare const obj2: { a: Wrapped<string> };\r\nconst v2: string = get1(obj2, 'a'); // works\r\n```\r\n\r\nHowever, it no longer works when the union types are nested:\r\n\r\n```ts\r\n// non-working example\r\ntype Props2<T> = {\r\n    [K in keyof T]: Wrapped<Props1<T[K]>> | Props1<T[K]>\r\n};\r\n\r\ndeclare function get2<T, K1 extends keyof T, K2 extends keyof T[K1]>(obj: Props2<T>, k1: K1, k2: K2): T[K1][K2];\r\n\r\ndeclare const obj3: { a: { b: string } };\r\nconst v3: string = get2(obj3, 'a', 'b'); // works\r\n\r\ndeclare const obj4: { a: Wrapped<{ b: Wrapped<string> }> };\r\nconst v4: string = get2(obj4, 'a', 'b'); // TS2345:Argument of type '\"b\"' is not assignable to parameter of type 'never'.\r\n```\r\n\r\nIf I eliminate the _right side_ of the union from `Props2`, then the `obj4` example works\r\n```ts\r\ntype Props2<T> = {\r\n    [K in keyof T]: Wrapped<Props1<T[K]>> //| Props1<T[K]>\r\n};\r\n```\r\nThe `obj4` example should pick the left side of the union to begin with",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/20280/comments",
    "author": "dwickern",
    "comments": [
      {
        "user": "chriskrycho",
        "created_at": "2017-11-27T19:01:09Z",
        "body": "To add a bit, the motivation is providing a type-safe wrapper around `Ember.get(someObj, 'a.b')`. We want to be able to do a `safeGet(someObj, 'a', 'b')` which simply dispatches internally to the relevant path, but which does type-checking on the supplied keys \u2013 for an API that's *slightly* less ergonomic than the built-in Ember API, but which is much nicer than doing it the way we are presently.\r\n\r\n```ts\r\n// current way to do it to get type inference\r\nconst a = get(someObj, 'a');\r\nconst b = get(a, 'b');\r\n\r\n// desired API\r\nconst b = safeGet(someObj, 'a', 'b');\r\n```\r\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-08-07T22:03:42Z",
        "body": "@dwickern @chriskrycho I wrote a version using conditional types that works:\r\n```ts\r\ntype Unwrap<T> = T extends Wrapped<infer U> ? U : T;\r\n\r\n// working example\r\ninterface Wrapped<T> {\r\n  value: T\r\n}\r\n\r\ntype Props1<T> = {\r\n    [K in keyof T]: T[K];\r\n}\r\n\r\ndeclare function get1<T, K1 extends keyof T>(obj: Props1<T>, k1: K1): Unwrap<T[K1]>;\r\n\r\ndeclare const obj1: { a: string };\r\nconst v1: string = get1(obj1, 'a'); // works\r\n\r\ndeclare const obj2: { a: Wrapped<string> };\r\nconst v2: string = get1(obj2, 'a'); // works\r\n\r\ntype Props2<T> = {\r\n    [K in keyof T]: Unwrap<Props1<T[K]>>\r\n};\r\n\r\ndeclare function get2<T, K1 extends keyof T, K2 extends keyof Unwrap<T[K1]>>(obj: Props2<T>, k1: K1, k2: K2): Unwrap<Unwrap<T[K1]>[K2]>;\r\n\r\ndeclare const obj3: { a: { b: string } };\r\nconst v3: string = get2(obj3, 'a', 'b'); // works\r\n\r\ndeclare const obj4: { a: Wrapped<{ b: Wrapped<string> }> };\r\nconst v4: string = get2(obj4, 'a', 'b'); // now works\r\n```\r\nI don't think this is solvable otherwise because we don't preferentially go down one path or the other when inferring a key type for the union."
      },
      {
        "user": "chriskrycho",
        "created_at": "2018-08-08T01:50:26Z",
        "body": "Ah, this is genuinely great. Thank you, @RyanCavanaugh. I don\u2019t have time to experiment tonight; it looks like it should be possible to extend this using overloads but probably not tuple/argument types, if I\u2019m tracking correctly?\r\n\r\nAt a minimum, it\u2019ll give us a tool we can build on for this. Thanks for circling back around to it!"
      },
      {
        "user": "dwickern",
        "created_at": "2018-10-05T19:06:52Z",
        "body": "This is possible now with conditional types \ud83c\udf89 "
      }
    ],
    "satisfaction_conditions": [
      "Handles nested wrapped/unwrapped types at multiple levels",
      "Preserves type safety for key validation",
      "Supports recursive unwrapping of wrapped types",
      "Maintains type inference through multiple accessor arguments"
    ]
  },
  {
    "number": 19529,
    "title": "Can TypeScript refer to an instance type over a namespace type?",
    "created_at": "2017-10-27T13:19:56Z",
    "closed_at": "2017-10-27T14:41:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19529",
    "body": "I have a library whose `.d.ts` file defined something like:\r\n\r\n```\r\ndeclare class Logger extends EventEmitter {\r\n    constructor();\r\n    info(message: string);\r\n    error(message: string);\r\n}\r\n\r\ndeclare namespace Logger {\r\n    const INFO: number;\r\n    const ERROR: number;\r\n}\r\n\r\nexport = Logger;\r\n```\r\n\r\nI'm accessing it with `require()` and loading it in at runtime:\r\n\r\n```\r\nimport LoggerType = require(\"mylogger\");\r\n\r\n...\r\n\r\nlet logger: typeof LoggerType;\r\ntry {\r\n    logger = require(\"mylogger\").createLogger(...);\r\n}\r\ncatch (err) {\r\n    ...\r\n}\r\n\r\nif (logger) {\r\n    logger.info(\"hello world\");\r\n}\r\n```\r\n\r\nBut this doesn't work because TypeScript doesn't see `logger` as an instance of `Logger` but as the namespace `Logger`.  Can it instead refer to the instance of `Logger` so `logger.info()` will not be a type violation?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19529/comments",
    "author": "jez9999",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2017-10-27T14:27:59Z",
        "body": "`let logger: LoggerType;`\r\n`typeof LoggerType` gives you the type of the module's export, which is a *class*. `LoggerType` gives you the type exported by the module, which is the type of *instances* of `Logger`."
      }
    ],
    "satisfaction_conditions": [
      "Clarify the distinction between class constructor types and instance types in TypeScript",
      "Resolve type violations when accessing instance methods through dynamically loaded modules",
      "Demonstrate proper type annotation for class instances when using require()",
      "Maintain compatibility with existing module declaration structure"
    ]
  },
  {
    "number": 19382,
    "title": "Referenced type variable incorrectly inferred as \"{}\" in function calls",
    "created_at": "2017-10-20T19:39:19Z",
    "closed_at": "2017-11-07T16:55:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19382",
    "body": "**TypeScript Version:**  2.6.0-dev.201xxxxx\r\n\r\n**Code**\r\n\r\n```ts\r\n// Fails:  error TS2339: Property 'a' does not exist on type '{}'.\r\ninfer({ thing: { a: 10 } }).a; \r\n\r\n// With explicit type parameters, it works\r\ninfer<{a:number}, Holder<{a: number}>>({ thing: { a: 10 } }).a; \r\n\r\ninterface Holder<T> {\r\n\tthing: T;\r\n}\r\nfunction infer<T, H extends Holder<T>>(holder: H): T {\r\n\treturn holder.thing;\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nThe type parameter `T` should be inferred to be the type of `thing` in the instance of `Holder` passed to the function `infer()`.\r\n\r\nPerhaps there is another way to get this type of inference to work? I'm building a builder-pattern class and really need this to correctly return the right types.\r\n\r\n**Actual behavior:**\r\n\r\nThe type parameter, `T`, is inferred to be `{}` when calling `infer()`\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19382/comments",
    "author": "Yona-Appletree",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2017-10-20T20:11:44Z",
        "body": "You don't actually need `H` here.\r\n```ts\r\nfunction infer<T>(holder: Holder<T>): T {\r\n\treturn holder.thing;\r\n}\r\n```"
      },
      {
        "user": "Yona-Appletree",
        "created_at": "2017-10-20T20:17:49Z",
        "body": "Fair, though in my actual code I do need it. Slightly contrived, but closer to my actual use case:\r\n\r\n```ts\r\nconst result = infer({ thing: { a: 10 } });\r\nresult.holder.thing += result.value.thing;\r\n\r\ninterface Holder<T> {\r\n\tthing: T;\r\n}\r\nfunction infer<T, H extends Holder<T>>(holder: H): { holder: H, value: T} {\r\n\treturn { holder, value: holder.thing };\r\n}\r\n```\r\n\r\n"
      },
      {
        "user": "ghost",
        "created_at": "2017-10-20T20:41:27Z",
        "body": "How about `function infer<T, H extends Holder<T>>(holder: H & Holder<T>): { holder: H, value: T} {`?"
      },
      {
        "user": "Yona-Appletree",
        "created_at": "2017-10-20T21:00:34Z",
        "body": "@andy-ms Yeah, that's perfect, actually. Thanks. It seems to me that it shouldn't be necessary, but this is a great work around."
      },
      {
        "user": "ghost",
        "created_at": "2017-10-20T21:02:46Z",
        "body": "@sandersn Could we infer a more specific `T` in the original example? It seems silly to add `& Holder<T>` when `H` already extends that."
      },
      {
        "user": "gcanti",
        "created_at": "2017-10-21T03:07:17Z",
        "body": "Another option\r\n\r\n```ts\r\nfunction infer<H extends Holder<any>>(holder: H): { holder: H; value: H['thing'] } {\r\n  return { holder, value: holder.thing }\r\n}\r\n```"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-11-07T00:20:59Z",
        "body": "you can define your function as: \r\n```ts\r\nfunction infer<T, H extends Holder<T>>(holder: Holder<T> & H): T \r\n```\n\n---\n\nAutomatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      },
      {
        "user": "ghost",
        "created_at": "2017-11-07T15:50:09Z",
        "body": "@sandersn Could we infer a more specific `T` in the original example? It seems silly to add `& Holder<T>` when `H` already extends that."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-11-07T16:55:28Z",
        "body": "constraints are not inference positions.. they are merely for checking constraints after an inference has occurred. \r\n\r\nNow, the general question is i want to capture a container type \"and\" the type it contains.. this is doable through one of two ways.. either, you infer the container type, and you access the element type using indexed access type, e.g.:\r\n```ts\r\nfunction infer<H extends Holder<any>>(holder: H): H['thing'];\r\n```\r\nor through making two inferences using intersection types, e.g.:\r\n\r\n```ts\r\nfunction infer<T, H extends Holder<T>>(holder: Holder<T> & H): T;\r\n```"
      }
    ],
    "satisfaction_conditions": [
      "Type parameter T must be automatically inferred from the 'thing' property's type in the passed Holder instance",
      "Solution must preserve access to nested properties of the inferred type without type errors",
      "Approach should avoid requiring redundant type annotations at call sites",
      "Must maintain the H extends Holder<T> relationship while still allowing type inference"
    ]
  },
  {
    "number": 19207,
    "title": "Allow narrowing of discriminated unions at type level",
    "created_at": "2017-10-16T09:36:00Z",
    "closed_at": "2017-10-16T20:05:34Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19207",
    "body": "Typescript currently supports narrowing of discriminated unions at value level.\r\n\r\nFor example,\r\n```ts\r\ntype Action = {\r\n    kind: \"CASE_1\";\r\n    payload: number;\r\n} | {\r\n    kind: \"CASE_2\";\r\n    payload: string;\r\n}\r\n...\r\n```\r\nSo, if we have a value of type `Action`, we can\r\ndetermine the type of the `payload` parameter based on the `kind` property.\r\n```ts\r\nconst action: Action = ...;\r\nif (action.kind === \"CASE_1\") {\r\n    action.payload; // type inferred as number\r\n} else if (action.kind === \"CASE_2\") {\r\n    action.payload; // type inferred as string;\r\n}\r\n```\r\nNow, since the compiler already has this information, it would be nice if we\r\ncould do this \"narrowing\" at the type level.\r\n\r\nSo, we should be able to have something like.\r\n```ts\r\n// not currently valid\r\ntype PayloadOf<Kind extends Action[\"kind\"]> =\r\n   Action[\"payload\"] where { Action[\"kind\"] is Kind }\r\n```\r\nHere, the where clause is adding a constraint to the `Action` type\r\nthat it's `kind` property is known to be the generic parameter `Kind`.\r\n\r\nHence,\r\n```ts\r\ntype PayloadOfCase1 = PayloadOf<\"CASE_1\">;\r\n```\r\nwill alias `PayloadOfCase1` to `number`.\r\n\r\n**Use cases**\r\nOne specific use case I can think of is in redux, where \"reducers\" are\r\njust functions that perform certain actions based on the `kind` of the action\r\nreceived. They're essentially giant switch statements on `action.kind`.\r\n\r\nIf implemented, something like this\r\n```ts\r\nfunction reducer(state: State, action: Action): State {\r\n    switch(action.type) {\r\n    case \"CASE_1\": return case1Handler(state, action.payload);\r\n    case \"CASE_2\": return case2Handler(state, action.payload);\r\n    ...\r\n    default: return state;\r\n    }\r\n}\r\n```\r\nCould be converted to this\r\n```ts\r\nconst reducer = createReducer({\r\n   \"CASE_1\": case1Handler,\r\n   \"CASE_2\": case2Handler,\r\n   ...\r\n});\r\ntype Cases {\r\n    [Kind in Action[\"kind\"]]: PayloadOf<Kind>\r\n}\r\nfunction createReducer(cases: Partial<Cases>): Reducer {\r\n    ...\r\n}\r\n```\r\nwithout losing type safety.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19207/comments",
    "author": "dhruvrajvanshi",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2017-10-16T17:11:14Z",
        "body": "You can actually do this without any new features:\r\n\r\n```ts\r\ntype ActionMap = {\r\n    \"CASE_1\": number;\r\n    \"CASE_2\": string;\r\n}\r\n\r\ntype ActionKind = keyof ActionMap;\r\ntype ActionPayload<K extends ActionKind> = ActionMap[K];\r\ntype ActionObject<K extends ActionKind> = { kind: K, payload: ActionPayload<K> };\r\ntype Action = { [P in ActionKind]: ActionObject<P> }[ActionKind];\r\n```\r\n"
      },
      {
        "user": "dhruvrajvanshi",
        "created_at": "2017-10-16T20:05:34Z",
        "body": "Yes that works! Thanks."
      }
    ],
    "satisfaction_conditions": [
      "Ability to map union discriminant values to their corresponding payload types at the type level",
      "Maintain type safety when handling discriminated union variants generically",
      "Work with existing TypeScript type system features",
      "Enable creation of type-safe abstraction patterns for union handling"
    ]
  },
  {
    "number": 19186,
    "title": "TS2339: Property 'tooltip' does not exist on type '{ label: string; } | { label: string; tooltip: string; }'.",
    "created_at": "2017-10-14T19:27:31Z",
    "closed_at": "2017-10-30T18:31:36Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19186",
    "body": "**TypeScript Version:**  typescript@2.6.0-dev.20171014\r\n\r\n**Code**\r\n\r\n```ts\r\nconst cells = [\r\n  { label: '1' },\r\n  { label: '2', tooltip: '2' },\r\n  { label: '3', tooltip: '3' },\r\n  { label: '4' },\r\n  { label: '5' },\r\n  { label: '6' },\r\n]\r\nfor (const cell of cells) {\r\n  if (cell.tooltip) console.log(cell.tooltip)\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nThat this compiles without error; the error message seems to indicate TS sees a call to cell.tooltip as valid but then forbids it in the second part of the error message.\r\n\r\n**Actual behavior:**\r\n```\r\ntt.ts(10,12): error TS2339: Property 'tooltip' does not exist on type '{ label: string; } | { label: string; tooltip: string; }'.\r\n  Property 'tooltip' does not exist on type '{ label: string; }'.\r\ntt.ts(10,38): error TS2339: Property 'tooltip' does not exist on type '{ label: string; } | { label: string; tooltip: string; }'.\r\n  Property 'tooltip' does not exist on type '{ label: string; }'.\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19186/comments",
    "author": "retorquere",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-10-14T21:20:28Z",
        "body": "Looks like a duplicate of #1260. You can get around this with a user-defined type guard or a type-assertion."
      },
      {
        "user": "retorquere",
        "created_at": "2017-10-14T21:53:16Z",
        "body": "I eyed that issue but couldn't make out whether it was the same problem; If it's a dup feel free to close. The suggestions in #1260 do allow compilation, but is this issue planned for a fix in a 2.x release? #1260 has been open for a while."
      },
      {
        "user": "ajafff",
        "created_at": "2017-10-14T22:22:10Z",
        "body": "The easy fix for your problem is a type annotation:\r\n```ts\r\nconst cells: {label: string, tooltip?: string} = [\r\n  { label: '1' },\r\n  { label: '2', tooltip: '2' },\r\n  { label: '3', tooltip: '3' },\r\n  { label: '4' },\r\n  { label: '5' },\r\n  { label: '6' },\r\n]\r\n```"
      },
      {
        "user": "retorquere",
        "created_at": "2017-10-14T22:27:10Z",
        "body": "Yeah, that's what I settled on in the end."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-10-30T18:31:36Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ],
    "satisfaction_conditions": [
      "TypeScript must recognize optional property existence checks as type guards",
      "Solution must handle mixed object types in arrays without explicit type assertions",
      "Approach must preserve type safety for optional properties",
      "Resolution should align with TypeScript's type narrowing capabilities"
    ]
  },
  {
    "number": 19017,
    "title": "Type inference by property comparison",
    "created_at": "2017-10-08T12:59:55Z",
    "closed_at": "2017-10-08T16:00:32Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19017",
    "body": "**TypeScript Version:**  2.5.3\r\n\r\n**Code**\r\n\r\n```ts\r\ninterface Symbol\r\n{\r\n    kind: \"namespace\"|\"class\"|\"interface\"|\"enum\";\r\n    basename: string;\r\n}\r\n\r\ninterface SymbolClass extends Symbol\r\n{\r\n    kind: \"class\";\r\n    extends: string;\r\n}\r\n\r\nfunction (symbol: Symbol)\r\n{\r\n    if (symbol.kind === \"class\")\r\n    {\r\n        //infer symbol as SymbolClass, is it possible?\r\n        console.log(symbol.extends);\r\n    }\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nNo error\r\n\r\n**Actual behavior:**\r\nProperty 'extends' does not exist on type 'Symbol'.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19017/comments",
    "author": "lmcarreiro",
    "comments": [
      {
        "user": "j-oliveras",
        "created_at": "2017-10-08T13:57:12Z",
        "body": "Something like:\r\n```ts\r\ninterface SymbolBase {\r\n    basename: string;\r\n}\r\n\r\ninterface SymbolClass extends SymbolBase {\r\n    kind: \"class\";\r\n    extends: string;\r\n}\r\n\r\ninterface SymbolNamespace extends SymbolBase {\r\n    kind: \"namespace\";\r\n}\r\n\r\ninterface SymbolInterface extends SymbolBase {\r\n    kind: \"interface\";\r\n}\r\n\r\ninterface SymbolEnum extends SymbolBase {\r\n    kind: \"enum\";\r\n}\r\n\r\ntype SymbolType = SymbolClass | SymbolNamespace | SymbolInterface | SymbolEnum;\r\n\r\nfunction func(sym: SymbolType) {\r\n    if (sym.kind === \"class\") {\r\n        console.log(sym.extends);\r\n    }\r\n}\r\n```"
      },
      {
        "user": "lmcarreiro",
        "created_at": "2017-10-08T16:00:32Z",
        "body": "It works, thanks!"
      }
    ],
    "satisfaction_conditions": [
      "Demonstrate type narrowing through discriminated union pattern",
      "Ensure common base interface with discriminant property",
      "Enable type safety for extended interface properties"
    ]
  },
  {
    "number": 18973,
    "title": "compiler hide errors in tsx files, if there is \"import\"",
    "created_at": "2017-10-05T20:02:24Z",
    "closed_at": "2017-10-06T08:32:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18973",
    "body": "**TypeScript Version:**  2.5.3\r\n\r\n**Code**\r\n\r\n1.tsx\r\n```ts\r\nimport Test from \"./2\"\r\n\r\ndeclare namespace JSX {\r\n  interface IntrinsicElements {\r\n    foo: { requiredProp: string; optionalProp?: number }\r\n  }\r\n}\r\nclass React {  static Render(a?: any, b?: any, c?: any) {} }\r\n\r\nfunction xxxxx() {\r\n  <foo />;\r\n}\r\n```\r\n2.ts\r\n```ts\r\nexport default class Test {}\r\n```\r\ncommand line\r\n``` tsc 1.tsx --jsx react```\r\n\r\n**Expected behavior:**\r\n```error TS2322: Type '{}' is not assignable to type '{ requiredProp: string; optionalProp?: number; }'.\r\n  Property 'requiredProp' is missing in type '{}'\r\n```\r\n\r\n**Actual behavior:**\r\ncompilation is success\r\n\r\n**Note:**  \r\nif I comment line 'import Test from \"./2\"', I get error as expected.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18973/comments",
    "author": "jack128",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-10-05T20:18:49Z",
        "body": "once a file has a top-level `import` or `export` it becomes a module. modules have their own scope. declarations within this module do not merge with declarations in the global scope.\r\n\r\nUse `declare global` instead:\r\n\r\n```ts\r\ndeclare global {\r\n  namespace JSX {\r\n    interface IntrinsicElements {\r\n      foo: { requiredProp: string; optionalProp?: number }\r\n    }\r\n  }\r\n}\r\n```"
      },
      {
        "user": "jack128",
        "created_at": "2017-10-06T08:32:57Z",
        "body": "Oh, I see. Thanks."
      }
    ],
    "satisfaction_conditions": [
      "Explains why module scope affects JSX type declarations",
      "Demonstrates how to make declarations available globally in modules",
      "Clarifies relationship between imports and declaration scoping"
    ]
  },
  {
    "number": 18869,
    "title": "Suggestion: a better way to handle enums in generic functions",
    "created_at": "2017-09-30T19:45:18Z",
    "closed_at": "2017-10-01T01:15:29Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18869",
    "body": "Currently, there's no \"easy\" way to write a generic function that takes an enum as input/generic parameter and returns one of its constants. Consider the following example, which shows a way to almost accomplish it:\r\n\r\n```ts\r\nenum Color {\r\n    RED = \"#FF0000\",\r\n    GREEN = \"#00FF00\",\r\n    BLUE = \"#0000FF\"\r\n}\r\n\r\ndeclare function randomKey<T>(object: T): keyof T;\r\n\r\n// One overload for numeric enums and one for string enums\r\nfunction randomEnumValue<E extends {[P in keyof E]: number}>(enumObject: E): number;\r\nfunction randomEnumValue<E extends {[P in keyof E]: string}>(enumObject: E): string;\r\n\r\nfunction randomEnumValue(enumObject: any): any {\r\n    return enumObject[randomKey(enumObject)];\r\n}\r\n\r\ndeclare function doSomethingWithColor(color: Color);\r\n\r\nlet color = <Color> randomEnumValue(Color);\r\ndoSomethingWithColor(color);\r\n```\r\n\r\nThe problem with this approach is that every call to `randomEnumValue` requires a cast to the enum type (the code would compile if `Color` was a numeric enum but `color` would still be a `number`, not a `Color`). Also note that two overloads were required and the generic restriction `E extends {[P in keyof E]: number}` allows a lot of undesired types (i.e non-enums).\r\n\r\nI suggest the following version:\r\n```ts\r\nfunction randomEnumValue<T, E extends enum<T>>(enumObject: typeof E): E {\r\n    return enumObject[randomKey(enumObject)];\r\n}\r\n```\r\n\r\nHere, `T` is the underlying type of the enum (currently, that means either `number` or `string`). `enum<T>` is a special type used to restrict a generic parameter to an enum of underlying type `T`. Also note that the parameter `enumObject` has type `typeof E`, which I think is currently not allowed and therefore is also part of my suggestion. That example would make it unnecessary to put a cast when calling that function, e.g\r\n\r\n```ts\r\n// calls randomEnumValue<string, Color>(enumObject: typeof Color): Color\r\nlet color = randomEnumValue(Color);\r\n// color has type Color\r\n```\r\n\r\nAnother possibility that crossed my mind is something like this:\r\n```ts\r\nfunction randomEnumValue<T, E extends enum<T>>(enumObject: E): EnumMember<E> {\r\n    return enumObject[randomKey(enumObject)];\r\n}\r\n```\r\n\r\nThis might be easier to implement and I'm not sure which way would be preferable, but I feel like the overall idea of this suggestion would make enums better to manipulate.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18869/comments",
    "author": "Ghabriel",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2017-09-30T22:24:48Z",
        "body": "It already works without any overloads:\r\n\r\n```ts\r\nenum Color {\r\n    RED = \"#FF0000\",\r\n    GREEN = \"#00FF00\",\r\n    BLUE = \"#0000FF\"\r\n}\r\n\r\ndeclare function randomKey<T>(object: T): keyof T;\r\n\r\nfunction randomEnumValue<T>(enumObject: T) {  // Inferred return type is T[keyof T]\r\n    return enumObject[randomKey(enumObject)];\r\n}\r\n\r\nlet color = randomEnumValue(Color);  // Inferred type is Color\r\n```\r\n\r\nThe inferred return type for `randomEnumValue` is `T[keyof T]` which for an enum object is the enum type, i.e. precisely what you want. Of course it also works if you add a type annotation:\r\n\r\n```ts\r\nfunction randomEnumValue<T>(enumObject: T): T[keyof T] {\r\n    return enumObject[randomKey(enumObject)];\r\n}\r\n```\r\n"
      },
      {
        "user": "Ghabriel",
        "created_at": "2017-10-01T01:15:28Z",
        "body": "Thanks, totally forgot about T[keyof T]... I still think that it would be useful to restrict a function to only accept enums, but considering that your example works I can't really think of a good use case right now. If anyone can think of a good use case, feel free to reopen this issue (if that's possible) or reference it in a new one."
      }
    ],
    "satisfaction_conditions": [
      "Eliminates the need for explicit type casting when using enum values from generic functions",
      "Handles both numeric and string enums through a single unified mechanism",
      "Preserves enum type information in return values"
    ]
  },
  {
    "number": 18761,
    "title": "Cannot find types in sub-project",
    "created_at": "2017-09-26T07:23:08Z",
    "closed_at": "2017-09-27T03:23:02Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18761",
    "body": "**TypeScript Version:**  2.5.2\r\n\r\n**Code**\r\n```js\r\n// [1]\r\n// tsconfig.json\r\n{\r\n    \"compilerOptions\": {\r\n      \"allowJs\": true,\r\n      \"sourceMap\": true,\r\n      \"declaration\": false,\r\n      \"skipLibCheck\": true,\r\n      \"noImplicitAny\": false,\r\n      \"strictNullChecks\": false,\r\n      \"module\": \"es2015\",\r\n      \"moduleResolution\": \"node\",\r\n      \"target\": \"es5\",\r\n      \"typeRoots\": [\r\n        \"node_modules/@types\"\r\n      ],\r\n      \"lib\": [\r\n        \"dom\",\r\n        \"es5\",\r\n        \"scripthost\",\r\n        \"es2015\"\r\n      ]\r\n    },\r\n    \"include\": [\r\n      \"types/**/*.d.ts\",\r\n      \"src/**/*.ts\"\r\n    ],\r\n    \"exclude\": [\r\n      \"node_modules\"\r\n    ]\r\n  }\r\n```\r\n\r\n```ts\r\n// git-submodule/src/index.ts\r\nDate.prototype.format = function () {\r\n    return 90; // Just for demo\r\n};\r\nconst date = new Date();\r\nconst format = date.format();\r\nexport default format;\r\n\r\n// git-submodule/types/custom.d.ts\r\ninterface Date {\r\n    format(): number;\r\n}\r\n\r\n// git-submodule/tsconfig.json // see above [1]\r\n\r\n// src/index.ts\r\nimport Sub from '../git-submodule/src/index';\r\n\r\n// src/tsconfig.json // see above [1]\r\n```\r\n\r\nthen, run `tsc` in root directory.\r\n\r\n**Expected behavior:**\r\nNo errors.\r\n\r\n**Actual behavior:**\r\n```\r\n// errors\r\ngit-submodule/src/index.ts(1,16): error TS2339: Property 'format' does not exist on type 'Date'.\r\ngit-submodule/src/index.ts(6,21): error TS2339: Property 'format' does not exist on type 'Date'.\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18761/comments",
    "author": "Aqours",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2017-09-26T14:38:43Z",
        "body": "TypeScript won't look at the `tsconfig.json` for imported modules. So it won't know that in `git-submodule` you had a `tsconfig.json` that included the types.\r\nIf you need to expose types from a package, you should reference them from its `index` in some way, such as with `/// <reference path=\"./types/custom.d.ts\" />.`\r\nIn this case, you could also not bother with putting types in a separate file and just do:\r\n```ts\r\ndeclare global {\r\n    interface Date {\r\n        format(): number;\r\n    }\r\n}\r\n```"
      },
      {
        "user": "Aqours",
        "created_at": "2017-09-27T03:23:02Z",
        "body": "@andy-ms \r\nIt works great.\r\n\r\nFurthermore, defined types of root project(e.g: `/// <reference path=\"./root-project.d.ts\" />`) will expose to sub-project which can use those types in `root-project.d.ts` file even if sub-project does not define those types. And compiling code will not throw type error, it's unreasonable.\r\n\r\n"
      }
    ],
    "satisfaction_conditions": [
      "Ensure type declarations from sub-projects are visible to parent projects",
      "Handle type definition exposure between interconnected projects",
      "Maintain type safety across project boundaries"
    ]
  },
  {
    "number": 18676,
    "title": "Cannot find module 'vue' when 'module' is set to 'umd'",
    "created_at": "2017-09-22T02:08:27Z",
    "closed_at": "2017-09-22T05:08:51Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18676",
    "body": "**TypeScript Version:**  2.5.2\r\n\r\nwhen tsc complie `d:/elecapp/one/comp/test.ts`\r\n\r\n**Code**\r\n\r\n```javascript\r\n======== Resolving module 'vue' from 'd:/elecapp/one/comp/test.ts'. ========\r\nModule resolution kind is not specified, using 'Classic'.\r\nFile 'd:/elecapp/one/comp/vue.ts' does not exist.\r\nFile 'd:/elecapp/one/comp/vue.tsx' does not exist.\r\nFile 'd:/elecapp/one/comp/vue.d.ts' does not exist.\r\nFile 'd:/elecapp/one/vue.ts' does not exist.\r\nFile 'd:/elecapp/one/vue.tsx' does not exist.\r\nFile 'd:/elecapp/one/vue.d.ts' does not exist.\r\nFile 'd:/elecapp/vue.ts' does not exist.\r\nFile 'd:/elecapp/vue.tsx' does not exist.\r\nFile 'd:/elecapp/vue.d.ts' does not exist.\r\nFile 'd:/vue.ts' does not exist.\r\nFile 'd:/vue.tsx' does not exist.\r\nFile 'd:/vue.d.ts' does not exist.\r\nDirectory 'd:/elecapp/one/comp/node_modules' does not exist, skipping all lookups in it.\r\nDirectory 'd:/elecapp/one/node_modules' does not exist, skipping all lookups in it.\r\nFile 'd:/elecapp/node_modules/@types/vue.d.ts' does not exist.\r\nDirectory 'd:/node_modules' does not exist, skipping all lookups in it.\r\nFile 'd:/elecapp/one/comp/vue.js' does not exist.\r\nFile 'd:/elecapp/one/comp/vue.jsx' does not exist.\r\nFile 'd:/elecapp/one/vue.js' does not exist.\r\nFile 'd:/elecapp/one/vue.jsx' does not exist.\r\nFile 'd:/elecapp/vue.js' does not exist.\r\nFile 'd:/elecapp/vue.jsx' does not exist.\r\nFile 'd:/vue.js' does not exist.\r\nFile 'd:/vue.jsx' does not exist.\r\n======== Module name 'vue' was not resolved. ========\r\n```\r\n\r\n**Expected behavior:**\r\n\r\n```javascript\r\nFile 'd:/elecapp/node_modules/@types/vue.d.ts' does not exist.\r\nFile 'd:/elecapp/node_modules/vue/types/index.d.ts' exist.\r\n```\r\n\r\n**Actual behavior:**\r\n\r\n```javascript\r\nFile 'd:/elecapp/node_modules/@types/vue.d.ts' does not exist.\r\n```\r\n\r\nIt's only find `@types/vue.d.ts` does not exist , but it didn't find there is `vue/types/index.d.ts` already exists.\r\n\r\ninside /vue/package.json(there is typings):\r\n\r\n```javascript\r\n  \"typings\": \"types/index.d.ts\",\r\n  \"unpkg\": \"dist/vue.js\",\r\n  \"version\": \"2.4.4\"\r\n```\r\n\r\n\r\nps tsconfig.json:\r\n```javascript\r\n{\r\n  \"compilerOptions\": {\r\n    \"target\": \"es5\",\r\n    \"module\": \"umd\",\r\n    \"declaration\": false,\r\n    \"traceResolution\": true,\r\n    \"noImplicitAny\": false, \r\n    \"skipLibCheck\": true, \r\n    \"allowJs\": false,\r\n    \"checkJs\": false,\r\n    \"lib\": [\r\n      \"dom\",\r\n      \"scripthost\",\r\n      \"webworker\",\r\n      \"es5\",\r\n      \"es2015\",\r\n      \"es2016\",\r\n      \"es2017\",\r\n      \"esnext\"\r\n    ]\r\n  },\r\n  \"include\": [\r\n    \"one/*/*.tsx\",\r\n    \"one/*/*.ts\"\r\n  ],\r\n  \"exclude\": []\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18676/comments",
    "author": "yolio2003",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-09-22T03:18:42Z",
        "body": "Try setting your `\"moduleResolution\"` strategy to `\"node\"` which isn't the default on `\"module\": \"umd\"`"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how TypeScript resolves modules when using UMD module format",
      "Clarification on relationship between 'module' and 'moduleResolution' compiler options",
      "Solution ensuring TypeScript can locate package's own typings through its package.json 'typings' field",
      "Configuration that enables node_modules package resolution while maintaining UMD output format"
    ]
  },
  {
    "number": 18401,
    "title": "No way to type-constrain a value as object-but-not-a-function",
    "created_at": "2017-09-12T03:43:58Z",
    "closed_at": "2017-09-27T22:40:00Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18401",
    "body": "**TypeScript Version:**  2.5.2\r\n\r\nJust as `typeof someFunction === 'function'`, how do I type-constrain a generic parameter to only those types which would satisfy that same expression?\r\n\r\n**Code**\r\n\r\n```ts\r\nfunction isObject<T extends object>(value: T | string | number | boolean | symbol | Function | null | undefined): value is T {\r\n  return typeof value === 'object' && value !== null;\r\n}\r\n\r\nconst fn = function () { return 'foo'; };\r\n!isObject(fn) && fn.name; // fn.name is never\r\n```\r\n\r\n**Expected:**\r\n\r\nAfter failing the type guard check, `fn.name` should have a compile time type of `string`, seeing as `fn` is a function primitive, not a standard object primitive.\r\n\r\n**Actual:**\r\n\r\nAfter failing the type guard check, `fn.name` has a compile time type of `never`.\r\n\r\nThis issue does not occur if the function is a local function declared via a `function` statement, rather than as a variable assignment.\r\n\r\nThe `object` type seems to match variables assigned a function value, and there appears to be no primitive type keyword that TypeScript understands as meaning a value having the `function` type, rather than just an object (`Function`) that has functional characteristics. I have also tried `((...args: any[]) => any)`, though I suspect the compiler treats that the same way as `Function`. I know that in JavaScript, functions are technically objects and can have arbitrary properties attached, but they're also special in that they're callable, and are first class primitives in JavaScript in that respect, and so I would expect TypeScript would be able to help me identify objects that are *not* functions, especially seeing as functions are such an integral and fundamental type in JavaScript.\r\n\r\n**Update:**\r\n\r\nFunction overloads appear to solve the problem:\r\n\r\n```ts\r\nexport type Primitive = string | number | boolean | symbol | null | undefined;\r\n\r\nexport function isObject<T extends Function>(value: T): false;\r\nexport function isObject<T extends object>(value: T | Primitive): value is T;\r\nexport function isObject<T extends object>(value: T | Primitive): value is T {\r\n  return typeof value === 'object' && value !== null;\r\n}\r\n\r\n// compilation tests:\r\nfunction c () { return 'foo'; }\r\nconst d = function () { return 'foo'; };\r\nconst a = 'foo', b = { foo: 'bar' };\r\nisObject(a) && a.length; // good; compiles fine\r\n!isObject(a) && a.length; // good; compiles fine\r\nisObject(b) && b.foo; // good; compiles fine\r\n!isObject(b) && b.foo; // good; error as expected\r\nisObject(c) && c.name; // good; compiles fine\r\n!isObject(c) && c.name; // good; compiles fine\r\nisObject(d) && d.name; // good; compiles fine\r\n!isObject(d) && d.name; // good; compiles fine\r\n```\r\n\r\nI'll leave the issue open pending confirmation that I'm not missing any relevant caveats. Devs, feel free to close it if so.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18401/comments",
    "author": "axefrog",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-09-12T19:57:46Z",
        "body": "Not a bug; functions are a subtype of objects. There isn't a way to express `isObjectButNotFunction` (same as there isn't a way to express `isAnimalButNotDog`)"
      },
      {
        "user": "axefrog",
        "created_at": "2017-09-27T22:40:00Z",
        "body": "Ok, thanks."
      }
    ],
    "satisfaction_conditions": [
      "A type constraint that excludes function types while preserving other object types",
      "Type narrowing that correctly identifies function values after type guard checks",
      "Handling of both function expressions and function declarations consistently"
    ]
  },
  {
    "number": 18389,
    "title": "Overloading function with literal argument doesn't work",
    "created_at": "2017-09-11T15:56:31Z",
    "closed_at": "2017-09-11T16:04:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18389",
    "body": "**TypeScript Version:**  2.5.2\r\n\r\n**Code**\r\n```ts\r\nfunction test(p: 'a'): 'a';\r\nfunction test(p: string): string {\r\n    return p;\r\n}\r\n\r\ntest('b');\r\n```\r\n\r\n**Expected behavior:**\r\nno errors\r\n\r\n**Actual behavior:**\r\nArgument of type '\"b\"' is not assignable to parameter of type '\"a\"'.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18389/comments",
    "author": "dfilatov",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-09-11T15:59:21Z",
        "body": "The function has one signature. the other one is called an \"implementation\" signature, is only visible within the body of the function. so if you want your function to be called with a `string`, add a new overload.\r\n\r\n```ts\r\nfunction test(p: 'a'): 'a';\r\nfunction test(p: string): string;\r\nfunction test(p: string): string {\r\n    return p;\r\n}\r\n```"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how TypeScript function overload signatures interact with implementation signatures",
      "Demonstration of proper overload declaration syntax to handle both literal and general string types",
      "Clarification on visibility rules for TypeScript overload signatures vs implementation signatures",
      "Solution showing how to expose both literal and base type signatures to callers"
    ]
  },
  {
    "number": 18041,
    "title": "keyof strange type casting",
    "created_at": "2017-08-25T12:53:09Z",
    "closed_at": "2017-08-29T14:17:37Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18041",
    "body": "TSC 2.4.2\r\n\r\n```ts\r\nfunction foo1<T>(e: T, k: string) {\r\n    let\r\n        v = e[k];   // v: any\r\n}\r\n\r\nfunction foo2<T>(e: T, k: keyof T) {\r\n    let\r\n        v = e[k];   // v: T[keyof T]\r\n}\r\n```\r\n\r\nI would expect that for `foo2` type of `v` should also be `any`",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18041/comments",
    "author": "pankleks",
    "comments": [
      {
        "user": "ikatyang",
        "created_at": "2017-08-25T13:49:24Z",
        "body": "`v` in `foo2` must be something in `e`, `T[keyof T]` did describe its relationship well."
      },
      {
        "user": "pankleks",
        "created_at": "2017-08-29T12:18:42Z",
        "body": "@ikatyang not sure I understand your answer - could you please elaborate a bit more - thanks:)"
      },
      {
        "user": "ikatyang",
        "created_at": "2017-08-29T12:50:50Z",
        "body": "Not sure how to elaborate, lets take an example. Imagine passing `MyObject` as `T` into that function:\r\n\r\n```ts\r\ninterface MyObject {\r\n  a: boolean;\r\n  b: number;\r\n  c: string;\r\n}\r\n\r\ntype MyKeys = keyof MyObject; //=> 'a' | 'b' | 'c'\r\ntype MyValues = MyObject[MyKeys]; //=> boolean | number | string\r\n\r\nfunction foo1<T>(e: T, k: string) {\r\n    //           ^     ^ string\r\n    //           MyObject\r\n    let\r\n        v = e[k];\r\n    //  ^ MyObject[string] = ??? = any\r\n    //    (string is not one of its keys, so TS think it can be anything.)\r\n    //    (keys are string, but string is not key, since key is more specific.)\r\n}\r\n\r\nfunction foo2<T>(e: T, k: keyof T) {\r\n    //           ^     ^ MyKeys\r\n    //           MyObject\r\n    let\r\n        v = e[k];\r\n    //  ^ MyObject[MyKeys] = MyValues = boolean | number | string\r\n    //    (MyKeys is one of its keys, so TS knows how to get its type)\r\n}\r\n```"
      },
      {
        "user": "pankleks",
        "created_at": "2017-08-29T14:17:37Z",
        "body": "It's smarter than I assumed - just notation `T[keyof T]` is a little confusing :)\r\n\r\nThanks!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why T[keyof T] is inferred instead of 'any' when using keyof constraint",
      "Comparison between string keys vs keyof-constrained keys in type safety",
      "Clarification of TypeScript's indexed access type semantics",
      "Demonstration of type relationship preservation with keyof"
    ]
  },
  {
    "number": 18002,
    "title": "Signature test with overloading not working",
    "created_at": "2017-08-24T09:19:41Z",
    "closed_at": "2017-08-24T10:49:24Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18002",
    "body": "**TypeScript Version:**  2.4.1\r\n\r\n**Code**\r\n\r\n```ts\r\nexport class api {\r\n    public static works();\r\n    public static works(propertyName: string);\r\n    public static works(propertyNames: string[]);\r\n\r\n    public static works(propertyName?: string | string[]) {\r\n        return system.testing(propertyName as string); // No idea why the type assertion is needed\r\n    }\r\n    public static worksNot();\r\n    public static worksNot(propertyName: string);\r\n    public static worksNot(propertyNames: string[]);\r\n\r\n    public static worksNot(propertyName?: string | string[]) {\r\n        return system.testing(propertyName); // compile error!\r\n    }\r\n}     \r\n\r\nexport class system {\r\n    public static testing();\r\n    public static testing(propertyName: string);\r\n    public static testing(propertyNames: string[]);\r\n    // [Edit] needs\r\n    //public static testing(propertyName?: string | string[])\r\n\r\n    public static testing(propertyName?: string | string[]) {\r\n        // Do some stuff with string or string[]\r\n        return;\r\n    }\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nShould compile without a problem\r\n**Actual behavior:**\r\n error TS2345: Build:Argument of type 'string | string[]' is not assignable to parameter of type 'string[]'.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18002/comments",
    "author": "HolgerJeromin",
    "comments": [
      {
        "user": "ikatyang",
        "created_at": "2017-08-24T09:44:43Z",
        "body": "Duplicate of #17508."
      },
      {
        "user": "HolgerJeromin",
        "created_at": "2017-08-24T10:15:55Z",
        "body": "Thanks for the link. \r\nBut IMO this is still a bug."
      },
      {
        "user": "kitsonk",
        "created_at": "2017-08-24T10:23:02Z",
        "body": "It maybe your opinion, but this has been discussed quite a lot before.  #17508 is just one example.\r\n\r\nThe reason it doesn't work is because of the need for co-variant types, which at the moment is problematic with TypeScript.  That being said, it also is totally redundant now that we have union types.  We used to have to expand overloads because we didn't have the union types, now we don't."
      },
      {
        "user": "HolgerJeromin",
        "created_at": "2017-08-24T10:49:24Z",
        "body": "Ok, thanks a lot both of you. My usecase is solvable. \r\nAnd you are right. It is better to leave it like that for the big picture."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why TypeScript requires type assertions when passing union types to overloaded methods",
      "Clarification of proper overload usage with union type parameters",
      "Solution that maintains type safety while allowing flexible parameter types (string|string[])",
      "Guidance on when to use overloads vs union types in TypeScript"
    ]
  },
  {
    "number": 17854,
    "title": "deconstruction of the object ",
    "created_at": "2017-08-17T02:44:22Z",
    "closed_at": "2017-08-17T03:16:22Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17854",
    "body": "let obj = {\r\n    p: [\r\n      'Hello',\r\n      { y: 'World' }\r\n    ]\r\n  };\r\n  \r\n  let { p, p: [x, { y }] } = obj;\r\n \r\n\r\nwhy \r\nerror TS2459: Type 'string | {\r\ny: string; }' has no property 'y' and no strin\r\ng index signature.???????????",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17854/comments",
    "author": "JLBear",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2017-08-17T02:57:23Z",
        "body": "Can you please format your code examples using GitHub flavored markdown?\r\n```markdown\r\n```ts\r\nTypeScript code here\r\n```\r\n```"
      },
      {
        "user": "ikatyang",
        "created_at": "2017-08-17T03:01:31Z",
        "body": "The type for property will always be widened (no tuple, no literal type) unless place it in the place contextual type inference is available, e.g.\r\n\r\n(original)\r\n\r\n```ts\r\nlet obj = {\r\n  p: ['Hello', { y: 'World' }],\r\n}; //=> { p: (string | { y: string })[] }\r\n\r\nlet { p, p: [x, { y }] } = obj;\r\n//                ^ [ts] Type 'string | { y: string; }' has no property 'y' and no string index signature.\r\n```\r\n\r\n(solution 1)\r\n\r\n```ts\r\nlet { p, p: [x, { y }] } = {\r\n  p: ['Hello', { y: 'World' }],\r\n}; // works fine\r\n```\r\n\r\n(solution 2)\r\n\r\n```ts\r\nfunction deconstruction({ p, p: [x, { y }] }) {\r\n  // do something\r\n}\r\n\r\ndeconstruction({\r\n  p: ['Hello', { y: 'World' }],\r\n}); // works fine\r\n```"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of TypeScript's type widening behavior in object destructuring",
      "Clarification of contextual type inference requirements",
      "Identification of type safety mechanisms in destructuring patterns",
      "Guidance on maintaining type information through declaration contexts"
    ]
  },
  {
    "number": 17795,
    "title": "Type loss when using generic decorators",
    "created_at": "2017-08-15T04:50:06Z",
    "closed_at": "2017-09-06T19:01:22Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17795",
    "body": "**TypeScript Version:**  2.4.1\r\n\r\nThe following code aims to restrict the decorator `decorate` to members of a class inheriting from `Base`. However, it seems that `K` ends up only including members in `Base`, not in the inherited class. (This is a minimal reproducible example for other cases, e.g., restricting the decorator to methods within subclasses of `Base` of a certain return type.)\r\n\r\n**Code**\r\n\r\n```ts\r\nabstract class Base {\r\n  base() { return 1; };\r\n}\r\n\r\ntype ProtoOf<T> = Pick<T, keyof T>;\r\n\r\nfunction decorate<T extends Base, K extends keyof ProtoOf<T>, F extends T[K]>() {\r\n  return (proto: ProtoOf<T>, propertyKey: K, descriptor: TypedPropertyDescriptor<F>) => {\r\n    // Do stuff.\r\n  };\r\n}\r\n\r\nclass Test extends Base {\r\n  @decorate()\r\n  bar(): boolean {\r\n    return false;\r\n  }\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nNo errors when applying `@decorate()` to `bar()`.\r\n\r\n**Actual behavior:**\r\nError: `[ts] Argument of type '\"bar\"' is not assignable to parameter of type '\"base\"'.`",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17795/comments",
    "author": "oleg-codaio",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2017-08-16T03:15:11Z",
        "body": "You can work around it by returning a generic decorator from your decorator factory.\r\n```ts\r\nfunction decorate() {\r\n  return <T extends Base, K extends keyof T, F extends T[K]>\r\n    (proto: ProtoOf<T>, propertyKey: K, descriptor: TypedPropertyDescriptor<F>) => {\r\n    // Do stuff.\r\n  };\r\n}\r\n\r\nclass Test extends Base {\r\n  @decorate() bar(): boolean {\r\n    return false;\r\n  }\r\n}\r\n```\r\nI think this behavior is correct since it is equivalent to writing\r\n```ts\r\n\r\nfunction decorate<T extends Base, K extends keyof ProtoOf<T>, F extends T[K]>() {\r\n  return (proto: ProtoOf<T>, propertyKey: K, descriptor: TypedPropertyDescriptor<F>) => {\r\n    // Do stuff.\r\n  };\r\n}\r\n\r\nconst decorator = decorate();\r\n\r\nclass Test extends Base {\r\n  @decorator bar(): boolean {\r\n    return false;\r\n  }\r\n}\r\n```"
      },
      {
        "user": "oleg-codaio",
        "created_at": "2017-08-16T19:11:41Z",
        "body": "@aluanhaddad thanks for the update! Your solution does address the issue in my earlier example, though I guess the actual problem I was having had to do with decorator arguments:\r\n\r\n```\r\nfunction decorate<T extends Base>(property: keyof T) {\r\n  return <U extends T, K extends keyof U, F extends U[K]>\r\n    (proto: ProtoOf<U>, propertyKey: K, descriptor: TypedPropertyDescriptor<F>) => {\r\n    // Do stuff.\r\n  };\r\n}\r\n\r\nclass Test extends Base {\r\n  @decorate('foo') bar(): boolean {\r\n    return false;\r\n  }\r\n\r\n  foo(): boolean { return false; }\r\n}\r\n```\r\n\r\nSo the decorator works on `bar()` fine now, but is failing with this error: `[ts] Argument of type '\"foo\"' is not assignable to parameter of type '\"base\"'.` Basically, is there a good way of having the decorator parameters be generic w.r.t. the decorated class?\n\n---\n\nOn another note, if `bar()` is marked private, then the original error returns - it seems that in this case, the decorator is only able to access public properties? My gut feeling is this is a limitation we'd have to deal with."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-08-22T22:24:53Z",
        "body": "Just nothing that this `function decorate<T extends Base>(property: keyof T)`  does not have any place to infer `T`, you can not infer a type from a name of one of its properties. and remember decorate is a factory that returns a function that will be used to decorate. so it is equivalent to `decorate(property: keyof Base)`, which means you can only decorate properties that have the same name as ones in `Base`.\r\n\r\nSo @aluanhaddad's suggestion seems like the correct solution here.\r\n"
      },
      {
        "user": "oleg-codaio",
        "created_at": "2017-08-22T22:40:04Z",
        "body": "Your explanation makes sense. Though the issue still stands that it doesn't seem currently possible to have decorate properties work off the decorated class. It would be great if there was a way to give \"context\" to decorator properties as to what exact object they're decorating."
      },
      {
        "user": "aluanhaddad",
        "created_at": "2017-08-23T15:15:04Z",
        "body": "@vaskevich I'm not sure if I understand what you are trying to achieve correctly, but you can capture a string literal type parameter when the decorator factory is applied and then subsequently validate that this property exists on the class with the decorated method.\r\n\r\nSo, going back to your example, you can validate that a `foo` member exists on the decorated class and we can even place constraints on its type. For example, in the following, `Test` must have a callable member `foo` that has the same return type as the decorated member.\r\n\r\n(Warning these types are pretty hard to read and I experienced several language service crashes in VS code due to recursion while working them out.)\r\n\r\n```ts\r\ntype ProtoOf<T> = Pick<T, keyof T>;\r\n\r\nfunction decorate<CK extends string>(property: CK) {\r\n\r\n  return <\r\n    T extends Base & {[P in CK]: G},\r\n    K extends keyof T,\r\n    F extends T[K] & G,\r\n    G extends  ((...args: {}[]) => R),\r\n    R>(\r\n      proto: ProtoOf<T> & {[P in CK]: (...args: {}[]) => R},\r\n      propertyKey: K,\r\n      descriptor: TypedPropertyDescriptor<F>) => {\r\n    // Do stuff.\r\n  };\r\n}\r\n\r\nclass Test extends Base {\r\n  @decorate('foo') bar(): boolean {\r\n    return false;\r\n  }\r\n\r\n  foo(): boolean {return false;}\r\n}\r\n````\r\nThe way this works is by capturing a type for the argument to the factory and using that argument to define the expected shape of the object that will be decorated. The declaration of `G` and the intersection type used to describe the target of the decorator was an experiment that seemed to work. The intent was that if we change `foo` to return a type not assignable to the return type of `bar`, we will get an error at the decorator application site.\r\n\r\nNote that the the declaration of T is provided, as in my previous example, by the decorator and not the decorator factory."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-09-06T19:01:21Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      },
      {
        "user": "oleg-codaio",
        "created_at": "2017-09-06T19:12:48Z",
        "body": "Thanks for the replies - I haven't been able to take a look at this again yet, but will open a new issue if there's a specific defect here (which doesn't seem to be the case)."
      }
    ],
    "satisfaction_conditions": [
      "Decorator must preserve type information from inherited classes",
      "Solution must support decorator parameters that reference subclass properties",
      "Type constraints must handle method return types in decorated classes",
      "Approach must work with private class members",
      "Type inference should not require explicit generic parameters"
    ]
  },
  {
    "number": 17333,
    "title": "Relax rule about `super` followed by member access",
    "created_at": "2017-07-20T22:33:00Z",
    "closed_at": "2017-07-22T01:07:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17333",
    "body": "I have a method that takes a class type. I can pass an explicit class name to it `Foo`, or I can pass `this`, but I cannot pass `super` because of the ts error:\r\n\r\n> 'super' must be followed by an argument list of member access.\r\n\r\nIs there a specific design goal behind disabling this?\r\n\r\n**TypeScript Version:**  2.4.1\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17333/comments",
    "author": "yebrahim",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-07-20T23:40:32Z",
        "body": "> Is there a specific design goal behind disabling this?\r\n\r\nIt's not in any sense \"disabled\" as much as simply not existing in the first place - it's not legal ES6 code to nakedly reference `super`, and there's not an immediately obvious ES5 transpilation."
      },
      {
        "user": "yebrahim",
        "created_at": "2017-07-22T01:07:59Z",
        "body": "I see, I'll close this then. Thanks for the quick reply!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why TypeScript prohibits standalone `super` references in this context",
      "Clarification of ES6 compliance requirements that influence this behavior",
      "Identification of transpilation challenges with ES5 targets"
    ]
  },
  {
    "number": 17034,
    "title": "how to disable 'this' tranform to '_this'\uff0cI want to add linq extension metthod for Array",
    "created_at": "2017-07-08T16:49:51Z",
    "closed_at": "2017-07-08T17:47:22Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17034",
    "body": "I want to add linq extension metthod for Array, like c# static Extension method\u3002\r\n\r\nhere is the code\r\n\r\ndeclare interface Array<T> {\r\n    where(predicate: (value?: T, index?: number, list?: T[]) => boolean): T[];\r\n}\r\nArray.prototype.where = (predicate?: (value?: T, index?: number, list?: T[]) => boolean) => {\r\n return this.filter(predicate);\r\n};\r\n\r\nbut the tsc compiled 'this 'into '_this',and code work incorrect.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17034/comments",
    "author": "mokeyish",
    "comments": [
      {
        "user": "ikatyang",
        "created_at": "2017-07-08T16:55:50Z",
        "body": "You should use `function () { /* ... */ }`(function) instead of `() => { /* ... */ }`(arrow-function), arrow-function is a function that does not have its own `this`."
      },
      {
        "user": "mokeyish",
        "created_at": "2017-07-08T17:08:39Z",
        "body": "@ikatyang Thank you for your answer.The problem's been solved."
      }
    ],
    "satisfaction_conditions": [
      "Preserves correct 'this' context in Array prototype extension methods",
      "Enables LINQ-style extension methods for native Array type",
      "Avoids arrow function syntax for prototype method definitions"
    ]
  },
  {
    "number": 16935,
    "title": "Compiler API transpile type cast code wrong.",
    "created_at": "2017-07-05T03:12:16Z",
    "closed_at": "2017-07-05T06:35:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16935",
    "body": "**TypeScript Version:**  2.3.4 \r\n\r\n**Code**\r\n- compiler api invoke\r\n```ts\r\nimport * as ts from \"typescript\";                                                                                                                                                       \r\nfunction _go_transpileModule(script: string): string {\r\n    let result = ts.transpileModule(script, {compilerOptions: {module: ts.ModuleKind.CommonJS, target: ts.ScriptTarget.ES5}}); \r\n    return result.outputText;\r\n}  \r\n```\r\nI call _go_transpileModule method in myself embed v8 engine application, not node.js.\r\n\r\n- ts source code\r\n```ts\r\nfunction sqlDemo() {                                           \r\n                                                               \r\n    try {                                                      \r\n        let s = db.sql();                                      \r\n        let records = <Object[]>s.exec('select * from script');\r\n                                                               \r\n        records.forEach((r) => printRecord(r));                \r\n                                                               \r\n        for (let i = 0; i < records.length; i++) {             \r\n            printRecord(records[i]);                           \r\n        }                                                      \r\n                                                               \r\n        s.exec(\"update script set id = 1111 where id = 1;\");   \r\n    } catch (error) {                                          \r\n        console.log(error.name, error.message);                \r\n    }                                                          \r\n}                       \r\n\r\n```\r\n\r\n- the javascript code after transpiled\r\n```js\r\nfunction sqlDemo() {\r\n    try {\r\n        var s = db.sql();\r\n        var records = <Object />, _a =  > s.exec('select * from script');\r\n        records.forEach(function (r) { return printRecord(r); });\r\n        for (var i = 0; i < records.length; i++) {\r\n            printRecord(records[i]);\r\n        }\r\n        s.exec(\"update script set id = 1111 where id = 1;\");\r\n    }\r\n    catch (error) {\r\n        console.log(error.name, error.message);\r\n    }\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n\r\neverything is ok.\r\n\r\n**Actual behavior:**\r\n\r\nbut the follow code:\r\n```ts\r\n<Object[]>\r\n```\r\n has been translated to \r\n```js\r\n<Object />, _a =  >\r\n```\r\n\r\nHow can I solve this problem?\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16935/comments",
    "author": "saibing",
    "comments": [
      {
        "user": "ikatyang",
        "created_at": "2017-07-05T03:44:05Z",
        "body": "It seems something might be wrong with your `jsx` config, can you give a try with\r\n\r\n```js\r\ntranspileOptions = {compilerOptions: {jsx: ts.JsxEmit.None, /* ... */}, /* ... */}\r\n``` \r\n\r\nor \r\n\r\n```js\r\ntranspileOptions = {fileName: 'something.ts', /* ... */}\r\n```"
      },
      {
        "user": "saibing",
        "created_at": "2017-07-05T06:35:34Z",
        "body": "@ikatyang \r\n\r\nThank you very much. it works well."
      }
    ],
    "satisfaction_conditions": [
      "Ensure TypeScript compiler API doesn't misinterpret angle bracket type assertions as JSX elements",
      "Provide proper configuration to distinguish TypeScript files from JSX files during transpilation",
      "Maintain valid JavaScript output syntax while preserving type assertion intent"
    ]
  },
  {
    "number": 16927,
    "title": "Failed to launch external program tsc -p ts spawn tsc ENOENT",
    "created_at": "2017-07-04T16:06:56Z",
    "closed_at": "2017-08-17T17:25:56Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16927",
    "body": "**TypeScript Version:**  2.4.1\r\n**VSCode Version:** 1.3.1\r\n**OS Version:** Linux Mint 18.1\r\n**node:** 6.11.0\r\n**npm:** 5.0.3\r\n\r\nSteps to Reproduce:\r\n\r\nOpen VSCode insider from Nemo or from terminal\r\nTry to run build task **Ctrl+Shift+B** (using tsc -p in task.json 'args')\r\n\r\ntasks.json\r\n```javascript\r\n{\r\n    \"version\": \"0.1.0\",\r\n    \"command\": \"tsc\",\r\n    \"isShellCommand\": true,\r\n    \"args\": [\"-p\", \"ts\"],\r\n    \"showOutput\": \"silent\",\r\n    \"problemMatcher\": \"$tsc\"\r\n}\r\n```\r\n\r\nhelloworld.ts in **ts** folder\r\n```typescript\r\nclass HelloWorld {\r\n    \r\n}\r\n```\r\ntsconfig.json\r\n```javascript\r\n{\r\n    \"compilerOptions\": {\r\n        \"target\": \"es5\",\r\n        \"outFile\": \"../js/app.js\",\r\n        \"sourceMap\": true\r\n    }\r\n}\r\n```\r\n\r\nEmpty folder **js**\r\n\r\n**Expected behavior:**\r\nI believe that this setup should compile the typescrpt files in my project to js files and put them in my js folder.\r\n\r\n**Actual behavior:**\r\nWhen I hit **Ctrl+Shift+B** i get: \r\n**Failed to launch external program tsc -p ts.**\r\n**spawn tsc ENOENT**\r\nin the output window\r\n\r\nIts worth noting that if I run the **tsc** command with args in the VSCode terminal window in my projects root directory (tsc -p ts) it **DOES** seem to work fine(I get the expected behavior). \r\n\r\nThis issues is similar to #8434 \r\nI do have custom code in my .profile and .bashrc, but in my case it does not matter if I open from the terminal or from the file explorer\r\n\r\nrunning process.env.PATH in VScode dev tools console outputs the same path as running echo $PATH from my command line. ",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16927/comments",
    "author": "kylerdanielster",
    "comments": [
      {
        "user": "leonadler",
        "created_at": "2017-07-05T13:00:43Z",
        "body": "This is normally caused by `tsc` not being in your $PATH. Double-check if your global node_modules/.bin is reachable outside of bash, e.g. via running `which tsc` in `sh`/`zsh`.\r\n\r\nWhile not a fix for your issue per se, consider running the local `tsc` in your project:\r\n```json\r\n{\r\n    \"version\": \"0.1.0\",\r\n    \"command\": \"node\",\r\n    \"isShellCommand\": true,\r\n    \"args\": [\"${workSpaceRoot}/node_modules/typescript/bin/tsc\", \"-p\", \"ts\"],\r\n    \"showOutput\": \"silent\",\r\n    \"problemMatcher\": \"$tsc\"\r\n}\r\n```\r\n\r\nThis allows you to track the version of the TypeScript compiler you want to use in your package.json independent of the globally installed one (`npm i -g typescript`)."
      },
      {
        "user": "kylerdanielster",
        "created_at": "2017-07-09T02:00:22Z",
        "body": "This worked.\r\n\r\nInstalled typescript locally with `npm i typescript` and changed tasks.json to \r\n```\r\n{\r\n    \"version\": \"0.1.0\",\r\n    \"command\": \"node\",\r\n    \"isShellCommand\": true,\r\n    \"args\": [\"{pathToWorkSpaceRoot}/node_modules/typescript/bin/tsc\", \"-p\", \"ts\"],\r\n    \"showOutput\": \"silent\",\r\n    \"problemMatcher\": \"$tsc\"\r\n}\r\n```\r\nWhich as you say \"allows you to track the version of the TypeScript compiler you want to use in your package.json independent of the globally installed one\". Seems like a good idea. \r\n\r\nI think it is worth noting that: ~/.npm-global/bin is in my path which contains the tsc package. This should be equivalent to node_modules/.bin I believe. \r\n\r\nRegardless, running 'sh' and 'tcs' I get 'tsc: not found'."
      },
      {
        "user": "leonadler",
        "created_at": "2017-07-10T09:36:25Z",
        "body": "@kylerdanielster glad it solves your issue!\r\nJust a little addendum, since you wrote \"{pathToWorkSpaceRoot}\", I assume you hard-coded the path - you can use the actual string `${workSpaceRoot}` so it works regardless of where you checkout the project."
      },
      {
        "user": "kylerdanielster",
        "created_at": "2017-07-11T00:14:53Z",
        "body": "@leonadler \"${workSpaceRoot}/node_modules/typescript/bin/tsc\" did not work for me, that is why I hard coded it. \r\n\r\nI played around with the path some more and \"node_modules/typescript/bin/tsc\" this did the trick as well.\r\n\r\nCurrent task.json (in .vscode folder)\r\n```\r\n{\r\n    \"version\": \"0.1.0\",\r\n    \"command\": \"node\",\r\n    \"isShellCommand\": true,\r\n    \"args\": [\"node_modules/typescript/bin/tsc\", \"-p\", \"ts\"],\r\n    \"showOutput\": \"silent\",\r\n    \"problemMatcher\": \"$tsc\"\r\n}\r\n```"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-08-17T17:25:56Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ],
    "satisfaction_conditions": [
      "Ensure tsc executable is properly resolved in VSCode's execution environment",
      "Support project-specific TypeScript version management",
      "Handle environment variable differences between shell and VSCode runtime",
      "Provide reliable path resolution for build tools",
      "Avoid dependency on global npm package installations"
    ]
  },
  {
    "number": 16812,
    "title": "Add an \"argument is not type\" operator",
    "created_at": "2017-06-28T21:04:10Z",
    "closed_at": "2017-08-17T17:26:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16812",
    "body": "We already have:\r\n```ts\r\nfunction isNotUndefined(obj:any): obj is string | number | boolean | MyCustomType | null | MyOtherCustomType {\r\n    return typeof obj !== \"undefined\";\r\n}\r\n```\r\n\r\nNow we just need:\r\n\r\n```ts\r\nfunction isNotUndefined(obj:any): obj is not undefined { // or isnot\r\n    return typeof obj !== \"undefined\";\r\n}",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16812/comments",
    "author": "Arlen22",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2017-06-28T21:09:00Z",
        "body": "Dupe (or heavily related to) #4183"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-06-28T21:16:53Z",
        "body": "```ts\r\nfunction isNotUndefined<T>(obj: T | undefined): obj is T {\r\n    return typeof obj !== \"undefined\";\r\n}\r\nvar x = Math.random() > 0.5 ? undefined : 32;\r\nif (isNotUndefined(x)) {\r\n    console.log(x.toFixed());\r\n}\r\n```"
      },
      {
        "user": "Arlen22",
        "created_at": "2017-06-28T23:25:52Z",
        "body": "```ts\r\nconst test: (string | undefined)[] = []\r\ntest.filter(<T>(a: T): a is T | undefined => { \r\n    return !!a; \r\n}).map(t => {\r\n    // t is string | undefined\r\n})\r\n```"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-06-28T23:43:48Z",
        "body": "@Arlen22 why did you write the predicate wrong? This works in 2.4:\r\n```ts\r\nconst test: (string | undefined)[] = []\r\ntest.filter(<T>(a: T | undefined): a is T => { \r\n    return !!a; \r\n}).map(t => {\r\n    t;\r\n    // t is string\r\n})\r\n```"
      },
      {
        "user": "Arlen22",
        "created_at": "2017-06-29T00:23:47Z",
        "body": "~~Strange. In 2.4.1:~~\r\n```ts\r\nconst test: (string | undefined)[] = []\r\ntest.filter(<T>(a: T | undefined): a is T => { \r\n    return !!a; \r\n}).map(t => {\r\n    let r: string = t; //Error: Type 'string | undefined' is not assignable to type 'string'\r\n})\r\n```\n\n---\n\nNevermind, I forgot to update my global tsc. Now I'm seeing the new feature. Nice :)\n\n---\n\nAny idea what PR brought this in?"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-06-29T00:24:28Z",
        "body": "#11858"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-08-17T17:26:00Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ],
    "satisfaction_conditions": [
      "Support type negation in type predicates without explicitly listing all possible types",
      "Type narrowing must work correctly in array filter operations",
      "Solution must be compatible with TypeScript's existing type system features",
      "Clear documentation of version availability for the feature"
    ]
  },
  {
    "number": 16629,
    "title": "Change return type by type guard",
    "created_at": "2017-06-19T20:54:04Z",
    "closed_at": "2017-06-19T21:07:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16629",
    "body": "```\r\nclass Foo {\r\n  foo = 123;\r\n}\r\nclass Bar {\r\n  bar = 123;\r\n}\r\nfunction distinguish(arg: Foo | Bar): Foo | Bar {\r\n  if(arg instanceof Foo) {\r\n    return arg\r\n  }\r\n  else {\r\n    return arg\r\n  }\r\n}\r\nlet result: Foo = distinguish(new Foo())\r\n// Type 'Foo | Bar' is not assignable to type 'Foo'\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16629/comments",
    "author": "pravdomil",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-06-19T21:04:40Z",
        "body": "I'm not sure what you're asking or what the motivating scenario is, but would this fix it?\r\n\r\n```ts\r\nfunction distinguish<T extends Foo | Bar>(arg: T): T {\r\n  if (arg instanceof Foo) {\r\n    return arg\r\n  }\r\n  else {\r\n    return arg\r\n  }\r\n}\r\n```\r\n"
      },
      {
        "user": "pravdomil",
        "created_at": "2017-06-19T21:07:57Z",
        "body": "yea!"
      }
    ],
    "satisfaction_conditions": [
      "The solution must narrow the return type based on type guard checks",
      "Type inference must preserve input type specificity",
      "Avoid unnecessary type assertions while maintaining type safety"
    ]
  },
  {
    "number": 16192,
    "title": "can any one tell me how to implement extension method for Array in Typescript (Let's suppose i want to write functionality for sorting the array )",
    "created_at": "2017-06-01T11:29:42Z",
    "closed_at": "2017-06-05T22:05:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16192",
    "body": "",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16192/comments",
    "author": "Prashant3108",
    "comments": [
      {
        "user": "ikatyang",
        "created_at": "2017-06-01T11:39:56Z",
        "body": "(./extend.ts)\r\n\r\n```ts\r\ndeclare global {\r\n  interface Array<T> {\r\n    some_method(): this;\r\n  }\r\n}\r\n\r\nArray.prototype.some_method = function () {\r\n  return this.sort().reverse();\r\n};\r\n\r\nexport {};\r\n```\r\n\r\n(./test.ts)\r\n\r\n```ts\r\nimport './extend';\r\n\r\nconst a = ['abc', 'def'].some_method();\r\n```\r\n\r\nIs this what you want?\r\n\r\n"
      },
      {
        "user": "Prashant3108",
        "created_at": "2017-06-01T14:14:51Z",
        "body": "yes, thanks"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-06-05T22:05:12Z",
        "body": "This is an issue tracker, not a support forum. Please use an appropriate venue for questions as indicated in the template."
      }
    ],
    "satisfaction_conditions": [
      "Demonstrates how to extend the built-in Array type interface in TypeScript",
      "Shows proper TypeScript declaration merging technique for native types",
      "Ensures the extension method is available across files after import"
    ]
  },
  {
    "number": 15994,
    "title": "Control flow type narrowing doesn't work",
    "created_at": "2017-05-22T15:24:34Z",
    "closed_at": "2017-05-22T16:00:06Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15994",
    "body": "**TypeScript Version:**  2.3.2\r\n\r\n**Code**\r\n\r\n```ts\r\ntype JoinModels<A, K extends string, B> = A & {\r\n    [k in K]: B;\r\n};\r\n\r\ninterface User {\r\n    username: string;\r\n}\r\n\r\ninterface Post {\r\n    title: string;\r\n}\r\n\r\ntype UserWithPosts = JoinModels<User, \"posts\", Post[]> | null;\r\n\r\nlet userWithPosts: UserWithPosts = null;\r\nif (userWithPosts == null) {\r\n    console.log(userWithPosts.posts[0].title);\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n`userWithPosts` should be narrowed to null;\r\n\r\n**Actual behavior:**\r\nNo error occurs",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15994/comments",
    "author": "CurlerRoo",
    "comments": [
      {
        "user": "blakeembrey",
        "created_at": "2017-05-22T15:32:21Z",
        "body": "@pc-lover If you enable `strictNullChecks`, this should work as expected. Without it, there is no `null` or `undefined` types used. Do you have an expected behaviour without `strictNullChecks` enabled?"
      },
      {
        "user": "CurlerRoo",
        "created_at": "2017-05-22T16:00:03Z",
        "body": "@blakeembrey I'm sorry, my mistake"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why strictNullChecks is required for null type narrowing",
      "Clarification of how TypeScript compiler flags affect type narrowing logic",
      "Identification of required compiler options for null type safety"
    ]
  },
  {
    "number": 15976,
    "title": "Compiler API: How to get the \"type\" of an interface?",
    "created_at": "2017-05-21T07:27:45Z",
    "closed_at": "2017-05-22T18:26:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15976",
    "body": "**TypeScript Version:**  2.3.2\r\n\r\n**Code**\r\n\r\nGiven an interface like this:\r\n\r\n```ts\r\n/**\r\n * The props which can be passed to `<Foo/>`.\r\n */\r\nexport interface FooProps {\r\n  /**\r\n   * Use a date formatted as RFC 3339/ISO 8601 (e.g. `'2017-02-22T10:36:24Z'`).\r\n   */\r\n  date: string;\r\n}\r\n```\r\n\r\nI'd like to get the documentation of the interface. Currently I do something like this:\r\n\r\n```ts\r\nconst exports = checker.getExportsOfModule(checker.getSymbolAtLocation(sourceFile));\r\nconst docs: Array<DocumentedExport> = exports.map(exportedSymbol => {\r\n    const symbol = getOriginalSymbol(exportedSymbol, checker);  // returns exportedSymbol or the aliased symbol if it is a re-export\r\n    const documentation = displayPartsToString(symbol.getDocumentationComment());\r\n\r\n    const declaration = symbol.declarations![0];\r\n    const sourceFile = declaration.getSourceFile();\r\n    const { fileName } = sourceFile;\r\n    const { line, character } = sourceFile.getLineAndCharacterOfPosition(declaration.getStart());\r\n    const type = checker.typeToString(checker.getTypeOfSymbolAtLocation(symbol, declaration));\r\n\r\n    if (declaration.kind === SyntaxKind.InterfaceDeclaration) {\r\n      console.log('Found FooProps!');\r\n    }\r\n\r\n    return {\r\n      name: symbol.getName(),\r\n      kind: declaration.kind,\r\n      fileName,\r\n      line,\r\n      character,\r\n      documentation,\r\n      type  // this is `'any'`\r\n    }\r\n  });\r\n```\r\n\r\nMy `type` is `'any'`. Shouldn't it be something like `{ date: string; }`? And how would I get the documentation for `date` (the `Use a date formatted as...'` line).`? \r\n\r\nThank you :)",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15976/comments",
    "author": "donaldpipowitch",
    "comments": [
      {
        "user": "donaldpipowitch",
        "created_at": "2017-05-21T18:34:17Z",
        "body": "Is this the correct way? :)\r\n\r\n```ts\r\nconst exports = checker.getExportsOfModule(checker.getSymbolAtLocation(sourceFile));\r\nconst docs: Array<DocumentedExport> = exports.map(exportedSymbol => {\r\n  const symbol = getOriginalSymbol(exportedSymbol, checker);  // returns exportedSymbol or the aliased symbol if it is a re-export\r\n  const documentation = displayPartsToString(symbol.getDocumentationComment());\r\n\r\n  const declaration = symbol.declarations![0];\r\n  const sourceFile = declaration.getSourceFile();\r\n  const { fileName } = sourceFile;\r\n  const { line, character } = sourceFile.getLineAndCharacterOfPosition(declaration.getStart());\r\n  let type = checker.typeToString(checker.getTypeOfSymbolAtLocation(symbol, declaration));\r\n\r\n  if (declaration.kind === SyntaxKind.InterfaceDeclaration) {\r\n    type = checker.typeToString(checker.getTypeAtLocation(declaration));\r\n  }\r\n\r\n  return {\r\n    name: symbol.getName(),\r\n    kind: declaration.kind,\r\n    fileName,\r\n    line,\r\n    character,\r\n    documentation,\r\n    type  // this is `'FooProps'` now \\o/\r\n  }\r\n});\r\n```\r\n\r\nCan someone explain me when `getTypeOfSymbolAtLocation` and when `getTypeAtLocation` should be used?\r\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-05-22T17:35:16Z",
        "body": "There are two functions, `getDeclaredTypeOfSymbol` and `getTypeOfSymbol`. The former is for getting the types of *types*, the latter is for getting the types of *values*. So `getTypeOfSymbol(/*the FooProps symbol*/)` tries to get the type of the *value identifier* (variable) named `FooProps`. `getDeclaredTypeOfSymbol` will do the right thing here.\r\n\r\nI cannot coherently explain the naming convention in a way that would let anyone intuit this behavior."
      },
      {
        "user": "donaldpipowitch",
        "created_at": "2017-05-23T11:40:05Z",
        "body": "Cool, thank you again. \u2764\n\n---\n\n> There are two functions, getDeclaredTypeOfSymbol and getTypeOfSymbol.\r\n\r\n@RyanCavanaugh  There is a `getTypeOfSymbol` function in the `checker.ts`, but it is not public. Should it be public? Or is `getTypeOfSymbolAtLocation` (which is public) basically for similar use cases like `getTypeOfSymbol`?\r\n\r\n(`getDeclaredTypeOfSymbol` is on the public `interface TypeChecker`.)\n\n---\n\n> The former is for getting the types of types\r\n\r\nTypes of types are... `interface` and `type`? So basically TypeScript keywords/primitives which aren't included in your compiled JS code?"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-05-23T19:07:04Z",
        "body": "Not sure on the first question.\r\n\r\nFor the second, there are also classes and imports to consider. The identifier for a class resolves to both a value (which is the constructor function) and a type (the instance type); similarly an `import`ed identifier *may* have both type and value meanings (or possibly neither, if it's a namespace)."
      }
    ],
    "satisfaction_conditions": [
      "Clarification of TypeChecker method selection criteria",
      "Interface type structure extraction",
      "Symbol type/value distinction explanation",
      "Public API method guidance"
    ]
  },
  {
    "number": 15858,
    "title": "React Props validation does not work for extended classes",
    "created_at": "2017-05-15T22:08:29Z",
    "closed_at": "2017-05-15T22:31:26Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15858",
    "body": "We have a generic BaseComponent that does some autobinding and transition blocking. \r\n\r\nIf I have a component that extends BaseComponent<Props, State>, the compiler does not recognize error in props validation.\r\n\r\nThe following component does not throw compiler errors.\r\n```jsx\r\ninterface Props {\r\n  notMyField: string,\r\n}\r\n\r\nclass MyComponent extends BaseComponent<Props, any> {\r\n   render() {\r\n      return <div>{this.props.myField}</div>;\r\n   } \r\n}\r\n```\r\n\r\n```jsx\r\nimport * as PropTypes from 'prop-types';\r\nimport * as React from 'react';\r\n\r\n/**\r\n * The base component that autobinds all the methods to this.\r\n */\r\nclass BaseComponent<Props, State> extends React.Component<Props, State> {\r\n  static propTypes;\r\n  static contextTypes = {\r\n    router: PropTypes.object,\r\n  };\r\n\r\n  props;\r\n  unblock;\r\n\r\n  constructor(props: Props) {\r\n    super(props);\r\n    Object.getOwnPropertyNames(Object.getPrototypeOf(this)).forEach((method) => {\r\n      if (typeof this[method] !== 'function') {\r\n        return;\r\n      }\r\n      this[method] = this[method].bind(this);\r\n    });\r\n  }\r\n\r\n  componentDidMount() {\r\n    const {\r\n      props: {\r\n        history\r\n      },\r\n      willTransition\r\n    } = this as any;\r\n    // TODO: Figure out why react/prop-types is warning here.\r\n    /* eslint-disable react/prop-types */\r\n    if (history && willTransition) {\r\n      this.unblock = history.block(willTransition);\r\n    }\r\n    /* eslint-enable react/prop-types */\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    if (this.unblock) {\r\n      this.unblock();\r\n    }\r\n  }\r\n}\r\n\r\nexport default BaseComponent;\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15858/comments",
    "author": "robin-anil",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-05-15T22:24:13Z",
        "body": "`BaseComponent` has a declaration for `props` with no type, and hence it gets a type `any`. remove the declaration of `props`. \r\n```ts\r\nclass BaseComponent<Props, State> extends React.Component<Props, State> {\r\n    ...\r\n    // props;\r\n   ...\r\n```\r\n\r\nalso worth nothing that using `--noImplicitAny` would have flagged these properties as `any` for you."
      },
      {
        "user": "robin-anil",
        "created_at": "2017-05-15T22:31:26Z",
        "body": "Makes sense."
      }
    ],
    "satisfaction_conditions": [
      "Ensures TypeScript properly validates props in components extending BaseComponent",
      "Maintains React's prop type checking functionality in derived components",
      "Avoids type overrides that disable TypeScript's static analysis",
      "Works with TypeScript's type system rather than circumventing it"
    ]
  },
  {
    "number": 15801,
    "title": "--allowJs Unexpected behavior",
    "created_at": "2017-05-12T16:54:18Z",
    "closed_at": "2017-05-30T18:59:14Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15801",
    "body": "Hello mates, \r\nI have a problem, when enable option \"allowJs\" , The ts compiler goes crazy \r\ntrying to compile again and again the same files \ud83d\udc4e \r\n\r\nThey could tell me why, Thanks for your time greetings!\r\n\r\nTypescript 2.3.2 \r\nvscode 1.12.1",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15801/comments",
    "author": "11ume",
    "comments": [
      {
        "user": "aaronbeall",
        "created_at": "2017-05-12T18:04:24Z",
        "body": "Are you outputting the JS in the same folder you are compiling?"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-05-12T18:35:55Z",
        "body": "make sure you have your output folder in your `exclude` property."
      },
      {
        "user": "11ume",
        "created_at": "2017-05-12T19:22:06Z",
        "body": "I have included the output folder in my exclude property and now works perfectly thank you for your time\r\nregards!!"
      }
    ],
    "satisfaction_conditions": [
      "Prevent TypeScript compiler from processing output files",
      "Ensure proper configuration to avoid infinite compilation loops",
      "Provide guidance on managing compilation scope with allowJs"
    ]
  },
  {
    "number": 15793,
    "title": "Object types (Specification)",
    "created_at": "2017-05-12T08:21:38Z",
    "closed_at": "2017-05-12T13:19:26Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15793",
    "body": "From specification:\r\n````\r\n3.3 Object Types\r\n\r\nObject types are composed from properties, call signatures, construct signatures, \r\nand index signatures, collectively called members.\r\n3.8.3 Object Type Literals\r\n  ...\r\n  TypeMember:\r\n\u2003\u2003\u2003PropertySignature\r\n\u2003\u2003\u2003CallSignature\r\n\u2003\u2003\u2003ConstructSignature\r\n\u2003\u2003\u2003IndexSignature\r\n\u2003\u2003\u2003MethodSignature\r\n  ...\r\n  Object type members are described in section 3.9.\r\n\r\n3.9 Specifying Members\r\n3.9.5 Method Signatures\r\n\r\n  A method signature is shorthand for declaring a property of a function type.\r\n\r\n````\r\nWhy there is no **method signatures** in the first sentence?\r\n_Object types are composed from properties, call signatures, construct signatures, \r\nand index signatures, collectively called members._\r\n\r\nDoes `properties` mean `method and property signatures` together?\r\nIf so it is not evidently.\r\nMay be it is better to split `properties` into `property and method signatures`,\r\nbecause we will enumerate entities from one domain (signatures).  \r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15793/comments",
    "author": "olegdunkan",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-05-12T09:18:19Z",
        "body": "A method signature is really just a property signature whose type is an object type which contains a call signature.\r\n\r\nIn other words\r\n\r\n```ts\r\ninterface Foo {\r\n  bar(): string;\r\n}\r\n```\r\n\r\nis the same as\r\n\r\n```ts\r\ninterface Foo {\r\n  bar: {\r\n    (): string;\r\n  }\r\n}\r\n```"
      },
      {
        "user": "olegdunkan",
        "created_at": "2017-05-12T13:19:18Z",
        "body": "@DanielRosenwasser thanks, I expected that they are the same entity but in the context of object literal they are apart.\r\n\r\n\r\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-05-12T16:12:24Z",
        "body": "No prob! It's more a difference between the syntax and the type itself"
      }
    ],
    "satisfaction_conditions": [
      "Clarify the hierarchical relationship between method signatures and property signatures in type system documentation",
      "Explain why method signatures are not listed as separate primitive members in type composition",
      "Demonstrate that method signatures are semantically equivalent to a specific property signature pattern",
      "Address documentation clarity concerns about member type categorization"
    ]
  },
  {
    "number": 15646,
    "title": "[2339] Property ... does not exist on type 'typeof (Anonymous class)'",
    "created_at": "2017-05-08T00:34:59Z",
    "closed_at": "2017-05-08T19:46:41Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15646",
    "body": "**TypeScript Version:**  2.2.1 stable\r\n\r\n**Code**\r\n\r\n```ts\r\nclass skrolr {\r\n    private static _Array = class extends Array {\r\n        from( obj: HTMLCollection ) {\r\n            let arr = [];\r\n            for( let i=0, len=obj.length; i<len; i++ ) {\r\n                arr[i] = obj[i];\r\n            }\r\n        }\r\n    }\r\n    \r\n    // in another class\r\n    skrolr._Array.from( [HTMLCollection object] );\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nSuccessful transpiling to ES3\r\n\r\n**Actual behavior:**\r\nError 2339\r\n\r\nBasically just trying to have a simplified polyfill for Array.from(), but I don't want this to be global, so I'm doing it in a subclass. It works as expected in ES6, and the subclass transpiles correctly to ES3, it's just the parser for some reason isn't seeing it.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15646/comments",
    "author": "jhpratt",
    "comments": [
      {
        "user": "hediet",
        "created_at": "2017-05-08T09:01:30Z",
        "body": "You are not instantiating your class `_Array`, so either you want to make `from` static or put it in an object rather than a class:\r\n```\r\n... \r\nprivate static _array = { from: function() {...}} ;\r\n... \r\n```"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-05-08T16:21:07Z",
        "body": "` skrolr._Array` is a class, whose instances have a function called `from`. \r\n\r\nso either defined `from` as `static`, or call `(new skrolr._Array()).from`"
      },
      {
        "user": "jhpratt",
        "created_at": "2017-05-08T19:42:37Z",
        "body": "Ok, yes, that was the issue. However, why does it transpile to ES6 but not ES3 without declaring `static`?"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-05-08T19:46:37Z",
        "body": "not sure what you mean by `transpile`..\r\n\r\nthe generated code is the same semantically, it just happens that on ES6 engine, your class has a static `from` method that it got from the base `Array`, on an ES3 engine, that is not the same..\r\n\r\nin both cases, your new function goes not get to execute."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why static method inheritance behaves differently between ES3 and ES6 targets",
      "Solution that maintains class-based structure while working in ES3",
      "Clarification of static vs instance method behavior in TypeScript class hierarchies",
      "Explanation of how TypeScript handles base class static members in different target environments"
    ]
  },
  {
    "number": 15561,
    "title": "Generic hash base type (Suggestion)",
    "created_at": "2017-05-03T17:21:16Z",
    "closed_at": "2017-05-03T23:38:05Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15561",
    "body": "In Typescript and javascript  all variables are hashes.  There isn't necessarily a specific hash object.  But the hash is a non generic type that returns type any and there is no way of have a typed hash without creating your own object which of course then adds overhead.  It would be nice to have a base type in typescript that can be used generically that would cast the return of a [] statement on a variable with the type specific in the generic declaration of the variable.  \r\nAn example would be the following.\r\n`var hash: Hash<string> = {};\r\nvar value = hash['somekey'];\r\n`\r\n\r\nThe value would have the implicit type of string based on the declaration of the hash and wouldn't require additional casting of the value coming back from the object.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15561/comments",
    "author": "cwunderly",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2017-05-03T17:26:26Z",
        "body": "How would this differ from:\r\n\r\n```ts\r\ninterface Hash<T> {\r\n  [key: string]: T;\r\n}\r\n\r\nconst hash: Hash<string> = {};\r\nhash['somekey'] = 'foo';\r\n```\r\n"
      },
      {
        "user": "cwunderly",
        "created_at": "2017-05-03T17:35:41Z",
        "body": "Didn't realize you could declare that in an interface.  Would still be nice to have it as a base type i guess but i could very easily make that myself.\n\n---\n\nTrying that out this does bring up a slight irregularity in the error reporting behavior.  I would have declared\r\nthe hash to be this instead. `interface Hash<T> {\r\n  [key: string|number]: T;\r\n}\r\n`\r\nthe hash to be this instead. `interface Hash<T> {\r\n  [key: string|number]: T;\r\n}\r\n`\r\nBut the compiler tells me it has to be a string or number but it can't be a string \"or\" number in the syntactical sense.  I see that you can still get the the interface this way by doing this:\r\n`interface Hash<T> {\r\n  [key: number]: T;\r\n[key: string]: T;\r\n}\r\n`\r\nso its really not a big deal but just seemed a little strange.\r\n\r\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2017-05-03T17:43:07Z",
        "body": "> But the compiler tells me it has to be a string or number but it can't be a string \"or\" number in the syntactical sense.\r\n\r\nBecause you can't... indexes have to be `string` or `number` not the intersection of the two.  At runtime they are technically always `string`, but `number` is allowed to make it easier to model `Array` and its related types."
      },
      {
        "user": "cwunderly",
        "created_at": "2017-05-03T17:53:39Z",
        "body": "OK I read up on the union symbol.  I had seen it and used in other code and assumed that | meant or.  I realize now that it isn't the same thing.  That makes sense.  Thanks for the clarification."
      }
    ],
    "satisfaction_conditions": [
      "A mechanism to define hash/object types with generic value types in TypeScript",
      "Type inference for property access without explicit type casting",
      "Clarification of TypeScript's index signature constraints",
      "Validation of pattern's type safety"
    ]
  },
  {
    "number": 15264,
    "title": "No --target es2016 support on VS2017?",
    "created_at": "2017-04-19T05:31:15Z",
    "closed_at": "2017-04-19T08:41:20Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15264",
    "body": "**TypeScript Version:**  2.1.5.0 (VS2017)\r\n\r\n**Code**\r\n\r\n```xml\r\n  <PropertyGroup Label=\"Configuration\" Condition=\"'$(Configuration)|$(Platform)'=='Release|AnyCPU'\">\r\n    <TypeScriptTarget>ES2016</TypeScriptTarget>\r\n    <TypeScriptNoImplicitAny>true</TypeScriptNoImplicitAny>\r\n    <TypeScriptOutFile>js/app.js</TypeScriptOutFile>\r\n  </PropertyGroup>\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nIt should compile\r\n\r\n**Actual behavior:**\r\n\r\n`Build:Cannot find name '(every type in lib.d.ts e.g. Document)'`",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15264/comments",
    "author": "saschanaz",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-04-19T07:45:51Z",
        "body": "I think this is related to #14401. Can you try adding `\"lib\": [\"es2016\", \"dom\"]`?"
      },
      {
        "user": "saschanaz",
        "created_at": "2017-04-19T08:41:20Z",
        "body": "Seems it does the work. Thanks!\r\n\r\n```xml\r\n<TypeScriptLib>es2016,dom</TypeScriptLib>\r\n```"
      }
    ],
    "satisfaction_conditions": [
      "Solution must address missing DOM type definitions when targeting ES2016",
      "Answer must explain how to include both target-specific and environment-specific type libraries"
    ]
  },
  {
    "number": 15263,
    "title": "Typing static class",
    "created_at": "2017-04-19T02:11:56Z",
    "closed_at": "2017-04-19T03:31:02Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15263",
    "body": "**TypeScript Version:**  2.2.1\r\n\r\n**Code**\r\n\r\n```ts\r\nimport { Component, DebugElement, Type } from '@angular/core';\r\nimport { ComponentFixture, TestBed } from '@angular/core/testing';\r\n\r\ninterface TestFixture<T> {\r\n  component: T;\r\n  debugElement: DebugElement;\r\n  element: any;\r\n  fixture: ComponentFixture<T>;\r\n}\r\n\r\nexport function createComponent<T>(TestBed: Static<TestBed>, cmpt: Type<T>): TestFixture<T> {\r\n  const fixture = TestBed.createComponent(cmpt);\r\n  const component = fixture.componentInstance;\r\n  const debugElement = fixture.debugElement;\r\n  const element = fixture.nativeElement;\r\n\r\n  return { component, debugElement, element, fixture };\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nI propose that we have a good way of typing a static class value in a function argument - in this example, this prevents me from accurately typing `fixture`, `component`, `debugElement`, and `element` without force casting since TypeScript does not appear to support typing static instances.\r\n\r\nIn my example, I am proposing that a syntax such as `Static<TestBed>` represent the static class `TestBed`, which is not meant to be newed.\r\n\r\n**Actual behavior:**\r\n\r\nI get errors such as\r\n```\r\nTS2345: Argument of type 'typeof TestBed' is not assignable to parameter of type 'TestBed'\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15263/comments",
    "author": "wesleycho",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2017-04-19T02:32:05Z",
        "body": "> In my example, I am proposing that a syntax such as Static<TestBed> represent the static class TestBed, which is not meant to be newed.\r\n\r\nThere is such syntax already:\r\n```ts\r\ninterface TestBed {\r\n  createComponent<T extends new (...args:{}[]) => {})>(Component: T): Fixture;\r\n}\r\ninterface Fixture {...}\r\n```\r\n> TypeScript does not appear to support typing static instances.\r\n\r\nMaybe I misunderstand, but what is a static instance? Everything is just an object, even a class which is why the interface declaration above will work."
      },
      {
        "user": "wesleycho",
        "created_at": "2017-04-19T03:31:02Z",
        "body": "TestBed is not something I own - it is something that the Angular team provides with static methods on the class itself.\r\n\r\nLooks like the answer was to use `typeof TestBed` in this instance though.\r\n\r\nClosing as this appears to have a good enough solution for my case."
      },
      {
        "user": "aluanhaddad",
        "created_at": "2017-04-19T07:01:41Z",
        "body": "@wesleycho that doesn't mean you can't declare a type for it. Just use another name.\r\n\r\nThat said, I think using `typeof` is the right solution here but I wanted to explain how the specific feature requested is already provided so that you could employ it whenever you might need to. I feel like there's a fair amount of confusion around classes."
      }
    ],
    "satisfaction_conditions": [
      "Demonstrates how to correctly type a static class reference in TypeScript function parameters",
      "Explains TypeScript's existing mechanisms for representing static class types",
      "Avoids requiring type assertions/force casting while maintaining type safety",
      "Clarifies distinction between class instances and class constructors/static sides"
    ]
  },
  {
    "number": 15215,
    "title": "Performance request/question: direct use of \"arguments\" variable inside a function ",
    "created_at": "2017-04-17T06:24:03Z",
    "closed_at": "2017-04-17T06:57:53Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15215",
    "body": "**TypeScript Version:**  2.2.2, Linux Ubuntu 16.04 x86_64.\r\n\r\nI find it depressing that I cannot use the arguments variable somehow directly, that I have to see TypeScript creating a horrible duplication of memory, and waste of time. I think/wish/dream we should be able to use \"...arguments\" so that the generated javascript can just use \"arguments\" directly.\r\n\r\nI think I want something like:\r\n\r\n```ts\r\nfunction foo(...arguments) {\r\n   console.log( arguments[0] ); // TS2396\r\n}\r\n```\r\n\r\nso I have to do something like:\r\n\r\n```ts\r\nfunction foo(...args) {\r\n   console.log( args[0] ); // ok\r\n}\r\n```\r\n\r\nbut it generates depressing overhead in the final js:\r\n\r\n```js\r\n// the generated js \r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15215/comments",
    "author": "raould",
    "comments": [
      {
        "user": "ikatyang",
        "created_at": "2017-04-17T06:51:26Z",
        "body": "Default target is `es5` which cannot use `...`, you have to set `es6` or above\r\n\r\nCLI\r\n\r\n```sh\r\ntsc test.ts --target es6\r\n```\r\n\r\nor using `tsconfig.json`:\r\n\r\n```json\r\n{\r\n    \"compilerOptions\": {\r\n        \"target\": \"es6\"\r\n    }\r\n}\r\n\r\n```\r\ntest.ts\r\n```ts\r\nfunction foo(...args) {\r\n   console.log( args[0] ); // ok\r\n}\r\n```\r\n\r\ntest.js\r\n```js\r\nfunction foo(...args) {\r\n    console.log(args[0]); // ok\r\n}\r\n```"
      },
      {
        "user": "raould",
        "created_at": "2017-04-17T06:57:53Z",
        "body": "thank you, will try!"
      }
    ],
    "satisfaction_conditions": [
      "Avoids unnecessary runtime overhead in generated JavaScript code",
      "Allows using rest parameters with TypeScript's type checking",
      "Leverages native JavaScript features when possible"
    ]
  },
  {
    "number": 15025,
    "title": "Inexplicable behavior",
    "created_at": "2017-04-05T14:54:28Z",
    "closed_at": "2017-04-05T15:32:08Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15025",
    "body": "**Example 1**\r\n\r\n```ts\r\nclass foo {\r\n  readonly 1 // the same with private and static\r\n}\r\n```\r\n\r\n**Error**\r\n\r\nNo\r\n\r\n**Result**:\r\n\r\n```js\r\nvar foo = (function () {\r\n    function foo() {\r\n    }\r\n    return foo;\r\n}());\r\n\r\n```\r\n\r\n**Example 2**\r\n\r\n```ts\r\nclass foo {\r\n  const a () {} \r\n}\r\n```\r\n\r\n**Error**\r\n\r\n```\r\nError:(2, 9) TS1248:A class member cannot have the 'const' keyword.\r\n```\r\n\r\n**Result**:\r\n\r\n```js\r\nvar foo = (function () {\r\n    function foo() {\r\n    }\r\n    foo.prototype.a = function () { };\r\n    return foo;\r\n}());\r\n```\r\n\r\nIs it ok?\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15025/comments",
    "author": "monolithed",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2017-04-05T15:04:07Z",
        "body": "**Example 1**:\r\nIt might help clarify to turn on `\"noImplicitAny\": true,` in your tsconfig. `1` is the *key* of the property there, and the type is omitted.\r\nProperty declarations have no effect on emit (unless they have an initializer).\r\nFYI `readonly 1 = 2;` is totally valid code. Then `new foo()[1]` will be `2`.\r\n\r\n**Example 2**:\r\n`const` isn't allowed on a method (this ain't C++), so TypeScript correctly gave you an error here.\r\nTS will still have a best-guess emit even after an error; in this case it simply ignores `const`."
      },
      {
        "user": "monolithed",
        "created_at": "2017-04-05T15:32:08Z",
        "body": "Got it, thanks"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of TypeScript's property declaration rules for numeric property keys without initializers",
      "Clarification of TypeScript's error handling for invalid method modifiers like 'const'",
      "Description of TypeScript's emit behavior for class members without initializers",
      "Comparison between TypeScript's static type system and JavaScript runtime behavior"
    ]
  },
  {
    "number": 14763,
    "title": "Readonly tuple function",
    "created_at": "2017-03-21T13:24:08Z",
    "closed_at": "2017-03-21T15:34:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14763",
    "body": "I want to create a function that returns a tuple with literal types.\r\n\r\nHere is what I got with TS 2.2:\r\n\r\n``` ts\r\nconst tuple2 = <A, B>(tuple: Readonly<[A, B]>): Readonly<[A, B]> => tuple\r\ntuple2(['foo', 'bar']) // actual Readonly<[string, string]>, expected Readonly<['foo', 'bar']>\r\n```\r\n\r\nIs there any way to make this return literal types?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14763/comments",
    "author": "OliverJAsh",
    "comments": [
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2017-03-21T13:49:58Z",
        "body": "```typescript\r\nconst tuple2 = <A extends string, B extends string>(tuple: Readonly<[A, B]>): Readonly<[A, B]> => tuple\r\ntuple2(['foo', 'bar']) // Readonly<['foo', 'bar']>\r\n```"
      },
      {
        "user": "gcnew",
        "created_at": "2017-03-21T15:23:58Z",
        "body": "I've defined a `Literal` type alias. This way the function can accept all literal values and treat them as such.\r\n\r\n```ts\r\ntype Literal = boolean | string | number | null | undefined | object;\r\n\r\nfunction pair<L extends Literal, R extends Literal>(l: L, r: R): [L, R] {\r\n    return [l, r]\r\n}\r\n\r\npair(1, 'hello');            // [1, 'hello']\r\npair(true, false);           // [true, false]\r\npair([1, 2, 3], { a: 'a' })  // [number[], { a: string }]\r\npair(/test/, 'value')        // [RegExp, 'value']\r\npair(null, undefined)        // [null, undefined]\r\n```\r\n"
      },
      {
        "user": "OliverJAsh",
        "created_at": "2017-03-21T15:34:18Z",
        "body": "Thanks all!"
      }
    ],
    "satisfaction_conditions": [
      "Preserves literal type information in tuple elements",
      "Works with multiple primitive literal types",
      "Maintains readonly tuple structure",
      "Allows type inference from input values"
    ]
  },
  {
    "number": 14687,
    "title": "TS2300: Duplicate identifier",
    "created_at": "2017-03-16T13:22:43Z",
    "closed_at": "2017-04-21T16:30:50Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14687",
    "body": "**TypeScript Version:**  2.2.1\r\n\r\n```\r\n{\r\n\t\"compilerOptions\": {\r\n\t\t\"typeRoots\": [\r\n\t\t\t\"./node_modules/@types\",\r\n\t\t\t\"./types\"\r\n\t\t],\r\n\r\n\t\t\"outDir\": \"cache/\",\r\n\r\n\t\t\"types\": [\r\n\t\t\t\"debug\",\r\n\t\t\t\"deepmerge\",\r\n\t\t\t\"imap\",\r\n\t\t\t\"faker\",\r\n\t\t\t\"minimist\",\r\n\t\t\t\"mocha\",\r\n\t\t\t\"nodemailer\",\r\n\t\t\t\"node\",\r\n\t\t\t\"request\",\r\n\t\t\t\"webdriverio\"\r\n\t\t],\r\n\r\n\t\t\"lib\": [\r\n\t\t\t\"es2017\",\r\n\t\t\t\"scripthost\",\r\n\t\t\t\"webworker\",\r\n\t\t\t\"dom\"\r\n\t\t],\r\n\r\n\t\t\"target\": \"es2017\",\r\n\t\t\"module\": \"commonjs\",\r\n\t\t\"moduleResolution\": \"node\",\r\n\t\t\"noImplicitAny\": false,\r\n\r\n\t\t\"declaration\": false,\r\n\t\t\"allowJs\": true,\r\n\r\n\t\t\"emitDecoratorMetadata\": true,\r\n\t\t\"experimentalDecorators\": true,\r\n\t\t\"sourceMap\": true\r\n\t},\r\n\r\n\t\"exclude\": [\r\n\t\t\"./config.js\",\r\n\t\t\"./config.local.js\",\r\n\t\t\"./node_modules\",\r\n\t\t\"./utils\",\r\n\t\t\"./tasks\",\r\n\t\t\"./files\",\r\n\t\t\"./cache\"\r\n\t]\r\n}\r\n```\r\n\r\n```\r\n\u279c tsc\r\n/usr/local/lib/node_modules/typescript/lib/lib.dom.d.ts(14171,14): error TS2300: Duplicate identifier 'EventListenerOrEventListenerObject'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.dom.d.ts(14897,6): error TS2300: Duplicate identifier 'AlgorithmIdentifier'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.dom.d.ts(14898,6): error TS2300: Duplicate identifier 'BodyInit'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.dom.d.ts(14920,6): error TS2300: Duplicate identifier 'IDBKeyPath'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.dom.d.ts(14929,6): error TS2300: Duplicate identifier 'RequestInfo'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.dom.d.ts(14930,6): error TS2300: Duplicate identifier 'USVString'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.dom.d.ts(14934,6): error TS2300: Duplicate identifier 'IDBValidKey'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.dom.d.ts(14935,6): error TS2300: Duplicate identifier 'BufferSource'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(72,5): error TS2403: Subsequent variable declarations must have the same type.  Variable 'source' must be of type 'Window', but here has type 'any'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(367,5): error TS2375: Duplicate number index signature.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(398,14): error TS2403: Subsequent variable declarations must have the same type.  Variable 'srcElement' must be of type 'Element', but here has type 'any'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(446,5): error TS2375: Duplicate number index signature.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(715,14): error TS2403: Subsequent variable declarations must have the same type.  Variable 'source' must be of type 'Window', but here has type 'any'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1096,14): error TS2403: Subsequent variable declarations must have the same type.  Variable 'responseXML' must be of type 'Document', but here has type 'any'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1684,14): error TS2300: Duplicate identifier 'EventListenerOrEventListenerObject'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1710,13): error TS2403: Subsequent variable declarations must have the same type.  Variable 'onmessage' must be of type '(this: Window, ev: MessageEvent) => any', but here has type '(this: DedicatedWorkerGlobalScope, ev: MessageEvent) => any'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1715,13): error TS2403: Subsequent variable declarations must have the same type.  Variable 'location' must be of type 'Location', but here has type 'WorkerLocation'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1716,13): error TS2403: Subsequent variable declarations must have the same type.  Variable 'onerror' must be of type 'ErrorEventHandler', but here has type '(this: DedicatedWorkerGlobalScope, ev: ErrorEvent) => any'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1718,13): error TS2403: Subsequent variable declarations must have the same type.  Variable 'self' must be of type 'Window', but here has type 'WorkerGlobalScope'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1724,13): error TS2403: Subsequent variable declarations must have the same type.  Variable 'navigator' must be of type 'Navigator', but here has type 'WorkerNavigator'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1743,6): error TS2300: Duplicate identifier 'AlgorithmIdentifier'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1744,6): error TS2300: Duplicate identifier 'BodyInit'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1745,6): error TS2300: Duplicate identifier 'IDBKeyPath'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1746,6): error TS2300: Duplicate identifier 'RequestInfo'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1747,6): error TS2300: Duplicate identifier 'USVString'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1748,6): error TS2300: Duplicate identifier 'IDBValidKey'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1749,6): error TS2300: Duplicate identifier 'BufferSource'.\r\n```\r\n\r\nI see these errors with `lib.webworker`",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14687/comments",
    "author": "monolithed",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-03-16T15:26:10Z",
        "body": "You can't target `webworker` and `dom` at the same time -- these are mutually exclusive, and have different types for certain global variables. You'll need two separate compilations, one for the code which runs in your webworker threads, and one for code which runs in the DOM"
      },
      {
        "user": "monolithed",
        "created_at": "2017-03-16T18:58:54Z",
        "body": "@RyanCavanaugh, I got it, thanks! Could you show such errors not like a stack trace?"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-03-16T19:40:29Z",
        "body": "Not sure what you mean?"
      },
      {
        "user": "monolithed",
        "created_at": "2017-03-16T20:14:59Z",
        "body": "```\r\n/usr/local/lib/node_modules/typescript/lib/lib.dom.d.ts(14171,14): error TS2300: Duplicate identifier 'EventListenerOrEventListenerObject'.\r\n```\r\n\r\nUsually such error messages are not informative. It would be nice to print something like:\r\n\r\n> You can't target webworker and dom at the same time -- these are mutually exclusive, and have different types for certain global variables. You'll need two separate compilations, one for the code which runs in your webworker threads, and one for code which runs in the DOM\r\n\r\n\ud83d\ude09"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why 'dom' and 'webworker' libs cannot coexist in the same compilation",
      "Guidance on separating environment-specific configurations",
      "Clarification of TypeScript lib conflict resolution strategy",
      "Validation of configuration structure for mixed environments"
    ]
  },
  {
    "number": 14627,
    "title": "how can i type-annotate a function that creates an object literal out of a literal key and a value?",
    "created_at": "2017-03-13T11:38:44Z",
    "closed_at": "2017-03-13T15:56:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14627",
    "body": "i have\r\n```typescript\r\nconst key: 'name' = 'name';\r\nconst value: number = 1;\r\n```\r\n\r\ni need a function that turns these key/value into an object with a property, in JavaScript it would look like:\r\n```javascript\r\n// javascript\r\nfunction(key, value) {\r\n    return { [key]: value };\r\n}\r\n```\r\n\r\nso that:\r\n```typescript\r\nconst data = fn(key, value);\r\n// data is expected to be of type: { name: number; }\r\n```\r\n\r\nis there a way to type-annotate `fn` so that it returns an object of type `{ name: number; }`? if so, how?\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14627/comments",
    "author": "zpdDG4gta8XKpMCd",
    "comments": [
      {
        "user": "gcanti",
        "created_at": "2017-03-13T14:07:50Z",
        "body": "```ts\r\nfunction fn<K extends string, V>(key: K, value: V): { [k in K]: V } {\r\n  return { [key as any]: value } as any\r\n}\r\n```"
      }
    ],
    "satisfaction_conditions": [
      "Function must preserve literal key type in return type",
      "Function must maintain value type association in return object",
      "Solution must work without manual type assertions at call site",
      "Return type must be a proper mapped type",
      "Type annotations must handle generic key/value pairs"
    ]
  },
  {
    "number": 14611,
    "title": "Suggestion: infer type based on first non-null-or-undefined assignment",
    "created_at": "2017-03-12T20:07:17Z",
    "closed_at": "2017-03-14T08:41:42Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14611",
    "body": "It would be very convenient if types for variables were inferred based on the first non-null-or-undefined assignment to that variable rather than always based on initialisation. For example, it must be very common to write the following code.\r\n\r\n```ts\r\nlet result = null; //Or just let result;\r\ntry{\r\nresult = doSomethingThatMightFail();\r\n}catch(ex){}\r\nif(!result){\r\ndoOneThing(result);\r\n}else{\r\ndoAnother(result);\r\n}\r\n```\r\nCurrently the inferred type of result is any. However, it would be useful if it was the return type of doSomethingThatMightFail (which is often quite a complicated type in operations such as querying a database, so awkward to declare manually).\r\n\r\nThis would also apply to inference of function return types. For example the following must be an extremely common pattern.\r\n\r\n```ts\r\nfunction myFunc(input: MyClass){\r\n  if(!input){\r\n    return null;\r\n  }\r\n  //do some stuff which ends up declaring a variable called result \r\n  return result;\r\n}\r\n```\r\nIn this case it would be useful if the inferred return type of myFunc was the type of result, not any.\r\n\r\nI suppose when I say 'first' assignment here, the 'first' might be a bit unclear. It could just be the first non-null-or-undefined assignment that could possibly happen. If this it too difficult or not well-defined in general then it could apply only to a few simple cases to start with, such as the ones above.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14611/comments",
    "author": "benstevens48",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-03-13T00:59:06Z",
        "body": "This already works pretty well if you use `strictNullChecks`:\r\n```ts\r\ndeclare function doSomethingThatMightFail(): HTMLElement | undefined;\r\ndeclare function doOneThing(s: undefined): void;\r\ndeclare function doAnother(s: HTMLElement): void;\r\n\r\nlet result;\r\ntry {\r\n\tresult = doSomethingThatMightFail();\r\n} catch (ex) {\r\n}\r\nif (!result) {\r\n\tdoOneThing(result);\r\n} else {\r\n\tdoAnother(result);\r\n}\r\n```"
      },
      {
        "user": "benstevens48",
        "created_at": "2017-03-13T09:53:00Z",
        "body": "Hi @RyanCavanaugh ,\r\nThanks for the reply. I think maybe my example wasn't written very well. The functions doOneThing and doAnother were meant to be placeholders for that block's body rather than actual functions. A more complete example would be something like\r\n\r\n```ts\r\ndeclare function doSomethingThatMightFail(): HTMLElement;\r\n\r\nlet result = null; //or perhaps also just let result;\r\ntry {\r\n\tresult = doSomethingThatMightFail();\r\n} catch (ex) {\r\n}\r\nif (!result) {\r\n  console.log('something failed');\r\n} else {\r\n  result.innerHTML = 'test';\r\n}\r\n```\r\n\r\nThe point is I want to avoid having to manually write out the type of result anywhere. I'd also like my second example to work. I realise that this is in conflict with how you've defined null initialisation to work in strictNullChecks mode. \r\n\r\nI suppose what I'm asking for is some sort of type widening based on control flow analysis. Initially I said it should be based on the first non-null assignment, but maybe it could continue to widen the type based on possible assignments. I think it should only widen the type if one is a subtype of the other, or null or undefined, else you would lose any type checking.\r\n\r\nIt would also be useful if this worked for empty arrays `[]` as well as null and undefined.\r\n\r\nI actually use the `if(!input) return null` pattern as given in my second example in almost all my functions, which means I get no type inference for any of my function return types. I suppose maybe in the long run it's better to explicitly declare the return type, but often with client side code that changes a lot based on changing requirements putting in explicit types doesn't seem worth it, however it would still be really useful to have type checking.\r\n"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2017-03-14T06:21:08Z",
        "body": "@benstevens48 You need to specify `--noImplicitAny` and `--strictNullChecks`. Under these settings, all of your examples work fine. Also, arrays work as you suggest."
      },
      {
        "user": "benstevens48",
        "created_at": "2017-03-17T19:41:55Z",
        "body": "Hi @aluanhaddad ,\r\nOh, Ok thanks. I hadn't been using noImplicityAny. Also, I think I might have been wrong about the second example anyway. It seems to work even without these settings in simple cases. \r\n\r\nThe problem I have with noImplicitAny is that I would end up typing a lot of stuff as any just to get it to work initially, then when I came back to look at it, it would look like I'd already typed it even though it was meant to be a quick fix. It might be useful if the above worked under less strict conditions, or I have another suggestion that would be pretty simple to implement. \r\n\r\nPerhaps add another type that has the same effect as any, but is meant to be used by the developer as a temporary measure before going back and putting a better type in. Then there could be a flag which would highlight any instances of this type as an error if turned on. Maybe I will add this as a separate suggestion.\n\n---\n\nHi @aluanhaddad , @RyanCavanaugh ,\r\nI would like to make a small addendum to this issue.\r\n\r\nIn my second example above, about inferring the return type of a function, TypeScript correctly infers the type even without any flags. However, the reason why I got confused was a lot of my functions have the async modifier, and  if you add the async modifier then this is no longer the case. For example, given this code\r\n```ts\r\nasync function removeStart(input: string) {\r\n  if (!input) {\r\n    return null;\r\n  }\r\n  return input.substr(1);\r\n}\r\n```\r\nthe return type is inferred as `Promise<any>`, unless strictNullChecks is enabled in which case it correctly gives `Promise<string | null>`. \r\n\r\nSince the non-async version works even without strictNullChecks, would it be possible to make the async version work even without strictNullChecks as well?"
      }
    ],
    "satisfaction_conditions": [
      "Type inference works for variables initialized with null/undefined when later assigned non-null values without explicit type annotations",
      "Control flow analysis considers subsequent non-null assignments for type widening",
      "Function return type inference works with early null returns in async functions without strictNullChecks",
      "Type safety is maintained without requiring strict compiler flags",
      "Handles common initialization patterns with empty arrays and null/undefined guards"
    ]
  },
  {
    "number": 14608,
    "title": "Unable to parameterize keyof (in function) to access object's fields",
    "created_at": "2017-03-12T13:05:47Z",
    "closed_at": "2017-03-12T17:17:39Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14608",
    "body": "I'm having problems understanding how to parameterize **keyof**. I have extracted a simple code that describes the issue I'm facing.\r\n\r\n```ts\r\ninterface INested3 {\r\n    id: number;\r\n    name: string;\r\n}\r\n\r\ninterface INested2a {\r\n    id: number;\r\n    name: string;\r\n    nested3: INested3;\r\n}\r\n\r\ninterface INested2b {\r\n    id: number;\r\n    name: string;\r\n    nested3: INested3;\r\n}\r\n\r\ninterface INested1 {\r\n    id: number;\r\n    name: string;\r\n    nested2a: INested2a;\r\n    nested2b: INested2b;\r\n}\r\n\r\ninterface IFoo {\r\n    id: number;\r\n    name: string;\r\n    nested1: INested1;\r\n}\r\n\r\nfunction get<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(obj: T, key1: K1, key2: K2, key3: K3): T[K1][K2][K3] {\r\n    return obj[key1][key2][key3];\r\n}\r\n\r\n// Fine\r\nfunction foo1a(f: IFoo): void {\r\n    console.log(\r\n        get(f, \"nested1\", \"nested2a\", \"nested3\")\r\n    );\r\n}\r\n\r\nfunction foo1b(f: IFoo): void {\r\n    console.log(\r\n        get(f, \"nested1\", \"nested2b\", \"nested3\")\r\n    );\r\n}\r\n\r\n// Not fine - why?\r\n// Argument of type '\"nested3\"' is not assignable to parameter of type '\"toString\" | \"valueOf\"'.\r\nfunction foo1param(f: IFoo, nested2key: keyof INested1): void {\r\n    console.log(\r\n        get(f, \"nested1\", nested2key, \"nested3\")\r\n    )\r\n}\r\n\r\nvar f: IFoo = {\r\n    id: 1,\r\n    name: \"Foo\",\r\n    nested1: {\r\n        id: 1,\r\n        name: \"Nested 1\",\r\n        nested2a: {\r\n            id: 1,\r\n            name: \"Nested 2A\",\r\n            nested3: {\r\n                id: 1,\r\n                name: \"Nested 3\",\r\n            }\r\n        },\r\n        nested2b: {\r\n            id: 1,\r\n            name: \"Nested 2B\",\r\n            nested3: {\r\n                id: 2,\r\n                name: \"Nested 3\",\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Would like to use it like this\r\nfoo1param(f, \"nested2a\");\r\nfoo1param(f, \"nested2b\");\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14608/comments",
    "author": "vladimir-djokic",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2017-03-12T17:11:54Z",
        "body": "In your example, `keyof INested1` is equivalent to `\"id\" | \"name\" | \"nested2a\" | \"nested2b\"` (the full set of property names for `INested1`). You need to restrict it to just `\"nested2a\" | \"nested2b\"`:\r\n\r\n```ts\r\nfunction foo1param(f: IFoo, nested2key: \"nested2a\" | \"nested2b\"): void { ... }\r\n```\r\n\r\nOnce you do that your example works."
      },
      {
        "user": "vladimir-djokic",
        "created_at": "2017-03-12T17:17:39Z",
        "body": "I understand now, thank you! I guess this was a classic case of _\"can't see the forest for the trees\"_."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how to properly constrain generic type parameters for nested key access",
      "Demonstration of type-safe parameterization for multiple levels of object access",
      "Clarification on TypeScript's keyof behavior with union types",
      "Solution preserving the ability to call with both 'nested2a' and 'nested2b' parameters"
    ]
  },
  {
    "number": 14352,
    "title": "String not assignable to string enum even when value is known at compile time and is part of the enum.",
    "created_at": "2017-02-28T03:27:45Z",
    "closed_at": "2017-03-01T04:02:00Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14352",
    "body": "Typescript@2.1.6\r\n\r\nHere's an example:\r\n\r\n```\r\ninterface Test {\r\n    fun(opts: {foo: 'enum1' | 'enum2'}): void\r\n}\r\n\r\nconst bar: Test = {\r\n    fun: (opts) => { }\r\n}\r\n\r\nconst defaults = {\r\n    foo: 'enum1'\r\n};\r\n\r\nbar.fun(defaults) // Error: Type 'string' is not assignable to type '\"enum1\" | \"enum2\"'\r\n```\r\n\r\nShouldn't `defaults.foo` be inferred to be a subset of the string enum?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14352/comments",
    "author": "realyze",
    "comments": [
      {
        "user": "realyze",
        "created_at": "2017-02-28T03:30:34Z",
        "body": "FWIW, `bar.fun({foo: 'enum1'})` compiles OK.\n\n---\n\nI would suggest `defaults` type to be inferred as `{ foo: string & 'enum1' }` rather than `string`."
      },
      {
        "user": "Jessidhia",
        "created_at": "2017-02-28T04:39:12Z",
        "body": "Note that `defaults.foo` is mutable, so the inferred type has to be `string`; otherwise it would prevent you from ever mutating it. Using `&` is even more dangerous as, if you _did_ mutate it, the `& 'enum1'` part of the type would make its type be `'enum1'` even if it was any other value.\r\n\r\nYou probably want something similar to this, probably with an `interface` or `type` alias to avoid repetition:\r\n\r\n```ts\r\nconst defaults: { foo: 'enum1' | 'enum2' } = {\r\n  foo: 'enum1'\r\n}\r\n```"
      },
      {
        "user": "realyze",
        "created_at": "2017-03-01T04:01:59Z",
        "body": "@Kovensky Right, hmm, yeah that does make sense. I'll close this. Thanks!"
      },
      {
        "user": "ubershmekel",
        "created_at": "2017-08-14T23:48:36Z",
        "body": "Going to leave the answer to my case here because google brought me to this issue:\r\n\r\n    import * as isomorphicFetch from \"isomorphic-fetch\";\r\n    const fetchOptions: isomorphicFetch.RequestInit = {\r\n        method: \"POST\",\r\n        body: JSON.stringify(body),\r\n        headers: headers,\r\n        // required for cookies in ajax\r\n        \"credentials\": \"include\",\r\n    };\r\n    let response = await isomorphicFetch(url, fetchOptions);\r\n\r\nCaused this error:\r\n\r\n```\r\nfile: 'file:///Users/backend/packages/nuxt-typescript/lib/api.ts'\r\nseverity: 'Error'\r\nmessage: 'Argument of type '{ method: string; headers: { \"Content-Type\": string; }; \"credentials\": string; }' is not assignable to parameter of type 'RequestInit | undefined'.\r\n  Type '{ method: string; headers: { \"Content-Type\": string; }; \"credentials\": string; }' is not assignable to type 'RequestInit'.\r\n    Types of property 'credentials' are incompatible.\r\n      Type 'string' is not assignable to type '\"include\" | \"omit\" | \"same-origin\" | undefined'.'\r\nat: '120,51'\r\nsource: 'ts'\r\n```\r\n\r\nSolved by:\r\n\r\n    let fetchOptions: RequestInit = {\r\n\r\n"
      },
      {
        "user": "ZelphirKaltstahl",
        "created_at": "2017-12-22T10:58:21Z",
        "body": "It seems like `tsc` does not consider `string`s like `\"cors\"` or `\"default\"` to be of the types `RequestMode` or `RequestCache`, unless one adds the type declaration as @ubershmekel did in their answer."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why TypeScript infers string literals as general string types in object literals",
      "Clarification of when explicit type annotations are required for literal type preservation",
      "Guidance on proper type declaration patterns for object literals with constrained values",
      "Explanation of TypeScript's type safety considerations around mutable vs immutable values"
    ]
  },
  {
    "number": 14321,
    "title": "locally modifying+testing published definitions is a pain (bug/rant/perhaps-question)",
    "created_at": "2017-02-26T19:56:07Z",
    "closed_at": "2017-04-21T13:50:25Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14321",
    "body": "the ```@types``` process is pretty great for consuming .d.ts files (much better than the previous typings or tsd workflows)   \r\n\r\nhowever, I seem to have a big problem as a creator of ```.d.ts``` for publication.    I don't see any way of creating a .d.ts file for local use and testing, and then be able to then publish the file as-is.   \r\n\r\nFor example, if this is a definition I publish to DT:  \r\n\r\n```foo/index.d.ts```:\r\n`\r\ndeclare namespace Foo{ export function foo():void; }\r\nexport = Foo;\r\nexport as namespace Foo;\r\n`\r\n\r\nand usage:\r\n`\r\nimport foo = require(\"foo\");\r\n`\r\n\r\n\r\nHow would I consume my own definitions for ```foo``` locally?  I don't see how to do this with the normal import style.  instead I need to modify my d.ts and consumption usage like:\r\n\r\n```myProject/_dts/foo.ts```\r\n`\r\nexport declare namespace _foo{ export function foo():void; }\r\nexport const Foo: typeof _foo = require(\"foo\");\r\n`\r\nand usage:\r\n`\r\nimport foo = require(\"./_dts/foo\");\r\n`\r\n\r\nBasically this means that I can't easily test and/or modify a definition that I want to share publically, which adds a lot of friction for re-contributing to the community.   Am I doing something wrong?  Is there an easy way to modify and locally reference a published type?\r\n\r\n\r\n\r\n**Note**: I don't know if i'm doing it wrong these days, so please correct my understanding if you see problems with my logic above.\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14321/comments",
    "author": "jasonswearingen",
    "comments": [
      {
        "user": "jasonswearingen",
        "created_at": "2017-02-27T19:42:50Z",
        "body": "by the way, pre ```@types``` I published perhaps 10 ```d.ts``` on DefinitelyTyped, but based on the issues described in my above rant the friction to publish+maintain typings is too great, so I just write definitions for private use.   \r\n\r\nbasically from a consumption standpoint, ```@types``` is great, but from a producer's perspective it is worse than the previous DT ```tsd``` model."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-02-27T21:49:02Z",
        "body": "> How would I consume my own definitions for foo locally? I don't see how to do this with the normal import style. instead I need to modify my d.ts and consumption usage like:\r\n\r\nLet's say you want to write defintions for `foo`, which is a module:\r\n- under your app: `src\\extra-types\\foo`, create `index.d.ts` that has your declaration as noted above (along with tsconfig.json, tslint.json, and tests for DT if you want). \r\n- in your `tsconfig.json` add a path mapping rule: \r\n ```js\r\n{\r\n     ...\r\n    \"paths\": {\r\n       \"foo\" : [\"src/extra-types/foo\"]\r\n    }\r\n}\r\n  ```\r\n  or if you have multiple:\r\n  ```js\r\n{\r\n     ...\r\n    \"paths\": {\r\n       \"*\" : [ \"*\", \"src/extra-types/*\"]\r\n    }\r\n}\r\n  ```\r\n- once you have published to DT, delete `src\\extra-types\\foo` and add `@types/foo`, no other changes should be required.\r\n"
      },
      {
        "user": "jasonswearingen",
        "created_at": "2017-04-21T13:50:25Z",
        "body": "ok thank you for those details.  I finally got around to writing a new definition and see that your info works.\r\n\r\nare those in the docs somewhere?\r\n"
      }
    ],
    "satisfaction_conditions": [
      "Solution must allow local testing of type definitions without requiring code changes when switching to published @types",
      "Must maintain identical import statements between local development and published consumption",
      "Should enable seamless transition from local development to DefinitelyTyped publication",
      "Must work with standard TypeScript configuration mechanisms",
      "Should eliminate need for special directory structures or file naming conventions"
    ]
  },
  {
    "number": 13952,
    "title": "Local @types",
    "created_at": "2017-02-08T12:49:49Z",
    "closed_at": "2017-02-09T08:33:44Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13952",
    "body": "Hi all,\r\n\r\nI'm developing 2 libraries `A` and `B` in different folders where `A` is exported as target es5 and module commonjs.\r\n\r\nIn `B` I'd like to use `index.d.ts` from `A` among other @types libraries which are in node_modules folder. And then use some classes from `A` via in import like this: `import {MyClass} from \"a\";`.\r\nUnfortunately this doesn't work: a not found in `node_modules/@types/a` etc.\r\nI tried without success with:\r\n \r\n```typescript\r\n\"baseUrl\": \".\",\r\n    \"paths\": {\r\n      \"a\": [\r\n        \"lib/a\"\r\n      ]\r\n    },\r\n```\r\n\r\nHow to setup typescript to find lib/a/index.d.ts without modifying my import with relative path (e.g. `import {MyClass} from \"../lib/a/index\";`)?\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13952/comments",
    "author": "sternbel",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-02-08T18:55:57Z",
        "body": "The target in the \"paths\" list is relative to `\"baseUrl\"`. so your \"paths\" here says `\"a\" => \"./lib/a\"` so you either want to set the `\"baseUrl\"` to `\"../\"` or set the target to `\"../lib/a\"`.\r\n\r\n```ts\r\n{\r\n    \"compilerOptions\": {\r\n        \"module\": \"commonjs\",\r\n        \"target\": \"es5\",\r\n        \"baseUrl\": \"./\",\r\n        \"paths\": {\r\n            \"a\" : [\"../lib/a/index.d.ts\"]\r\n        }\r\n    }\r\n}\r\n```"
      },
      {
        "user": "sternbel",
        "created_at": "2017-02-09T08:33:42Z",
        "body": "Hi @mhegazy,\r\n\r\nThanks a lot, it's working now!"
      }
    ],
    "satisfaction_conditions": [
      "Correct configuration of TypeScript's module resolution paths to map 'a' to the local library's type definitions",
      "Support for absolute imports without relative path references",
      "Integration with TypeScript's type resolution system for local type definitions"
    ]
  },
  {
    "number": 13809,
    "title": "[request] allow namespaces to become types",
    "created_at": "2017-02-01T06:21:10Z",
    "closed_at": "2017-02-01T11:10:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13809",
    "body": "How about allowing namespaces to become types?\r\n\r\ne.g.)\r\n\r\n```typescript\r\n// some declaration file I can't touch\r\ndeclare module monaco {   //this is monaco, not 'monaco'. so it's a namespace.\r\n   ...\r\n}\r\n\r\ntype _MonacoNamespaceType = ::monaco; // or any other syntax is fine.\r\n```\r\n--------------------------------\r\nbackground: I'm having problems trying to write d.ts file for react-monaco-editor.\r\n\r\nmonaco-editor's typescript definition has everything in ts namespaces, so I'm stuck trying to get 'monaco' as a type.\r\n\r\nhere's the definition file I'm working on:\r\n```typescript\r\n/// <reference path=\"../../node_modules/monaco-editor/monaco.d.ts\" />\r\n\r\n\r\ndeclare module 'react-monaco-editor' {\r\n  import { Component } from 'react';\r\n  export type ReactMonacoEditorProps = {\r\n    width: string,\r\n    height: string,\r\n    language: string,\r\n    options: monaco.editor.IEditorOptions,\r\n    editorDidMount?: (editor: monaco.editor.ICodeEditor, monaco: any) => any,\r\n  };\r\n  import test = monaco;\r\n  export type ICodeEditor = monaco.editor.ICodeEditor;\r\n  export default class ReactMonacoEditor\r\n      extends Component<ReactMonacoEditorProps, void> { }\r\n}\r\n```\r\nAs you can see on **editorDidMount?: (editor: monaco.editor.ICodeEditor, monaco: any) => any,**\r\nI couldn't give the 'monaco' type on monaco as 'monaco' namespace cannot be a type.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13809/comments",
    "author": "devdoomari",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-02-01T06:32:21Z",
        "body": "`typeof monaco` ?"
      },
      {
        "user": "devdoomari",
        "created_at": "2017-02-01T11:10:18Z",
        "body": "@mhegazy oh so there was already a way! Thanks : )\n\n---\n\n."
      }
    ],
    "satisfaction_conditions": [
      "Provide a way to reference a namespace's type structure in TypeScript type positions",
      "Maintain compatibility with existing namespace declarations that cannot be modified",
      "Enable type-safe usage of namespace contents without resorting to 'any' type"
    ]
  },
  {
    "number": 13581,
    "title": "tsc doesn't resolve module specified in the typeRoots",
    "created_at": "2017-01-19T18:17:36Z",
    "closed_at": "2017-04-21T16:56:05Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13581",
    "body": "**TypeScript Version:**  2.1.5\r\n\r\nI have the following directory structure:\r\n```\r\ntsconfig.json\r\na.ts\r\nnode_modules\r\n|--- custom\r\n     |--- rembo\r\n           |---index.d.ts\r\n```\r\n\r\nThe content of `index.d.ts` is the following:\r\n```\r\nexport declare class Rembo {\r\n    name: string;\r\n}\r\n```\r\n\r\nI reference this module in `a.ts`:\r\n`import {Rembo} from 'rembo';`\r\n\r\nThe `package.json` is the following:\r\n```\r\n{\r\n  \"compilerOptions\": {\r\n    \"moduleResolution\": \"node\",\r\n    \"module\": \"es6\",\r\n    \"target\": \"es6\",\r\n    \"typeRoots\": [\r\n      \"node_modules/custom\"\r\n    ]\r\n  }\r\n}\r\n```\r\nThe problem is that `rembo` module can't be resolved. When compiled, I get the following result:\r\n\r\n`$ tsc --traceResolution`\r\n\r\n```\r\n======== Resolving type reference directive 'rembo', containing file 'D:/Projects/typescript/__inferred type names__.ts', root directory 'D:/Projects/typescript/node_modules/custom'. ========\r\nResolving with primary search path 'D:/Projects/typescript/node_modules/custom'\r\nFile 'D:/Projects/typescript/node_modules/custom/rembo/package.json' does not exist.\r\nFile 'D:/Projects/typescript/node_modules/custom/rembo/index.d.ts' exist - use it as a name resolution result.\r\nResolving real path for 'D:/Projects/typescript/node_modules/custom/rembo/index.d.ts', result 'D:/Projects/typescript/node_modules/custom/rembo/index.d.ts'\r\n======== Type reference directive 'rembo' was successfully resolved to 'D:/Projects/typescript/node_modules/custom/rembo/index.d.ts', primary: true. ========\r\na.ts(3,21): error TS2307: Cannot find module 'rembo'.\r\n```\r\n\r\nI don't understand why the error, since it reports then:\r\n\r\n> Type reference directive 'rembo' was **successfully** resolved to 'D:/Projects/typescript/node_modules/custom/rembo/index.d.ts', primary: true.\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13581/comments",
    "author": "maxkoretskyi",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-01-19T22:49:50Z",
        "body": "TypeRoots is useful for global declarations, things that you do not `import`, e.g. node definition file. when the compiler starts it loads all files under `typeRoots` and adds them in the global scope.\r\n\r\nSeems like this is not what you are looking for, what you need is [Path mapping](www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping):\r\n\r\n```ts\r\n{\r\n  \"compilerOptions\": {\r\n    \"moduleResolution\": \"node\",\r\n    \"module\": \"es6\",\r\n    \"target\": \"es6\",\r\n    \"baseUrl\": \"./\",\r\n    \"paths\": {\r\n      \"*\" : [\"node_modules/custom/*\"]\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThis tells the compiler to look under `<baseUrl>/node_modules/custom` for any import it sees."
      },
      {
        "user": "maxkoretskyi",
        "created_at": "2017-01-20T06:37:09Z",
        "body": "Thanks a lot for you quick reply. As I understand, the `node_modules` and `node_modules/@types` are automatically added to \"paths\", correct? I have imports of one module residing inside `node_modules` and the other in `node_modules/@types` and don't \"paths\" configured, but both modules are still successfully resolved.\r\n\r\nAnd is my understanding correct that both \"typeRoots\" and \"types\" is used for global modules resolve?"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-01-21T22:13:42Z",
        "body": "that is correct. I would not think about `typeRoots` unless you are using something global, e.g. `node`. otherwise, just think about modules."
      },
      {
        "user": "maxkoretskyi",
        "created_at": "2017-01-26T18:37:00Z",
        "body": "Got it, thanks. Where can I read about all supported patterns for `paths`? For example, can I match part of the module name and provide mappings for that part? Or only `*` pattern is supported?"
      },
      {
        "user": "gdamjan",
        "created_at": "2017-02-10T00:27:35Z",
        "body": "What if the node_modules including node_modules/@types are outside the source directory alltogether?\r\n\r\n```\r\nSRC=$HOME/Pojects/demo\r\nDEST=/tmp/build\r\n\r\nln -s $SRC/package.json $DEST/package.json\r\ncd $DEST\r\nnpm install\r\n\r\ncd $SRC\r\ntsc --outDir $DEST/build --typeRoots $DEST/???\r\n```\r\nthis doesn't work\r\n\r\n\r\n\r\n\r\n(ts 2.1.6)"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-02-10T00:47:46Z",
        "body": "`paths` is relative to the `baseUrl` and not the `projectRoot`. so you can make the `baseUrl` whatever you want."
      }
    ],
    "satisfaction_conditions": [
      "Clarifies the distinction between typeRoots (global declarations) and module resolution paths (imported modules)",
      "Explains how to configure module resolution for custom locations outside node_modules/@types",
      "Documents supported patterns for TypeScript path mapping configuration",
      "Addresses scenarios where type definitions exist outside the project directory structure",
      "Explains relationship between baseUrl, paths, and module resolution context"
    ]
  },
  {
    "number": 13530,
    "title": "Invoking methods from object iteration",
    "created_at": "2017-01-17T12:05:32Z",
    "closed_at": "2017-01-17T20:01:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13530",
    "body": "**TypeScript Version:**  2.1.5\r\n\r\n**Code**\r\n\r\n```ts\r\nclass Params {\r\n\tpublic paramsInit () {\r\n\t\tfor ( let prop in this ) {\r\n\t\t\tif ( typeof this[ prop ] === 'function' ) {\r\n\t\t\t\tlet res = this[ prop ]();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nclass Test extends Params {\r\n\tconstructor () {\r\n\t\tsuper();\r\n\t\tthis.paramsInit();\r\n\t}\r\n\r\n\tpublic param1 (): void {\r\n\t\tconsole.log( 'param1' );\r\n\t}\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nIn TypeScript 2.0 the above compiles without any errors.\r\n\r\n**Actual behavior:**\r\n\r\nIn TypeScript 2.1.5 I get:\r\n\r\n> test.ts(5,15): error TS2349: Cannot invoke an expression whose type lacks a call signature. Type 'Params[keyof this]' has no compatible call signatures.\r\n\r\nI can see why tsc might not like invooking `this[ prop ]`, but I can't see any way to tell it that it is a valid function. I've tried using `as` in various combinations, but with no luck.\r\n\r\nIs there a way to get this to compile in 2.1 without errors?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13530/comments",
    "author": "DataTables",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2017-01-17T14:33:46Z",
        "body": "This works:\r\n\r\n```ts\r\nclass Params {\r\n    public paramsInit () {\r\n        for ( let prop in this ) {\r\n            if ( typeof this[ prop ] === 'function' ) {\r\n                let res = (this[ prop ] as any)();\r\n            }\r\n        }\r\n    }\r\n}\r\n```"
      },
      {
        "user": "DataTables",
        "created_at": "2017-01-17T14:42:48Z",
        "body": "Thanks! Yes, that allows a clean compile with tsc 2.1.5.\r\n\r\nSo I guess the question becomes, is the 2.0 or 2.1 behaviour correct?"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2017-01-17T18:40:13Z",
        "body": "The current behavior is correct. The call without a type assertion is clearly not type safe, but previously we were not equipped to track the type of a computed property access so we would give an implicit `any` type to `this[prop]` (and you'd get an error with `--noImplicitAny`). Now, because of indexed access types (a.k.a. \"lookup types\") we can do a better job."
      },
      {
        "user": "DataTables",
        "created_at": "2017-01-17T20:01:49Z",
        "body": "Awesome - thanks very much.\r\n\r\nOthers have said it many times, and I as well, but going to say it again - TypeScript is excellent and a credit to all involved!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why TypeScript 2.1's type checking prevents the function invocation",
      "Validation of TypeScript's current behavior correctness"
    ]
  },
  {
    "number": 13399,
    "title": "files/dirs that start with a dot (.) do not get copied or transpiled by default",
    "created_at": "2017-01-10T20:04:48Z",
    "closed_at": "2017-04-21T16:31:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13399",
    "body": "**TypeScript Version:**  2.1.4\r\n\r\n**Code**\r\n\r\n```\r\n/lib\r\n/test\r\n    /.suman\r\n    /test-src\r\n```\r\n\r\nif I build this project with `tsc` and use the outDir option, the .suman directory **won't** get moved/transpiled, presumably because it starts with a dot .\r\n\r\nbased on the above project structure, the resulting _incorrect_ build would look like:\r\n\r\n```\r\n/dist\r\n   /lib\r\n   /test\r\n       /test-src  \r\n```\r\nabove we can see that the .suman dir is missing from the test dir\r\n\r\nif I rename the .suman directory to suman like so:\r\n\r\n```\r\n/lib\r\n/test\r\n    /suman    // renamed from .suman to suman\r\n    /test-src\r\n```\r\n\r\nthen it will get moved to the outDir, because it no longer starts with a dot .\r\n\r\nso the expected result actually happens, which is of course:\r\n\r\n```\r\n/dist\r\n   /lib\r\n   /test\r\n       /suman\r\n       /test-src\r\n```\r\n\r\n\r\n\r\n\r\nhere is my config, which shows that I want to `include` my test dir, in the build.\r\n\r\n```json\r\n{\r\n  \"compilerOptions\": {\r\n    \"compileOnSave\": true,\r\n    \"target\": \"es5\",\r\n    \"noImplicitAny\": false,\r\n    \"removeComments\": true,\r\n    \"preserveConstEnums\": true,\r\n    \"outDir\": \"dist\",\r\n    \"allowJs\": true,\r\n    \"allowUnreachableCode\": true,\r\n    \"lib\": [\"es2015\", \"dom\"]\r\n  },\r\n  \"include\": [\r\n    \"./**/*\"\r\n  ],\r\n  \"exclude\": [\r\n    \"node_modules\"\r\n  ]\r\n}\r\n\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nI would expect it would include files/directories that start with a dot, unless you exclude files/dirs that start with a dot\r\n\r\n**Actual behavior:**\r\n\r\nTS/tsc seems to exclude files/dirs that start with a dot by default, which seems very strange, since users could easily specify with a regex to ignore dirs/files that start with a dot!\r\n\r\n**My question is then, is there a tsconfig.json setting I can use to include the .suman directory with my build?**\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13399/comments",
    "author": "ORESoftware",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-01-11T17:49:38Z",
        "body": "files and folders starting with a `.` are ignored by the glob patterns. this to accomodate for hidden folders that tools like git rely on. You need to add the folder starting with a `.` explcitlly in your include patter:\r\n\r\n```json\r\n  \"include\": [\r\n    \"./**/*\",\r\n    \"./test/.suman/**/*\"\r\n  ],\r\n```\r\n\r\nalso one note, you need to exclude your outDir, or you will be consuming the output again, given that you have `--allowJs` set. so your exclude patterns should be:\r\n```json\r\n  \"exclude\": [\r\n    \"node_modules\",\r\n    \"./dist\"\r\n  ]\r\n```"
      },
      {
        "user": "ORESoftware",
        "created_at": "2017-01-11T23:18:18Z",
        "body": "ahh thanks so much that helps a ton!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how to override default exclusion of dot-prefixed files/directories in TypeScript builds",
      "Configuration pattern that allows explicit inclusion of specific hidden directories",
      "Guidance on preventing output directory recursion in build process",
      "Clarification of TypeScript's default glob pattern behavior"
    ]
  },
  {
    "number": 13207,
    "title": "\u03bb return object",
    "created_at": "2016-12-29T05:43:13Z",
    "closed_at": "2016-12-29T07:11:36Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13207",
    "body": "let func=(val:number)=>{x:val};//error\r\nlet func=(val:number)=>{return {x:val};};//ok",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13207/comments",
    "author": "kgtkr",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-12-29T05:47:06Z",
        "body": "The first line is, unfortunately , a valid JS grammar production. the `{}` represent the body of the function, the `x` is a label, the `val` is an expression, the function as a whole implicitly returns `undefined`.\r\n\r\nyou can wrap it in parans to avoid this. e.g. \r\n```ts\r\nlet func1 = (val: number) => ({ x: val });\r\n```"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of arrow function syntax ambiguity between object literals and function bodies",
      "Demonstration of valid object return syntax without explicit return statement",
      "Clarification of TypeScript/JavaScript parsing rules for arrow functions"
    ]
  },
  {
    "number": 13200,
    "title": " Conflict between  Intersection types and keyof",
    "created_at": "2016-12-28T13:36:15Z",
    "closed_at": "2016-12-28T16:44:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13200",
    "body": "**TypeScript Version:**  2.1.4 / nightly (2.2.0-dev.20161228)\r\n\r\n**Code**\r\n\r\n```ts\r\nclass Tween<T>{\r\n\r\n    static get<T>(target: T): Tween<T> {\r\n        return new Tween(target);\r\n    }\r\n\r\n    constructor(private target: T) {\r\n\r\n    }\r\n\r\n    /** \r\n     * modify the value of target from a old number value to new number value;\r\n     * there are two rules props should be followed : \r\n     * 1. key of props must be the key of target \r\n     * 2. every value of props should be number\r\n     */\r\n    public to(props: Partial<T> & { [index: string]: number }) {\r\n\r\n    }\r\n}\r\n\r\n\r\nvar textField = { x: 0, y: 0, text: \"helloworld\" };\r\nvar tween = Tween.get(textField);\r\ntween.to({ \"x\": 100 })\r\ntween.to({ \"xx\": 100 });\r\ntween.to({ \"text\": \"hello,typescript\" });\r\ntween.to({ \"text\": 1 });\r\n\r\n```\r\n\r\n\r\n**Expected behavior:**\r\n```\r\ntween.to({ \"x\": 100 }) // right\r\ntween.to({ \"xx\": 100 });  // report error because 'xx' is not existed in typeof textfield\r\ntween.to({ \"text\": \"hello,typescript\" }); // report error because 'hello,typescript' is not number\r\ntween.to({ \"text\": 1 });// report error because 'text' in typeof textfield should be string\r\n```\r\n\r\n\r\n**Actual behavior:**\r\n\r\n```\r\ntween.to({ \"x\": 100 }) // right\r\ntween.to({ \"xx\": 100 });  // right , why ???????\r\ntween.to({ \"text\": \"hello,typescript\" }); // report error because 'hello,typescript' is not number\r\ntween.to({ \"text\": 1 });// report error because 'text' in typeof textfield should be string\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13200/comments",
    "author": "WanderWang",
    "comments": [
      {
        "user": "blakeembrey",
        "created_at": "2016-12-28T16:00:51Z",
        "body": "This looks correct to me. Your signature is saying `{ [key: string]: number }` is valid, so any key not in `T` must be a number (and anything in `T` intersects with `number` so makes some `never` types when `string & number`. Perhaps you want a signature more like `Partial<{ [X in keyof T]: number }>`? If `{ text: 1 }` is definitely meant to be an error, try the signature `Partial<T & { [X in keyof T]: number }>`, I couldn't really tell if the error there was intentional."
      },
      {
        "user": "WanderWang",
        "created_at": "2016-12-28T16:44:23Z",
        "body": "Thanks !!!\r\n``` Partial<T & { [X in keyof T]: number }> ``` it worked well !!!! I think this issue should be closed"
      }
    ],
    "satisfaction_conditions": [
      "Ensure type system enforces that only valid keys of the target object can be used in the 'to' method",
      "Enforce numeric value constraints for valid keys while preserving original property types",
      "Maintain type safety for non-number properties in the target object"
    ]
  },
  {
    "number": 13197,
    "title": "support of native async/await is missing ",
    "created_at": "2016-12-28T10:29:16Z",
    "closed_at": "2016-12-30T18:08:40Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13197",
    "body": "\r\n**TypeScript Version:**  2.1.1 / nightly (2.2.0-dev.201xxxxx)\r\n\r\n**Code**\r\n\r\n```ts\r\n\r\nasync function f() {\r\n let value = await anotherAsyncFunction()\r\n  ....\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nIf target type is set to ES7 (which it currently doesn't even support) it should leave the above code _as is_, since the current versions of Node already support it (and it is much easier to debug, too).\r\n\r\n**Actual behavior:**\r\n1. Currently it generates the __awaiter code and uses yield, etc.\r\n1. There's no support for target type es7\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13197/comments",
    "author": "dharmax",
    "comments": [
      {
        "user": "alitaheri",
        "created_at": "2016-12-28T10:42:09Z",
        "body": "@dharmax es doesn't follow that versioning semantic anymore. use `es2017`."
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-12-28T12:18:57Z",
        "body": "`--target esnext` should disable all transformations that are not module format related.\r\n@alitaheri did they ever?\ud83d\ude1d "
      },
      {
        "user": "dharmax",
        "created_at": "2016-12-28T15:21:04Z",
        "body": ":+1: \r\n@alitaheri oh, i see. I gave it a try and indeed it outputs the right code now. However, seems like my node doesn't understand async, although it's version 7.3.... "
      },
      {
        "user": "blakeembrey",
        "created_at": "2016-12-28T15:53:35Z",
        "body": "@dharmax it's still behind a flag, try `node --harmony-async-await`."
      }
    ],
    "satisfaction_conditions": [
      "TypeScript must preserve native async/await syntax when targeting compatible environments",
      "Clear documentation of required runtime flags for native async/await execution",
      "Accurate target specification for modern ECMAScript features"
    ]
  },
  {
    "number": 12877,
    "title": "How to convert enum type to Array<Object>",
    "created_at": "2016-12-13T11:47:34Z",
    "closed_at": "2016-12-13T19:04:27Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12877",
    "body": "I want convert enum type to Array<Object>.\r\n\r\nexample : \r\n\r\nenum A {\r\n  dog = 1,\r\n  cat = 2,\r\n  ant = 3\r\n}\r\n\r\nconvert to: [{id: 1, name: 'dog'}, {id: 2, name: 'cat'}, {id: 3, name: 'ant'}]\r\n\r\n\r\nthank you.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12877/comments",
    "author": "attachai-b",
    "comments": [
      {
        "user": "dead-claudia",
        "created_at": "2016-12-13T14:36:37Z",
        "body": "@narutomxc \r\n\r\nThis is an issue tracker, not a standard help forum. But anyways, here's how you'd do it:\r\n\r\n```ts\r\n// This requires TypeScript 2.1.\r\n// If you need older versions, use `string` instead of `keyof E`.\r\ninterface EnumItem<E> { id: E; name: keyof E; }\r\n\r\nfunction enumToArray<E>(Enum: {[keyof E]: E}): EnumItem<E>[] {\r\n    return Object.keys(Enum).map(key => ({id: Enum[key], name: key} as EnumItem<E>))\r\n}\r\n```"
      },
      {
        "user": "attachai-b",
        "created_at": "2016-12-14T02:46:40Z",
        "body": "OK, thx"
      },
      {
        "user": "xmeng1",
        "created_at": "2017-11-01T12:57:37Z",
        "body": "I found `{[keyof E]: E}` cannot be recognise in Webstorm. so replace it with any..."
      }
    ],
    "satisfaction_conditions": [
      "Solution must transform enum entries into array objects with 'id' and 'name' properties",
      "Must handle both numeric and string enum value types",
      "TypeScript type safety for enum key/value relationships",
      "Compatibility with common TypeScript development environments"
    ]
  },
  {
    "number": 12821,
    "title": "Is it safe to access private members by using an element access expression?",
    "created_at": "2016-12-10T10:36:12Z",
    "closed_at": "2016-12-11T00:20:58Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12821",
    "body": "**TypeScript Version:**  2.1 / nightly (2.2.0-dev.20161127)\r\n\r\n**Code**\r\n```ts\r\ninterface SomeType { }\r\n\r\nclass A { private m: SomeType; }\r\n\r\nclass B {\r\n\tfoo(a: A) {\r\n\t\tconst n1 = a.m; // (1)\r\n\t\tconst n2 = a[\"m\"]; // (2)\r\n\t}\r\n}\r\n```\r\nAs expected, the property access expression (1) produces a compile error. However, the element access expression (2) does not, even though typescript recognizes that (2) refers to member \"A.m\" as it infers the type \"SomeType\" for n2.\r\n\r\nCan I expect (2) to not produce any compile errors in future typescript versions?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12821/comments",
    "author": "hediet",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2016-12-10T23:27:57Z",
        "body": "It's been that way since forever and several code bases depend on it so I don't imagine us changing it. If we did, we would minimally put it under a compiler switch."
      }
    ],
    "satisfaction_conditions": [
      "Clarification about TypeScript's long-term stance on private member access via element access expressions",
      "Explanation of TypeScript's design philosophy regarding intentional vs accidental behavior",
      "Information about potential breaking change policies",
      "Mention of real-world usage considerations"
    ]
  },
  {
    "number": 12549,
    "title": "bug: type predicates (`V is T`) fails on expressions (`V[K] is T`)",
    "created_at": "2016-11-29T04:37:52Z",
    "closed_at": "2016-11-29T07:13:38Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12549",
    "body": "**TypeScript Version:** nightly (2.2.0-dev.20161128)\r\n\r\n**Code**\r\n\r\n```ts\r\npropIs<T, V, K extends keyof V>(type: T, name: K, obj: V): V[K] is T;\r\n```\r\n\r\n**Expected behavior:**\r\nTS being totally cool with `V[K] is T`.\r\n\r\n**Actual behavior:**\r\nNope, many syntax errors.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12549/comments",
    "author": "KiaraGrouwstra",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-11-29T04:42:19Z",
        "body": "The type predicate syntax has always taken a parameter name on the left side of the `is` keyword. So it sounds like what you want is better parser recovery here."
      },
      {
        "user": "KiaraGrouwstra",
        "created_at": "2016-11-29T04:50:16Z",
        "body": "Oh, yeah, `V is T` itself works fine, this seems to be specifically about adding the `[K]` there. It does seem like storing (`extends`) `V[K]` in a new generic may form a solution here...\r\nBut apparently `propIs<T, V, K extends keyof V, R extends V[K]>(type: T, name: K, obj: V): R is T;` yields `Cannot find parameter 'R'`. I must be doing something wrong...\r\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-11-29T06:07:13Z",
        "body": "Well it's only the *parameter* that a type predicate can operate on - in other words, you write\r\n\r\n```ts\r\nfunction foo(x: any): x is string {\r\n    // ....\r\n}\r\n```\r\n\r\nAs opposed to the following:\r\n\r\n```ts\r\nfunction foo(x: any): any is string {\r\n    // ....\r\n}\r\n```"
      },
      {
        "user": "KiaraGrouwstra",
        "created_at": "2016-11-29T06:34:59Z",
        "body": "I'm sorry, that would be my misinterpretation then.\r\nIn that event I would be inclined to try the following for this specific case:\r\n```ts\r\npropIs<T, V, K extends keyof V, R extends V[K]>(type: T, name: K, obj: V): obj[name] is T;\r\n```\r\nStill not okay though. I suppose it'd help if I had the ability to save this result to a new variable first, but I'm not confident I can do this in the type language...\r\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-11-29T07:08:10Z",
        "body": "You could do something like this:\r\n\r\n```ts\r\npropIs<T, V, K extends keyof V, R extends V[K]>(type: T, name: K, obj: V): obj is (V & Record<K, T>)\r\n```"
      },
      {
        "user": "KiaraGrouwstra",
        "created_at": "2016-11-29T07:13:38Z",
        "body": "Whoa, some out of the box thinking there, wouldn't have come up with that myself. Thanks for thinking along. :)"
      }
    ],
    "satisfaction_conditions": [
      "Solution must allow type predicates to work with nested/calculated property types",
      "Must adhere to TypeScript's type predicate syntax constraints",
      "Should enable type narrowing for specific object properties",
      "Must work within TypeScript's generic type system",
      "Solution should provide type safety for property access patterns"
    ]
  },
  {
    "number": 12385,
    "title": "error TS2304: Cannot find name 'UriMapHandlerArray'.",
    "created_at": "2016-11-19T21:03:42Z",
    "closed_at": "2016-11-19T23:52:05Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12385",
    "body": "UriMapHandlerArray is defined in the same file, TS cannot find it.\r\n\r\nts v2.0.10\r\n**Code**\r\n\r\n```js\r\ninterface UriMapHandlerArray {\r\n  [index: string]: IUriMapHandler;\r\n}\r\n\r\nexport class Furi {\r\n\r\n  private _get:    IUriMap = { uri_map: UriMapHandlerArray };\r\n```\r\n\r\n```ts\r\n// A *self-contained* demonstration of the problem follows...\r\n\r\n```\r\n\r\n**Expected behavior:**\r\n\r\n**Actual behavior:**\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12385/comments",
    "author": "rajinder-yadav",
    "comments": [
      {
        "user": "j-oliveras",
        "created_at": "2016-11-19T21:20:02Z",
        "body": "You uses UriMapHandlerArray as a value of uri_map property not as a type.\n\nIf you want to define IUriMap type as { uri_map: UriMapHandlerArray } you can do:\n`type IUriMap = { uri_map: UriMapHandlerArray }`\nor:\n`interface IUriMap { uri_map: UriMapHandlerArray }`\nand then use it as \n\n```\nexport class Furi {\n  private _get: IUriMap = { uri_map: {} };\n}\n```\n"
      },
      {
        "user": "rajinder-yadav",
        "created_at": "2016-11-19T23:52:05Z",
        "body": "OK I see my mistake, thanks!\n"
      }
    ],
    "satisfaction_conditions": [
      "Clarify the distinction between type definitions and runtime values in TypeScript",
      "Explain proper type annotation usage for object property declarations",
      "Demonstrate correct object initialization that matches type definitions"
    ]
  },
  {
    "number": 12005,
    "title": "TS is incorrectly disallowing a variable assignment.",
    "created_at": "2016-11-02T20:25:10Z",
    "closed_at": "2016-11-03T16:14:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12005",
    "body": "**TypeScript Version:**  2.0.3 \r\n\r\n**Code**\r\n\r\nAll of the code in this issue can be run in the playground.\r\n\r\nThe following gives this compile error: **\"Type 'EntityInstance' is not assignable to type 'EntityInstance'.\"**\r\n\r\n```ts\r\nexport class EntityInstance {\r\n    public deleted = false;\r\n    private children = new EntityArray<EntityInstance>();\r\n\r\n    getChildren(): EntityArray<EntityInstance> {\r\n        return this.children;\r\n    }\r\n}\r\n\r\nexport class ExtendedInstance extends EntityInstance {\r\n    public anotherProperty = true;\r\n\r\n    getChildren(): EntityArray<ExtendedInstance> {\r\n        return super.getChildren() as EntityArray<ExtendedInstance>;\r\n    }\r\n}\r\n\r\nlet ei = new ExtendedInstance();\r\nei.getChildren()[0].anotherProperty = false;\r\n\r\nexport class EntityArray<EntityInstance> extends Array<EntityInstance> {\r\n\r\n    delete(index?: number) {\r\n        let ei = new EntityInstance();\r\n        ei = this.splice( index, 1 )[0];\r\n        ei.deleted = true;\r\n    }\r\n}\r\n\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nThis should be allowed.  It appears that TS thinks that EntityInstance as specified in \"EntityArray<EntityInstance>\" is a different type from EntityInstance.  The former EntityInstance doesn't appear to have type information.  For example, if I rewrite the delete() as follows there is an error because TS doesn't know about the 'deleted' property:\r\n\r\n```ts\r\n    delete(index?: number) {\r\n        let ei = this.splice( index, 1 )[0];\r\n        ei.deleted = true;\r\n    }\r\n```\r\n\r\n**Actual behavior:** \r\n\r\nTS raises compile error.\r\n\r\n**More notes:**\r\n\r\nI could define EntityArray without the <> (which then correctly determines the types in delete) but then I lose type information when I call ExtendedInstance.getChildren().  For example, the above code fails when rewitten as:\r\n\r\n```ts\r\nexport class EntityInstance {\r\n    public deleted = false;\r\n    private children = new EntityArray();\r\n\r\n    getChildren(): EntityArray {\r\n        return this.children;\r\n    }\r\n}\r\n\r\nexport class ExtendedInstance extends EntityInstance {\r\n    public anotherProperty = true;\r\n\r\n    getChildren(): EntityArray {\r\n        return super.getChildren();\r\n    }\r\n}\r\n\r\nlet ei = new ExtendedInstance();\r\nei.getChildren()[0].anotherProperty = false;\r\n\r\nexport class EntityArray extends Array<EntityInstance> {\r\n\r\n    delete(index?: number) {\r\n        let ei = new EntityInstance();\r\n        ei = this.splice( index, 1 )[0];\r\n        ei.deleted = true;\r\n    }\r\n}\r\n```\r\n\r\nI can get by the original error by casting to <any> in the delete method but who wants to do that in Typescript?\r\n\r\n```ts\r\ndelete(index?: number) { \r\n    let ei = this.splice( index, 1 )[0] as any; \r\n    ei.deleted = true; \r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12005/comments",
    "author": "DeegC",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-11-02T21:54:42Z",
        "body": ">  It appears that TS thinks that EntityInstance as specified in \"EntityArray<EntityInstance>\" is a different type from EntityInstance\n\nIt is. You declared a type parameter that shadowed the name:\n\n``` ts\nclass EntityArray<EntityInstance> extends Array<EntityInstance> {\n```\n\nYou probably meant to write\n\n``` ts\nclass EntityArray extends Array<EntityInstance> {\n```\n\n\n---\n\nOr perhaps this:\n\n``` ts\nclass EntityArray<T extends EntityInstance> extends Array<T> {\n```\n"
      },
      {
        "user": "DeegC",
        "created_at": "2016-11-03T15:32:26Z",
        "body": "Thanks Ryan, that solved my problem.  It does seem like a confusing error message; would it be possible to flag the original `EntityArray<EntityInstance>` as an error for attempting to create a type with an already-existing name?\n\nEither way, I appreciate the help.\n"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-11-03T15:59:48Z",
        "body": "Shadowing is, for better or worse, a part of JavaScript that is fairly ubiquitous. Of course these are types, not Java Script values but it makes sense that the same naming rules would apply. Maybe just displaying that it's a type parameter in the error message would be helpful.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-11-03T16:14:46Z",
        "body": "It's kind of necessary to allow type name shadowing, otherwise we wouldn't be able to safely add things to the global namespace without the risk of a breaking change.\n\nThere's perhaps a suggestion lurking here which is that our error messages should do something (I don't know what) if we ever issue a message like \"Cannot assign X to X\" where both X's have identical spelling. I mean ideally you'd see something like \"Cannot assign X (Type Parameter) to X (Interface)\", but it's hard to guess if even that would cover all the cases.\n"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-11-04T11:17:05Z",
        "body": "> There's perhaps a suggestion lurking here which is that our error messages should do something (I don't know what) if we ever issue a message like \"Cannot assign X to X\" where both X's have identical spelling. I mean ideally you'd see something like \"Cannot assign X (Type Parameter) to X (Interface)\", but it's hard to guess if even that would cover all the cases.\n\n@RyanCavanaugh I was going to suggest this at first but there are a lot of lenses via which to look at a type so it could become ambiguous, or a just a best guess, in a lot of cases. \n\nMaybe a simpler, higher value option would be to do something like\n\n``` scala\ngiven Types A and B over assignment\nwhere not A assignable to B\nreport IncompatableAssignementOfIdenticallyNamedTypesDiagnostic\nwhen A name is B name\notherwise report IncompatibleTypesDiagnostic\n```\n\nSo it would say something like **\"Type 'B' is not assignable to type 'A'. (note that they are _not_ same Declaration)\"**\n"
      },
      {
        "user": "DeegC",
        "created_at": "2016-11-05T20:17:36Z",
        "body": "Would it be possible to make it illegal for the name of a generic type to shadow a previously defined type?  I'm obviously no TS expert (yet!) but I can't think of a reason one would need to shadow a currently existing type.  The error message could be something like \"Generic type name 'EntityInstance' not allowed because it would shadow an existing type.'\n\nThat would potentially break some current client code; if that's forbidden maybe make it a warning?\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why TypeScript considers the two 'EntityInstance' types as different",
      "Guidance on avoiding type parameter shadowing while preserving generics functionality",
      "Clarification on proper generic class inheritance patterns",
      "Recommendations for type-safe alternatives to 'any' type assertions",
      "Insight into TypeScript's type name resolution mechanics"
    ]
  },
  {
    "number": 11887,
    "title": "Typescript error TS5055",
    "created_at": "2016-10-27T12:49:27Z",
    "closed_at": "2016-10-27T18:34:15Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11887",
    "body": "**TypeScript Version:**  nightly (2.1.0-dev.20161027)\n\n**Simulation**\n\nCreate a project with the following configuration:\n\n``` json\n{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"target\": \"es5\",\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n    \"noImplicitAny\": true,\n    \"noUnusedParameters\": true,\n    \"noUnusedLocals\": true,\n    \"noEmitOnError\": true,\n    \"skipLibCheck\": true,\n    \"declaration\": true,\n    \"sourceMap\": true,\n    \"outDir\": \"out/\",\n    \"rootDir\": \"src\",\n    \"baseUrl\": \"src\",\n    \"moduleResolution\": \"node\",\n    \"lib\": [\n      \"es5\",\n      \"es2015\",\n      \"dom\"\n    ]\n  },\n  \"exclude\": [\n    \"node_modules\"\n  ]\n}\n```\n\nThe directory structure should be:\n- project\n  - src\n    - index.ts\n    - hello.ts\n  - out\n\nThe content of the `hello.ts` could be:\n\n``` typescript\nexport function hello(name: string) {\n  return `Hello, ${name}`;\n}\n```\n\nThe `index.ts` should re-export the hello module contents:\n\n``` typescript\nexport * from \"./hello\";\n```\n\nAfter that, compile twice using the vscode or the tsc:\n- `tsc -p .`\n- `tsc -p .`\n\n**Expected behavior:**\n\nCompile and produce again the js and the definitions.\n\n**Actual behavior:** \n\nIn the first compilation, it will compile normally. But at the second one, it will file with a message like `error TS5055: Cannot write file '.../hello.d.ts' because it would overwrite input file.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11887/comments",
    "author": "danfma",
    "comments": [
      {
        "user": "danfma",
        "created_at": "2016-10-27T12:55:40Z",
        "body": "Just to point out, it works with the current production release version.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-10-27T18:34:14Z",
        "body": "add your  `\"outDir\"` to your exclude list. i.e.:   `\"exclude\": [\"node_modules\", \"out\"]`\n"
      }
    ],
    "satisfaction_conditions": [
      "Prevent generated declaration files from being treated as input files during subsequent compilations",
      "Maintain strict compiler options while resolving the conflict",
      "Ensure compatibility with TypeScript's file input/output handling logic",
      "Avoid manual file management outside compiler configuration"
    ]
  },
  {
    "number": 11792,
    "title": "Question: Why are some of the CompilerOptions Internal?",
    "created_at": "2016-10-22T00:45:52Z",
    "closed_at": "2016-10-22T21:39:50Z",
    "labels": [
      "Question",
      "API"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11792",
    "body": "I am upgrading my bundling Typescript compiler to use Typescript 2.x and noticed that a number of CompilerOptions ares now internal ( Diagnostics, ListFiles, Watch, etc ). Is there a reason for this?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11792/comments",
    "author": "ToddThomson",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-10-22T00:48:04Z",
        "body": "These are options that are used only by commandline compiler driver (tsc.js), no other parts of the system use them, so specifying them would be not be useful. e.g. `help`. setting this on the API does not do any thing. \n"
      },
      {
        "user": "ToddThomson",
        "created_at": "2016-10-22T17:50:52Z",
        "body": "I use them. For example when doing white space elimination I use the Diagnostics flag to output white space reduction statistics. I also need to know if the user has the Watch flag set as I have compile and bundling and minification functions that result when a source file changes.\nI agree that these settings are most likely only used by those of us writing features on top of the transpiler, but they are needed. \n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-10-22T20:52:35Z",
        "body": "Nothing stops you from defining a new property on the option bag. Your diagnostics flag means something to you, so that is fine, but it is not the same meaning the one in types has. So my recomedation is to add your declarations on top of the exisitng compileroptions as needed.\n"
      },
      {
        "user": "ToddThomson",
        "created_at": "2016-10-22T21:39:50Z",
        "body": "Yes, I see your point, I am just piggybacking my use of a few of the \"internal\" compiler options.\nIn any event, as you say, it is simple enough to get those properties back for my use. Cheers, @mhegazy \n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why specific CompilerOptions are marked internal",
      "Mechanism to extend/customize compiler options",
      "Preservation of existing integration capabilities",
      "Clear distinction between public API and internal implementation details"
    ]
  },
  {
    "number": 11472,
    "title": "Define array of non-nullables",
    "created_at": "2016-10-09T19:20:31Z",
    "closed_at": "2016-10-09T19:38:50Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11472",
    "body": "I need to define array of any non-nullable values. Is it possible?\nExample:\n\n``` ts\ndeclare type NonNullable; // this is placeholder for type, which I am looking for\nlet a: NonNullable[] = [];\nlet b: string | null;\na.push(b); // expected compile error;\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11472/comments",
    "author": "Strate",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-10-09T19:30:18Z",
        "body": "`{}` is the empty object type, which every type is structurally compatible with, except for `null`, `undefined`, and `void`.\n\nThis should work with `--strictNullChecks` mode.\n\n``` ts\ntype NonNullable = {};\n\nlet a: NonNullable[] = [];\nlet b: string | null;\n\na.push(b); // expected compile error;\n```\n"
      },
      {
        "user": "Strate",
        "created_at": "2016-10-09T19:38:49Z",
        "body": "@DanielRosenwasser nice, it works, thank you!\n"
      }
    ],
    "satisfaction_conditions": [
      "The type must exclude null and undefined values",
      "Must work with TypeScript's strictNullChecks compiler option",
      "Must produce compile-time errors for invalid assignments",
      "Must define an array type that enforces element non-nullability"
    ]
  },
  {
    "number": 11402,
    "title": "Unification overly simplifies types resulting in the swallowing of 'undefined'",
    "created_at": "2016-10-05T21:33:16Z",
    "closed_at": "2016-10-06T08:50:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11402",
    "body": "**TypeScript Version:**  2.0.3\n\nThis is very problematic as it weakens undefined safety _a lot_.\n\n**Code**\n\n``` ts\nfunction bar<A>(c:boolean, a:A, au:A |\u00a0undefined) { // foo return type is inferred to A instead of A | undefined\n    return c ? a : au;\n}\n```\n\n**Expected behavior:**\n\nbar return type is inferred to A | undefined (valid simplification of A | A | undefined)\n\n**Actual behavior:** \n\nbar return type is inferred to A\n\nNote: similar problem with 'null' instead of 'undefined'\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11402/comments",
    "author": "sledorze",
    "comments": [
      {
        "user": "yortus",
        "created_at": "2016-10-06T00:26:32Z",
        "body": "If you set `strictNullChecks: true` in your `tsconfig.json`, then `bar` does return `A | undefined` as you expect.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-10-06T03:55:57Z",
        "body": "@sledorze does that fix things for you?\n"
      },
      {
        "user": "sledorze",
        "created_at": "2016-10-06T08:50:12Z",
        "body": "Oh dear, yes of course, wonderful! :)\n"
      }
    ],
    "satisfaction_conditions": [
      "Ensures TypeScript preserves union types with 'undefined' in generic return type inference",
      "Addresses both 'undefined' and 'null' type handling in generic scenarios",
      "Maintains strict null checking compatibility"
    ]
  },
  {
    "number": 11053,
    "title": "Redundant rest parameter should be omitted from compiled output",
    "created_at": "2016-09-22T01:45:26Z",
    "closed_at": "2016-09-22T04:33:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11053",
    "body": "**TypeScript Version:**  2.0.2 (rc)\n\nIn some cases I am iterating through arguments using the arguments object, and don't actually need to reference the paremeters. In these sorts of cases, the only reason to include the rest parameter in the original source is to tell TypeScript that the function may be called with any number of arguments. If the parameter is never actually referenced (particularly if you then access the arguments object), it should be able to infer that the parameter is redundant and drop it from the compiled output.\n\nHaving an intermediate array built, or even just a redundant rest parameter when targeting ES2015, is not ideal when your code is performance-critical. Optimizing compilers might be smart enough to skip an unused rest parameter, but it still feels sloppy, and ES5 output will be worse, of course.\n\nThe example below is contrived of course, but it serves to illustrate the redundant output:\n\n``` ts\nfunction run(...args: any[]) {\n  const values = arguments;\n  for(var i = 0; i < values.length; i++) {\n    console.log(values[i]);\n  }\n}\n```\n\nES5 output:\n\n``` js\nfunction run() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i - 0] = arguments[_i];\n    }\n    var values = arguments;\n    for (var i = 0; i < values.length; i++) {\n        console.log(values[i]);\n    }\n}\n```\n\nand ES2015 output:\n\n``` js\nfunction run(...args) {\n    const values = arguments;\n    for (var i = 0; i < values.length; i++) {\n        console.log(values[i]);\n    }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11053/comments",
    "author": "axefrog",
    "comments": [
      {
        "user": "yortus",
        "created_at": "2016-09-22T02:29:15Z",
        "body": "@axefrog since the prime concern here seems to be performance, what is the performance difference if you actually use the `args` rest parameter instead of `arguments` in your implementation? E.g. is `run1` slower than `run2` in the code below? I'm genuinely curious.\n\n``` ts\nfunction run1(...args: any[]) {\n  for(var i = 0; i < args.length; i++) {\n    console.log(args[i]);\n  }\n}\n\nfunction run2() {\n  const values = arguments;\n  for(var i = 0; i < values.length; i++) {\n    console.log(values[i]);\n  }\n}\n```\n"
      },
      {
        "user": "axefrog",
        "created_at": "2016-09-22T02:44:07Z",
        "body": "@yortus it's not quite as specific as this (yes I do have one function in mind right now, but I don't want to focus on that); rather than optimizing for one specific case I'm experiencing, and then changing my code to try and cater to TypeScript idiosyncracies, I'm just observing that, because JavaScript offers an arguments object and that sometimes it will be used directly, and that sometimes doing so will be in an area of code where redundancy creates a question mark as to expected performance characteristics on different runtime compilers, it seems logical that I should be able to take advantage of this language feature of JavaScript without paying the cost of redundant compiler output. Also, generating redundant syntax seems sloppy.\n"
      },
      {
        "user": "yortus",
        "created_at": "2016-09-22T03:00:01Z",
        "body": "Would the following meet your needs? It has both the compile-time (variadic) and runtime (no redundant var) characteristics you mentioned.\n\n``` ts\nconst foo: (...args) => void = function () {\n    const values = arguments;\n    for (var i = 0; i < values.length; i++) {\n        console.log(values[i]);\n    }\n}\n```\n\n**EDIT:** @RyanCavanaugh's solution below is more idiomatic TS and preserves hoisting, so use that.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-09-22T03:00:55Z",
        "body": "The solution is simple, though undiscoverable:\n\n``` ts\nfunction run(...args: any[]): void;\nfunction run() {\n  const values = arguments;\n  for(var i = 0; i < values.length; i++) {\n    console.log(values[i]);\n  }\n}\n```\n"
      },
      {
        "user": "axefrog",
        "created_at": "2016-09-22T05:59:30Z",
        "body": "@RyanCavanaugh Ah, thanks! May I suggest a ticket to clarify this in the documentation?\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-09-22T06:57:05Z",
        "body": "We try to keep the documentation to common-ish cases and this seems to be fairly rare. You can also see #498 which we're accepting PRs for.\n"
      }
    ],
    "satisfaction_conditions": [
      "Unused rest parameters are omitted from compiled JavaScript output",
      "TypeScript recognizes functions as variadic without requiring explicit rest parameters when using arguments object",
      "Solution preserves access to arguments object functionality",
      "No performance penalty from unnecessary parameter processing",
      "Solution maintains TypeScript's type checking for variadic functions"
    ]
  },
  {
    "number": 10854,
    "title": "Simultaneous use of export equals and export default in a module",
    "created_at": "2016-09-11T12:35:00Z",
    "closed_at": "2016-09-11T14:52:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10854",
    "body": "I have some NPM modules written that uses the old default export syntax:\n\n``` ts\ndeclare module 'my-module' {\n    function test(): string;\n    export = test;\n}\n```\n\nTo promote ES import syntax but still keep the old one, I wanted to add both the new and old default export syntax:\n\n``` ts\ndeclare module 'my-module' {\n    function test(): string;\n    export default test;\n    export = test; // An export assignment cannot be used in a module with other exported element\n}\n```\n\nThough it complains that it cannot use an export assignment with other export statements.\n\nI think it is reasonable to support both syntax simultaneously in a module. Because choosing between both syntax. I would choose `export =` before `export default`, simply because of no API breakage.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10854/comments",
    "author": "tinganho",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-09-11T13:21:19Z",
        "body": "No it isn't really practical at all, because it isn't \"magic\" that produces the default export.  It is added as a property on the export of the module.  What is provided above is trying to export something as `my-module.default` and then overwriting it with a function named `test` and TypeScript is preventing you from describing something that contradicts itself.\n\nI think what you might want to consider the solution to #5285 (`--allowSyntheticDefaultImports`), which allows you to import a module as if it were the shape you denoted.\n"
      },
      {
        "user": "tinganho",
        "created_at": "2016-09-11T13:42:13Z",
        "body": "> I think what you might want to consider the solution to #5285 (--allowSyntheticDefaultImports), which allows you to import a module as if it were the shape you denoted.\n\n@kitsonk thanks that was what I wanted.\n\n\n---\n\nThere could be a problem. I'm currently doing the magic on the module itself and not relying on any module loader doing the magic for me. There could possibly be people that are not using `--allowSyntheticDefaultImports` so they cannot use one of my modules, unless they want to use the old import syntax. Telling all users that they need to add a flag just to use a module is little bit harsh also.\n\nFYI. This is the magic I do:\n\n``` ts\ndeclare var module: any;\nmodule.exports = myModule;\nmodule.exports.default = myModule;\n```\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-09-11T14:37:01Z",
        "body": "``` typescript\ndeclare module 'my-module' {\n    const test: () => string & { default: () => string };\n    export = test;\n}\n```\n"
      },
      {
        "user": "tinganho",
        "created_at": "2016-09-11T14:52:16Z",
        "body": "Very neat trick!\n"
      }
    ],
    "satisfaction_conditions": [
      "Supports both CommonJS and ES module imports without breaking existing consumers",
      "Doesn't require consumers to modify their TypeScript configuration flags",
      "Provides a default export that aligns with ES module expectations",
      "Avoids TypeScript export assignment conflicts"
    ]
  },
  {
    "number": 10779,
    "title": "Generics not inferred from union type",
    "created_at": "2016-09-08T14:08:19Z",
    "closed_at": "2016-09-08T14:37:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10779",
    "body": "Latest 2 beta\n\n``` ts\nconst y = <S, E>(z: S | E) => 1;\ny(5 || 'foo') // generics should be number and string, but are {} and {}\n```\n\nI expect the generics `S` and `E` to be inferred correctly as `number` and `string`, but it seems like TypeScript infers them both as `{}` instead.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10779/comments",
    "author": "OliverJAsh",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-09-08T14:24:23Z",
        "body": "TypeScript cannot infer generics in that way.  A simple example:\n\n``` typescript\nconst y = <S, E>(z: S | E) => 1;\ny(5 || 'foo' || true) // What should be inferred here?\n```\n\nWhere as:\n\n``` typescript\nconst y = <S>(z: S) => 1;\ny(5 || 'foo') // inferred as `string | number`\n```\n\nIn order to infer generics contextually, TypeScript needs to be in a position to actually resolve to a single type (which a union type is a single type).  For example:\n\n``` typescript\nconst y = <S, E>(z: S | E, a: S, b: E) => 1;\ny(5 || 'foo', 6, 'bar') // inferred as number, string\ny(5 || true, 6, 'bar') // an Error\n```\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why TypeScript cannot split union types into separate generic parameters during inference",
      "Identification of contextual requirements for TypeScript to distinguish generic parameters",
      "Guidance on structuring code to enable distinct generic type inference",
      "Demonstration of TypeScript's type resolution limitations with union types in generics"
    ]
  },
  {
    "number": 10655,
    "title": "Async map iteration does not work as expected",
    "created_at": "2016-08-31T22:37:21Z",
    "closed_at": "2016-09-02T22:07:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10655",
    "body": "**TypeScript Version:**  1.8.10\n\n**Code**\n\n``` ts\nvar map = new Map<string, any>();\nmap.set('abc', 123);\nmap.forEach(async (value)=>{\nawait DoSomethingAsyncWithValue(val);\n});\n```\n\n**Expected behavior:**\nShould asynchronously iterate over the map.\n\n**Actual behavior:** \nSynchronously iterates over the map.\n\nThere are no compilation errors from this code, so a developer would assume it'd work the same as an Array forEach.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10655/comments",
    "author": "Roam-Cooper",
    "comments": [
      {
        "user": "Arnavion",
        "created_at": "2016-09-01T01:13:42Z",
        "body": "> Expected behavior:\n> Should asynchronously iterate over the map.\n\nThat would be a violation of the ES6 spec, and is outside of TS's control at any rate.\n\n> There are no compilation errors from this code, so a developer would assume it'd work the same as an Array forEach.\n\nThat is technically legal from both runtime perspective and compiler perspective.\n\nFrom runtime's point of view, the callback given to `forEach` is returning a `Promise` that `forEach` ignores and throws away.\n\nFrom TS compiler's point of view, `forEach` excepts a callback that returns `void`, whereas the actual callback is returning a `Promise`. But it is legal to assign callbacks that return non-`void` to callbacks that return `void`. (This is useful for writing single-expression lambdas where one just wants the result of the expression to be ignored.) So there is nothing to raise a compiler error about.\n\nPerhaps you could create a tslint rule for this, something like \"Async lambda used with Array#forEach may not work as expected.\"\n"
      },
      {
        "user": "yortus",
        "created_at": "2016-09-01T07:20:23Z",
        "body": "@Roam-Cooper you could try something like this:\n\n``` ts\nasync function foo() {\n    var map = new Map<string, any>();\n    map.set('abc', 123);\n\n    for (let [key, val] of map) {\n        await doSomethingAsyncWithValue(val);\n    }\n}\n```\n"
      },
      {
        "user": "Roam-Cooper",
        "created_at": "2016-09-01T07:26:52Z",
        "body": "I've already solved it with a for..of loop of course, just didn't know es6\nspec doesn't include asynchronous map iteration. :)\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why Map.forEach behaves synchronously according to ES6 specifications",
      "Alternative approach for sequential asynchronous iteration over Map entries",
      "Clarification that TypeScript's type system allows Promise-returning callbacks in void-expected contexts",
      "Differentiation between iteration mechanism and async execution control"
    ]
  },
  {
    "number": 10551,
    "title": "Generic type constraint for abstract class.",
    "created_at": "2016-08-26T02:10:03Z",
    "closed_at": "2016-08-26T04:11:27Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10551",
    "body": "Too constraint a generic type that is a class, we can write `{new():T}`, however it doesn't match an abstract class.\n\n``` typescript\nclass X{};\nabstract class Y{};\nfunction f<T>(x: {new():T});\nf(X);// OK\nf(Y);// Faild\n```\n\nIs there any way overcome this?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10551/comments",
    "author": "thynson",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-08-26T03:32:14Z",
        "body": "Why would you want to? It's illegal to `new Y`.\n\nYou could also write `function f<T>(x: {prototype: T})`\n"
      },
      {
        "user": "thynson",
        "created_at": "2016-08-26T04:11:27Z",
        "body": "I'm writing an IoC container, use abstract class itself as indentifier to register its implementation.\nAnd `function f<T>(x: {prototype: T})` works, thank you!\n"
      }
    ],
    "satisfaction_conditions": [
      "Allows passing abstract classes as type identifiers without requiring instantiation capability",
      "Provides a way to reference class/constructor types that may not have public constructors",
      "Maintains type relationship between class and its prototype"
    ]
  },
  {
    "number": 10156,
    "title": "On static method Error TS2339: Property 'then' does not exist on type '() => Promise'",
    "created_at": "2016-08-04T22:26:53Z",
    "closed_at": "2016-08-04T23:29:43Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10156",
    "body": "<!-- BUGS: Please use this template. -->\n\n**TypeScript Version:**  1.8.10 and nightly (2.1.0-dev.20160804)\n\n**Code**\n\n``` ts\n/// <reference path=\"typings/globals/core-js/index.d.ts\" />\n\nexport class CryptoService\n{\n  static getToken()\n  {\n    return Promise.resolve('123');\n  }\n\n  static setXsrf()\n  {\n    return this.getToken.then( token  => {} );\n  }\n}\n```\n\n**Not expected error:**\n\n> error TS2339: Property 'then' does not exist on type '() => Promise<string>'.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10156/comments",
    "author": "KostyaTretyak",
    "comments": [
      {
        "user": "DickvdBrink",
        "created_at": "2016-08-04T22:30:47Z",
        "body": "You wanted to write `this.getToken()` (notice the `()`) right?\n"
      },
      {
        "user": "KostyaTretyak",
        "created_at": "2016-08-04T22:38:57Z",
        "body": "@DickvdBrink, you say that I can not get a token?\n"
      },
      {
        "user": "normalser",
        "created_at": "2016-08-04T23:26:09Z",
        "body": "Change:\n`return this.getToken.then( token  => {} );`\nto\n`return this.getToken().then( token  => {} );`\n"
      },
      {
        "user": "KostyaTretyak",
        "created_at": "2016-08-04T23:30:58Z",
        "body": "Thank you guys! I am ashamed =)\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-08-05T01:04:28Z",
        "body": "Unless you have reason to believe there's actually a compiler bug, please use Stack Overflow for questions or log an issue with the definition file. Thanks!\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why accessing a method reference without invocation causes a type mismatch",
      "Clarification of the distinction between method references and method return values in TypeScript's type system",
      "Resolution of TS2339 error through proper Promise chain access"
    ]
  },
  {
    "number": 10135,
    "title": "Cannot rebuild declarations with declarationDir",
    "created_at": "2016-08-04T13:03:51Z",
    "closed_at": "2016-08-31T14:54:47Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10135",
    "body": "**TypeScript Version:**  2.0.0-beta\n\n**Configuration**\n\n``` json\n{\n    \"compilerOptions\": {\n        \"declaration\": true,\n        \"declarationDir\": \"declarations\"\n    }\n}\n```\n\n**Expected behavior:**\nIn the first run, compiler generate declarations. When start second build `.d.ts` files should be updated.\n\n**Actual behavior:** \nAfter second run, I get this error:\n\n``` cmd\nerror TS5055: Cannot write file 'declarations/*.d.ts' because it would overwrite input file.\n```\n\nAnd declarations files not updated.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10135/comments",
    "author": "GiedriusGrabauskas",
    "comments": [
      {
        "user": "lostfields",
        "created_at": "2016-08-31T07:39:44Z",
        "body": "add the following to your tsconfig.json to avoid making declarations of declarations or something :-)\n\n```\n\"exclude\": [\"./declarations\"]\n```\n"
      },
      {
        "user": "GiedriusGrabauskas",
        "created_at": "2016-08-31T08:53:20Z",
        "body": "Yep, it's working and that make sense. Thanks :+1: \n"
      }
    ],
    "satisfaction_conditions": [
      "Prevent TypeScript compiler from treating declaration output directory as input source",
      "Allow successful regeneration of declaration files on subsequent builds",
      "Maintain declaration file generation functionality",
      "Avoid manual file management between builds"
    ]
  },
  {
    "number": 10105,
    "title": "Use lib/lib.*.d.ts as regular program files",
    "created_at": "2016-08-03T00:20:32Z",
    "closed_at": "2016-08-03T05:56:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10105",
    "body": "We use the same `tsconfig.json` `compilerOptions` for all code in our monorepo.\nEach target gets to specify only the `files` list.\n\nWe'd like some targets to be able to opt-in for typings like collections. In the past, we did that by including the DefinitelyTyped es6-collections.d.ts in the files.\n\nIf I include one of the `///<reference no-default-lib=true/>` files, though, I get an error:\n\n```\nalexeagle@alexeagle:~/Projects/repro$ cat tsconfig.json \n{\n    \"compilerOptions\": {\n        \"module\": \"commonjs\",\n        \"target\": \"es5\"\n    },\n    \"files\": [\"node_modules/typescript/lib/lib.es2015.collection.d.ts\"]\n}\nalexeagle@alexeagle:~/Projects/repro$ $(npm bin)/tsc\nerror TS2318: Cannot find global type 'Array'.\nerror TS2318: Cannot find global type 'Boolean'.\nerror TS2318: Cannot find global type 'Function'.\nerror TS2318: Cannot find global type 'IArguments'.\nerror TS2318: Cannot find global type 'Number'.\nerror TS2318: Cannot find global type 'Object'.\nerror TS2318: Cannot find global type 'RegExp'.\nerror TS2318: Cannot find global type 'String'.\n```\n\nThis is the case even if other files are included in the compilation. I can solve it by removing the `///ref` but this means we have local modifications to Typescript. Is there another way to defeat the error?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10105/comments",
    "author": "alexeagle",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-08-03T03:13:14Z",
        "body": "Those errors only come up because you didn't include `lib.es5.d.ts` , so you didn't have the global core types available.\n\nDoes this using this `tsconfig.json` fix the issue?\n\n``` json\n{\n    \"compilerOptions\": {\n        \"module\": \"commonjs\",\n        \"target\": \"es5\"\n    },\n    \"files\": [\n        \"node_modules/typescript/lib/lib.es5.d.ts\",\n        \"node_modules/typescript/lib/lib.es2015.collection.d.ts\"\n    ]\n}\n```\n"
      },
      {
        "user": "alexeagle",
        "created_at": "2016-08-03T05:56:12Z",
        "body": "Thanks Daniel, that does work.\n\nI had tried\n\n```\n{\n    \"compilerOptions\": {\n        \"module\": \"commonjs\",\n        \"target\": \"es5\",\n        \"noImplicitAny\": false,\n        \"sourceMap\": false,\n        \"lib\": [\"es5\"]\n    },\n    \"files\": [\n        \"app.ts\",\n        //\"node_modules/typescript/lib/lib.es5.d.ts\",\n        \"node_modules/typescript/lib/lib.es2015.collection.d.ts\"\n    ]\n}\n```\n\nthinking that the `--lib` flag would bring in the standard types (and this is what we have today). I imagine that `no-default-lib` actually means don't use any default libs, and the `--lib` flag just chooses a different set of \"default\" libs?\n\nBut it will probably make our setup easier to just use `--noLib` and pass all files together, rather than a mix of `--lib` and `files`\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-08-03T06:27:23Z",
        "body": "Sounds good, keep us posted on how that works out.\n"
      },
      {
        "user": "alexeagle",
        "created_at": "2016-08-08T21:27:49Z",
        "body": "Submitted it today, works great and solves our problem \ud83d\udc4d \n\n\n---\n\nI take that back, we are investigating a 2x performance regression for compiles.\nWe now include v1_9_0_dev_20160526/lib/lib.es5.d.ts in the `files[]` of tsconfig. Even though we have a cache that prevents re-reading from disk, and we don't ask to type-check that file, I suspect we now hit some parse time when creating a `ts.Program` containing that.\nPreviously, it was in `--lib` and we `skipDefaultLibCheck` - I am guessing we also skipped parsing?\n\ncc @evmar who is profiling it.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-09-08T23:10:21Z",
        "body": "@alexeagle is this still an issue?\n"
      },
      {
        "user": "alexeagle",
        "created_at": "2016-09-09T13:11:40Z",
        "body": "thanks for following up. We did track down our performance regression. @evmar could confirm, looking at the history we were not certain what introduced it. removing `--noEmitOnError` helped, as that was triggering an extra type-check.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explains how to include TypeScript library definition files without causing missing global type errors",
      "Clarifies the interaction between compilerOptions.lib and explicit file inclusion",
      "Addresses performance implications of different lib inclusion strategies",
      "Provides guidance on maintaining monorepo configuration consistency while allowing per-target customization",
      "Explains the relationship between no-default-lib references and compiler options"
    ]
  },
  {
    "number": 9811,
    "title": "Cannot define declared variable with the same property",
    "created_at": "2016-07-19T07:46:15Z",
    "closed_at": "2016-07-25T06:14:32Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9811",
    "body": "**TypeScript Version:**  1.8.0 / nightly (2.0.0-dev.201xxxxx)\n\n**Code**\n\n``` ts\ninterface A {   \n}\n\ndeclare var A: {\n    x: number;\n}\n\nclass AShim implements A {\n    x: number;\n}\n\nvar A: {\n     x: number;\n} = AShim;\n```\n\n**Expected behavior:**\nI expect this to compile successfully.\n\n**Actual behavior:** \n\n```\na.ts(12,5): error TS2322: Type 'typeof AShim' is not assignable to type '{ x: number; }'.\n  Property 'x' is missing in type 'typeof AShim'.\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9811/comments",
    "author": "NN---",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-07-19T10:41:56Z",
        "body": "Classes have two interfaces, the instance interface and the static interface of the constructor function.  You are trying to assign something that is a class to something that is a simple object interface.  The static interface can be referenced as `typeof AShim` and `new AShim()` would produce something that is assignable to `A`.\n\nTo describe an interface that `AShim` could be assigned to, it would look like this:\n\n``` typescript\ninterface AConstructor {\n    new (): A;\n    prototype: A;\n}\n\nvar A: AConstructor = AShim;\n```\n"
      },
      {
        "user": "NN---",
        "created_at": "2016-07-19T18:25:03Z",
        "body": "Why it works for other cases like this:\n\n``` ts\n\ninterface Blob {\n    size: number;\n    type: string;\n    msClose(): void;\n    msDetachStream(): any;\n    slice(start?: number, end?: number, contentType?: string): Blob;\n}\n\ndeclare var Blob: {\n    prototype: Blob;\n    new (blobParts?: any[], options?: BlobPropertyBag): Blob;\n}\n\nclass BlobShim implements Blob {\n    constructor(blobParts?: any[], options?: BlobPropertyBag) { }\n    msDetachStream(): any {}\n    slice(start?: number, end?: number, contentType?: string): Blob {\n        return null;\n    }\n    msClose(): void {}\n    type: string;\n    size: number;\n}\n\n// OK\nvar Blob: {\n    prototype: Blob;\n    new(blobParts?: any[], options?: BlobPropertyBag): Blob;\n} = BlobShim;\n```\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-07-19T21:39:17Z",
        "body": "Because BlobShim's interface matches the interface for `var Blob`.  Above, you were trying to put assign a constructor function/class to an instance interface, as I explained.  Here, you are assigning `BlobShim` to a constructor interface, which works.\n"
      },
      {
        "user": "NN---",
        "created_at": "2016-07-20T06:20:49Z",
        "body": "@kitsonk Your example doesn't compile.\n\n``` ts\ninterface A {   \n}\n\ndeclare var A: {\n    x: number;\n}\n\nclass AShim implements A {\n    x: number;\n}\n\ninterface AInterface {\n    x: number;\n}\n\nvar A: AInterface = AShim;\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-07-20T06:25:54Z",
        "body": "@NN--- can you explain what is the original issue behind the OP? \n"
      },
      {
        "user": "NN---",
        "created_at": "2016-07-20T09:40:56Z",
        "body": "@mhegazy I am writing tests with PhantomJS runner.\nIt doesn't have window.URL object, so I want to create my own.\nThe code worked well in TS 1.8 and stopped working in TS 2.0.\nAfter some investigations I got to this minimal code sample.\n\nI don't understand why it doesn't work while having the exact same types on both sides.\n"
      },
      {
        "user": "normalser",
        "created_at": "2016-07-21T03:03:47Z",
        "body": "@NN---  \n\nSeems like you did not understand @kitsonk explanation\n\nHere is your last full example adjusted to compile\n\n``` ts\ninterface A {   \n}\n\ndeclare var A: {\n    x: number;\n}\n\nclass AShim implements A {\n    x: number;\n}\n\ninterface AInterface {\n    x: number;\n}\n\nvar A: AInterface = AShim.prototype;\nvar A: AInterface = new AShim();\n\ninterface AInterface2 {\n    new (): AInterface;\n    prototype: AInterface;\n}\n\nvar A2: AInterface2 = AShim;\n```\n"
      },
      {
        "user": "NN---",
        "created_at": "2016-07-21T20:38:27Z",
        "body": "@wallverb The only problem that I want to it without A2.\n\nI want to define a variable of URL with my implementation.\nHow I do it ?\nThank you.\n\n``` ts\ninterface URL {\n    hash: string;\n    host: string;\n    hostname: string;\n    href: string;\n    readonly origin: string;\n    password: string;\n    pathname: string;\n    port: string;\n    protocol: string;\n    search: string;\n    username: string;\n    toString(): string;\n}\n\ndeclare var URL: {\n    prototype: URL;\n    new(url: string, base?: string): URL;\n    createObjectURL(object: any, options?: ObjectURLOptions): string;\n    revokeObjectURL(url: string): void;\n}\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-07-21T23:27:17Z",
        "body": "all you need is somehting that has the shape of the the URL constructor, i.e. the type of the `var` `URL`.\n\nso:\n\n``` ts\nclass URLShim {\n    // instace side, i.e. interface URL\n    hash: string;\n    host: string;\n    hostname: string;\n    href: string;\n    readonly origin: string;\n    password: string;\n    pathname: string;\n    port: string;\n    protocol: string;\n    search: string;\n    username: string;\n\n    // Static side, i,e. typeof var URL\n    constructor(url: string, base?: string) { }\n    static createObjectURL(object: any, options?: ObjectURLOptions): string { }\n    static revokeObjectURL(url: string): void { }\n}\n\nURL = URLShim;\n\n```\n"
      },
      {
        "user": "NN---",
        "created_at": "2016-07-25T06:14:32Z",
        "body": "@mhegazy **static createObjectURL** \nThis does the trick :+1: \n\nDidn't think that 'static' affects on type matching, while it is logical though.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of the distinction between class static interfaces and object instance interfaces in TypeScript",
      "Demonstration of proper type matching for constructor functions when shimming global variables",
      "Clarification of how static class members affect type compatibility with object literal types"
    ]
  },
  {
    "number": 9604,
    "title": "Overriding addEventListener to augment event objects",
    "created_at": "2016-07-11T00:25:45Z",
    "closed_at": "2016-07-11T21:33:53Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9604",
    "body": "Ultimately, what I want to do is to describe the following trick:\n\n``` js\nconst element = document.createElement(\"div\");\n\nelement.addEventListener(\"click\", event => {\n  event.foo = 123;\n});\n```\n\nAs you see, my `<div>` element intercepts all \"click\" events and adds a new property to them, so whoever attaches a \"click\" listener later will see this new property.\n\nA practical example would be a custom UI element that represents, for instance, a chess board, and adds `row` and `col` properties to every mouse event, as the consumers of the UI element shouldn't need to convert the plain `x` and `y` coordinates to the cell coordinates.\n\nMy attempt to describe this failed:\n\n``` ts\ninterface MyMouseEvent {\n  foo?: number;\n}\n\ninterface MyElement extends HTMLElement {\n  addEventListener(type: \"click\", listener: (ev: MyMouseEvent) => any, capture?: boolean): void;\n}\n```\n\ntsc complains that the HTMLElement interface is incorrectly extended:\n\n```\nTS2430  Interface 'MyElement' incorrectly extends interface 'HTMLElement'.\n  Types of property 'addEventListener' are incompatible.\n    Type '(type: \"click\", listener: (ev: MyMouseEvent) => any, useCapture?: boolean) => void' is not assignable to type '{ (type: \"MSContentZoom\", listener: (ev: UIEvent) => any, useCapture?: boolean): void; (type: \"MS...'.\n      Type '(type: \"click\", listener: (ev: MyMouseEvent) => any, useCapture?: boolean) => void' provides no match for the signature '(type: string, listener: EventListener | EventListenerObject, useCapture?: boolean): void'\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9604/comments",
    "author": "d180cf",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-07-11T07:19:31Z",
        "body": "When you have overrides that is also an overload, you have to provide at least one overload that matches the overridden function.  This is fairly clearly implied by the error:\n\n``` typescript\ninterface MyElement extends HTMLElement {\n  addEventListener(type: \"click\", listener: (ev: MyMouseEvent) => any, capture?: boolean): void;\n  addEventListener(type: string, listener: EventListener | EventListenerObject, useCapture?: boolean): void;\n}\n```\n"
      },
      {
        "user": "d180cf",
        "created_at": "2016-07-12T01:49:58Z",
        "body": "This works nicely, indeed. Thanks!\n"
      }
    ],
    "satisfaction_conditions": [
      "Properly handle TypeScript interface extension requirements for overloaded methods",
      "Enable type-safe augmentation of event objects for specific event types",
      "Maintain compatibility with standard DOM event listener patterns"
    ]
  },
  {
    "number": 9311,
    "title": "Should syntax like `+someVariable` be allowed by itself?",
    "created_at": "2016-06-22T13:19:02Z",
    "closed_at": "2016-06-22T14:22:29Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9311",
    "body": "**TypeScript Version:**  1.8.10\n\nI've seen some developers at my organization do something like the following _(usually a typo)_\n\n``` ts\nvar num = 4;\nvar demo = +num;\nconsole.log(demo); //4\n```\n\nWriting `+num` seems like it should not be valid syntax by itself, although it is allowed in plain JavaScript.  Either way it really does nothing except look strange as far as I can tell.\n\nI can't really think of a valid reason why syntax like this should be allowed, but I'd be curious to hear if anyone knows reasons why it should.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9311/comments",
    "author": "ChrisMBarr",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-06-22T13:43:41Z",
        "body": "It is a form of _valid_ implicit coercion:\n\n``` javascript\nconst four = 4;\nconst a = +four;\nconst b = +false;\nconst c = +'4';\nconsole.log(a, b, c); // 4, 0, 4\nconsole.log(typeof a, typeof b, typeof c); // number, number, number\n```\n\nSo not in all cases would it be an error.  This sort of thing is usually addressed best by a linter (e.g. `tslint`) instead of \"breaking\" the JavaScript compatibility in TypeScript.\n"
      },
      {
        "user": "ChrisMBarr",
        "created_at": "2016-06-22T13:53:46Z",
        "body": "ah ok, I was not aware of that. I suppose I've only seen it used \"improperly\" then\n"
      }
    ],
    "satisfaction_conditions": [
      "Explains valid use cases for unary plus operator syntax in JavaScript/TypeScript",
      "Addresses TypeScript's design philosophy regarding JavaScript compatibility",
      "Differentiates between language syntax validation and code quality enforcement"
    ]
  },
  {
    "number": 9302,
    "title": "Typing is clumsy when instancing using class objects derived from an abstract class",
    "created_at": "2016-06-21T20:04:57Z",
    "closed_at": "2016-09-20T22:48:19Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9302",
    "body": "Suppose you have an abstract class `A` and two concrete clases `B`, `C` derived from `A`, and you want to store `B` and `C` as first-class values to make instances from these values: \n\n``` ts\nabstract class A  { a: any}\nclass B extends A { b: any}\nclass C extends A { c: any}\n\nlet classes  = [B, C]            // inferred type = (typeof B | typeof C)[]\nlet instance = new classes[1]()  // inferred type = (B | C)\ninstance.a                       // ok, because .a is in B and C\n```\n\nIt will be nice if the previous example inferred the `instance` type as `A` instead of `(B | C)`. But it works. \nThe problem comes when TS can't infer the `classes` type, like when using a `Map` instead of an array:\n\n``` ts\nlet classes2 = new Map([[\"b\", B], [\"c\", C]]) // error TS2453: The type argument for type parameter 'V' cannot be inferred from the usage.\nlet classes3 = new Map<string, typeof A>([[\"b\",B], [\"c\", C]])\nlet classes4 = new Map<string, typeof B | typeof C>([[\"b\",B], [\"c\", C]])\n\nvar instance3 = new (classes3.get(\"c\"))()   // TS2511: Cannot create an instance of the abstract class 'A'.\nvar instance4 = new (classes4.get(\"c\"))()   // inferred type = (B | C)\n```\n\n`classes2` doesn't work because TS can't infer the type. \n`classes3` doesn't work because you can't use it for instancing.\n`classes4` example worked but is very clumsy for a large number of classes, you need to type `(typeof B | typeof C | ...)` for all the classes involved. Maybe this is acceptable but I think there is a need to be able of defining (and inferring) a type like \"all concrete classes derived from A\".\n\nBelow is the same example but using a concrete base class. Note in this case you can use `<typeof A>` as the type of the array / map values:\n\n``` ts\nclass A  {a : any}    // now concrete\nclass B extends A { b: any}\nclass C extends A { c: any}\n\nlet classes0 = [B, C]  // inferred type = (typeof B | typeof C)[]\nlet classes1 = <typeof A[]>[B,C]\n\nlet instance1 = new classes0[1]()  // inferred type = (B | C)\ninstance1.a                        // ok, because .a is in B and C\nlet instance2 = new classes1[1]()  // inferred type = A\ninstance2.a                        // ok, because .a is in A\n\nlet classes2 = new Map([[\"b\", B], [\"c\", C]]) // error TS2453: The type argument for type parameter 'V' cannot be inferred from the usage.\nlet classes3 = new Map<string, typeof A>([[\"b\",B], [\"c\", C]])\nlet classes4 = new Map<string, typeof B | typeof C>([[\"b\",B], [\"c\", C]])\n\nvar instance3 = new (classes3.get(\"c\"))()   // inferred type = A\nvar instance4 = new (classes4.get(\"c\"))()   // inferred type = (B | C)\n```\n\n**TypeScript Version:** \n\n1.9.0-dev.20160616-1.0\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9302/comments",
    "author": "nahuel",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-06-21T20:13:35Z",
        "body": "I think what you want is this?\n\n``` ts\nlet classes5 = new Map<string, new() => A>([[\"b\",B], [\"c\", C]]); // OK\n\nvar instance5 = new (classes5.get(\"c\"))(); // OK, instance5: A\n```\n"
      },
      {
        "user": "nahuel",
        "created_at": "2016-06-22T14:27:38Z",
        "body": "@RyanCavanaugh thanks, your example solves this problem! Just a detail, there is a way to reference the `A` constructor signature to avoid repeating it on the `Map` one? I mean:\n\n``` ts\nabstract class A  { a: any\n                    constructor (x: number, y: number) {}}\nclass B extends A { b: any}\nclass C extends A { c: any}\n\nlet classes5 = new Map<string, new(x : number, y : number) => A>([[\"b\",B], [\"c\", C]]); // OK\n     // must repeat args signature ^^^^^^^^^^^^^^^^^^^^^^\nvar instance5 = new (classes5.get(\"c\"))(1,2); // OK, instance5: A\n\n// Is possible to reference the A constructor signature? something like this:\nlet classes6 = new Map<string, typeof A.new>([[\"b\",B], [\"c\", C]]); \n```\n\nThanks for your reply.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-06-22T15:45:15Z",
        "body": "Unfortunately there isn't\n"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-06-22T19:53:00Z",
        "body": "It's interesting to note that using an object literal might be more typesafe and refactoring friendly than using a `Map`.\n\n``` TypeScript\nabstract class A  { a: any}\nclass B extends A { b: any}\nclass C extends A { c: any}\n\nlet classes  = { B, C };\nlet instance = new classes.B()  // inferred type = B\ninstance.a                       // ok, because .a is in B\n```\n"
      },
      {
        "user": "nahuel",
        "created_at": "2016-06-25T20:28:02Z",
        "body": "@aluanhaddad that works, but not when you use an string based key (eg. one taken from a config file). In your example `var a = 'B' ; classes[a]` will be inferred as `any`.\n"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-06-25T21:01:13Z",
        "body": "The keys are strings, I'm simply using concise object literal notation for brevity and in order to leverage refactoring. It's true that if you're using an index signature with a string literal, it becomes more difficult, but I don't see how it is any worse than an array, and at least it makes any necessary casting more intuitive. But you could add an index signature like\n\n``` typescript\n[key: string]: B | C;\n```\n\nor\n\n``` typescript\n[key: string]: new () => A;\n```\n\nThen again that kind of defeats the thing you were trying to achieve in the first place. When the keys are not constants, it's easy to run into this sort of thing.\nWould it be possible for the config file to be a TypeScript file containing exported constants? I found that to be quite useful in certain cases. Also it looks like there will be support for typed JSON Imports at some point in the future.\n"
      },
      {
        "user": "nahuel",
        "created_at": "2016-06-25T21:18:17Z",
        "body": "@aluanhaddad: let me check if I get you, given this:\n\n``` ts\nlet classes1 = new Map<string, new() => A>([[\"B\", B], [\"C\", C]]); \nlet classes2 : {[k : string] : new() => A } = { B, C };\n```\n\n`classes2` is more concise, and his initialization is more refactorizable when you change `B` or `C` names. But there are no other advantages over `classes1` in the later usage when you need to access it using string keys.\n"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-06-25T21:45:11Z",
        "body": "Actually, I think this works better,\n(TypeScript 1.9.0-dev.20160624-1.0)\n\n``` TypeScript\nlet classes = { B, C };\n\nlet CPrime = classes[\"C\"]; // CPrime has the same type as C\nlet instance = new C(); // instance is an instance of C\nconsole.log(instance.c);\n```\n\nThe problem is the config file. The constant value does not seem to propagate across module boundaries. Forgot my idea of about using a _.ts_ configuration file. It only seems to work within one file.\n\nI had a thought that you could do \n\n``` TypeScript\nimport { classKey } from \"./config\"; // classKey is defined as \"export const classKey = 'C';\"\nlet CPrime = classes[classKey]; // Unfortunately has type any\n```\n\nEdit: It's not related to modules, it has to do with string literal type inference. Even if I give a variable an explicit string literal type, it does not flow from the variable to the index signature. There are a lot of issues related to this.\n"
      },
      {
        "user": "nahuel",
        "created_at": "2016-06-25T22:37:51Z",
        "body": "@aluanhaddad when I said \"a config file\" I meant an arbitrary JSON document loaded at runtime, not an imported \"config\" module. But yes, I think you are pointing to another valid issue.\n"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-06-26T00:14:06Z",
        "body": "@nahuel that probably should have been obvious to me because otherwise they wouldn't have been much of a point to the scenario you described. Sorry if I got the issue off track. I don't see how TypeScript could provide this however, without compile time constants. A run-time scenario like you mention, where the type is decided based on dynamically imported configuration is going to have to do type assertions. There is an issue tracking type providers which may be closer to what you're looking for #3136\n"
      }
    ],
    "satisfaction_conditions": [
      "Solution must allow storing concrete subclass constructors in collections (like Map) while preserving the ability to create instances with abstract base class type inference",
      "Must avoid repetitive union type declarations for all concrete subclasses",
      "Should support abstract class constructor signature references without duplication",
      "Must maintain type safety when using string-based keys for dynamic class lookup",
      "Solution should handle constructor parameter changes in base class without breaking dependent collections"
    ]
  },
  {
    "number": 9247,
    "title": "Cannot set property 'xyz' of undefined",
    "created_at": "2016-06-18T11:38:15Z",
    "closed_at": "2016-06-18T18:13:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9247",
    "body": "It would seem like this is a (common?) bug that the compiler could catch for us.\n\nGiven this example class:\n\n``` javascript\nclass Foo {\n    bar: number;\n}\nlet a: Foo;\na.bar = 1;\n```\n\nAt runtime I will get an error 'Cannot set property 'bar' of undefined because I never actually initialized the object. (i.e. `let a: Foo = new Foo();` or `let a = new Foo();`)\nThis seems to me like it could probably be a pretty common developer mistake given the ability to provide types (: Foo), especially since editors will give you full Intellisense on the object just by naming the type of it without initialization.  I'm curious if it's something that the Compiler could catch?  (variable a is undefined; declared, but never initialized)\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9247/comments",
    "author": "benjaminmillhouse",
    "comments": [
      {
        "user": "yortus",
        "created_at": "2016-06-18T13:25:50Z",
        "body": "If you use the `--strictNullChecks` compiler option, you'll get a compiler error stating `Variable 'a' is used before being assigned`. Is that what you are after?\n"
      },
      {
        "user": "benjaminmillhouse",
        "created_at": "2016-06-18T17:57:14Z",
        "body": "That probably would do it. Sorry, didn't see that in the tsconfig options. I'll give it a try. \n"
      },
      {
        "user": "yortus",
        "created_at": "2016-06-18T20:47:14Z",
        "body": "@benmillhouse it's only in the nightly version, so might not be documented yet. See #7140. \n"
      }
    ],
    "satisfaction_conditions": [
      "Detects uninitialized variables at compile time",
      "Works with TypeScript's type system",
      "Prevents 'undefined' property access errors",
      "Doesn't require explicit initialization syntax changes"
    ]
  },
  {
    "number": 9243,
    "title": "a class cannot extend events node module",
    "created_at": "2016-06-18T06:11:48Z",
    "closed_at": "2016-06-18T18:17:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9243",
    "body": "**TypeScript Version:** \n\n1.8.10\n\n**Code**\n\n``` ts\n/// <reference path=\"./../../../typings/index.d.ts\" />\nimport {EventEmitter} from \"events\";\nclass _req extends EventEmitter {\n    constructor() {\n        super();\n    }\n    emit() {\n        super.emit(\"test\")\n    }\n}\nconst a = new _req();\na.on(\"test\", _ => {\n    console.log(\"test was called\");\n})\na.emit();\n```\n\n**Expected behavior:**\ncompile with no errors \n**Actual behavior:** \ni got the error telling me \n\n```\nts/core/request/index.ts(3,7): error TS2415: Class '_req' incorrectly extends base class 'EventEmitter'.\n  Types of property 'emit' are incompatible.\n    Type '() => void' is not assignable to type '(event: string, ...args: any[]) => boolean'.\n      Type 'void' is not assignable to type 'boolean'.\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9243/comments",
    "author": "ta3pks",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-06-18T06:56:05Z",
        "body": "This isn't an issue with TypeScript.  This is basic stuff.  You should read the error and fix it.\n\nThe method you are extending does not match the contract of the underlying class.  As the error says, your extended `emit` is of type `() => void`, but the method you are extending is of type `(event: string, ...args: any[]) => boolean` and the need to be compatible, so at the very least `emit` need to return a boolean value.\n\nFor basic questions like these, StackOverflow, Gitter or IRC are better places to ask.\n"
      },
      {
        "user": "ta3pks",
        "created_at": "2016-06-18T18:17:01Z",
        "body": "ah now it makes sense i am sorry for opening this i just didnt pay attention to my own emit method \n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of method signature compatibility when overriding base class methods",
      "Clarification of TypeScript's inheritance requirements for method overrides",
      "Guidance on proper EventEmitter subclassing patterns"
    ]
  },
  {
    "number": 9137,
    "title": "Allow to discard code when generating code.",
    "created_at": "2016-06-13T18:15:15Z",
    "closed_at": "2016-06-13T18:48:43Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9137",
    "body": "I have JavaScript library , where I have multiple inheritance done with my own functions to extend.\n\nBut for intellisense purpose we have add some interface to allow lookup for function withing the classes and implemented dummy functions for completeness. But when generating the code, I would like to take that out.\n\nCan we added that feature take out some code when generating JS code.\nJust one switch let us say, #NOT_A_CODE #END_NOT_A_CODE ... and ignore the code in between.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9137/comments",
    "author": "mubbasher16",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-06-13T18:22:41Z",
        "body": "Interfaces don't generate code; if you need to have a class that doesn't generate code, you can use the `declare` keyword to create an ambient class. There shouldn't be anything you need to do for intellisense / type information purposes that requires a construct that generates code.\n"
      },
      {
        "user": "mubbasher16",
        "created_at": "2016-06-13T19:10:31Z",
        "body": "It's not ambient class.\nit is actual class.  I get this error.\n[ts] 'declare' modifier cannot appear on a class element.\n\nSome stuff needs to be added to the class for intellisense. But It would be only added at runtime.\nby some other JS library say for instance.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-06-13T19:43:05Z",
        "body": "not the class member, the whole class.\n\n``` ts\ndeclare class C {\n    property: number;\n    method(a: string): C;    \n}\n\n\nvar x = new C();\nx.method(\"string\");\n```\n"
      },
      {
        "user": "mubbasher16",
        "created_at": "2016-06-13T22:17:33Z",
        "body": "Got it that would work in fact.\n\nBut if someone ends up in a situation like me...\n\nI just created a small quick code in C# to post process my final javascript and remove the code between the comments, //##NOT_A_CODE //##END_NOT_A_CODE.\nMy situation is slightly different.\n\nAnd if someone interested in how to do multiple inheritance using JavaScript or even using the TypeScript which apparently doesn't support it ... give me a ping. :) as I did achieved :+1: \n"
      }
    ],
    "satisfaction_conditions": [
      "A mechanism to exclude specific code segments from generated output while retaining them for development tooling",
      "Support for development-time constructs that don't affect runtime behavior",
      "Compatibility with existing class-based patterns",
      "Non-intrusive exclusion syntax"
    ]
  },
  {
    "number": 8890,
    "title": "Unable to run Array.map on an Array",
    "created_at": "2016-05-31T07:45:40Z",
    "closed_at": "2016-05-31T09:48:34Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8890",
    "body": "**TypeScript Version:** \n\n1.8\n\n**Code**\n\n``` ts\nfunction getARPTable() {\n    return new Promise((resolve, reject) => {\n        arp.table((error, devices) => {\n            if (error) reject(error);\n            else resolve(devices);\n        });\n    });\n}\n\nasync function scanPorts() {\n    let devices = await getARPTable();\n    console.log(Array.isArray(devices)); // true\n    devices = devices.map((device) => device); // error\n                      ^\n    return true;\n}\n\nscanPorts();\n```\n\n**Expected behavior:**\n\nNo error output\n\n**Actual behavior:** \n\n`error TS2339: Property 'map' does not exist on type '{}'.`\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8890/comments",
    "author": "xeoneux",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-05-31T09:31:33Z",
        "body": "TypeScript cannot contextually determine what the `Promise` resolves to (see: #5254) therefore you have to assert it.\n\nSomething like:\n\n``` typescript\nfunction getARPTable() {\n    return new Promise<any[]>((resolve, reject) => {\n        arp.table((error, devices) => {\n            if (error) reject(error);\n            else resolve(devices);\n        });\n    });\n}\n```\n"
      },
      {
        "user": "xeoneux",
        "created_at": "2016-05-31T09:37:51Z",
        "body": "@kitsonk Thanks! I created a similar interface to fix it. However, I am still not sure why does the error occur even after successful compilation to JavaScript and running under node?\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-05-31T09:44:02Z",
        "body": "Because, instead of inferring type `any` for the `Promise` resolution, TypeScript infers `{}` which is an object with no properties, therefore doesn't have a `.map` method.  IIRC there was a lot of discussion in the ticket I linked to as to why `{}` instead of `any` makes sense when filling a generic that cannot be contextually determined.  By default, TypeScript will still emit the code, even if it has errors.  So while the run-time behaviour works, TypeScript couldn't be sure it would be when it emitted the code.\n"
      },
      {
        "user": "xeoneux",
        "created_at": "2016-05-31T09:48:34Z",
        "body": "@kitsonk I didn't realise that the error was during compilation and not during runtime. Thanks for the clarification! \ud83d\ude04 \n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of TypeScript's type inference behavior for Promise resolutions",
      "Solution ensuring TypeScript recognizes the resolved value as an array type",
      "Clarification of compile-time vs runtime type checking differences in TypeScript",
      "Addresses contextual typing limitations with Promises in TypeScript"
    ]
  },
  {
    "number": 8642,
    "title": "Using interface of an enumeration and module merged type as generics type parameter",
    "created_at": "2016-05-17T09:45:41Z",
    "closed_at": "2016-05-18T09:31:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8642",
    "body": "I found a strange behaviour of enumeration and module merging when using generics. Take a look at the following example:\n\n``` typescript\ninterface IEnumerationType {\n     getNames(): string[];\n}\n\nenum RoleType {\n    ApplicationRole,\n    CompanyRole,\n}\n\nmodule RoleType {\n    export function getNames(): string[] {\n        return [\"ApplicationRole\", \"CompanyRole\"];\n    }\n}\n\nvar r : IEnumerationType = RoleType;\n```\n\nIt compiles without error. The RoleType implements the IEnumerationType, it has a getNames method because of the enum+module merging.\n\nIf I want to use IEnumerationType and RoleType as a generic type parameter, it fails:\n\n``` typescript\ninterface MyInterface<TEnumeration extends IEnumerationType> {\n    enumerationType: TEnumeration;\n}\n\nvar x : MyInterface<RoleType>; // error, why? RoleType implements IEnumerationType\n```\n\nIs this a bug or is it a documented behaviour?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8642/comments",
    "author": "laszlojakab",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-05-17T19:18:14Z",
        "body": "The type name `RoleType` refers to a value of the enum type. Remember that you would normally write:\n\n``` ts\nlet x: RoleType = RoleType.CompanyRole;\n```\n\nThe type `RoleType` doesn't implement `IEnumerationType` because it's just a specialized subtype of `number`.\n\nThe type of the value `RoleType` itself is actually anonymous; you can refer to it using the `typeof` operator:\n\n``` ts\nvar x : MyInterface<typeof RoleType>; // OK\n```\n"
      },
      {
        "user": "laszlojakab",
        "created_at": "2016-05-18T09:31:49Z",
        "body": "Thanks for the help I could solve the problem. \n"
      }
    ],
    "satisfaction_conditions": [
      "Clarify the distinction between enum value types and merged module object types in TypeScript",
      "Explain how to reference the complete merged type in generics",
      "Address why the initial type assertion worked but generic usage failed"
    ]
  },
  {
    "number": 8498,
    "title": "interface optional methods not showing ",
    "created_at": "2016-05-06T12:25:37Z",
    "closed_at": "2016-05-09T08:37:15Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8498",
    "body": "**TypeScript Version:** \n\n1.8.30\n\n**Code**\n\n``` ts\ninterface ITest {\n  init?();\n}\n\nclass Test implements ITest {\n  print() {\n    if (typeof this.init == \"function\")\n      this.init();\n  }\n}\n\nclass MyOwnTest extends Test {\n  init() {\n    // boo!  \n  }\n}\n```\n\n**Expected behavior:**\ncompiles without error\n\n**Actual behavior:** \nProperty 'init' does not exist in 'Test'\n\nWhy such construction? \nI would like to provide optional implementation of `init` in user derived type, and check in base class if it was really implemented.\n\ntoday I have to use `this[\"init\"]` - which is not strong type.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8498/comments",
    "author": "pankleks",
    "comments": [
      {
        "user": "malibuzios",
        "created_at": "2016-05-06T12:58:21Z",
        "body": "_(tested on `1.9.0-dev.20160506`)_\n\nI believe it is possible to work around this by declaring an uninitialized property having a a function type in the base class:\n\n``` ts\ninterface ITest {\n    init?(): void;\n}\n\nclass Test implements ITest {\n    init: () => void; // when strict null checking is enabled,\n                      // '() => void | undefined' is possible here as well\n\n    print() {\n        if (typeof this.init == \"function\")\n            this.init();\n    }\n}\n\nclass MyOwnTest extends Test {\n    init = () => {\n        // boo!  \n    }\n}\n```\n"
      },
      {
        "user": "pankleks",
        "created_at": "2016-05-06T13:17:27Z",
        "body": "You right - thanks!\n\nHowever for me it's workaround only as in derived class you MUST use arrow function to define method - can't use \"regular\" method syntax anymore.\n\nSo still, IMO my original syntax should be possible.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-05-06T16:42:33Z",
        "body": "you can use a class/interface pair to define optional properties on a class, so \n\n``` ts\ninterface Test {\n    init?();\n}\n\nclass Test {\n    print() {\n        if (typeof this.init == \"function\")\n            this.init();  // OK\n    }\n}\n```\n\n\n---\n\nthe other option is to use abstract classes/methods. not sure if this fits your requirements though,\n"
      },
      {
        "user": "pankleks",
        "created_at": "2016-05-09T08:37:14Z",
        "body": "Not obvious but works. \nThanks - closing item.\n"
      }
    ],
    "satisfaction_conditions": [
      "Allows optional interface methods to be checked in base classes without type errors",
      "Maintains strong type checking for optional methods",
      "Supports standard method syntax in derived classes",
      "Preserves optional implementation flexibility for subclasses"
    ]
  },
  {
    "number": 8475,
    "title": "is there a way to declare an interface with a method returning an anonymous class?",
    "created_at": "2016-05-05T16:37:36Z",
    "closed_at": "2016-05-05T17:31:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8475",
    "body": "``` typescript\nfunction toClass() {\n    return class {}\n}\n\ninterface I {\n    toClass: () => { /* what goes here? */ }\n}\n\nconst i : I = {\n    toClass: toClass\n};\n\n// need the following to work:\nclass MyClass extends i.toClass() {\n\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8475/comments",
    "author": "zpdDG4gta8XKpMCd",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-05-05T16:44:25Z",
        "body": "there is not a way to keep the class construct, but you should be able to declare it as a consttructor and instance type pair:\n\n``` ts\ninterface Base {\n ....\n}\n\ninterface I {\n    toClass: () => { new (...args: any[]) : Base }\n}\n```\n"
      }
    ],
    "satisfaction_conditions": [
      "The interface must specify a return type that represents a constructable class type",
      "The solution must work with anonymous class expressions",
      "The type declaration must allow proper type checking when extending the class",
      "The interface should not require concrete class names in its definition"
    ]
  },
  {
    "number": 8260,
    "title": "Can't minus two Date object",
    "created_at": "2016-04-23T06:31:58Z",
    "closed_at": "2016-04-23T10:21:50Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8260",
    "body": "**TypeScript Version:** \n\n1.8.9\n\n**Code**\n\n``` ts\n\"use strict\";\n\nlet start = new Date()\nlet end = new Date()\nconsole.log(start - end)\n```\n\n**Expected behavior:**\nprint the difference between two date\n**Actual behavior:** \ndon't compile when compile option  `noEmitOnError` is enabled. \nHere is the error message:\n\n``` bash\napp.ts(5,13): error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.\napp.ts(5,21): error TS2363: The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8260/comments",
    "author": "bennyyip",
    "comments": [
      {
        "user": "Arnavion",
        "created_at": "2016-04-23T08:14:49Z",
        "body": "TS doesn't understand `valueOf`, so it doesn't consider `Date` to be intrinsically convertible to `number` for arithmetic operations. You have to be explicit with `end.getTime() - start.getTime()`\n"
      },
      {
        "user": "weswigham",
        "created_at": "2016-04-23T09:23:57Z",
        "body": "Explicitly coercing to a number with `+` also works.\n\n``` ts\n\"use strict\";\n\nlet start = new Date()\nlet end = new Date()\nconsole.log(+start - +end)\n```\n"
      },
      {
        "user": "bennyyip",
        "created_at": "2016-04-23T10:21:50Z",
        "body": "@Arnavion @weswigham  thanks\n"
      },
      {
        "user": "mikemaccana",
        "created_at": "2017-10-18T14:45:13Z",
        "body": "A more explicit way to coerce to a Number is to use Number:\r\n\r\n    Number(new Date())"
      }
    ],
    "satisfaction_conditions": [
      "Explains how to perform arithmetic operations on Date objects in TypeScript",
      "Resolves TypeScript's type safety error TS2362/TS2363",
      "Provides a type-safe way to convert Date objects to numeric representations",
      "Maintains the ability to calculate time differences in milliseconds",
      "Works with TypeScript's strict type checking (noEmitOnError enabled)"
    ]
  },
  {
    "number": 8032,
    "title": "Empty object or type (`{} | Type`) doesn't work as expected",
    "created_at": "2016-04-12T19:19:44Z",
    "closed_at": "2016-04-12T20:06:31Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8032",
    "body": "**TypeScript Version:** \n\n1.8.9\n\n**Code**\n\n``` ts\ninterface IAnimal {\n  legs: Number;\n}\n\ninterface IHouse {\n  cat: {} | IAnimal;\n}\n\nconst obj: IHouse = {\n  cat: {\n    legs: 2,\n  },\n};\n\nobj.cat.legs = 5;   // Property 'legs' does not exist on type '{} | IAnimal'.\nobj.cat = {};\n```\n\n**Expected behavior:**\n\nShould be able to assign `cat.legs` or `{}` interchangeably.\n\n**Actual behavior:** \n\nUnable to assign `legs` of `{} | IAnimal`.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8032/comments",
    "author": "alexgorbatchev",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-04-12T19:22:25Z",
        "body": "You can't assign the `legs` property to `{}` (it has no members), and the `cat` property might be `{}`.\n\nWhat was your intent in writing `{} | IAnimal` ? This is a somewhat unusual thing to write and it's probably not doing what you think it does.\n"
      },
      {
        "user": "alexgorbatchev",
        "created_at": "2016-04-12T19:24:07Z",
        "body": "You are most likely correct. I'm trying to have a property where it could be a predefined type or an empty object `{}`. \n\n`{} | IAnimal` seemed like an intuitive thing to do, I couldn't find an existing example.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-04-12T19:33:52Z",
        "body": ">  I'm trying to have a property where it could be a predefined type or an empty object `{}`.\n\nIn that case, what you wrote is correct (usually people use `null` or `undefined` as a placeholder, hence my question).\n\nFor this example, the best solution would be a type assertion, since the compiler doesn't know whether or not the `cat` property is `{}` or not:\n\n``` ts\ninterface IAnimal {\n  legs: Number;\n}\n\ninterface IHouse {\n  cat: {} | IAnimal;\n}\n\nconst obj: IHouse = {\n  cat: {\n    legs: 2,\n  },\n};\n\n(obj.cat as IAnimal).legs = 5;   // OK\nobj.cat = {};\n```\n\nThere are other solutions you could play with (writing a type predicate, making `legs` optional, etc) but it really depends on the situation.\n\nAs an aside, you _definitely_ want to use `number` instead of `Number`. `Number` refers to the boxed object you get from e.g. `new Number(5)`; `number` refers to actual numbers you'd commonly see in JS.\n"
      },
      {
        "user": "alexgorbatchev",
        "created_at": "2016-04-12T20:06:31Z",
        "body": "Interesting, thanks for clearing that up. I believe I see how it works now. Because there's no clear way to discern between `{}` and `IAnimal` compiler just choses the first one from `{} | IAnimal`, is that right?\n\nI got it work with making `legs` optional, which isn't ideal, because it's either all properties or an empty object (the actual code is more involved).\n\nThanks for the `number` correction, I haven't realized that.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-04-12T20:53:10Z",
        "body": ">  Because there's no clear way to discern between {} and IAnimal compiler just choses the first one from {} | IAnimal, is that right?\n\nBasically. The rule for union types is that we only allow an operation if it would be legal to do on _each_ member of the union. Since `{}` doesn't have `legs`, the property assignment isn't allowed.\n\nDepending on context we can sometimes tell which you happen to have and will \"narrow\" to one member of the union (e.g. if there's an `instanceof` or `typeof` check), but this situation isn't one of them.\n"
      },
      {
        "user": "tonyxiao",
        "created_at": "2018-03-03T20:03:03Z",
        "body": "@RyanCavanaugh what if I actually want to define an empty object that may not have any properties? (such that the only acceptable value for that object is `{}`)? How would I define the type for that in TypeScript?"
      },
      {
        "user": "mhegazy",
        "created_at": "2018-03-03T20:16:57Z",
        "body": "use `object` instead."
      },
      {
        "user": "evenfrost",
        "created_at": "2018-05-16T16:13:47Z",
        "body": "`object` throws same error. I'm using this to define Vuex default state structure. Any way to define `empty object | Type`  without making all properties of `Type` optional?"
      }
    ],
    "satisfaction_conditions": [
      "Allows a property to accept either a fully defined type or an empty object without requiring optional properties",
      "Provides type safety when accessing properties after assignment",
      "Clarifies how to represent an empty object type in TypeScript unions",
      "Explains TypeScript's type narrowing behavior for union types",
      "Maintains ability to assign empty objects and fully shaped objects interchangeably"
    ]
  },
  {
    "number": 7790,
    "title": "[Question] - Is it possible to cast a type to an entire block?",
    "created_at": "2016-04-02T22:30:32Z",
    "closed_at": "2016-04-02T23:07:03Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7790",
    "body": "Hi there,\n\nQuick question (or suggestion if this isn't possible):\n\nWhat I'm interested in doing is casting a type to an entire block (or to the rest of the current block). I do pretty explicit error handling, and I've found that I have to do this overly verbose `as <type>` statement each time. \n\nHere's a very pointless, but descriptive example:\n\n``` ts\ninterface Person {\n  firstname: string\n  lastname: string\n  age: number\n}\n\nfunction myFunc(x: boolean): Person|Error {\n  if (!x) {\n     return new Error('My error message');\n  }\n  return {\n    firstname: 'John',\n    lastname: 'Doe',\n    age: 45,\n  }\n}\n\nlet output = myFunc(true);\n\n// Handle the error\nif ((output as Error).name === 'Error') {\n  throw output;\n} \n\nconsole.log(\n  (output as Person).firstname + ' ' + (output as Person).lastname\n);\n\n```\n\nI'd like to assume that the `output` variable is of type Person after the if block that checks for an error. Is there any way to re-declare that it is type `Person` so that I don't have to do `(output as Person)` for everything thereafter?\n\nI hope that makes sense. Thanks a lot for the clarification! :smile: \n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7790/comments",
    "author": "dsifford",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-04-02T23:01:31Z",
        "body": "This will be possible once type guards are rewritten to use flow control analysis (this work is currently in progress), assuming you add one helper function that creates an explicit type predicate.\n\nThe working version of the code (simplified) would look like this:\n\n``` ts\nfunction isError(p: any): p is Error {\n  return (p as Error).name === 'Error';\n}\n\nlet x: Person | Error = /* ... */;\n\nif (isError(x)) {\n  throw x;\n}\n\n// Because we know we can't get here if 'x' is 'Error',\n// all future uses of 'x' in this block are seen as type 'Person'\nlet n = x.firstname; // OK\n```\n"
      },
      {
        "user": "dsifford",
        "created_at": "2016-04-02T23:07:03Z",
        "body": "Excellent! Thanks for the clarification.\n"
      }
    ],
    "satisfaction_conditions": [
      "Demonstrates how to narrow variable type after error checking without repeated type assertions",
      "Shows how TypeScript can automatically infer correct type in subsequent code blocks",
      "Utilizes TypeScript's type guard mechanisms",
      "Provides pattern for permanent type reassignment after conditional check"
    ]
  },
  {
    "number": 7659,
    "title": "[Question] - Is there a syntax for defining interface properties of the same type on the same line?",
    "created_at": "2016-03-23T20:29:52Z",
    "closed_at": "2016-03-23T20:39:50Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7659",
    "body": "Hello, \n\nSorry if this has been asked before. The issue history is massive and I couldn't locate it if it has. I also checked SO but didn't find anything.\n\nI'm coming from Golang and one thing that I like from there is the ability to declare properties of the same type on the same line (It reads cleaner IMO). \n\nIs this possible with Typescript?\n\nHere's how I'd define an interface (struct type) in Go\n\n``` go\ntype person struct {\n        firstName, lastName string\n        age int\n}\n```\n\nHere's how I do the same thing currently in TypeScript\n\n``` ts\ninterface person {\n  firstName : string\n  lastName : string\n  age : number\n}\n```\n\nHere's how I'd like to do it\n\n``` ts\ninterface person {\n  firstName, lastName : string\n  age : number\n}\n```\n\nThanks for the clarification! :smile: \n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7659/comments",
    "author": "dsifford",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-03-23T20:37:15Z",
        "body": "It is not allowed to define multiple member declarations in the same declaration statements for interfaces, or classes. nor is it allowed for variable declarations.\n\nto get this behavior you will need to specify the type for each member. If no type is specified, the type is `any`.\n\nthis also applies for variable declarations.\n\n``` ts\nvar x, y : number;  // x : any, y: number\n```\n"
      },
      {
        "user": "dsifford",
        "created_at": "2016-03-23T20:39:50Z",
        "body": "Understood! Thanks for the quick reply! :+1: \n"
      }
    ],
    "satisfaction_conditions": [
      "Clarification of TypeScript's syntax capabilities for grouped property declarations in interfaces",
      "Confirmation that individual type annotations are required for interface properties"
    ]
  },
  {
    "number": 7641,
    "title": "Possible to add a static method on a union type?",
    "created_at": "2016-03-22T19:40:35Z",
    "closed_at": "2016-03-22T20:55:53Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7641",
    "body": "I'm using C like a companion object in Scala:\n\n``` ts\ninterface A {\n  a: number\n}\ninterface B {\n  b: number\n}\nclass C {\n  a: number\n  b: number\n  static c(d: number): number {...}\n}\n```\n\nHow do I express that `C = A|B`? I can do\n\n``` ts\ninterface A {...}\ninterface B {...}\ntype C = A|B\n```\n\nBut then I lose the static method\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7641/comments",
    "author": "bcherny",
    "comments": [
      {
        "user": "jeffreymorlan",
        "created_at": "2016-03-22T20:33:50Z",
        "body": "Just use a variable, not a class:\n\n``` ts\ntype C = A|B;\nvar C = {\n    c(d: number): number {...}\n};\n```\n"
      },
      {
        "user": "bcherny",
        "created_at": "2016-03-22T20:55:53Z",
        "body": "Fantastic, that works great! Thanks @jeffreymorlan!\nAlso, will move these sorts of questions to stackoverflow from now on.\n"
      }
    ],
    "satisfaction_conditions": [
      "Preserve union type semantics while retaining static method functionality",
      "Avoid class-based implementation for the union type",
      "Maintain separate type definition and static method implementation"
    ]
  },
  {
    "number": 7633,
    "title": "Index signature not inherited from interface to class",
    "created_at": "2016-03-22T09:31:25Z",
    "closed_at": "2016-03-29T00:06:57Z",
    "labels": [
      "Question",
      "Canonical"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7633",
    "body": "``` ts\ninterface Foo {\n    [key:string]:any;\n}\n\ninterface Bar extends Foo {\n}\n\nclass Baz implements Foo {\n    [key:string]:any;\n}\n\nclass Qux implements Foo {\n}\n\nconsole.log((<Foo>{})['x']);\nconsole.log((<Bar>{})['x']);\nconsole.log((<Baz>{})['x']);\nconsole.log((<Qux>{})['x']);\n```\n\nOn `(<Qux>{})['x']` compiler fails with `Index signature of object type implicitly has an 'any' type.` message. When it's explicitly added to a class, like with `Baz`, everything works ok. With interfaces it seems to work fine, for example, `Bar` interface behaves as expected.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7633/comments",
    "author": "iby",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-03-29T00:06:56Z",
        "body": "There is a distinction between `extends` and `implements` clauses for classes. `extends` means the current class inherits the shape of the parent; this includes index signatures, properties, and methods. `implements` on the other hand, is just a constraint. it says to the compiler, \"please check that this class incorrectly implements this interface\". there is nothing that is \"inherited\" by implementing the interface.\n\nTypeScript's type system is a structural one. so the implements clause is not required for an instance of this class to be assignable to an instance of the interface it implements. the only requirements, is that their structures match. As a matter of fact, removing the implement clause, should not change the semantics of your program.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why interface index signatures are not inherited when using 'implements' clause",
      "Clarification of difference between structural typing and explicit implementation requirements",
      "Guidance on proper pattern for index signature inheritance in classes",
      "Explanation of 'implements' clause limitations compared to 'extends'"
    ]
  },
  {
    "number": 7620,
    "title": "A syntax for returning \"this\" for method call chaining would be great",
    "created_at": "2016-03-21T20:55:50Z",
    "closed_at": "2016-03-21T21:13:30Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7620",
    "body": "When you've got a bit of inheritance going on, there can be limits to what you can do with method chaining.  Say you've got these two classes:\n\n```\nclass Animal {\n    public sleep() : Animal {\n        return this;\n    }\n}\n\nclass Elephant extends Animal {\n    public squirtWithTrunk(): Elephant {\n        return this;\n    }\n}\n```\n\nGiven an instance of Elephant, you could do this:\nmyElephant.squirtWithTrunk().sleep()\n\nbut you couldn't do this:\nmyElephant.sleep().squirtWithTrunk()\n\nBecause Animal doen't have a \"squirtWithTrunk\" method.\n\nSeems fair enough, but given how much code space method chaining can save, and how much that can matter in JavaScript, it's a shame.  And obviously in raw JavaScript this sort of thing just works.\n\nIf the following syntax were allowed, and \"this\" could be passed through a method chain without its type being narrowed to ancestor types, I think that might be quite nice:\n\n```\nclass Animal {\n    public sleep() : this {\n    }\n}\n\nclass Elephant extends Animal {\n    public squirtWithTrunk(): this {\n    }\n}\n```\n\nI don't know how feasible that would be from a compiler point of view, but as a user of the language I'd find it very useful.  In the last code snippet I imagine that the return statement would be disallowed, and that the returned value would always be the current object.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7620/comments",
    "author": "philthy256",
    "comments": [
      {
        "user": "sandersn",
        "created_at": "2016-03-21T21:14:13Z",
        "body": "TypeScript already works this way. You do have to `return this` at the end of each method though.\n\n\n---\n\nSee #4910\n"
      },
      {
        "user": "philthy256",
        "created_at": "2016-03-21T22:18:49Z",
        "body": "@sandersn That's awesome, thank you!\n\nThe following works a treat - great stuff:\n\nclass Animal {\n    public sleep() {\n        return this;\n    }\n}\n\nclass Elephant extends Animal {\n    public squirtWithTrunk() {\n        return this;\n    }\n}\n"
      }
    ],
    "satisfaction_conditions": [
      "Preserves subclass type information during method chaining in inheritance hierarchies",
      "Allows method chaining across parent/child classes without type narrowing",
      "Works with standard TypeScript compiler behavior",
      "Requires minimal boilerplate for method definitions"
    ]
  },
  {
    "number": 7357,
    "title": "Overloaded array type",
    "created_at": "2016-03-03T01:27:45Z",
    "closed_at": "2016-03-03T05:53:14Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7357",
    "body": "I was unable to find this in the documentation or among the existing issues.\n\nIs there any way to have overloaded array types? Something that would look like:\n\n```\ninterface I {\n    [s: string]<T extends Bar>: T;\n    method<T extends Bar>(): T;   // this is allowed\n}\n```\n\nI guess it would also need a syntax at call-sites, which would look weird:\n\n```\ndeclare var array: I\n\n// and in client code:\nclass Foo extends Bar { foo(); }\narray[\"field\"]<Foo>.foo();\n```\n\n(As an aside, I'm not sure how to use the array type syntax)\n\nMy apologies if this is already do-able, I couldn't find a way...\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7357/comments",
    "author": "Ptival",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-03-03T05:19:23Z",
        "body": "There isn't a direct way to do this, but really all you're doing is writing a type assertion at the indexing site. You could equivalently write:\n\n``` ts\ndeclare var array: { [s: string]: Bar; };\n(<Foo>array[\"field\"]).foo();\n```\n"
      },
      {
        "user": "Ptival",
        "created_at": "2016-03-03T05:42:50Z",
        "body": "It would indeed defer type assertions to the indexing site, but it could at least guarantee the subtyping condition.\n\nMy use case is for a JS library which registers multiple kinds of objects into an array.\nIf I just make it:\n\n```\ninterface W2UI {\n    [s: string]: any;\n}\ndeclare var w2ui : W2UI\n```\n\nThen I don't get any documentation/type-checking out of what comes out of the array.\nSince the main mode of interaction with the library is with:\n\n```\nw2ui[\"layout\"].layoutMethod();\nw2ui[\"tab\"].tabMethod();\n```\n\nIt becomes pretty much useless to even give type to anything.\n\nIs there a way to describe a type that is one of 7 classes, but is allowed to be any of them? (even when they are not compatible)\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-03-03T05:49:24Z",
        "body": "You could use a union type:\n\n``` ts\ninterface W2UI {\n  [s: string]: TabControl | InputControl | LabelControl;\n}\nvar arr: W2UI;\n// Just type assert\n(<InputControl>arr[\"input\"]).setValue();\n// N.B. still typesafeish\n(<HTMLDivElement>arr[\"nope\"]).blur(); // Error, can't convert HTMLDivElement to ...\n\n// Use some actual sanity checking\nconst x = arr['layout'];\nif(x instanceof TabControl) {\n  x.tabMethod();\n}\n```\n"
      },
      {
        "user": "Ptival",
        "created_at": "2016-03-03T05:53:14Z",
        "body": "Ok, that's what I though of initially but was annoyed to have to cast every time. I can't think of a better way to do it though. Thanks for the quick feedback!\n"
      }
    ],
    "satisfaction_conditions": [
      "Support type-safe access to dynamically named properties with specific subtypes",
      "Allow multiple unrelated class types in the registry while preserving type information",
      "Maintain subtyping guarantees for retrieved values"
    ]
  },
  {
    "number": 7090,
    "title": "Union type of string literals",
    "created_at": "2016-02-16T09:28:30Z",
    "closed_at": "2016-02-16T10:47:29Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7090",
    "body": "With TypeScript 1.8, this code fails:\n\n```\ntype SomeString = ('string1' | 'string2') & ('string3' | 'string4');\nconst x: SomeString = 'string1';\n```\n\nWith the following error: `Type 'string' is not assignable to type '(\"string1\" | \"string2\") & (\"string3\" | \"string4\")'. Type 'string' is not assignable to type '\"string1\" | \"string2\"'. Type 'string' is not assignable to type '\"string2\"'`.\n\nIs this by design? Should it not be possible to use unions for string literal types?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7090/comments",
    "author": "andersekdahl",
    "comments": [
      {
        "user": "yortus",
        "created_at": "2016-02-16T10:36:42Z",
        "body": "The following _does_ work:\n\n``` typescript\ntype SomeString = 'string1' | 'string2' | 'string3' | 'string4';\nconst x: SomeString = 'string1';\n```\n\nSo it is possible to use unions for string literal types. Your example is an intersection, which `'string1'` cannot possibly satisfy, because it must simultaneously satisfy `'string3'|'string4'`, which it clearly can't.\n\nThe error message you are getting from tsc is not very helpful in this case.\n"
      },
      {
        "user": "andersekdahl",
        "created_at": "2016-02-16T10:47:29Z",
        "body": "Ah, completely mixed up union and intersection types, sorry!\nClosing this because brain fart.\n"
      }
    ],
    "satisfaction_conditions": [
      "Clarify the difference between union and intersection types in TypeScript",
      "Explain why intersection of mutually exclusive string literals causes type errors",
      "Confirm that unions of string literals are valid and supported",
      "Address TypeScript's error message clarity for type composition"
    ]
  },
  {
    "number": 6806,
    "title": "Question: Interface with _at least one_ defined member?",
    "created_at": "2016-02-02T00:02:48Z",
    "closed_at": "2016-02-02T00:48:21Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6806",
    "body": "In RxJS, we have a need for an interface that is basically this:\n\n``` TypeScript\ninterface Observer<T> {\n  next?: (value: T) => void;\n  error?: (err: any) => void;\n  complete?: () => void;\n}\n```\n\nbut you'll notice that it matches `{}` in that case, which isn't what we want. What we _really_ want is _at least one_ of those members.\n\nIt seems like I'd be able to do something with `PartialObserver<T> = NextObserver<T>|ErrorObserver|CompleteObserver`, but I'm honestly not sure how to accomplish this.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6806/comments",
    "author": "benlesh",
    "comments": [
      {
        "user": "weswigham",
        "created_at": "2016-02-02T00:12:30Z",
        "body": "``` ts\ninterface NextObserver<T> {\n  next: (value: T) => void;\n}\ninterface ErrorObserver {\n  error: (err: any) => void;\n}\ninterface CompleteObserver {\n  complete: () => void;\n}\ntype Observer<T> = NextObserver<T> | ErrorObserver | CompleteObserver | (NextObserver<T> & ErrorObserver & CompleteObserver) | (ErrorObserver & CompleteObserver) | (NextObserver<T> & ErrorObserver) | (NextObserver<T> & CompleteObserver);\n```\n\nYou can enumerate the power set of interface combinations by hand, though I'll admit the definition is a little dense (and possibly more verbose than need be).\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2016-02-02T00:26:34Z",
        "body": "Perhaps this?\n\n``` typescript\ninterface NextObserver<T> {\n  next: (value: T) => void;\n  error?: (err: any) => void;\n  complete?: () => void;\n}\ninterface ErrorObserver<T> {\n  next?: (value: T) => void;\n  error: (err: any) => void;\n  complete?: () => void;\n}\ninterface CompleteObserver<T> {\n  next?: (value: T) => void;\n  error?: (err: any) => void;\n  complete: () => void;\n}\ntype Observer<T> = NextObserver<T> | ErrorObserver<T> | CompleteObserver<T>;\n```\n"
      },
      {
        "user": "benlesh",
        "created_at": "2016-02-02T00:49:49Z",
        "body": "@ahejlsberg  ... that did it. Thank you!\n\n\n---\n\nAlso, @weswigham I tried the same thing you recommended, and (just for informational purposes) it caused compilation errors on the consumption side.  `observer.next()` would say `\"next\" does not exist on  NextObserver<T> | ErrorObserver | CompleteObserver | (NextObserver<T> & ErrorObserver & CompleteObserver) | (ErrorObserver & CompleteObserver) | (NextObserver<T> & ErrorObserver) | (NextObserver<T> & CompleteObserver);` unless I cast it first.\n"
      },
      {
        "user": "weswigham",
        "created_at": "2016-02-10T09:55:23Z",
        "body": "Just realized I never came back to this - the intention of my definitions would be for a strongly typed observer which _requires_ checks for members before calls are allowed. Pair the definitions in my prior post with type guards like so:\n\n``` ts\nfunction hasNext<T, U extends Observer<T>>(o: U): o is NextObserver<T> {\n  return !!(o as NextObserver<T>).next;\n}\n\nfunction hasComplete<T, U extends Observer<T>>(o: U): o is CompleteObserver<T> {\n  return !!(o as any).complete;\n}\n\nfunction hasError<T, U extends Observer<T>>(o: U): o is ErrorObserver<T> {\n  return !!(o as any).error;\n}\n```\n\nAnd use like so:\n\n``` ts\nconst obs: Observer<Observee> = fetchObs();\nfor (i=1, i<3, i++) {\n  if (hasNext(obs)) {\n    try {\n      thing = doThing()\n    }\n    catch (e) {\n      if (hasError(obs)) {\n        return obs.error(e);\n      }\n    }\n    obs.next(thing);\n  }\n}\nif (hasComplete(obs)) {\n  obs.complete()\n}\n```\n\nI _think_ I've got the types right for that, but I can't claim to have tested it, as it makes use of TS 1.8's F-Bounded Polymorphism, so I can't just drop it into the playground to test it yet (and I'm away from my PC at the moment).\n"
      }
    ],
    "satisfaction_conditions": [
      "Observer type must enforce at least one of next/error/complete methods",
      "Type definitions must allow safe method access without casting",
      "Solution must work with TypeScript's type system constraints"
    ]
  },
  {
    "number": 6641,
    "title": "Generics in indexers",
    "created_at": "2016-01-27T13:55:22Z",
    "closed_at": "2016-01-27T16:30:36Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6641",
    "body": "Hi,\n\nI was wondering why something like that is not possible:\n\n``` javascript\ninterface IDictionary<TKey, TValue> {\n  [index: TKey]: TValue;\n}\n```\n\nit tells me: index signature parameter must be string or number\n\nI agree, but why I could not get this error when trying to use something else than string or number as TKey? Generics are analyzed at build time right? if so, this should be easy to find.\n\n``` javascript\n  temp: IDictionary<number, ...>;\n```\n\nshould work.\n\nI could even do something like this, to be more precise:\n\n``` javascript\ninterface IDictionary<TKey extends string | number, TValue>\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6641/comments",
    "author": "pankleks",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-01-27T16:30:36Z",
        "body": "String indexers and number indexers have very different effects on the types they're contained in. They're not really interchangeable in any meaningful way, so it's pointless to make them able to be based on generic type parameters.\n\nPractically speaking, you really have two types: `IDictionaryString<T> { [s: string]: T }` and `IDictionaryNumber<T> { [n: number]: T }`. There's nothing gained by making them generic.\n"
      },
      {
        "user": "pankleks",
        "created_at": "2016-01-27T16:36:30Z",
        "body": "ok thanks.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why generic type parameters cannot be used for index signatures despite compile-time analysis",
      "Clarification of the practical distinction between string/number indexers in TypeScript's type system",
      "Rationale for why generic index signatures don't provide meaningful type safety benefits"
    ]
  },
  {
    "number": 6543,
    "title": "Can't get to the instance type of a wrapped class across modules",
    "created_at": "2016-01-19T22:58:31Z",
    "closed_at": "2016-01-19T23:09:21Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6543",
    "body": "Ran into this trying to leverage higher-order React components but it doesn't take much to reproduce:\n\nThing.ts\n\n``` typescript\nclass Thing { }\n\nfunction wrap<T>(classType: T): T {\n    return classType;\n}\n\nexport default wrap(Thing);\n```\n\nThingImporter.ts\n\n``` typescript\nimport Thing from \"./Thing\";\n\nlet thingInstance: Thing; //error: Cannot find name 'Thing'\nlet thingConstructor: typeof Thing; //ok\n```\n\nEven though the wrap function returns exactly what it takes in, the type gets changed from `class Thing` to `typeof Thing` and it seems this causes it to lose the class-reference-equals-instance-type magic in other modules.\n\nTS versions: 1.7.5 and 1.8.0-dev.20160119\ntsconfig:\n\n``` json\n{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"target\": \"es5\"\n  }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6543/comments",
    "author": "jwbay",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-01-19T23:09:21Z",
        "body": "Thanks for reducing the repro.\n\nWhen we see an `export default` declaration, we expose \"all meanings\" of the expression on the right. The expression on the right, in this case, does not have any types, so there is no type meaning to expose.\n\nDoing a general purpose expansion of the right-hand side here is generally not tractable.\n\nIf you wanted to create a default export that had a type meaning, you could write something like this:\n\n``` ts\nclass _Thing { }\n\nfunction wrap<T>(classType: T): T {\n    return classType;\n}\n\nconst Thing: typeof _Thing = wrap(_Thing);\ntype Thing = _Thing;\nexport default Thing;\n```\n"
      },
      {
        "user": "jwbay",
        "created_at": "2016-01-19T23:29:38Z",
        "body": "Thanks for the quick reply! That works like a charm. I never would have thought to make an alias/local type with the same name as the actual export.\n\nFor anyone else who runs across this -- the root cause seems to be the wrap function and not so much the export. The same problem and fix applies within a single file.\n\n``` typescript\nfunction wrap<T>(classType: T): T {\n    return classType;\n}\n\nclass Thing { }\n\nconst ThingTwo = wrap(Thing);\nconst ThingThree = wrap(Thing);\ntype ThingThree = Thing;\n\nlet thingTwo: ThingTwo; //error: Cannot find name \"ThingTwo\"\nlet thingThree: ThingThree; //ok \n```\n"
      }
    ],
    "satisfaction_conditions": [
      "Preserve both instance type and constructor type information when exporting wrapped classes",
      "Maintain type identity through higher-order wrapper functions",
      "Explain TypeScript's type inference behavior with default exports and wrapped classes",
      "Provide a pattern that works across module boundaries and within single files",
      "Enable type accessibility without direct class references"
    ]
  },
  {
    "number": 6519,
    "title": "Discussion: Type casting and typing = position ambiguity",
    "created_at": "2016-01-17T11:10:47Z",
    "closed_at": "2016-01-17T17:19:40Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6519",
    "body": "Hello,\n\nHere is my code example:\n\n```\nlet value : any;                   // ok javascript like \n(<string[]>value).length     // why not (value<string[]>).length\n```\n\n< string[] > value is more c# like : (string[])value in c#\n\nWhy not using a javascript style for typing and type casting: always put typing at the end of the expression ? (I mean \"javascript style\" because :any signature seems to be adopted)\n\nThanks in advance for your answers.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6519/comments",
    "author": "Alphapage",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2016-01-17T17:18:20Z",
        "body": "We already support postfix type assertions using the `as` operator, so if you prefer that you can simply write `(value as string[]).length`.\n"
      },
      {
        "user": "Alphapage",
        "created_at": "2016-01-17T18:29:58Z",
        "body": "Thank you. You learn me something. +1\n"
      }
    ],
    "satisfaction_conditions": [
      "Explains TypeScript's support for postfix type assertion syntax alternatives",
      "Addresses syntax flexibility for type casting preferences",
      "Demonstrates equivalent approaches for type safety"
    ]
  },
  {
    "number": 6463,
    "title": "Cannot define type while destructuring in a $q.all ",
    "created_at": "2016-01-13T13:43:49Z",
    "closed_at": "2016-01-13T22:49:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6463",
    "body": "<pre>\n$q.all([\n  IPromise&lt;type does not work here&gt;promise1,\n  promise2\n])\n.then([result1: &lt;can't define type here as well&gt;, result2] => { }`\n</pre>\n\n\nI have tried to type cast promise and tried to define type in `.then` as well and it still gives error. I have tried with simple function as well and it does not work for simple functions as well.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6463/comments",
    "author": "khagesh",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-01-13T18:57:11Z",
        "body": "These are best for other forums, like StackOverflow or gitter.im.\n\nYou need to understand tuple types in TypeScript better.\n\n``` typescript\n$q.all([ promise1, promise2 ])\n    .then(( [ result1, result2 ]: [ string, string ] ) => { });\n```\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of TypeScript tuple type annotation syntax for destructured array parameters",
      "Guidance on proper type annotation placement in arrow function parameters"
    ]
  },
  {
    "number": 6360,
    "title": "Cannot use type that is re-exported by another module",
    "created_at": "2016-01-05T16:29:34Z",
    "closed_at": "2016-01-05T17:49:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6360",
    "body": "I'm trying to re-export a class from a module `bar.ts` that has been imported from `foo.ts`. The class itself is usable but its type cannot be used for declaring variables. I'm using latest typescript 1.8.0-dev.20160105 from npm:\n\nfoo.ts (type definition):\n\n```\nexport class Foo {\n}\n```\n\nbar.ts (type re-export):\n\n```\nexport = {\n  Foo: require('./foo')\n};\n```\n\nqux.ts (type usage):\n\n```\nimport Bar = require('./bar');\nvar foo: Bar.Foo;\n```\n\ntsconfig.json:\n\n```\n{\n  \"compilerOptions\": {\n    \"target\": \"es6\",\n    \"module\": \"commonjs\"\n  }\n}\n```\n\nThe actual error:\n\n```\n$ tsc\nqux.ts(2,10): error TS2503: Cannot find namespace 'Bar'.\n```\n\nI haven't found a way to re-export a type. It's useful for me to split up several database models in multiple files, and then aggregate all of them in a single file. However actually I'm losing the types.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6360/comments",
    "author": "lucabrunox",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-01-05T17:00:12Z",
        "body": "With `bar.ts`:\n\n``` ts\nexport = {\n  Foo: require('./foo')\n};\n```\n\nWe don't recognize that as `require` as an import form, so there's no type/namespace side that we know of.\n\nInstead, I'd suggest you use an ES2015 style export:\n- New `bar.ts`\n  \n  ``` ts\n  export { Foo } from \"./foo\";\n  ```\n\nWhile you're at it, you might as well use a new import form in `qux.ts` as well:\n\n``` ts\nimport * as Bar from \"./bar\";\nlet foo: Bar.Foo;\n```\n"
      },
      {
        "user": "lucabrunox",
        "created_at": "2016-01-05T17:07:35Z",
        "body": "Yeah I understand the problem, thanks for the answer.\n\nUsing `import * as Bar from \"./bar\"` gives `qux.ts(1,22): error TS2497: Module '\"bar\"' resolves to a non-module entity and cannot be imported using this construct.`.\n\nWhile for `export { Foo } from \"./foo\";`, I don't have a `Foo` inside `foo.ts`, it's an `export =`.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-01-05T17:39:15Z",
        "body": "If you really need to keep it as an `export =`, you'll need to use the old-style imports like so:\n\n``` ts\nexport import Foo = require(\"./foo\");\n```\n\nfor `foo.ts`.\n\nIf you use a module loader that automatically fixes up `export =` forms to `default` exports, you can use the `--allowSyntheticDefaultImports` which is available in the nightly.\n"
      },
      {
        "user": "lucabrunox",
        "created_at": "2016-01-05T17:44:46Z",
        "body": "I think I will simplify and do it this way: `export class Foo` + `export { Foo} from './foo'`. It's quite ok, thanks :)\n\n\n---\n\nAlso `export import Foo = require('./foo');` + `export = Foo;` works very well.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-01-05T17:49:44Z",
        "body": "Sounds good - I think we an close this up then.\n"
      }
    ],
    "satisfaction_conditions": [
      "Solution must enable proper type re-exporting from modules using CommonJS/export= syntax",
      "Type declarations must remain accessible through namespace-like imports",
      "Must maintain compatibility with existing module resolution patterns",
      "Solution should avoid namespace resolution errors during compilation",
      "Must support both value and type exports simultaneously"
    ]
  },
  {
    "number": 5877,
    "title": "Incorrect function return type: expected it to match generic type parameter",
    "created_at": "2015-12-02T00:33:12Z",
    "closed_at": "2015-12-02T00:45:29Z",
    "labels": [
      "By Design",
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5877",
    "body": "I may just be abusing the type system here, but there's no warnings or errors, so I have to assume it should work. I'm trying to dispatch a command to a registered handler and return the result, which should be of the type specified by the command.\n\nQuestion is, why is the result always of type object, when the type parameter is clearly a string? Is this a bug or known limitation, and if so, is it a bug that there is no error or warning here?\n\n``` typescript\ninterface Command<T>\n{\n}\n\nclass TestCommand implements Command<string>\n{\n}\n\nfunction dispatch<T>(command: Command<T>): T\n{\n    let result: any = \"Result of executing the command handler\";\n\n    return result as T;\n}\n\nlet result = dispatch(new TestCommand());\n// Why is result of type object? I expected it to be a string.\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5877/comments",
    "author": "thomas-darling",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-12-02T00:45:29Z",
        "body": "The problem is that `T` is never manifested in the object, and since it is a structural type system, setting `T` to a string without using it has no impact on the inference. if you add a property `p: T` to your interface, your result should be of type `T`, in this case, `string` as you would expect.\n"
      },
      {
        "user": "thomas-darling",
        "created_at": "2015-12-02T01:04:28Z",
        "body": "Ahhh, that makes sense, although it would likely have been a while before I figured that one out on my own - looking at the code it kinda feels like it should just work. But thanks for the quick response, the workaround solved my problem :-)\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why TypeScript's structural type system fails to infer the generic type parameter in this scenario",
      "Clarification of how generic type parameters need to be manifested in object structures for proper type inference",
      "Identification of why no error/warning occurs despite apparent type mismatch",
      "Guidance on proper pattern for preserving generic type information in TypeScript interfaces"
    ]
  },
  {
    "number": 5778,
    "title": "Declaring a named module with call signature?",
    "created_at": "2015-11-24T21:05:51Z",
    "closed_at": "2015-11-25T21:55:15Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5778",
    "body": "I'm having trouble typing the following scenario.\n\ndefs.d.ts\n\n```\ndeclare module \"my/module\" {\n  export = (arg: string) => any;\n}\n```\n\nmain.ts\n\n```\nimport myModule = require(\"my/module\");\nmyModule(\"hello\");\n```\n\nLine 2 in `main.ts` compiles fine, VS even shows the correct call signature, however, `defs.d.ts` does not compile correctly:\n`error TS2304: Cannot find name 'any'`\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5778/comments",
    "author": "jseanxu",
    "comments": [
      {
        "user": "vladima",
        "created_at": "2015-11-24T21:43:09Z",
        "body": "can you define \"my/module\" like this?\n\n``` ts\ndeclare module \"my/module\" {\n    function f(arg: string) => any;\n    export = f;\n}\n```\n"
      },
      {
        "user": "jseanxu",
        "created_at": "2015-11-25T21:55:15Z",
        "body": "That works, thanks!\n"
      }
    ],
    "satisfaction_conditions": [
      "Correctly declares a TypeScript module that exports a callable function signature",
      "Uses valid TypeScript declaration syntax for module exports",
      "Maintains type information for function parameters and return values",
      "Supports CommonJS-style require imports"
    ]
  },
  {
    "number": 5629,
    "title": "Tests: no way ensuring that super has been called.",
    "created_at": "2015-11-12T01:39:36Z",
    "closed_at": "2015-11-13T06:37:04Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5629",
    "body": "When writing tests (using Jasmine in my case), how can one ensure that the super of a class is called?\n\nFor instance, in the following code:\n\n```\nclass Snake extends Animal {\n    constructor(name: string) { super(name); }\n    move(meters = 5) {\n        alert(\"Slithering...\");\n        super.move(meters);\n    }\n}\n```\n\nHow can one write a test ensuring `super.move()` is called when `Snake.move()` is called?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5629/comments",
    "author": "Izhaki",
    "comments": [
      {
        "user": "bmayen",
        "created_at": "2015-11-12T02:54:51Z",
        "body": "Should be able to spy on it and then check if it was called with `toHaveBeenCalled`\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-11-12T05:20:55Z",
        "body": "For the record, StackOverflow/StackExchange/our Gitter room/our IRC room is probably a better venue for these sorts of questions.\n"
      },
      {
        "user": "Izhaki",
        "created_at": "2015-11-12T10:58:10Z",
        "body": "@bmayen how?\n\nI can't see `super` anywhere on the prototype.\n\n@DanielRosenwasser, might be phrased as a question, but I'm really arguing this cannot be done and thus an issue.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-11-13T06:37:04Z",
        "body": "there is no entity called `super` super is just an alias to the class you are extending. in this case, `Animal`. so as @bmayen mentioned, `Animal.move` is what you want to check to have been called.\n"
      },
      {
        "user": "Izhaki",
        "created_at": "2015-11-13T16:24:55Z",
        "body": "@mhegazy Still not sure I understand. `Animal` is a class, not an instance.\n\nJust to make it more concrete, given this code:\n\n```\nclass Painter extends Transformer {\n\n    //.... \n\n    translate( aTranslation: Point ) {\n        this.context.translate( aTranslation.x , aTranslation.y );\n        super.translate( aTranslation );\n    }\n\n}\n```\n\nThe test:\n\n```\ndescribe( 'translate()', function() {\n\n    beforeAll( function () {\n        spyOn( iPainter.context, 'translate' );\n        iPainter.translate( new Point( 10, 20 ) );\n    });\n\n    it( 'Should translate the context', function() {\n        expect( iPainter.context.translate ).toHaveBeenCalledWith( 10, 20 );\n    });\n\n    it( 'Should call translate on its super', function() {\n        // What's here???\n    });        \n\n});\n```\n\nWhat would be the line to replace `What's here???`\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-11-13T17:18:14Z",
        "body": "``` ts\nvar originalTransformenrTranslate = Transformer. prototype.translate;\nTransformer. prototype.translate = function (...args) {\n    console.log(\"Transformer.translate is called!\");\n    originalTransformenrTranslate.apply(this, args);\n}\n\nvar originalPainterTranslate = Painter. prototype.translate;\nPainter. prototype.translate = function (...args) {\n    console.log(\"Painter.translate is called!\");\n    originalPainterTranslate.apply(this, args);\n}\n\n```\n"
      },
      {
        "user": "Izhaki",
        "created_at": "2015-11-13T17:48:11Z",
        "body": "Or alternatively:\n\n```\nbeforeAll( function () {\n    spyOn( Transformer.prototype, 'translate' );\n\n    iTranslation = new Point( 10, 20 );\n    iPainter.translate( iTranslation );\n});\n\nit( 'Should call translate on its super', function() {\n    expect( Transformer.prototype.translate ).toHaveBeenCalledWith( iTranslation );\n});\n```\n\nGot it, thanks!\n"
      }
    ],
    "satisfaction_conditions": [
      "Demonstrates how to verify that a parent class method is called when a subclass method invokes `super`",
      "Works with class inheritance patterns where `super` isn't directly accessible as a spy target",
      "Applies to testing frameworks in general rather than framework-specific syntax",
      "Handles prototype chain inspection for method calls"
    ]
  },
  {
    "number": 5609,
    "title": "Destructuring and function properties",
    "created_at": "2015-11-11T09:59:00Z",
    "closed_at": "2015-11-11T10:56:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5609",
    "body": "Hi,\n\nwe are using Visual Studio 2013 with TS 1.6\n\ni don't get why this is valid:\n\n``` typescript\nfunction foo({bar: string}) {}\n```\n\nbut this leads to a compile error:\n\n``` typescript\nfunction foo({bar: () => string}) {}\n```\n\nCompile error message is \"Cannon find name string\".\n\nFor me this is a defect behavior. What do you guys think?\n\nKind regards,\nTimo\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5609/comments",
    "author": "Kinchkun",
    "comments": [
      {
        "user": "falsandtru",
        "created_at": "2015-11-11T10:24:11Z",
        "body": "Correct code example:\n\n``` ts\nfunction foo1({bar}: {bar: () => string}) {}\nfunction foo2({bar = () => ''}: {bar?: () => string}) {}\n```\n"
      },
      {
        "user": "Kinchkun",
        "created_at": "2015-11-11T10:56:12Z",
        "body": "I see, thank you!\n\nKind regards,\nTimo\n"
      }
    ],
    "satisfaction_conditions": [
      "Explains the difference between destructuring patterns and type annotations in TypeScript function parameters",
      "Clarifies how to properly type destructured function parameters with return values",
      "Demonstrates correct syntax for destructuring parameters with complex types",
      "Addresses the specific error pattern 'Cannot find name X' in type annotations"
    ]
  },
  {
    "number": 5570,
    "title": "Unable to define async function type",
    "created_at": "2015-11-09T10:08:09Z",
    "closed_at": "2015-11-10T01:24:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5570",
    "body": "I'm just wondering if I could define an async function type. I want to create an interface where one of the properties of the interface is an async method.\n\n``` typescript\ninterface Setup {\n     asyncMethod: async () => Promise<any>; // cannot find name 'async'.\n}\n```\n\nThe reason I want to await, is so I can await on a function that returns a promise from a JS library. Also await on any type isn't working either.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5570/comments",
    "author": "tinganho",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-11-09T17:44:57Z",
        "body": "`async` is only allowed in implementation. use `Promise`\n\n``` ts\ninterface Setup {\n    asyncMethod: () => Promise<number>;\n}\n\nasync function asyncMethodImplementation() {\n    return 0;\n}\n\nvar s: Setup;\n\ns.asyncMethod = asyncMethodImplementation;\n```\n"
      }
    ],
    "satisfaction_conditions": [
      "Demonstrate how to define a function type in an interface that returns a Promise",
      "Show compatibility between async function implementations and the interface",
      "Enable proper awaiting of the interface method",
      "Avoid syntax that TypeScript rejects in type definitions"
    ]
  },
  {
    "number": 5542,
    "title": "Module resolution walks all parent directories to / with system module type",
    "created_at": "2015-11-05T19:59:23Z",
    "closed_at": "2015-11-06T08:45:32Z",
    "labels": [
      "Question",
      "API"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5542",
    "body": "This 'issue' may be behaviour by design, but I couldn't find a suitable reference to this logic anywhere. So apologies if that is the case. \n\n```\n$ tsc --version\nmessage TS6029: Version 1.8.0-dev.20151105\n```\n\nSteps to repro:\n- Create empty TypeScript project in `/tmp/path/to/my/project/`\n- Create a `tsconfig.json` as follows:\n\n```\n{\n    \"compilerOptions\": {\n        \"module\": \"system\",\n        \"target\": \"es5\",\n        \"noImplicitAny\": false,\n        \"sourceMap\": false\n    },\n    \"exclude\": [\n        \"node_modules\"\n    ]\n}\n```\n- Create a single TypeScript file `/tmp/path/to/my/project/test.ts`:\n\n``` typescript\nimport * as React from \"react\";\n```\n- Compile with `tsc`. Observe the following output as expected (because we haven't installed the type definition file anywhere):\n\n```\ntest.ts(1,24): error TS2307: Cannot find module 'react'.\n```\n\nWhat's interesting however is the output of `strace`:\n\n```\n$ strace tsc 2>&1 | grep react\nread(9, \"import * as React from \\\"react\\\";\\n\", 32) = 32\nstat(\"/tmp/path/to/my/project/react.ts\", 0x7ffd985dbb00) = -1 ENOENT (No such file or directory)\nstat(\"/tmp/path/to/my/project/react.d.ts\", 0x7ffd985dbb00) = -1 ENOENT (No such file or directory)\nstat(\"/tmp/path/to/my/react.ts\", 0x7ffd985dbb00) = -1 ENOENT (No such file or directory)\nstat(\"/tmp/path/to/my/react.d.ts\", 0x7ffd985dbb00) = -1 ENOENT (No such file or directory)\nstat(\"/tmp/path/to/react.ts\", 0x7ffd985dbb00) = -1 ENOENT (No such file or directory)\nstat(\"/tmp/path/to/react.d.ts\", 0x7ffd985dbb00) = -1 ENOENT (No such file or directory)\nstat(\"/tmp/path/react.ts\", 0x7ffd985dbb00) = -1 ENOENT (No such file or directory)\nstat(\"/tmp/path/react.d.ts\", 0x7ffd985dbb00) = -1 ENOENT (No such file or directory)\nstat(\"/tmp/react.ts\", 0x7ffd985dbb00)   = -1 ENOENT (No such file or directory)\nstat(\"/tmp/react.d.ts\", 0x7ffd985dbb00) = -1 ENOENT (No such file or directory)\nstat(\"/react.ts\", 0x7ffd985dbb00)       = -1 ENOENT (No such file or directory)\nstat(\"/react.d.ts\", 0x7ffd985dbb00)     = -1 ENOENT (No such file or directory)\n```\n\ni.e. in trying to resolve the non-relative `import` of `\"react\"`, every parent directory up to and including `/` is considered as a potential location for either `react.ts` or `react.d.ts`. \n\nWe got bitten by this the other day because I happened to have a copy of `react.d.ts` kicking around in a parent directory (two directories higher) of our project. The compiler also picked up the intended version within our project, installed via `tsd` in a `typings` subdirectory. This threw a number of 'duplicate definition' errors (which in the circumstances, i.e. loading two copies of the same file, is expected behaviour).\n\nSo the unexpected behaviour here was:\n- walking all the way to '/'\n- but also the non-relative import trying to load a file in the first place given the `\"system\"` module setting (but again I could be missing something here)\n\nPlease can someone confirm whether this is by design on both counts?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5542/comments",
    "author": "myitcv",
    "comments": [
      {
        "user": "vladima",
        "created_at": "2015-11-05T23:15:55Z",
        "body": "Currently this is by design. TypeScript has two strategies to resolve module names:\n- node - mimics the way how module names are resolved in Nod\n- classic - original strategy that involves folder walk and does not make distinctions between relative and non-relative names.\n  Strategy can be specified via `moduleResolution` compiler option. If this option is omitted compiler will use `node` when target module kind is `commonjs` and `classic` otherwise. In #5039 we plan to add path-mapping based way to do module resolution that I think will do what you need\n"
      },
      {
        "user": "myitcv",
        "created_at": "2015-11-06T08:45:32Z",
        "body": "@vladima - thanks for confirming. I'll pick up the thread of #5039 and close this issue.\n"
      }
    ],
    "satisfaction_conditions": [
      "Confirmation of whether parent directory traversal up to root is intentional behavior",
      "Explanation of module resolution strategy differences between system modules and other formats",
      "Identification of configuration options to control module resolution paths",
      "Reference to existing or planned module resolution features"
    ]
  },
  {
    "number": 5303,
    "title": "Duck typing on anonymous object literals and class objects",
    "created_at": "2015-10-17T06:29:13Z",
    "closed_at": "2015-10-18T22:57:44Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5303",
    "body": "Based on new duck typing concept fresh objects can not have access property.\nLike this\n\n``` javascript\nlet a = { name:\"Bill\"};\nlet b = {name:\"Bill\", age:20};\n\na = {name: \"James\", age:30 }; // Error - excess property not allowed\na = b; // No error - works fine\n```\n\nNow the questions is does this concept also applies to class objects\nLike this:\n\n``` javascript\nclass Human {    \n    name: string;    \n    constructor(name: string){\n        this.name = name;\n    }\n}\n\nclass Animal {\n    name: string;\n    age: number;    \n    constructor(name: string, age: number){\n        this.name = name;\n        this.age = age;\n    }\n    eat(){\n        console.log(this.name + \" is a Human and is eating\");\n    }\n}\n\nlet h1 = new Human(\"James\");\nlet a1 = new Animal(\"Dog\", 2);\nh1 = new Animal(\"Cat\", 1); //this is working -- But based on duck typing concept it should not because it has excess property and its fresh object\n```\n\nThe error is same if I remove constructor.\n\nIs there any difference in duck typing concept for anonymous objects and class objects OR may be I'm missing something?\nOr is it really considered as fresh object?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5303/comments",
    "author": "zeeshanhanif",
    "comments": [
      {
        "user": "ziaukhan",
        "created_at": "2015-10-17T06:33:33Z",
        "body": "I have the same question?\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-10-17T08:08:49Z",
        "body": "_Object literals_ have an associated freshness before they're bound to a variable. The same doesn't apply for any other expressions.\n\nThe idea is that object literals are often used for option bags (where the user has to manually type out each property name at each use-site), and this behavior catches typos.\n\nIf you'd like to prevent `Animal` from being assigned to a `Human`, you can add a `private` property to `Animal`, since `private` and `protected` properties need to originate from the same declaration to be compatible.\n"
      },
      {
        "user": "zeeshanhanif",
        "created_at": "2015-10-17T13:47:15Z",
        "body": "Thanks its clear now\n"
      }
    ],
    "satisfaction_conditions": [
      "Clarify how TypeScript's freshness concept applies differently to object literals vs class instances",
      "Explain TypeScript's design rationale for different freshness behavior between expression types",
      "Describe methods to enforce stricter type compatibility between classes"
    ]
  },
  {
    "number": 5057,
    "title": "jake local fails",
    "created_at": "2015-10-01T18:55:28Z",
    "closed_at": "2015-11-13T06:28:38Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5057",
    "body": "Hi,\n  since I have a few issues with tsx inside vs, I would like to use the latest language service instead of the packaged one to see if something is different.\n  I updated my typescript clone and launched **jake local** (I have already done this in the last months) but this time fails:\n  if I run from a command shell I obtain this error message\n\n> jake aborted.\n> Error: Cannot find module 'tslint'\n>    at Function.Module._resolveFilename (module.js:336:15)\n>    at Function.Module._load (module.js:278:25)\n> (See full trace by running task with --trace)\n\nif I run from powershell\n\n> module.js:338\n>    throw err;\n>          ^\n> Error: Cannot find module 'lru-cache'\n>    at Function.Module._resolveFilename (module.js:336:15)\n>    at Function.Module._load (module.js:278:25)\n>    at Module.require (module.js:365:17)\n>    at require (module.js:384:17)\n>    at D:\\GitHub\\typescript\\node_modules\\jake\\node_modules\\filelist\\node_modules\\minimatch\\minimatch.js:35:11\n>    at Object.<anonymous> (D:\\GitHub\\typescript\\node_modules\\jake\\node_modules\\filelist\\node_modules\\minimatch\\minimatch.js:1057:3)\n>    at Module._compile (module.js:460:26)\n>    at Object.Module._extensions..js (module.js:478:10)\n>    at Module.load (module.js:355:32)\n>    at Function.Module._load (module.js:310:12)\n\nThis is the first time I see something similar. Am I missing something?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5057/comments",
    "author": "lucamorelli",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-10-01T19:15:51Z",
        "body": "Run 'npm install' to update the necessary dependencies.\n"
      },
      {
        "user": "lucamorelli",
        "created_at": "2015-10-01T19:54:53Z",
        "body": "looks like it solved, but I don't understand why works fine from a powershell admin console and not from a cmd admin console\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-10-01T21:29:30Z",
        "body": "@weswigham does `&&` execute conditionally in PowerShell?\n"
      },
      {
        "user": "weswigham",
        "created_at": "2015-10-01T22:07:35Z",
        "body": "`&&` was removed from powershell as a valid deliminator recently, I think. You have to use `;` instead.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-10-01T22:15:52Z",
        "body": "Awesome. Is there anything we can do to keep the two consistent?\n"
      },
      {
        "user": "weswigham",
        "created_at": "2015-10-01T22:26:30Z",
        "body": "Cross-shell compatibility has never been easy... ahh... `|` I believe is supported on most shells, which could work if everything that needs to be run doesn't care about the output of the prior process...\n\n\n---\n\n@DanielRosenwasser But his question why why it worked in powershell but not in cmd, so I'm not sure it's important.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-10-01T22:29:04Z",
        "body": "This means that PowerShell wasn't explicitly failing even though `tslint` wasn't present.\n"
      },
      {
        "user": "weswigham",
        "created_at": "2015-10-01T23:01:18Z",
        "body": "Looking at his stack traces, the different is that in powershell he was never even able to load `jake` from the local node_modules dir whereas in `cmd` he had at least gotten `jake` installed and started to read the jakefile before it got to the missing tslint dependency.\n\n\n---\n\nI don't see anything there that would have anything to do with a `&&` at all.\n\n\n---\n\n@DanielRosenwasser Also, TIL `;` is a valid separator in bash. I've always used `&&`.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why dependency installation worked in PowerShell but failed in cmd",
      "Clarification of shell-specific command execution differences",
      "Identification of environment-specific factors affecting module resolution"
    ]
  },
  {
    "number": 4927,
    "title": "Inline casting? ",
    "created_at": "2015-09-22T14:57:10Z",
    "closed_at": "2015-09-22T16:20:04Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4927",
    "body": "Instead of doing something like the following:\n\n```\nlet myCastedObj = <SomeType>obj\n\nmyCastedObj.doSomething()\n```\n\nCan I do the following?\n\n```\n<<SomeType>obj>.doSomething()\n```\n\nIt _seems_ like I can't but is there a way to achieve this?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4927/comments",
    "author": "iam3yal",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2015-09-22T15:25:44Z",
        "body": "``` typescript\n(<SomeType> obj).doSomething();\n```\n"
      },
      {
        "user": "iam3yal",
        "created_at": "2015-09-23T16:39:26Z",
        "body": "@kitsonk thanks mate! :)\n"
      }
    ],
    "satisfaction_conditions": [
      "Demonstrates inline type casting without variable assignment",
      "Uses valid TypeScript syntax for immediate method invocation after casting"
    ]
  },
  {
    "number": 4863,
    "title": "Manually add to SystemJS imports, just like <amd-dependency> does for AMD",
    "created_at": "2015-09-18T19:57:14Z",
    "closed_at": "2015-09-18T20:54:22Z",
    "labels": [
      "Needs More Info",
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4863",
    "body": "I'm developing with Aurelia which uses SystemJS loader. \nThere are cases where I need to use special kind of \"import\" to load CSS dynamically.\nwhile the code below is fine with Babel, it obviously doesn't compile with TypeScript\n`import 'bootstrap/css/bootstrap.css!'`\n\nTo make use of this feature I had to switch to AMD module loader and use `<amd-dependency path=\"bootstrap/css/bootstrap.css!\">` which emits proper code\n\nI'd love to see similar feature for SystemJS\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4863/comments",
    "author": "migajek",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-09-18T20:07:16Z",
        "body": ">  it obviously doesn't compile with TypeScript\n\nthis compiles fine for me. what version are you using?\n\n``` cmd\nc:\\ts>type c:\\test\\module3.ts\nimport 'bootstrap/css/bootstrap.css!'\n\nc:\\ts>tsc c:\\test\\module3.ts --m system\n\nc:\\ts>type c:\\test\\module3.js\nSystem.register(['bootstrap/css/bootstrap.css!'], function(exports_1) {\n    return {\n        setters:[\n            function (_1) {}],\n        execute: function() {\n        }\n    }\n});\n```\n"
      },
      {
        "user": "migajek",
        "created_at": "2015-09-18T20:50:22Z",
        "body": "@mhegazy my bad, I'm _really_ sorry, this seems to be related to the (outdated) ReSharper I'm using.\n"
      }
    ],
    "satisfaction_conditions": [
      "Compatibility with TypeScript compilation workflow",
      "Support for non-JavaScript resource loading (CSS)",
      "Avoidance of tooling-specific workarounds"
    ]
  },
  {
    "number": 4710,
    "title": "Ability to exclude some compiled .ts files from output",
    "created_at": "2015-09-09T14:33:26Z",
    "closed_at": "2015-09-10T16:10:07Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4710",
    "body": "It would be good (and probably necessary for big projects) to have implementation that supports the following (I will provide a concreate example) use case:\n1. I have the terminal.ts file that depends on the core.ts, env.ts files:\n\n```\n///<reference path=\"env\">\n///<reference path=\"core\">\n\n// this is terminal.ts\n```\n1. I already included the compiled version of it in the main index.html file:\n\n``` html\n<html>\n...\n<script src=\"env-core-terminal_merged.js\"></script>\n</html>\n```\n\nThe env-core-terminal_merged.js contains compiled content of the following files: env.ts, core.ts, terminal.ts. I created the env-core-terminal_merged.js file with the following command:\n\n```\ntsc --out public/js/env-core-terminal_merged.js terminal.ts\n```\n\nIn this case the tsc will find all files (env.ts and core.ts) using ///reference directive and merge them into one.\n3. Now for some area of the site I need other files, say editor.ts that depends on env.ts, core.ts and other editor specic files: color.ts, mode.ts:\n\n```\n///<reference path=\"env\">\n///<reference path=\"core\">\n///<reference path=\"color\">\n///<reference path=\"mode\">\n\n// this is editor.ts\n```\n\nI want to include it like this:\n\n``` html\n<html>\n...\n<script src=\"env-core-terminal-merged.js\"></script>\n<script src=\"color-mode-editor_merged.js\"></script>\n</html>\n```\n\nand I created it with the following command:\n\n```\ntsc --out public/js/color-mode-editor_merge.js editor.ts\n```\n\nBut now there is a problem: as the editor.ts depends on the core.ts and env.ts the tsc will paste the compiled content of them into the color-mode-editor_merged.js again. But I need to have only one the compiled content of the core.ts, env.ts be included. I can't include only one file that will have compiled content for the all .ts files and replace the env-core-terminal-merged.js with it, because the site has block architecture and each block can define its own javascript files and have a common part for all blocks (in this case the common part is defined in the env-core-terminal-merged.js) For now to resolve of this problem I can only open the color-mode-editor_merged.js with editor and delete the compiled content of the core.ts and env.ts by hand (manually).\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4710/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "weswigham",
        "created_at": "2015-09-09T17:24:18Z",
        "body": "I believe the conventional wisdom right now is to reference the generated `.d.ts` files for the files whose sources you don't wish to compile, rather than the original sources.\n"
      },
      {
        "user": "ghost",
        "created_at": "2015-09-10T16:09:58Z",
        "body": "@weswigham, yes it works, thanks.\n"
      }
    ],
    "satisfaction_conditions": [
      "Mechanism to exclude already-compiled dependencies from merged output files",
      "Support for modular code splitting across different page sections",
      "Automated exclusion of dependencies without manual file editing",
      "Maintain type checking for excluded files"
    ]
  },
  {
    "number": 4687,
    "title": "Declare variable as typeof external module without import",
    "created_at": "2015-09-08T03:36:12Z",
    "closed_at": "2015-09-08T21:30:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4687",
    "body": "Hey there,\n\nIs it possible to write an external (commonjs) module \"A\", then in another module \"B\"'s code, declare a variable as being typeof module \"A\" without using import which ends up require-ing module \"A\".\n\nThe reason I want to do this is that I will be passing a reference to module \"A\" to the constructor of a class in another module \"B\", because I want module \"A\" to be a singleton. But I want to type the argument in the constructor to that of module \"A\", as if module \"A\" had been imported using import A = require(\"A\");\n\nThe reason I want a singleton module is that this module might contain instances of classes that manage database connections, etc, and I don't really want them re-initialising each time I have to import; I want to be able to pass them around rather than rely on potential \"node-module cache\" magic.\n\nIs there a way to do this? I've thought of other ways I can achieve want I want but this feels like the simplest, if it's possible.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4687/comments",
    "author": "Roam-Cooper",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-09-08T17:59:56Z",
        "body": "Module imports are elided if they are not used in a value position. so if your import of module `A` is only used in a type position the `require` call will not be written out.\n\nfor instance:\n\n``` ts\n// B.ts\nimport s = require(\"./A\");\nvar x: typeof s;\n```\n\nemits\n\n``` js\nvar x;\n```\n\ndoes this answer your question?\n"
      },
      {
        "user": "Roam-Cooper",
        "created_at": "2015-09-08T21:30:05Z",
        "body": "Oh, that's great! It definitely answers my question. I couldn't find this in the documentation, so thanks a tonne for your help. :)\n"
      },
      {
        "user": "BaamAadmi",
        "created_at": "2018-01-10T07:50:01Z",
        "body": "Hi Folks,\r\nI have a question which is on the same lines. I tried above solution but it did now work for me. \r\nI am importing classes from a webpack module parent   import { A, B } from \"parent\";\r\nI simply want to call constructor for these classes. I tried  const a = A( { data: 1} );  This does not give any TS error on compile. But it breaks on runtime javascript saying ,   Type error A is not a constructor. \r\n\r\nDo I need to create custom types and add it in devDependancies ? Or is there a specific way to export my \"parent\" module like export default. \r\n\r\nAny help is appreciated. \r\n\r\nCheers,\r\nSudeep"
      }
    ],
    "satisfaction_conditions": [
      "Allow type referencing of an external CommonJS module without triggering runtime dependency",
      "Maintain type safety for passed module references",
      "Avoid reliance on Node.js module cache behavior"
    ]
  },
  {
    "number": 4323,
    "title": "outDir compiler option description or function unclear",
    "created_at": "2015-08-14T23:44:40Z",
    "closed_at": "2015-08-17T17:41:04Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4323",
    "body": "The description \"Redirect output structure to the directory\" seems to imply mimicing of the source structure in the specified directory. \n\nFor example, I take the above description to mean:\nif source is \"app/app.ts\", then output should be <outDir>/app/app.js\n\nOutputs are placed in directory without structure. What is the correct behavior? \n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4323/comments",
    "author": "ldminoc",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-08-17T17:41:04Z",
        "body": "`--outDir` will mimic the input structure. the root of the input files is computed to be the longest common subpath of all input files, if you have one file, that is not going to work obviously.\n\nuse `--rootDir` to tell the compiler where is the root of your sources is. so in your case `--rootDir ./` should result in `<outDir>/app/app.js`\n"
      },
      {
        "user": "ldminoc",
        "created_at": "2015-08-18T00:51:32Z",
        "body": "Thanks, your answer describes the behavior I was expecting. (Looks like <outDir>  got left out in my original post).\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how the compiler determines the root directory structure for output files",
      "Description of how to maintain source directory hierarchy in output",
      "Clarification of the relationship between input files' locations and output directory configuration"
    ]
  },
  {
    "number": 4314,
    "title": "How can I debug language service with TSX?",
    "created_at": "2015-08-14T08:54:12Z",
    "closed_at": "2015-08-16T07:19:33Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4314",
    "body": "I've been debugging TypeScript with dev mode in Visual Studio but my VS2015 does not support .tsx file. Adding extension mapping does not help me very much as it doesn't really load language service.\n\nAre there other good tools to debug language service with TSX file?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4314/comments",
    "author": "saschanaz",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-08-15T16:41:12Z",
        "body": "You can create a fourslash test and run the test in the browser with `jake runtests-browser t=yourTestName` or add a `debugger` statement to your test and run `jake runtests-browser t=fourslash`. Then open your F12 tools to trigger an appropriate debug point.\n"
      },
      {
        "user": "saschanaz",
        "created_at": "2015-08-15T19:03:14Z",
        "body": "`jake runtest-browser`. Thanks! :+1:\n"
      }
    ],
    "satisfaction_conditions": [
      "Provides a method to debug TypeScript language service features with TSX files",
      "Works without relying on Visual Studio 2015's native TSX support",
      "Supports integration with debugging tools for breakpoints/inspection",
      "Leverages existing TypeScript test infrastructure"
    ]
  },
  {
    "number": 4140,
    "title": "Can't define variable using type of typeof",
    "created_at": "2015-08-04T04:37:39Z",
    "closed_at": "2015-08-07T15:53:14Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4140",
    "body": "I declared `test` module to export the global mongoose variable as below.\ntest1.d.ts:\n\n``` javascript\n  declare module \"test\" {\n    import _mongoose = require('mongoose');\n    export var export_mongoose: typeof _mongoose;\n  }\n```\n\nI tried to define mongoose.Model using the export_mongoose variable. Please refer to below code:\ntest2.ts:\n\n``` javascript\n  /// \\<reference path=\"test1.d.ts\" /\\>\n  import test = require('test');\n  var model: test.export_mongoose.Model\\<number\\>;  // it doesn't work.\n  var model = test.export_mongoose;  // it works well.\n```\n\nHowever, tsc compiler shows a following error message:\n  TS2305: Module `test` has no exported member `export_mongoose`.\n\nI think the export_mongoose is not proper as type cause defined by `typeof`.\nCan I use the `export_mongoose` as type?\n\nIt would be helpful for me if you have any idea on this.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4140/comments",
    "author": "estherk0",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-08-04T04:51:10Z",
        "body": "When you use `var export_mongoose = _mongoose`, `export_mongoose` only takes on the _value side_ of `_mongoose`.\n\nInstead of using `export_mongoose`, I suggest you instead export the import directly:\n\n``` TypeScript\ndeclare module \"test\" {\n    export import _mongoose = require(\"mongoose\");\n}\n```\n"
      },
      {
        "user": "estherk0",
        "created_at": "2015-08-04T07:36:30Z",
        "body": "Thanks for a quick reply!\n\nI understood how this code works.\nBut I have to use an export_mongoose variable for sharing the mongoose object in many places, not only test2.ts. \n\nIf there is no way to solve this problem, I will import mongoose and use it for type:\n\n``` javascript\nimport mongoose = ('mongoose');\nvar test_var: mongoose.Model<...>;\n```\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-08-04T14:27:07Z",
        "body": "Try \n\n``` Typescript\ndeclare module \"test\" {\n    import mongoose = require(\"mongoose\");\n    export import export_mongoose = mongoose;\n```\n\nThe `import...=` declaration above creates an alias to all meanings of `mongoose`.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-08-04T17:17:56Z",
        "body": "I would use the ES6 import/export syntax here.\n\n``` Typescript\ndeclare module \"test\" {\n   // import it locally \n   import * as mongoose from \"mongoose\";\n   // use the import\n   var test_var: mongoose.Model<...>;\n\n   // export it directly from \"mongoose\" module\n   export * from \"mongoose\";\n```\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-08-04T17:40:45Z",
        "body": "Yes - if you're still intent on doing it the way you wanted, you can do something like\n\n``` TypeScript\ndeclare module \"test\" {\n    import * as mongoose from \"mongoose\";\n    export { mongoose as export_mongoose };\n}\n```\n"
      },
      {
        "user": "estherk0",
        "created_at": "2015-08-07T08:07:01Z",
        "body": "This is an exactly what I wanted to do. It works for me. Thanks.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-08-07T15:53:20Z",
        "body": "glad that helped.\n"
      }
    ],
    "satisfaction_conditions": [
      "Allows using the exported variable as both a value and a type reference",
      "Maintains shared mongoose instance across multiple modules",
      "Avoids direct dependency on original mongoose imports in consuming modules",
      "Preserves full type capabilities of mongoose.Model"
    ]
  },
  {
    "number": 4069,
    "title": "systemjs plugin import, typescript says module not found",
    "created_at": "2015-07-29T07:51:35Z",
    "closed_at": "2015-08-10T23:35:32Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4069",
    "body": "typescript doesn't like `import somethingHTML from 'components/something/something.html!text';`complains it can't find a module.\n\n`import 'components/something/something.html!text';`\nwould work but not usable since I can't assign it to the template property of a component in angular.\n\nusing \njspm install text=github:systemjs/plugin-text\n\nWhat's odd is importing css via the systemjs loader works fine...\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4069/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2015-07-29T08:33:23Z",
        "body": "I think you will need to declare an ambient module, something like this I think:\n\n``` typescript\ndeclare module 'components/something/something.html!text' {\n    var text: string;\n    export = text;\n}\n```\n"
      },
      {
        "user": "ghost",
        "created_at": "2015-07-31T05:47:37Z",
        "body": "@kitsonk  that works but that means I will need to do that for every template file.\n\nThis might be an issue @guybedford can solve in the plugin.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-07-31T15:49:38Z",
        "body": "This is not something that systemJs or an extension can solve for you. There is a suggestion for the issue in #2709.\n"
      }
    ],
    "satisfaction_conditions": [
      "Solution avoids manual ambient module declarations for each template file",
      "Enables TypeScript to recognize SystemJS plugin syntax (!text) for HTML imports",
      "Maintains Angular component template assignment capability",
      "Works with TypeScript's module resolution system"
    ]
  },
  {
    "number": 3980,
    "title": "Class expression inside a generic function bug",
    "created_at": "2015-07-22T15:10:11Z",
    "closed_at": "2015-07-22T17:41:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3980",
    "body": "This code seems to be valid TS:\n\n``` ts\ninterface ReactClass<P, S> {\n    setState(state: S): void;\n}\n\ninterface Props {}\n\ninterface State {\n    hovered: boolean;\n}\n\nfunction createComponent<P extends Props, S extends State>() {\n    return class Component implements ReactClass<P, S> {\n        constructor() {\n            this.setState({ hovered: true })\n        }\n\n        setState(state: S): void {}\n    }\n}\n```\n\nBut it fails to compile:\n\n```\nissue.tsx(15,27): error TS2345: Argument of type '{ hovered: boolean; }' is not assignable to parameter of type 'S'.\n```\n\nIs it a bug?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3980/comments",
    "author": "s-panferov",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-07-22T17:39:54Z",
        "body": "this is not really related to classes or functions. the constraint on S is it has to be _at least_ of type state, but does not mean that a value of type State is assignable to it, it may need more properties that are missing in the base type.\n\nhere is a simplified version of your snippit:\n\n``` ts\nfunction setState<T extends State>(t: T) {\n    var s: State = { hovered: true };\n\n    s = t; // OK, t is a T, which is a State\n    t = s; // Error, s may not be a T\n}\n```\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why a value matching the base State type isn't assignable to generic type parameter S that extends State",
      "Clarification of TypeScript's generic type parameter variance rules in this context",
      "Demonstration of how generic constraints work with object type extensions",
      "Confirmation whether this is expected TypeScript behavior versus a compiler bug"
    ]
  },
  {
    "number": 3977,
    "title": "InterfaceTypeWithBaseTypes.baseTypes is lazily loaded without clear API to do that",
    "created_at": "2015-07-22T09:42:13Z",
    "closed_at": "2015-07-23T03:47:52Z",
    "labels": [
      "Question",
      "Fixed",
      "API"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3977",
    "body": "This issue appeared after upgrading from 1.4 to 1.5 - the baseTypes of a class were always returning `undefined` - by looking in the source I found that calling, for example, `getConstructSignatures()` would lazily load the data.\n\n```\n    if (node.kind === ts.SyntaxKind.ClassDeclaration) {\n        var cl = <ts.InterfaceTypeWithBaseTypes>checker.getTypeAtLocation(node);\n        console.log(cl.baseTypes); // prints \"undefined\"\n        cl.getConstructSignatures();\n        console.log(cl.baseTypes); // prints the actual base types\n    }\n```\n\nIt seems that instead of exposing the field `baseTypes`, there should be a method `getBaseTypes()` - similar to other such changes in the API.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3977/comments",
    "author": "Knagis",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-07-22T17:27:46Z",
        "body": "pinging @JsonFreeman\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2015-07-22T17:54:17Z",
        "body": "In general, there are two recommendations for using the Types API:\n1. Do not cast to a type that grants you access to more properties. These properties are generally hidden in a subtype for a reason.\n2. Do not directly access properties that start with `resolved`\n\nInstead, you should call a function that gets you these things and that will take care of the lazy computation.\n\n@Knagis In the version of the code that you're looking at, we do indeed have a getBaseTypes that you should call.\n\nIf you update to the latest in master, getBaseTypes is still there, but InterfaceTypeWithBaseTypes is gone. Instead there is a property called resolvedBaseTypes which should not be accessed. There is additionally resolvedBaseConstructorType which should not be accessed (for that one you call getBaseConstructorTypeOfClass).\n\nI wish there were a better way to hide members that should not be accessed directly, but the only way I know of is to use privates, which today require that the containing type be a class. And we don't use classes in the compiler.\n\nAlthough now that ambient classes and interfaces can be merged, maybe we can.\n\n\n---\n\n@mhegazy Is there anything that needs to be done here?\n\n\n---\n\n@Knagis, are you asking us to expose the getBaseTypes function on the TypeChecker interface? What are you trying to use it for?\n\nAlso, I think we should designate these properties as internal.\n"
      },
      {
        "user": "Knagis",
        "created_at": "2015-07-22T19:30:54Z",
        "body": "> @Knagis In the version of the code that you're looking at, we do indeed have a getBaseTypes that you should call.\n\nIn the master branch I only see `resolvedBaseTypes` field but no `getBaseTypes()` method.\n\n---\n\nI am writing code that extracts certain classes and properties from the code and creates documentation page from that. I need base types both to check if a class should be included in the documentation (if it is derived from a certain base class) and to display the type hierarchy there. Is there a different approach I should use for this purpose?\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2015-07-22T20:00:38Z",
        "body": "I was talking with @mhegazy and he suggested maybe getting the base type nodes from the AST and then getting the types of those base type nodes. So if you have the class declaration node `classNode`, you would `classNode.heritageClauses`, find the extends list in there, call it `heritage`. Then `heritage.types`, and those will be expressions with type arguments. Then call `checker.getTypeAtLocation` on that base type node. And then it should give you the right thing.\n"
      },
      {
        "user": "Knagis",
        "created_at": "2015-07-22T20:48:12Z",
        "body": "That could be done, it just slightly increases the complexity since there can be multiple declarations.\n\nWhat is the reason why the Type could not expose the baseTypes? If I call `Type.getProperties()`, it returns all properties including inherited properties from base types - so it does have this information internally.\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2015-07-22T22:32:28Z",
        "body": "Oh I see, you are not using the TypeChecker interface, you are using the Type interface defined in services. I think you're right - it's reasonable for us to expose getBaseTypes().\n\n\n---\n\n@Knagis does #3990 address your need?\n"
      },
      {
        "user": "Knagis",
        "created_at": "2015-07-23T03:47:52Z",
        "body": "Yes, it does.\nThank you!\n"
      }
    ],
    "satisfaction_conditions": [
      "Provides an official API method to retrieve base types without relying on internal properties",
      "Solution works without requiring complex AST traversal for basic inheritance checks",
      "Maintains API stability across TypeScript versions",
      "Exposes inheritance information through TypeChecker/Type interfaces"
    ]
  },
  {
    "number": 3785,
    "title": "problem with rest params and function overloading",
    "created_at": "2015-07-08T21:04:47Z",
    "closed_at": "2015-07-09T17:55:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3785",
    "body": "``` ts\nexport function injection(clazz: Class)\n    export function injection(...metadata: Metadata[])\n    export function injection(...value: any[]) {\n\n        if (typeof value === typeof []) {\n            return (clazz: Class) => {\n                Injector.instance.register(clazz, value);\n            }\n        }\n        else {\n            Injector.instance.register(<any>value);\n        }\n    }\n```\n\nI`v got the compilation error\n\n```\nArgument of type 'any[]' is not assignable to parameter of type 'Metadata'.\n```\n\nand \n\n```\nArgument of type 'any[]' is not assignable to parameter of type 'Metadata'.\n  Property 'name' is missing in type 'any[]'.   \n```\n\nHave you any idea?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3785/comments",
    "author": "OlegDokuka",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-07-08T21:10:20Z",
        "body": "What code is actually triggering the compilation error? Those lines you pasted do not have the errors you're mentioning.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-07-08T22:00:44Z",
        "body": "I'm presuming the code looks like this:\n\n``` ts\ninterface Class { }\ninterface Metadata {\n    name: string;\n}\n\ndeclare var Injector: {\n    instance: {\n        register(c: Class, value: Metadata[]);\n        register(c: Class);\n    }\n}\n\nfunction injection(clazz: Class)\nfunction injection(...metadata: Metadata[])\nfunction injection(...value: any[]) {\n    if (typeof value === typeof []) {\n        return (clazz: Class) => {\n            Injector.instance.register(clazz, value);\n        }\n    }\n    else {\n        Injector.instance.register(<any>value);\n    }\n}\n```\n\nSeveral problems going on here.\n\nFirst, this line is wrong:\n\n``` ts\n   function injection(...value: any[]) {\n```\n\nHaving a rest arg in the implementation signature means that you're always going to have your arguments wrapped in an array, which means you're never going to hit the `else` clause. Instead, this should be `value: any`.\n\nMore accurately, though, you can write:\n\n``` ts\n    function injection(value: Metadata[]|Class) {\n```\n\nIf you do this, we can move on to the next problem.\n\n``` ts\n    if (typeof value === typeof []) {\n```\n\nThis code is also wrong (or at least overstates its specificity). `typeof []` is `\"object\"`, so this test is always going to be `true` for a bunch of things that aren't arrays. It's more accurate to write\n\n``` ts\n        if (value instanceof Array) {\n```\n\nIf you do both these fixes, the entire example compiles without error:\n\n``` ts\ninterface Class { }\ninterface Metadata {\n    name: string;\n}\n\ndeclare var Injector: {\n    instance: {\n        register(c: Class, value: Metadata[]);\n        register(c: Class);\n    }\n}\n\nfunction injection(clazz: Class)\nfunction injection(...metadata: Metadata[])\nfunction injection(value: Metadata[]|Class) {\n    if (value instanceof Array) {\n        return (clazz: Class) => {\n            Injector.instance.register(clazz, value);\n        }\n    }\n    else {\n        Injector.instance.register(<any>value);\n    }\n}\n```\n"
      }
    ],
    "satisfaction_conditions": [
      "Resolve type incompatibility between rest parameters and Metadata interface requirements",
      "Ensure correct function overload resolution logic",
      "Maintain intended dual functionality of register method",
      "Implement proper type checking for array detection",
      "Avoid unsafe type assertions while maintaining type safety"
    ]
  },
  {
    "number": 3422,
    "title": "Config to compile `const enum` as `enum` in development / Get SyntaxKind during development",
    "created_at": "2015-06-08T18:30:20Z",
    "closed_at": "2015-06-08T18:54:04Z",
    "labels": [
      "By Design",
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3422",
    "body": "Hi,\n\nWhen I work on the code, I have to change `SyntaxKind` from `const enum` to `enum` so that I can do `write(`kind: ${SyntaxKind[node.kind]}`)`.\n\nIs there a way to config the compiler and jake to treat `const enum` as `enum` so this would work?\nOr is there another way to get the SyntaxKind without doing `SyntaxKind[node.kind]`?\n\nThanks,\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3422/comments",
    "author": "unional",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-06-08T18:54:04Z",
        "body": "You can keep the mapping at runtime with `--preserveConstEnum` for debugging purposes, but this behavior is the point of const enums.\n"
      },
      {
        "user": "unional",
        "created_at": "2015-06-08T20:59:50Z",
        "body": "jake already passes `--preserveConstEnums` to tsc.js, but it still fails compilation:\n\n`error TS2476: A const enum member can only be accessed using a string literal`\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-06-08T23:43:44Z",
        "body": "these exist only for debugging purposes. if you really want to do that cast to any. `(<any>ts).SyntaxKind[node.kind]`\n"
      },
      {
        "user": "unional",
        "created_at": "2015-06-09T00:33:19Z",
        "body": "great! That's exactly what I'm doing. Just to write out stuffs to understand about the node for debug purposes.\n\n`(<any>ts).SyntaxKind[node.kind]` works because `(<any>ts)` suppress all type checks?\n\nThanks a lot!\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-06-09T04:24:57Z",
        "body": "yes.\n"
      }
    ],
    "satisfaction_conditions": [
      "Allows runtime access to const enum values during development",
      "Works without converting const enum to regular enum declarations",
      "Avoids TypeScript compiler errors about const enum member access",
      "Provides a development-friendly workaround rather than production solution"
    ]
  },
  {
    "number": 3329,
    "title": "Function type error in union type",
    "created_at": "2015-06-01T19:31:47Z",
    "closed_at": "2015-06-01T19:36:54Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3329",
    "body": "I have been having issues with union types when using a function type as the second type in the union.\n\nAccording to the TypeScript 1.4 Language Specification: (3.4 Union Types, page 29)\n- A | B is equivalent to B | A\n\nThe following example compiles correctly:\n\n``` typescript\nfunction test(x: (y) => boolean | boolean) {\n    //do something with x\n}\n```\n\nBut this one gives an error:\n\n``` typescript\nfunction test(x: boolean | (y) => boolean) {\n    //do something with x\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3329/comments",
    "author": "joeskeen",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-06-01T19:36:20Z",
        "body": "The language in the spec is a specification of type system behavior, not grammar.\n\nYou can fix this with parens:\n\n``` ts\nfunction test2(x: boolean | ((y) => boolean)) {\n    //do something with x\n}\n```\n"
      },
      {
        "user": "joeskeen",
        "created_at": "2015-06-01T19:36:42Z",
        "body": "Perfect, thanks\n"
      },
      {
        "user": "btesser-r7",
        "created_at": "2016-03-04T17:58:27Z",
        "body": "```\nfunction test(x: (y) => boolean | boolean) {\n    //do something with x\n}\n```\n\nlooks like what you are trying to accomplish is this:\n\n```\nfunction test(x: (y) => (boolean | boolean)) {\n    //do something with x\n}\n```\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of TypeScript's grammar rules for union types containing function types",
      "Method to disambiguate function type syntax in union types",
      "Clarification of when union type ordering affects parsing"
    ]
  },
  {
    "number": 3290,
    "title": "Map,Set ... in ES5 target",
    "created_at": "2015-05-28T08:52:59Z",
    "closed_at": "2015-05-28T17:49:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3290",
    "body": "After update the typescript compiler from version 1.4.1 to 1.5.0 beta, the source code included in my project became to make error log such as 'Map is not found'.\nThus, I researched this problem, and I reached an conclusion. The lib.d.ts became not to contain Map and Set definitions except ES6 being selected in tsconfig.json.\n\nActually, Map and Set is specification of ES6. It is natural that we can't use Map and Set in the project targeting ES5 or lower.\nBut we could use Map and Set even if I select ES5 as the target before typescript 1.4.1.\nI know that making it being enabled to use Map and Set in the project that is made for ES5 contains risk.\nBecause there is some of browsers not supporting Map and Set.\n\nHowever, I think it is better to make some of property of configuration that is for switching to use these definitions or not. Don't you think so?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3290/comments",
    "author": "kyasbal",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-05-28T17:42:24Z",
        "body": "@LimeStreem we removed some IE-specific types from the library in 1.5.0-beta. you can just define the type in one of your files like:\n\n``` ts\ninterface Map<K, V> {\n    clear(): void;\n    delete(key: K): boolean;\n    forEach(callbackfn: (value: V, index: K, map: Map<K, V>) => void, thisArg?: any): void;\n    get(key: K): V;\n    has(key: K): boolean;\n    set(key: K, value: V): Map<K, V>;\n    size: number;\n}\ndeclare var Map: {\n    new <K, V>(): Map<K, V>;\n    prototype: Map<any, any>;\n}\ninterface Set<T> {\n    add(value: T): Set<T>;\n    clear(): void;\n    delete(value: T): boolean;\n    forEach(callbackfn: (value: T, index: T, set: Set<T>) => void, thisArg?: any): void;\n    has(value: T): boolean;\n    size: number;\n}\ndeclare var Set: {\n    new <T>(): Set<T>;\n    prototype: Set<any>;\n}\n```\n"
      },
      {
        "user": "kyasbal",
        "created_at": "2015-05-28T17:49:17Z",
        "body": "Wow, I appreciate you to write this code snippet! :laughing: \nI wonder this issue will help a lot of typescript users!\n"
      },
      {
        "user": "nin-jin",
        "created_at": "2017-06-27T09:57:39Z",
        "body": "```\r\ndeclare class WeakMap< Key , Value > {\r\n\tdelete( key : Key ) : boolean\r\n\tget( key : Key ) : Value\r\n\thas( key : Key ) : boolean\r\n\tset( key : Key , value : Value ) : Map< Key , Value >\r\n}\r\n\r\ndeclare class Map< Key , Value > {\r\n\tclear(): void\r\n\tdelete( key : Key ) : boolean\r\n\tforEach< Context = any >( handler : ( this : Context , value : Value , key : Key , map : Map< Key , Value > ) => void , context? : Context ) : void\r\n\tget( key : Key ) : Value\r\n\thas( key : Key ) : boolean\r\n\tset( key : Key , value : Value ) : Map< Key , Value >\r\n\tsize : number\r\n}\r\n\r\ndeclare class Set< Value > {\r\n\tadd( value : Value ) : Set< Value >\r\n\tclear() : void\r\n\tdelete( value : Value ) : boolean\r\n\tforEach< Context = any >( handler : ( this : Context , value : Value , key : Value , map : Set< Value > ) => void , context? : Context ) : void\r\n\thas( value : Value ) : boolean\r\n\tsize : number\r\n}\r\n```"
      }
    ],
    "satisfaction_conditions": [
      "Enable use of Map/Set types in TypeScript projects targeting ES5",
      "Maintain type safety without runtime polyfill enforcement"
    ]
  },
  {
    "number": 3243,
    "title": "vs plugin, 1.5beta regression: can not extend from class in external import",
    "created_at": "2015-05-21T13:29:24Z",
    "closed_at": "2015-05-21T17:44:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3243",
    "body": "this works in older versions.\n\nwhen I have the following code in 1.5beta:\n\n```\nimport refs = require(\"../refs\");\nvar xlib = refs.xlib;\n\nexport class PjscBe extends xlib.ClassBase{}\n```\n\nI get the following error:\n`265  Cannot find name 'xlib'.`\n\nthis issue goes away if I remove the extends.  I can use my external module in other ways just fine:\n`var log = new xlib.diagnostics.logging.Logger(__filename);`\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3243/comments",
    "author": "jasonswearingen",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2015-05-21T16:14:11Z",
        "body": "Which older versions does it work in? Anyway, looks to me like the issue is that you're attempting to reference a variable (`xlib`) in a type name (`xlib.ClassBase`), which isn't possible. It should work if you change the declaration of `xlib` to be an `import`:\n\n``` typescript\nimport refs = require(\"../refs\");\nimport xlib = refs.xlib;\n\nexport class PjscBe extends xlib.ClassBase {}\n```\n\nThis will enable `xlib` to be used in both value and type positions.\n"
      },
      {
        "user": "jasonswearingen",
        "created_at": "2015-05-21T17:44:52Z",
        "body": "I'm pretty sure this was working in the 1.4 vs plugin, but it might have been in 1.3.\n\nthank you for the solution Anders, `import xlib = refs.xlib;` works.  I did not know you could `import` without the `require` syntax.\n"
      }
    ],
    "satisfaction_conditions": [
      "Resolve the 'Cannot find name' error when extending a class from an external module import",
      "Maintain compatibility with existing module import patterns using require syntax",
      "Enable imported symbols to be used in both type and value contexts"
    ]
  },
  {
    "number": 3213,
    "title": "Access to static fields via constructor property",
    "created_at": "2015-05-19T10:57:45Z",
    "closed_at": "2015-06-08T03:12:15Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3213",
    "body": "This is example of correct code, though compiler raises an error `Property 'bar' does not exist on type 'Function'.`\n\n``` typescript\nclass A {\n    static bar(): void {\n        alert(\"Oh hi!\");\n    }\n\n    foo(): void {\n        this.constructor.bar(); //<-- compiler error\n    }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3213/comments",
    "author": "dvoyni",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-05-21T22:03:01Z",
        "body": "pinging @rbuckton for this one. the main reason is that constructor is not guaranteed to be set to the right thing all the time; consider an ambient class from a .d.ts modeling an existing js class implementation.\n"
      },
      {
        "user": "rbuckton",
        "created_at": "2015-05-21T22:15:01Z",
        "body": "Consider the following:\n\n``` ts\nclass A {\n    static x() { return 1; }\n    y() {\n        let z = this.constructor.x(); // z: string;\n        console.log(typeof z);\n    }\n}\n\nclass B extends A {\n    static x() { return undefined; }\n}\n\nclass C extends B {\n    static x() { return \"text\"; }\n}\n\nlet a = new A();\na.y(); // prints: \"number\";\nlet b = new B();\nb.y(); // prints: \"undefined\";\nlet c = new C();\nc.y(); // prints: \"string\";\n```\n\nIf we made `constructor` have the type `typeof A` here, a derived type could return something unexpected.\n"
      },
      {
        "user": "dvoyni",
        "created_at": "2015-05-22T02:32:07Z",
        "body": "Got it. Thank you.\n\nI've found this workaround:\n\n``` typescript\nclass A {\n    static bar(): void {\n        alert(\"Oh hi!\");\n    }\n\n    foo(): void {\n        (<AStatic>this.constructor).bar();\n    }\n}\n\nnew A().foo();\n\ninterface AStatic {\n    new (): A\n    bar(): void\n}\n```\n\nIs there any simpler solution?\n"
      },
      {
        "user": "oxyflour",
        "created_at": "2015-06-08T03:09:54Z",
        "body": "Hi, I just found that using <typeof A> instead of <AStatic> is ok : )\n\n``` typescript\nclass A {\n    static bar(): void {\n        alert('hello')\n    }\n    foo(): void {\n        (<typeof A> this.constructor).bar()\n    }\n}\n\nnew A().foo()\n```\n"
      },
      {
        "user": "dvoyni",
        "created_at": "2015-06-08T03:12:15Z",
        "body": "Wow, that's very nice! Thanks\n"
      }
    ],
    "satisfaction_conditions": [
      "Allows safe access to static class members via `this.constructor` without type errors",
      "Avoids requiring separate interface definitions for static members",
      "Maintains compatibility with class inheritance patterns",
      "Provides type-safe access without compromising compiler checks"
    ]
  },
  {
    "number": 3193,
    "title": "type-safe cast",
    "created_at": "2015-05-18T00:24:07Z",
    "closed_at": "2015-05-18T02:58:09Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3193",
    "body": "There doesn't seem to be a safe cast in Typescript. (&lt;T&gt; x) does no dynamic check. This is a very common need and is provided in every other optionally and gradually typed language I know of. What is needed is something like:\n\n```\nfunction cast<T>(x: any): T {\n    if (x instanceof T) return x;\n    throw new Error('type cast exception');\n}\n```\n\nexcept that doesn't compile. Is there an alternative solution I'm missing?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3193/comments",
    "author": "JonathanMEdwards",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-05-18T02:58:09Z",
        "body": "``` ts\nfunction cast<T>(instance: T, ctor: { new(...args: any[]): T }): T {\n    if (instance instanceof ctor) return instance;\n    throw new Error('type cast exception');\n}\n```\n\nThe reason there's no built-in operation for this is that it's not possible at runtime to detect many things (for example, `(x: number) => any` and `(x: string) => any` are indistinguishable from a runtime perspective).\n"
      },
      {
        "user": "JonathanMEdwards",
        "created_at": "2015-05-18T03:27:11Z",
        "body": "I think you're just saying that instanceof is broken on primitives in JavaScript. But why can't we have a cast operation that is consistent with the semantics of instanceof? Which would work as expected on classes.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-05-18T03:31:36Z",
        "body": "Can you post an example of how you'd want that to work? `instanceof` is already a qualifying operation for a type guard (e.g. if you have `var x: Giraffe|Elephant`, `if(x instanceof Giraffe) { x.longNeck(); }` works)\n"
      },
      {
        "user": "JonathanMEdwards",
        "created_at": "2015-05-18T03:45:32Z",
        "body": "Like I said:\n\n```\nfunction cast<T>(x: any): T {\n    if (x instanceof T) return x;\n    throw new Error('type cast exception');\n}\n```\n\nI find I keep repeating that boilerplate which mimics a \"normal\" safe cast operation.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-05-18T03:48:34Z",
        "body": "For example, let's say you wrote the following:\n\n``` ts\ninterface Foo {\n  (x: string): void;\n}\n\nvar j: any = whatever;\nvar x = cast<Foo>(j);\n```\n\n``` ts\n/* write the JavaScript you would expect to be emitted here */\n```\n\nThe `cast` function _that can exist_ is the one I wrote above -- you have to specify the constructor function, but the types work as expected and the runtime behavior is correct.\n"
      },
      {
        "user": "JonathanMEdwards",
        "created_at": "2015-05-18T11:55:01Z",
        "body": "OK. I'd expect that to be an error, but that certainly would be annoying for a supposed cast expression.\nHow does your suggestion work? This doesn't:\n\n```\nfunction cast<T>(instance: T, ctor: { new(...args: any[]): T }): T {\n    if (instance instanceof ctor) return instance;\n    throw new Error('type cast exception');\n}\nclass A {\n    foo: number;\n}\nvar x: A | number = new A();\nvar y:A = cast<A>(x, A);\n```\n\ntest.ts(9,19): error TS2345: Argument of type 'number | A' is not assignable to parameter of type 'A'.\n  Type 'number' is not assignable to type 'A'.\n"
      },
      {
        "user": "duanyao",
        "created_at": "2015-05-18T16:25:59Z",
        "body": "This works:\n\n``` javascript\nfunction cast<T>(instance, ctor: { new(...args: any[]): T }): T { // instance should be \"any\"\n    if (instance instanceof ctor) return instance;\n    throw new Error('type cast exception');\n}\nclass A {\n    foo: number;\n}\nvar x: A | number = new A();\nvar y = cast(x, A); // type param is not required\n```\n"
      },
      {
        "user": "JonathanMEdwards",
        "created_at": "2015-05-18T22:43:55Z",
        "body": "Thanks @duanyao that's exactly what I was looking for!\n"
      }
    ],
    "satisfaction_conditions": [
      "Runtime type validation using constructor checks",
      "Works with TypeScript's type system constraints",
      "Avoids manual type parameter specification",
      "Handles union types safely",
      "Provides explicit runtime type checking mechanism"
    ]
  },
  {
    "number": 3021,
    "title": "Getting \"Maximum call stack size exceeded\" when using \"getDocumentHighlights\" with reference paths and modules in 1.5.0-beta",
    "created_at": "2015-05-04T17:29:01Z",
    "closed_at": "2015-05-05T17:07:59Z",
    "labels": [
      "Question",
      "Fixed"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3021",
    "body": "If I have code that looks something like this: \n\n``` typescript\n/// <reference path=\"nounreachable.test.ts\" />\n\nmodule S {\n  var template = '';\n}\n```\n\nand I try to do getDocumentHighlights on \"template\" in just that one file, I get a \"Maximum call stack size exceeded\" error. Am I doing something wrong? Or can you guys fix this, please? Thanks!\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3021/comments",
    "author": "gscshoyru",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-05-04T17:52:09Z",
        "body": "Hey @gscshoyru, is the definition file required to reproduce this error?\n"
      },
      {
        "user": "gscshoyru",
        "created_at": "2015-05-04T17:54:14Z",
        "body": "The definition file isn't necessary, it's just the existence of a reference path that causes the bug. It's the combination of the module and the reference path that does it for some reason, if you don't have have one or the other the bug doesn't happen. \n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-05-04T18:52:48Z",
        "body": "Got it, I'll try to look into it as soon as I get in.\n\n\n---\n\nNot able to repro - can you supply both a call stack and the original call that's triggering it? What set of parameters are you passing in when calling?\n"
      },
      {
        "user": "gscshoyru",
        "created_at": "2015-05-04T21:38:40Z",
        "body": "Ok, sorry, I apparently I copied the wrong thing since it was failing that way before. Now it's failing if there's a ../ in the reference path, like `/// <reference path=\"../nounreachable.test.ts\" />`. It may also have something to with how we're doing it, though, since we are creating our own language service host and whatnot -- I can add the code for that if it's necessary, and you still can't repro. \n\n\n---\n\nActually, here:\n\n``` typescript\nmodule Lint {\n    export function createLanguageServiceHost(fileName: string, source: string) {\n        var host: ts.LanguageServiceHost = {\n            getScriptFileNames: () => [fileName],\n            getScriptVersion: () => \"1\",\n            getScriptSnapshot: () => {\n                return {\n                    getText: (start, end) => source.substring(start, end),\n                    getLength: () => source.length,\n                    getLineStartPositions: () => ts.computeLineStarts(source),\n                    getChangeRange: (oldSnapshot) => undefined\n                };\n            },\n            getCurrentDirectory: () => \"\",\n            getScriptIsOpen: () => true,\n            getCompilationSettings: () => Lint.createCompilerOptions(),\n            getDefaultLibFileName: () => \"lib.d.ts\",\n            log: (message) => { /* */ }\n        };\n\n        return host;\n    }\n}\n\nvar documentRegistry = ts.createDocumentRegistry();\nvar languageServiceHost = Lint.createLanguageServiceHost(\"file.ts\", sourceFile.getFullText());\nvar languageService = ts.createLanguageService(languageServiceHost, documentRegistry);\nlanguageService.getDocumentHighlights(\"file.ts\", position, [\"file.ts\"]);\n```\n\nThis is what we're doing (paraphrased a little) that's causing the issue. \n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-05-04T22:05:59Z",
        "body": "Still not able to repro.\n\n> `ts.computeLineStarts(source)`\n\nDoesn't seem to be publicly exposed anymore, how are you doing this?\n\n> `Lint.createCompilerOptions()`\n\nNot sure what we get back from this, could be useful for the repro\n\n---\n\nHere's what I'm currently working with:\n\n``` TypeScript\n/// <reference path=\"built/local/typescript.d.ts\" />\n\nimport * as ts from \"typescript\"\n\nmodule Lint {\n    export function createLanguageServiceHost(fileName: string, source: string) {\n        var host: ts.LanguageServiceHost = {\n            getScriptFileNames: () => [fileName],\n            getScriptVersion: () => \"1\",\n            getScriptSnapshot: () => {\n                return {\n                    getText: (start, end) => source.substring(start, end),\n                    getLength: () => source.length,\n                    getLineStartPositions: () => (<any>ts).computeLineStarts(source),\n                    getChangeRange: (oldSnapshot) => undefined\n                };\n            },\n            getCurrentDirectory: () => \"\",\n            getScriptIsOpen: () => true,\n            getCompilationSettings: () => ({}),\n            getDefaultLibFileName: () => \"lib.d.ts\",\n            log: (message) => { /* */ }\n        };\n\n        return host;\n    }\n}\n\nvar sourceText = \"/// <reference path=\\\"../TypeScript3/foo.ts\\\" />\\n\\nmodule m {\\n    var s;\\n}\\n\";\n\nvar documentRegistry = ts.createDocumentRegistry();\nvar languageServiceHost = Lint.createLanguageServiceHost(\"boo.ts\", sourceText);\nvar languageService = ts.createLanguageService(languageServiceHost, documentRegistry);\n\nfor (var i = 0; i < sourceText.length; i++) {\n    console.log(JSON.stringify(languageService.getDocumentHighlights(\"boo.ts\", i, [\"boo.ts\"])));\n}\n```\n\nI'm asking for highlights at every position in the document and I'm still not running into any problems.\n"
      },
      {
        "user": "gscshoyru",
        "created_at": "2015-05-04T22:24:34Z",
        "body": "Sorry, create compiler options is just \n\n``` typescript\nexport function createCompilerOptions(): ts.CompilerOptions {\n        return {\n            target: ts.ScriptTarget.ES5\n        };\n    }\n```\n\nso shouldn't be anything special.\n\nYou're right that it doesn't blow up that way, but it does blow up if you do `/// <reference path=\\\"../foo.ts` instead. Not entirely sure why. \n\nIt also seems to blow up without reference paths if you have imports with the same problem, such as `import xyz = require(\"../xyz\");` instead of the reference path.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-05-05T02:11:50Z",
        "body": "@gscshoyru the problem is that your `getScriptSnapshot` is not actually using its given parameters, nor is it trying to appropriately resolve the filename it is given.\n\n---\n\nEdit: Specifically, you're just returning the same source file as the root, so when requesting the file `../foo.ts`, you'll end up with the original file contents that have a reference comment asking for `../foo.ts` which is, relative to the original root, `../../foo.ts`.\n"
      },
      {
        "user": "ashwinr",
        "created_at": "2015-05-05T04:16:05Z",
        "body": "@DanielRosenwasser Thanks for the reply. Is there any way to ignore imports/references when calling this LS API (or other LS APIs in general)? TSLint doesn't actually need to resolve imports since it works on a file-by-file basis. Thanks again!\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-05-05T05:57:10Z",
        "body": "@ashwinr you should be able to just return an empty string if it's not one of the files you're interested in. Let us know how that works out.\n"
      },
      {
        "user": "vladima",
        "created_at": "2015-05-05T06:19:53Z",
        "body": "@ashwinr you can set `noResolve` to `true` in compilation options to tell compiler that it should not do any file resolutions except files that were provided explicitly\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-05-05T06:31:50Z",
        "body": "^^^ Do what Vlad said.\n"
      },
      {
        "user": "gscshoyru",
        "created_at": "2015-05-05T13:15:22Z",
        "body": "Looks like setting noResolve to true does the trick. Thanks ever so much, and sorry for the confusion! \n"
      }
    ],
    "satisfaction_conditions": [
      "Prevent infinite resolution loops caused by relative path references in language service operations",
      "Configure language service to avoid resolving external dependencies when unnecessary",
      "Handle custom language service host configurations safely"
    ]
  },
  {
    "number": 2931,
    "title": "Compiler Conditionals",
    "created_at": "2015-04-27T17:18:01Z",
    "closed_at": "2015-04-27T19:36:08Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2931",
    "body": "I'm currently using the tsconfig file in our project and I want to have two of them one that outputs es5 and one that outputs es6. Things are working great until I try and target es6 and run into the issue where I'm supplying a definition file for ES6-Promises.\n\n```\n[TsProject] Compiling Project Files...\n[TsProject] c:/Code/Exceptionless.JavaScript/node_modules/typescript/bin/lib.es6.d.ts(4727,11): error TS2300: Duplicate identifier 'Promise'.\n[TsProject] c:/Code/Exceptionless.JavaScript/node_modules/typescript/bin/lib.es6.d.ts(4812,13): error TS2300: Duplicate identifier 'Promise'.\n[TsProject] typings/es6-promise/es6-promise.d.ts(10,15): error TS2300: Duplicate identifier 'Promise'.\n[TsProject] typings/es6-promise/es6-promise.d.ts(40,16): error TS2300: Duplicate identifier 'Promise'.\n[TsProject] typings/es6-promise/es6-promise.d.ts(70,2): error TS1203: Export assignment cannot be used when targeting ECMAScript 6 or higher. Consider using 'export default' instead.\n[TsProject] Build completed with errors. Outputs generated.\n[12:17:44] Finished 'typescript' after 2.76 s\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2931/comments",
    "author": "niemyjski",
    "comments": [
      {
        "user": "niemyjski",
        "created_at": "2015-04-27T17:31:03Z",
        "body": "What would be the best way to get around this?\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-04-27T18:23:17Z",
        "body": "It sounds like you're using a polyfill for ES6 promises?\n\nOne fix would be to pass the `--noLib` compiler flag and manually specify the ES5-only `lib.es5.d.ts` file as a compilation input. That ensures you're not using any other ES6-only features.\n\nAlternatively, you could not include the ES6 polyfill .d.ts file in your ES6 build configuration.\n"
      },
      {
        "user": "niemyjski",
        "created_at": "2015-04-27T18:28:19Z",
        "body": "Yes, I need to use promises in es5 land and most people have them but I just wanted the definition file imported. But when my build targets es6 that definition already exists and hence the error. I need to conditionally exclude it based on my target. How would I do this from a tsconfig.json file?? This work around doesn't seem end user friendly / straightforward and would make build setups more complicated.\n\n\n---\n\nI have no option to not include it as I'm putting it in my references.d.ts file and every typescript file references that file and it's required for es5 or I get a ton of errors.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-04-27T18:47:20Z",
        "body": "Another option is to include a reference to the ES5 lib.d.ts file in your references.d.ts file. That way you have the same set of input files between both compilation targets.\n"
      },
      {
        "user": "niemyjski",
        "created_at": "2015-04-27T19:02:39Z",
        "body": "I don't want to do that because I want a fully targeted es6 build :(. \n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-04-27T19:09:40Z",
        "body": "I don't understand how that's possible at the same time as wanting an ES5 build from the same codebase. Can you give some examples of constructs you want to compile one way in ES5 and another way in ES6 that _doesn't_ work with any of the suggested fixes?\n"
      },
      {
        "user": "niemyjski",
        "created_at": "2015-04-27T19:26:23Z",
        "body": "I have one set of files written in typescript. I want to target es5 and es6. The reason for this is because my library needs to be self contained and references an external es6 js library. In this scenario my es5 build will polyfil things but my es6 build won't (much smaller). So with this said when my build targets es5 via tsconfig.json I get a million errors saying No such promise definition but es6 target works. When I add the es6 promise definition to my references.ts file es5 build succeeds but my es6 build fails with duplicate def.\n\n\n---\n\nI was assuming that since things are transpiled that I could have one target es6 and it would just use the es6 syntax but if I targeted es5 it would convert it to use the es5 compliant code. For example the of operator...\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-04-27T19:28:26Z",
        "body": "in your tsconfig for es5, include your promise .d.ts, in your tsconfig for es6 do not. would that work?\n"
      },
      {
        "user": "niemyjski",
        "created_at": "2015-04-27T19:50:04Z",
        "body": "That works!. Thank you.. Case of the mondays.\n\n\n---\n\nThis seems to work but broke other things like unit tests which haven't been updated to the new format.\n"
      }
    ],
    "satisfaction_conditions": [
      "Solution must allow conditional inclusion of ES6-Promise type definitions based on compilation target",
      "Configuration must support different TypeScript targets (ES5/ES6) without manual intervention during builds",
      "Must maintain compatibility with existing project references and type definitions",
      "Solution should avoid polyfill conflicts between ES5 and ES6 targets",
      "Configuration must be manageable through tsconfig.json files"
    ]
  },
  {
    "number": 2908,
    "title": "Suggestion: Add a special key that would disable resolving files that are missing in file list passed to the compiler",
    "created_at": "2015-04-24T14:06:07Z",
    "closed_at": "2015-04-24T17:12:44Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2908",
    "body": "Currently a compiler can be given one single file from where it can resolve all dependencies by looking at the file system. Most of the time it is a very convenient feature, but when I need to clearly separate one set of files from another I wish I could turn it off. So that unless a file is explicitly in the list passed to the compiler, I don't want it to be resolved.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2908/comments",
    "author": "zpdDG4gta8XKpMCd",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-04-24T16:36:44Z",
        "body": "use `--noResolve`.\n"
      },
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2015-04-24T17:12:48Z",
        "body": "Thanks!\n"
      }
    ],
    "satisfaction_conditions": [
      "Provides a way to disable automatic file resolution for dependencies not explicitly listed",
      "Ensures compiler only processes files explicitly provided in the input list",
      "Offers a toggleable option rather than permanent configuration"
    ]
  },
  {
    "number": 2844,
    "title": "Duplicate identifier error in Visual Studio 2015 CTP",
    "created_at": "2015-04-21T07:36:34Z",
    "closed_at": "2015-04-22T13:12:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2844",
    "body": "Hi\n\nI create the new \"typescript\" project.\nI generate the description file for the app.ts by `tsp --target es5 -d app.ts`\n\nI immediately receive the duplicate identifier error.\nI am not sure how to deal with this issue as I want to have both implementation and description files in my project.\n\nHere are the files `app.ts`\n\n``` javascript\nclass Greeter {\n    element: HTMLElement;\n    span: HTMLElement;\n    timerToken: number;\n\n    constructor(element: HTMLElement) {\n        this.element = element;\n        this.element.innerHTML += \"The time is: \";\n        this.span = document.createElement('span');\n        this.element.appendChild(this.span);\n        this.span.innerText = new Date().toUTCString();\n    }\n\n    start() {\n        this.timerToken = setInterval(() => this.span.innerHTML = new Date().toUTCString(), 500);\n    }\n\n    stop() {\n        clearTimeout(this.timerToken);\n    }\n\n}\n\nwindow.onload = () => {\n    var el = document.getElementById('content');\n    var greeter = new Greeter(el);\n    greeter.start();\n};\n```\n\nand `app.d.ts`\n\n``` javascript\ndeclare class Greeter {\n    element: HTMLElement;\n    span: HTMLElement;\n    timerToken: number;\n    constructor(element: HTMLElement);\n    start(): void;\n    stop(): void;\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2844/comments",
    "author": "tomitrescak",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-04-21T08:00:49Z",
        "body": "Do you mean that you're receiving duplicate identifier errors in VS when you have `app.ts` and `app.d.ts` (or another file that refers to `app.d.ts`) open at the same time?\n\nAlso could you be more specific with which duplicate identifier errors you're getting from underscore.d.ts?\n"
      },
      {
        "user": "tomitrescak",
        "created_at": "2015-04-21T11:47:19Z",
        "body": "I have both app.ts and app.d.ts in my project and I am receiving duplicate identifier error. Removing app.d.ts from the project seemed to help in a specific case.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-04-21T16:37:50Z",
        "body": "both app.ts and app.d.ts define the same objects. so you will get the duplicate identifier errors. you only need one of them, and not both. your .ts expresses API shape and implementation, where as your .d.ts expresses your API shape only. so if you are coding against it, you can use either, but not both.\n\nI usually think of .js + .d.ts together as package (e.g. a .net dll) that you use .js portion for execution, and .d.ts portion for typechecking. but both are outputs.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-04-21T23:19:59Z",
        "body": "@tomitrescak does this resolve your issues?\n"
      },
      {
        "user": "tomitrescak",
        "created_at": "2015-04-22T03:25:43Z",
        "body": "OK. The weird thing here is tha according to Typescript conventions I should always create d.t.s files and reserence them instead of the .ts files. This behaviour of Visual Studio makes this job a bit more difficult.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-04-22T04:14:12Z",
        "body": "If you have a group of files part of a common project, I don't see any reason you shouldn't just reference the `.ts` file. The `.d.ts` is more useful to an external consumer.\n\nIf you're familiar with C/C++, think of a `.d.ts` as a header file that describes the interface to a linked library, which is the `.js` file here.\n"
      },
      {
        "user": "tomitrescak",
        "created_at": "2015-04-22T13:12:59Z",
        "body": "Thanks for your help.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explains how to resolve duplicate identifier errors caused by having both .ts and .d.ts files in the same project",
      "Clarifies the intended relationship between .ts and .d.ts files in a project context",
      "Provides a strategy for API consumption without declaration/implementation conflicts"
    ]
  },
  {
    "number": 2755,
    "title": "error TS6050: Unable to open file 'tsconfig.json'.",
    "created_at": "2015-04-14T02:03:54Z",
    "closed_at": "2015-04-14T02:50:22Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2755",
    "body": "Why?\nI'm not giving reasons for this to happen:\n   1- Running on windows.\n   2- I've closed the tsconfig.json file.\n   2- The command is \"tsc\" under a folder that has the following tsconfig.json file:\n\n```\n{\n    \"files\": [\n        './js/**/*.ts',\n        './modules/**/*.ts'\n    ]\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2755/comments",
    "author": "ladaltamirano",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-04-14T02:44:03Z",
        "body": "tsc config doesn't support globbing, does removing that fix the error?\n"
      },
      {
        "user": "ladaltamirano",
        "created_at": "2015-04-14T02:50:22Z",
        "body": "Yeap...\nHey, at least modify the error message! I thought the issue had to do with what it communicated! But it didn't!...\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-04-14T02:51:48Z",
        "body": " #2627 is tracking showing the errors .\n"
      },
      {
        "user": "luzianz",
        "created_at": "2015-05-31T01:23:59Z",
        "body": "valid json uses **double** quotes, not single.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why glob patterns in tsconfig.json's 'files' array cause errors",
      "Clarification that the error relates to configuration validation rather than file presence",
      "Identification of unsupported tsconfig.json features in their TypeScript version"
    ]
  },
  {
    "number": 2609,
    "title": "Class decorator parameters",
    "created_at": "2015-04-03T19:57:28Z",
    "closed_at": "2015-04-08T22:57:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2609",
    "body": "I'm fairly sure I have the syntax right:\n\n``` javascript\n@ClassDecoratorTest(\"Test\")\nclass Test\n{\n}\n\nfunction ClassDecorationTest(target, name)\n{\n}\n```\n\nBut this won't compile. I get the following error on the @ClassDecorator line:\n\nerror TS2346: Supplied parameters do not match any signature of call target.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2609/comments",
    "author": "jamiewinder",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2015-04-05T18:52:57Z",
        "body": "This code works. It will log \"Test\" to the console.\n\n``` typescript\n@ClassDecoratorTest(\"Test\")\nclass Test {\n}\n\nfunction ClassDecoratorTest(str) {\n    return function (target): void {\n        target['d_value'] = str;\n        return target;\n    }\n}\n\nconsole.log(Test['d_value']);\n```\n\nWhen passing arguments you have to return a function with the correct format. `tsc` helps you with it, if you provide a wrong signature, it will tell you what you've done wrong.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explains how to structure a decorator function that accepts parameters",
      "Clarifies the required return type for parameterized decorators",
      "Addresses TypeScript's type checking requirements for decorators",
      "Demonstrates proper parameter passing to decorator factories"
    ]
  },
  {
    "number": 2492,
    "title": "tsconfig.json purpose?",
    "created_at": "2015-03-25T19:00:57Z",
    "closed_at": "2015-03-25T19:28:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2492",
    "body": "Question: tsconfig.json appears to be a reasonable way to specify a compilation context. Why isn't it available from the command line? ( tsc -c tsconfig.json ). I would like to be able to use tsconfig.json within a build system ( gulp based ) rather than it be a build system.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2492/comments",
    "author": "ToddThomson",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-03-25T19:19:51Z",
        "body": "On the command line you can run:\n\n> tsc -p <Directory path of tsconfig.json>\n\nor just call tsc with no file arguments in a directory with tsconfig.json in it\n\n> tsc\n\nyou can configure your build systems to call tsc with -p. @ivogabe might be able to help you better here.\n"
      },
      {
        "user": "ToddThomson",
        "created_at": "2015-03-25T19:28:46Z",
        "body": "Thank-you.\nAnd thank-you to the team!\n"
      }
    ],
    "satisfaction_conditions": [
      "Explains how to reference `tsconfig.json` via command-line parameters compatible with build systems like Gulp",
      "Clarifies that TypeScript's configuration can be used programmatically without being a build system itself",
      "Demonstrates compatibility with automation workflows"
    ]
  },
  {
    "number": 2490,
    "title": "Question: top-level interface and ES6 \"export default AssignmentExpression\"",
    "created_at": "2015-03-25T15:57:50Z",
    "closed_at": "2015-03-26T09:21:03Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2490",
    "body": "I see that this works in compiler built from recent sources:\n\n```\nexport default A;\ninterface A {}\n```\n\nAccording to the ES6 specification, after \"export default\" we only have three options:\n1) class declaration\n2) hoistable declaration (i.e., function or generator declaration)\n3) AssignmentExpression\n\nIf we treat \"A\" from my example as an AssignmentExpression, then it should work exactly the same way as AssignmentExpression in any other place, e.g. \"var x = A\".\n\nFor \"var x = A\" we reasonably have  'Cannot find name A'.\nBut in my example above, 'A' is resolved.\n\nIt means, that after 'export default' we have something different from an ordinary AssignmentExpression.\n\nAre there some special rules for what can appear after export default in the statement?\nDoes it have a special meaning in case of \"export default Identifier\"?\nThanks!\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2490/comments",
    "author": "zhuravlikjb",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-03-25T17:25:22Z",
        "body": "Note: there are some additional changes to how export default and export = work that is not in master now. see #2460 for more details.\n\nIn the current implementation `export default Identifier` indicates exporting all meanings of the Identifier (value, type and namespace), that is the same behavior in `export = Identifier`.\n\nAt compile time the compiler will elide exports that do not have a value, and in the given example, interface A, the export default statement, and any imports to the default binding in other modules will not be written to your .js output.\n"
      },
      {
        "user": "zhuravlikjb",
        "created_at": "2015-03-26T09:10:25Z",
        "body": "Thanks a lot, now it's clear for me, and I see that #2460 is merged into master, so I'll see and try the new changes. You may close this question, thanks.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explains TypeScript's special handling of 'export default Identifier' compared to standard ES6 AssignmentExpression rules",
      "Clarifies how TypeScript handles value/type/namespace meanings in default exports",
      "Addresses compilation behavior differences between interface exports and value exports",
      "Differentiates between TypeScript's export default rules and ES6 specification requirements"
    ]
  },
  {
    "number": 2420,
    "title": "Unsupported file encoding",
    "created_at": "2015-03-19T00:46:40Z",
    "closed_at": "2015-03-19T00:53:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2420",
    "body": "Hi, i have a typescript file which provide string translations for Italian in my solution, when i compile the solution, i got follow compile errors:\n\nSeverity    Code    Description Project File    Line\nError       Build: Cannot read file 'D:/workdir/devunits/song_cordova20150227_dev/src/cordova/scripts/app/I18N/it-IT/Strings.ts': Unsupported file encoding.\n\nEnv and Tools i used:\nVS2015 CTP5 (incl. TS 1.4), Cordova project.\n\nHere is the content of cordova/scripts/app/I18N/it-IT/Strings.ts: \n\n\"use strict\";\nexport var Strings = {\n    MsgMarkUpShareFailed: \"Impossibile condividere i markup in OneNote\",\n    Erase: \"Cancella\",\n    TextForSelectJTFolder: \"Selezionare la cartella JT suddivisa\",\n    Error_Printing: \"Errore durante la stampa del modello\",\n    SharedFileNotFoundExceptionMessage: \"Impossibile trovare il file richiesto in OneDrive. Verificare con gli utenti che condividono il file che siano state accordate le necessarie autorizzazioni.\",\n    Property_LastAuthor: \"Ultimo autore\",\n    OpenInJT2Go: \"Apri in JT2Go\",\n    ShowPMI: \"Mostra PMI\",\n    Share: \"Condividi\",\n    MsgBedDepth: \"La  profondit\u00e0 deve essere maggiore di 0.\",\n    Cancel: \"Annulla\",\n    Error_NonPositiveVolume: \"Stampa interrotta. Il modello non ha un volume positivo\",\n    Dimensions: \"Quote\",\n    DrillUp: \"Drill up\",\n    MsgBedHeight: \"L'altezza deve essere maggiore di 0.\",\n    Property: \"Propriet\u00e0\",\n    Note: \"Nota\",\n    MsgPLMXMLWasModified: \"Il markup \u00e8 stato modificato e deve essere salvato. Salvarlo ora?\",\n    Loading: \"Caricamento\",\n    Created: \"creato\",\n    Property_Parts: \"Parti\",\n    OrientTo: \"Orienta verso\",\n    DrillDown: \"Drill down\",\n    Section: \"Sezione: \",\n    Samples: \"Campioni\",\n    Print: \"Stampa\",\n    Property_ProjectName: \"Nome progetto\",\n    AlignToView: \"Allinea a vista\",\n    TakeImage: \"Scegli immagine\",\n    ToLast: \"Vai all'ultimo\",\n    Property_Density: \"Densit\u00e0\",\n    DFS: \"Simboli feature Datum\",\n    Default: \"Predefinita\",\n    MsgPLMXMLNotMatchJTError: \"Questo file plmxml non corrisponde al file jt attualmente aperto. Selezionare il file corretto e riportare.\",\n    MsgFailedCreateHomePage: \"Errore durante la creazione della pagina iniziale.\",\n    Snapshot: \"Istantanea\",\n    BedHeight: \"Altezza (mm)\",\n    PinToStart: \"Aggancia all'avvio\",\n    Property_Unit: \"Unit\u00e0\",\n    PrintBedDepth: \"Profondit\u00e0\",\n    SelectionColor: \"Finestra dei colori\",\n    Home: \"Pagina iniziale\",\n    Pan: \"Sposta\",\n    Text: \"Caricatore di testo\",\n    Property_DocumentNumber: \"Nr. documento\",\n    MsgBedWidth: \"Lo spessore deve essere maggiore di 0.\",\n    TextForSelectJT: \"Selezionare un file JT\",\n    Properties: \"Propriet\u00e0\",\n    DefaultMarkupItemDescription: \"Commenti senza titolo\",\n    Property_TranslationDate: \"Data conversione\",\n    FinishPrinting: \"Dati inviati alla stampante 3D\",\n    FCF: \"Fotogrammi controllo feature\",\n    Error_InvalidModel: \"Stampa interrotta. Il modello non \u00e8 definito correttamente\",\n    Property_Company: \"Azienda\",\n    General: \"Generale\",\n    PMIFilters: \"Filtri PMI\",\n    MeasurementPoints: \"Punti di misurazione\",\n    Save: \"Salva\",\n    Open: \"Apri\",\n    ChooseImage: \"Scegli immagine\",\n    Property_NameOfSavingApplication: \"Nome dell'applicazione da salvare\",\n    BedWidth: \"Larghezza (mm)\",\n    Other: \"Altro\",\n    OneDriveLoadMarkupExceptionMessage: \"Errore durante l'apertura del markup da OneDrive\",\n    SettingLanguage: \"Lingua\",\n    DatumTargets: \"Destinazioni datum\",\n    SpotWelds: \"Punti di unione\",\n    StartPrinting: \"Stampa iniziata. L'operazione potrebbe richiedere alcuni minuti\",\n    HidePMI: \"Nascondi PMI\",\n    ShareToOneNote: \"Condividi in OneNote\",\n    Accept: \"Accetta\",\n    Less: \"Meno\",\n    More: \"Altro\",\n    Property_CADSource: \"Origine CAD\",\n    PMIPanelState: \"Selezionare i tipi PMI da visualizzare\",\n    SelectAll: \"Seleziona tutto\",\n    MsgGreaterThan: \"{0} deve essere maggiore di 0.\",\n    ToggleCamera: \"Attiva/Disattiva  videocamera\",\n    CollapseBar: \"Comprimi barra\",\n    Normal: \"Normale\",\n    DeleteView: \"Elimina vista\",\n    Error_NonManifold: \"Stampa interrotta. Il modello non \u00e8 impermeabile\",\n    OneDriveAuthenticationExceptionMessage: \"Errore durante il caricamento del file richiesto perch\u00e9 le credenziali di autenticazione presentano un'anomalia per quanto riguarda la connessione a OneDrive.\",\n    LanguageTag: \"it-IT\",\n    Property_LastSaveDate: \"Data ultimo salvataggio\",\n    Property_TriangleCount: \"Numero di triangoli\",\n    AppDescription: \"Un'applicazione di rendering 3D per la visualizzazione di file di formato JT.\",\n    View: \"Vista\",\n    Property_Keywords: \"Parole chiave\",\n    LoadFile: \"Carica\",\n    EditDescription: \"Modifica descrizione\",\n    ShowAllPMI: \"Mostra tutte le informazioni PMI\",\n    BedDepth: \"Spessore (mm)\",\n    Delete: \"Elimina\",\n    Property_ApplicationName: \"Nome applicazione\",\n    FullScreen: \"Schermo intero\",\n    Error_LoadPart: \"Impossibile aprire il file JT specificato\",\n    ModelView: \"Vista modello\",\n    Fit: \"Adatta\",\n    SharingStatus: \"Condivisione\",\n    LoadingStatus: \"Caricamento\",\n    RestoreDefaults: \"Ripristina i default\",\n    ExceedPrintableAreaMessage: \"Il modello supera l'area stampabile\",\n    HideAllPMI: \"Nascondi tutte le informazioni PMI\",\n    Recent: \"Recente\",\n    TextForSelectImage: \"Seleziona un file di immagine\",\n    Error: \"Errore\",\n    Property_Geometry: \"Geometria\",\n    Locators: \"Localizzatori\",\n    OneDriveLoginExceptionMessage: \"Impossibile eseguire l'accesso a OneDrive\",\n    Property_Comments: \"Commenti\",\n    Property_Category: \"Categoria\",\n    Property_Attribute: \"Attributo\",\n    Settings: \"Impostazioni\",\n    Spin: \"Rotazione\",\n    Hide: \"Nascondi\",\n    Freehand: \"A mano libera\",\n    PrintBedWidth: \"Larghezza\",\n    Attribute: \"Attributo\",\n    Property_TranslatorVersion: \"Versione convertitore\",\n    Reset: \"Ripristina\",\n    Options: \"Opzioni\",\n    Surface: \"Superficie\",\n    BackgroundColor: \"Colore sfondo\",\n    ViewType: \"Visualizza tipo\",\n    Property_VertexCount: \"Numero di vertici\",\n    LoadFileExceptionMessage: \"Si \u00e8 verificato un errore durante il caricamento del file.\",\n    Status_Pinned_Success: \"JT2Go \u00e8 agganciato allo schermo iniziale\",\n    Property_Length: \"Lunghezza\",\n    FontFamily: \"Segoe UI\",\n    Property_Subject: \"Oggetto\",\n    PMIColor: \"Colore PMI\",\n    PartLoaderExceptionMessage: \"Si \u00e8 verificato un errore durante il caricamento del file JT specificato.\",\n    Property_Author: \"Autore\",\n    MsgMarkUpShareSuccessed: \"Markup condivisi correttamente in OneNote\",\n    ClearAll: \"Cancella tutto\",\n    Property_OriginationDate: \"Data di origine\",\n    OneDriveConnectionExceptionMessage: \"Errore durante il caricamento del file richiesto causato dalla connessione OneDrive.\",\n    MsgExpectedNumber: \"{0} deve essere un numero.\",\n    Part: \"Parte\",\n    Status_Pinned_Failure: \"Errore durante l'aggancio di JT2GO alla schermata iniziale\",\n    LiveCamera: \"Videocamera live\",\n    Legal: \"Legale\",\n    Property_Name: \"Nome\",\n    Property_Width: \"Larghezza\",\n    Discard: \"Elimina\",\n    Decline: \"Calo\",\n    MsgFailedCreateLicensePage: \"Errore durante la creazione della pagina di licenze.\",\n    Geometry: \"Geometria\",\n    ShowAllParts: \"Mostra tutte le parti\",\n    Property_Material: \"Materiale\",\n    ToFirst: \"Vai al primo\",\n    ShatteredFolderIncorrectExceptionMessage: \"Si \u00e8 verificato un problema durante il caricamento della cartella suddivisa. Verificare di aver selezionato la cartella esatta.\",\n    PrivacyPolicy: \"Criteri sulla privacy\",\n    PrintBedHeight: \"Altezza\",\n    Property_Title: \"Titolo\",\n    WaitingStatus: \"Attesa\",\n    Background: \"Sfondo\",\n    CoordinateSystems: \"Sistemi di coordinate\",\n    Property_Height: \"Altezza\",\n    Structure: \"Struttura\",\n    DefaultMarkupItemDescriptionWithUserName: \"Commenti di {0}\",\n    Default3DPrinter: \"Stampante 3D predefinita\",\n    Help: \"Guida\"\n}\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2420/comments",
    "author": "franksoong",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-03-19T00:49:02Z",
        "body": "The compiler does not support ANSI encoding, which i am guessing the encoding for this file. so you need to save the file in Unicode, to do that, in VS go to file\\Advanced Save Options, select \"Unicode (UTF-8 with Signature)\" and hit ok. save your file and try again.\n"
      },
      {
        "user": "franksoong",
        "created_at": "2015-03-19T00:53:35Z",
        "body": "this fix my issue, much thanks for the tips!!\n"
      }
    ],
    "satisfaction_conditions": [
      "Solution must resolve file encoding incompatibility with TypeScript compiler",
      "Method to convert file to compiler-supported encoding format",
      "Preserve special characters in Italian translations",
      "Compatibility with VS2015/TypeScript 1.4 toolchain"
    ]
  },
  {
    "number": 2373,
    "title": "Passthrough require(\"jsfile\") for commonjs",
    "created_at": "2015-03-16T16:53:03Z",
    "closed_at": "2015-03-16T22:01:36Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2373",
    "body": "Hello Typescipters,\n\nI'm using the `Q` library with its typings installed via `tsd`.\nIn a module I'm using\n\n``` typescript\n/// <reference path=\"../typings/q/Q.d.ts\"/>\n// ...\n```\n\ncompiled with\n\n``` bash\ntsc -m commonjs --out test.js test.ts\ntsc --version\nmessage TS6029: Version 1.4.1.0\n```\n\nand would like `test.js` to contain a line like\n\n``` javascript\nvar Q = require(\"path/to/q\"); // to be executed by nodejs\n```\n\nwhere `path/to/q` points to the javascript file and has nothing to do with `../typings/q/Q.d.ts`.\nUsing `import Q = require(\"path/to/q\");` won't work as it probably expects a typescript module.\n\n``` bash\nbuilder.ts(5,32): error TS2307: Cannot find external module './../bower_components/q/q'.\n```\n\nI haven't found how to achieve this without rolling out some hackish _ad-hoc_ source markup/parse/replace. Have I overlooked something?\n\nIn a way I'm trying to \"link\" to the library code (in the C meaning) with node's `require` after having included the declarations (references to the `d.ts`).\n\nIf this is not currently possible, may I suggest a pass-through version of `require()` which kicks in when `-m commonjs` is used? Perhaps `js_require(\"blabla\")` which would be emitted as node's `require(\"blabla\")`. This would make it a lot easier to leverage other tools which analyze `require` statements.\n\nGreetings\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2373/comments",
    "author": "dbarbeau",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-03-16T17:29:13Z",
        "body": "> Using `import Q = require(\"path/to/q\");` won't work as it probably expects a typescript module.\n\nThe `import` keyword with a `require(...)` on the RHS works the same way as if you'd used a `var` except that it also brings in type information at compile time. What you can do in `test.js` is include both the `/// <reference path=\"../typings/q/Q.d.ts\"/>` and then `import Q = require(\"path/to/q\");`. Give it a try and let us know. If not, maybe there's some information I'm missing.\n"
      },
      {
        "user": "dbarbeau",
        "created_at": "2015-03-16T18:44:34Z",
        "body": "Hi! And thanks!\nI think you meant using `var` instead of `import`, because\n\n``` typescript\n/// <reference path='typings/q/Q.d.ts'/>\nimport q = require(\"bower_components/q/q\");\nvar deferred = Q.Promise(function(a,b,c){});\n```\n\nthrows `error TS2307: Cannot find external module 'bower_components/q/q'` and no code is generated (the output file is blank) while\n\n``` typescript\n/// <reference path='typings/q/Q.d.ts'/>\nvar q = require(\"bower_components/q/q\");\nvar deferred = Q.Promise(function(a,b,c){});\n```\n\nthrows `error TS2304: Cannot find name 'require'` and... the compiler does output the code I want :)\nSo it does work, though user feedback is a bit misleading!\n\n**EDIT:** To remove the TS2304 error, I had to add a reference tag to `node.d.ts`. Changing `import` to `var` has some consequences!\n\nThanks again ;)\n\n\n---\n\nI should have done a few more tests, because there is a catch:\n\n``` typescript\n/// <reference path=\"typings/node/node.d.ts\"/>\n/// <reference path=\"typings/q/Q.d.ts\"/>\n\nvar Q            = require(\"./../bower_components/q/q\");   /* LINE X */\nimport path   = require(\"path\"); /* LINE Y */\n\nvar qprom = Q.Promise(function(a,b,c){\n    var dummy = path.join(__dirname, \"yo\");  /* LINE Z */\n});\n```\n\nThe reference tag will declare Q with the type information.\n**LINE X** will declare another Q.\n\nIf you compile it like this, tsc 1.4.1.0 will emit no error, but also no code :)\nRemove **LINE Y** and **LINE Z** and you'll get.\n\n``` bash\nrequiretest2.ts(4,5): error TS2300: Duplicate identifier 'Q'.\ntypings/q/Q.d.ts(10,18): error TS2300: Duplicate identifier 'Q'.\ntypings/q/Q.d.ts(14,18): error TS2300: Duplicate identifier 'Q'.\ntypings/q/Q.d.ts(16,16): error TS2300: Duplicate identifier 'Q'.\n```\n\nSeems reasonable enough, although the compiler does emit the code I want. \n\nNow, suppose that TS2300 didn't emit code (or that I simply want to avoid having errors in my code). I'd have to write my typescript code against the Q declared in the 'Q.d.ts' file, but this would conflict with the Q created on the `require(...)` line. So, I'd have to write `var smallq = require(...);` instead of **LINE X**, but then at runtime nodejs would complain that `Q` doesn't exist. Or I write against `smallq` and lose the benefit of types.\n\nI'm in a deadlock :)\n"
      },
      {
        "user": "danquirk",
        "created_at": "2015-03-16T20:13:13Z",
        "body": "You absolutely want to use `import` and not `var`. Without `import` there is no type information associated with the `Q` you declared. You also just want to require the name as `'q'` and not the relative path. The last 3 lines of Q.d.ts are written to enable this pattern, similar to why you can require `\"path\"` like that from node.d.ts. This is how it should look:\n\n``` ts\n/// <reference path=\"Q.d.ts\"/>\nimport Q = require('q');\n\nvar aprom = Q.Promise((a,b,c) => {\n    console.log('hi');\n});\n```\n\nemits:\n\n```\n> tsc a.ts -m commonjs\n> type a.js\n/// <reference path=\"Q.d.ts\"/>\nvar Q = require('q');\nvar aprom = Q.Promise(function (a, b, c) {\n    console.log('hi');\n});\n```\n"
      },
      {
        "user": "dbarbeau",
        "created_at": "2015-03-16T22:01:36Z",
        "body": "Thank you @DanielRosenwasser and @danquirk  for the clear instructions, I wasn't going the right way. Now, I just had one issue in that compiling that exact file (`a.ts`) with:\n\n``` bash\ntsc a.ts -m commonjs --out a.js\n```\n\n(notice the --out flag) produced an empty `a.js`, whereas just omitting the `--out a.js` flag worked. I'm a bit confused, I'll need to check my installation, there's something fishy. Regarding the initial question I think it has been answered so this issue is closed.\n\n### LAST MINUTE OMG\n\nThe `--out` doesn't do what I expected it to do!\n\n``` bash\n> rm *.js\n> tsc a.ts -m commonjs --out ahaha.js\n> ls -l\ntotal 8\n-rw-rw-r--. 1 d d 136 16 mars  22:51 a.js\n-rw-rw-r--. 1 d d 131 16 mars  22:40 a.ts\n-rw-rw-r--. 1 d d   0 16 mars  22:51 ahaha.js\n```\n\nI was NOT expecting `a.js`, I thought the output would just end up in `ahaha.js`. So by specifiying that flag, I was overwriting tsc's output with a blank file. But why is it blank?\nI'll need to check my basic assumptions of life (like does `gcc -o` behave like this?)... wow!\n\nThanks again!\nDaniel\n"
      },
      {
        "user": "danquirk",
        "created_at": "2015-03-16T23:02:46Z",
        "body": "You generally don't want to use --out with external modules like you have. The target file for --out only gets whatever is in the global namespace. This is good when you're concatenating multiple internal modules together but it doesn't support concatenating multiple files together into a single external module. So most of the time you'll get 1 js file per ts file and an empty file that you asked --out for. We have an issue logged somewhere around here to consider just making it an error if --out creates an empty file since other people also get confused by this behavior .\n"
      }
    ],
    "satisfaction_conditions": [
      "Solution must allow using external JS libraries with their typings without causing identifier conflicts",
      "Must preserve type information while generating correct CommonJS require statements",
      "Should explain proper module resolution strategy for external dependencies",
      "Must clarify when to use/avoid --out flag with external modules",
      "Should prevent type declaration conflicts between .d.ts files and runtime imports",
      "Must enable using TypeScript's type system with existing CommonJS module patterns"
    ]
  },
  {
    "number": 2189,
    "title": "Tuple type vs. array-of-union-type",
    "created_at": "2015-03-03T08:19:15Z",
    "closed_at": "2015-03-03T09:24:25Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2189",
    "body": "Have I made a silly mistake here? I thought the tuple type `[string, number]` was roughly equivalent to the array-of-union-type `(string | number)[]`, and that the following was therefore legal:\n\n```\nfunction lengths (xs: string[]): [string, number][] {\n   return xs.map((x: string) => [x, x.length])\n}\n```\n\nHowever tsc 1.4 complains:\n\n```\nConfig.ts(127,11): error TS2322: Type '(string | number)[][]' is not assignable to type '[string, number][]'.      Type '(string | number)[]' is not assignable to type '[string, number]'.\n    Property '0' is missing in type '(string | number)[]'.\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2189/comments",
    "author": "rolyp",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-03-03T08:46:10Z",
        "body": "I _believe_ (and others on the team should feel free to correct me) that this has to do with the way in which contextual typing takes effect (i.e. it _doesn't_ take effect on the return type of a call\u00a0expression).\n\nIn other words, `lengths`'s return type doesn't impact your call's type, and so the language computes the type `(string | number)[]`.\n\nYou can get the behavior you want by giving your lambda a return type.\n\n``` TypeScript\nfunction lengths(xs: string[]): [string, number][] {\n    return xs.map((x): [string, number] => [x, x.length]);\n}\n```\n"
      },
      {
        "user": "rolyp",
        "created_at": "2015-03-03T09:13:53Z",
        "body": "Ah, interesting. Thanks.\n\nAs an aside, I've become wary of adding types to lambdas: at least, adding parameter types seems to be broken (code which didn't type-check when the parameter type annotation was omitted type-checks fine with a suitable annotation, and then fails at runtime). I'll probably post an example at some point. It looks like the inferred type isn't being checked against the annotation, so the annotation is behaving like a cast.\n\nBut here you're talking about adding a return type, which is certainly an improvement on my current workaround (which involves any `<any>` cast). Cheers.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-03-03T09:24:25Z",
        "body": "Glad this helps, though, we'd definitely like to see an example where you run into the situation you mentioned if you can reproduce it.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explains why TypeScript doesn't infer tuple types in array mapping operations",
      "Demonstrates how to enforce tuple type preservation in array transformations",
      "Clarifies the relationship between contextual typing and method chaining",
      "Addresses type annotation validation concerns"
    ]
  },
  {
    "number": 2149,
    "title": "Define variable to match declared variable with 'new'",
    "created_at": "2015-02-26T10:24:05Z",
    "closed_at": "2015-02-26T14:31:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2149",
    "body": "It is possible to define variable with declared when the function name is not 'new'\n\n``` typescript\ninterface X {\n}\ndeclare var X: {\n    f(): X;\n}\n\n// OK, compatible type\nvar X = {\n    f() { return <X>null; }\n};\n\n\ninterface Y {\n}\ndeclare var Y: {\n    new(): Y;\n}\n\n// Not compatible types\n// new() : Y vs. new() => Y\nvar Y = {\n    new() { return <Y>null; }\n};\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2149/comments",
    "author": "NN---",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2015-02-26T14:31:12Z",
        "body": "Yes, you can do that by putting the property name in quotes in the declaration:\n\n``` typescript\ninterface Y {\n}\ndeclare var Y: {\n    \"new\"(): Y;  // Quotes to indicate this is not a construct signature\n}\n\n// OK, compatible type\nvar Y = {\n    new() { return <Y>null; }\n};\n```\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-02-26T18:40:19Z",
        "body": "Oh, I didn't knew about quotes syntax.\nActually it is logical since identifier can be quoted, but most people don't do it.\n\nFound it in the spec.\n\nTS spec:\n\n```\nMethod Signature:\n  PropertyName ?opt CallSignature\n```\n\nES spec:\n\n```\nPropertyName :\n  IdentifierName\n  StringLiteral\n  NumericLiteral\n```\n\nIt would be nice to mention 'new' case in the spec or in Q&A page.\nThanks.\n\n\n---\n\n@ahejlsberg The only problem is that I cannot change the declaration :)\nIt is in lib.d.ts\nI am trying to define variable of Blob:\n\n``` typescript\ninterface Blob {\n    type: string;\n    size: number;\n    msDetachStream(): any;\n    slice(start?: number, end?: number, contentType?: string): Blob;\n    msClose(): void;\n}\ndeclare var Blob: {\n    prototype: Blob;\n    new (blobParts?: any[], options?: BlobPropertyBag): Blob;\n}\n```\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2015-02-26T19:12:47Z",
        "body": "Not quite sure what you mean by \"trying to define variable of Blob\". Do you mean define a value that can be assigned to Blob? The Blob variable represents a constructor function (i.e. it is a variable of a constructor function type). To produce an assignment compatible value, you'll likely want to declare a class. For example:\n\n``` typescript\nclass MyBlob implements Blob {\n    type: string;\n    size: number;\n    constructor(blobParts?: any[], options?: BlobPropertyBag) {\n    }\n    msDetachStream(): any {\n        return undefined;\n    }\n    slice(start?: number, end?: number, contentType?: string): Blob {\n        return undefined;\n    }\n    msClose(): void {\n    }\n}\n```\n\nYou can then assign the class constructor function to the `Blob` variable:\n\n``` typescript\nBlob = MyBlob;\n```\n\nNote, it is important to understand that there are two distinct and different things called Blob: A type (produced by the interface declaration) and a variable (with an _unnamed_ constructor function type whose return value is the Blob interface). In type positions, Blob refers to the interface type, and in value positions (such as expressions) Blob refers to the constructor function.\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-02-26T19:18:17Z",
        "body": "I want to define the variable that is declared by 'declare var Blob : { ... }' .\n\n``` typescript\nvar Blob = {  \n // prototype and the constructor\n};\n```\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2015-02-26T20:03:02Z",
        "body": "You can't do that with an object literal because an object literal isn't \"callable\", i.e. it can't have a call or construct signature. Instead you need to write\n\n``` typescript\nvar Blob = MyBlob;\n```\n\nwhere `MyBlob` is a constructor function name introduced by a suitable class declaration (like my example above). Or you can assign some suitable constructor function object typed as `any` that you know has the correct shape.\n\nIt's important to understand that\n\n``` typescript\ndeclare var Blob: {\n    prototype: Blob;\n    new (blobParts?: any[], options?: BlobPropertyBag): Blob;\n}\n```\n\ndoesn't introduce a property named \"new\", but rather introduces a construct signature that defines how to call the constructor function using the `new` operator, as in\n\n```\nvar x = new Blob(...);\n```\n\nSo, basically the declaration says that `Blob` is a variable of a constructor function type that (a) has a property named `prototype` and (b) can be called using `new` with the specified parameters.\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-02-26T21:04:04Z",
        "body": "Unfortunately this doesn't work.\nIt works with explicit cast, is it a bug ?\n\n``` typescript\ninterface QQ {\n}\n\ndeclare var QQ:{\n    new(): QQ;\n}\n\nclass QQImpl {\n    constructor() {}\n}\n\nvar QQ = QQImpl; // Doesn't work \n\n// But works with explicit cast !\nvar QQ = <{new():QQ;}> QQImpl;\n```\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2015-02-26T21:14:35Z",
        "body": "You're getting an error because your `var QQ = QQImpl;` statement redeclares `QQ` with a (slightly) different type. The following works:\n\n``` typescript\ninterface QQ {\n}\n\ndeclare var QQ:{\n    prototype: QQ; // Include prototype property to make type identical to class\n    new(): QQ;\n}\n\nclass QQImpl {\n    constructor() {}\n}\n\nvar QQ = QQImpl; // Ok, types of QQ and QQImpl identical\n```\n\nAs does this:\n\n``` typescript\ninterface QQ {\n}\n\ndeclare var QQ:{\n    new(): QQ;\n}\n\nclass QQImpl {\n    constructor() {}\n}\n\nQQ = QQImpl; // Assignment, not redeclaration\n```\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-02-26T21:20:08Z",
        "body": "The first sample doesn't work since the QQImpl doesn't have prototype property and types are incompatible.\nThe second one is not what I need because it produces the following JS.\nIt will fail in strict parsing mode if nobody defined QQ before.\n\n``` javascript\nvar QQImpl = (function () {\n    function QQImpl() {\n    }\n    return QQImpl;\n})();\nQQ = QQImpl; // Assignment, not redeclaration\n```\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2015-02-26T21:41:29Z",
        "body": "It works in master, but apparently not with 1.3 or earlier.\n\nI'm still not sure what you're trying to accomplish so it's hard to make further suggestions. If all you care about is declaring a class QQ that has the same shape as the interface/var QQ, then you can simply do this:\n\n``` typescript\nclass QQ {\n}\n```\n\nThis introduces **_both**_ an interface QQ and a \"variable\" QQ (the constructor function) and in use you'll see the same effect as if you had declared the separate interface and variable.\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-02-27T18:58:16Z",
        "body": "Ok, the situation is the following.\nI am using ES5 and browser specific features but some of them don't exist in other environments like nodejs or other browsers.\nNow I want to define a variable and make everything works without getting RefereneError.\nI can access to all variables through 'window' object and then it is possible to check and assign easily:\n\n``` typescript\nif (window.Blob) {\n   // Use window.Blob\n}\n```\n\nBut I don't want to change my code, moreover some definition libraries do not define global variables both globally and in window, so it means that I must rewrite definitions.\n\nI can add pure JS file that does the simple thing: \"function Blob() {}\" and that's all I need.\nI wanted to solve it using TypeScript language.\nSince I have typing and all interfaces defined I won't make a mistake in defining variables or types.\n\nI hope it is clear now.\nThanks.\n\n\n---\n\nFound it ! :)\nYour code is totally correct but I was missing the 'var' part and it works as expected when I add it.\nThe only change is that I must specify the exact type of the declared variable.\nI would like to see whether it can be inferred somehow there. \n\n``` typescript\nclass MyBlob implements Blob {\n    constructor(blobParts?: any[], options?: BlobPropertyBag) { }\n    msDetachStream(): any {}\n    slice(start?: number, end?: number, contentType?: string): Blob { throw new Error(\"Not implemented\"); }\n    msClose(): void {}\n    type: string;\n    size: number;\n}\nvar Blob: {\n    prototype: Blob;\n    new(blobParts?: any[], options?: BlobPropertyBag): Blob;\n} = MyBlob;\n```\n"
      }
    ],
    "satisfaction_conditions": [
      "Solution must allow assigning a value to a declared variable with constructor signature (new()) without type incompatibility",
      "Approach must work with existing declarations in lib.d.ts that cannot be modified",
      "Must support environment-specific implementations without causing ReferenceErrors",
      "Solution should maintain type system integrity for constructor functions",
      "Method should avoid explicit type casts when possible"
    ]
  },
  {
    "number": 2147,
    "title": "Question, how to make a variable within declared module name",
    "created_at": "2015-02-26T06:41:20Z",
    "closed_at": "2015-02-26T07:16:30Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2147",
    "body": "I am writing a test and I have an issue.\nThe test runner doesn't have the global object I need since it is running in a different environment.\nI want to create this object because strict mode complains otherwise, but TypeScript cannot do it.\n\nI have declaration:\n\n``` typescript\ndeclare module Q {\n    function f(): string;\n}\n```\n\nand usage\n\n``` typescript\nvar x = Q.f();\n```\n\nNow in my test I want to mock Q.f and create object of my own.\n\n``` typescript\nvar Q = { ... }\n```\n\nThe TypeScript complains about multiple declarations.\n\nThere is a workaround to access the module through the global 'window' object in the code and then it is possible to test it.\n\n``` typescript\ninterface Window {\n Q: QInterface;\n}\n\ninterface QInterface {\n    function f(): string;\n}\n\n// the code\nvar x = !!window.Q ? window.Q.f() : \"\";\n```\n\nI would like to not use the workaround and find some solution without changing my code.\nThanks.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2147/comments",
    "author": "NN---",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-02-26T06:45:13Z",
        "body": "It sounds like describing your module with an interface will solve your problem.\n\n``` TypeScript\ninterface Q {\n    f(): string;\n}\n\nvar Q = {\n    f() {\n        return \"Hello\";\n    }\n}\n\nvar x = Q.f();\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-02-26T06:53:02Z",
        "body": "how about;\n\n``` TypeScript\ndeclare var Q : {\n    f(): string;\n};\n```\n\nlater on in your tests:\n\n``` TypeScript\nvar Q = {\n    f() { .. }\n}\n```\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-02-26T07:02:50Z",
        "body": "@DanielRosenwasser I don't see how it solves it\n@mhegazy It means that I must rewrite all the definition files that don't use 'var' .\nSome of definitions files are in the following form:\n\n``` typescript\ndeclare module A.B {\n function f(): Interface;\n interface I {}\n}\ndeclare module A.C {\n function g(): Interface; // Yes the same name as A.B but different meaning of course.\n interface I {}\n}\n//2500 similar lines\n```\n\nIs there easy way to refactor it ?:)\n\n\n---\n\nIf I could use modules as types specifiers then it would be easy to refactor the code for 'var' .\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-02-26T07:03:28Z",
        "body": "The probelm is that a module and var do not really merge. the var will override the value of the module, so this is why it is flagged as an error.\n\nhow about this:\n\n``` TypeScript\n// declaration\ndeclare module M {\n    function f(): string;\n}\n\n\n// tests\nmodule M { \n    M.f = ()=> \"\";\n}\n```\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-02-26T07:13:41Z",
        "body": "@mhegazy Great idea ! :)\nDidn't think about just defining the module.\nThanks :)\n"
      }
    ],
    "satisfaction_conditions": [
      "Solution must allow mocking module functionality without causing declaration conflicts",
      "Must preserve existing module-based type definitions",
      "Avoid global object workarounds like window.Q",
      "Support module augmentation patterns",
      "Maintain TypeScript's namespace merging capabilities"
    ]
  },
  {
    "number": 2135,
    "title": "Import statement causes problem with external module ",
    "created_at": "2015-02-25T10:32:56Z",
    "closed_at": "2015-02-26T05:11:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2135",
    "body": "I'm trying to write a tool for `Typescript`. Though I got some problem:\n\nIn scanner.ts:\n\n``` typescript\n/// <reference path=\"../../typings/node/node.d.ts\" />\n/// <reference path=\"../../typings/typescript/typescript.d.ts\" />\n/// <reference path=\"types.ts\" />\n\nimport ts = require(\"typescript\");\n\nmodule pp {\n    var textToToken: Map<AnnotationSyntaxKind> = {\n        \"@\": AnnotationSyntaxKind.AtsignToken,\n        \"@if\": AnnotationSyntaxKind.IfKeyword,\n        \"@endif\": AnnotationSyntaxKind.EndIfKeyword,\n        \"@requires\": AnnotationSyntaxKind.RequiresKeyword\n    }\n}\n```\n\nIn types.ts:\n\n``` typescript\nmodule pp {\n    export interface Map<T> {\n        [index: string]: T;\n    }\n\n    export const enum AnnotationSyntaxKind {\n        AtsignToken,\n        IfKeyword,\n        EndIfKeyword,\n        RequiresKeyword\n    }\n}\n```\n\nThis setup will yield:\n\n```\nsrc/preprocessor/scanner.ts(8,22): error TS2314: Generic type 'Map<K, V>' requires 2 type argument(s).\nsrc/preprocessor/scanner.ts(9,14): error TS2304: Cannot find name 'AnnotationSyntaxKind'.\nsrc/preprocessor/scanner.ts(10,16): error TS2304: Cannot find name 'AnnotationSyntaxKind'.\nsrc/preprocessor/scanner.ts(11,19): error TS2304: Cannot find name 'AnnotationSyntaxKind'.\nsrc/preprocessor/scanner.ts(12,22): error TS2304: Cannot find name 'AnnotationSyntaxKind'.\n```\n\nBut when I remove this line of code in scanner.ts:\n\n``` typescript\nimport ts = require(\"typescript\");\n```\n\nEverything works fine.\n\nWhat have I done wrong?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2135/comments",
    "author": "tinganho",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-02-25T19:25:10Z",
        "body": "Adding an `import` like that to scanner makes it an external module. This means everything inside it is in a new scope and the things from internal modules in other files are no longer accessible. Generally you do not want to mix internal and external modules.\n"
      },
      {
        "user": "tinganho",
        "created_at": "2015-02-25T20:58:11Z",
        "body": "@danquirk how do I achieve what I want to achieve then?\n\nI want to re-use some of the values in typescript like the enum `ts.SyntaxKind` in `scanner.ts`\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-02-25T23:46:48Z",
        "body": "in your external module do not add module pp, and refer to Map as pp.Map.\n"
      },
      {
        "user": "tinganho",
        "created_at": "2015-02-26T05:11:18Z",
        "body": "@mhegazy thanks!\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-02-26T05:47:04Z",
        "body": "u r most welcome :) \n"
      }
    ],
    "satisfaction_conditions": [
      "Explains how to properly reference internal module members when using external modules",
      "Demonstrates correct module structure for accessing both TypeScript library types and custom types",
      "Avoids namespace collisions between internal and external modules",
      "Provides guidance on module declaration best practices in TypeScript"
    ]
  },
  {
    "number": 2067,
    "title": "--mapRoot doesn't seem to work",
    "created_at": "2015-02-18T22:21:10Z",
    "closed_at": "2015-02-28T11:13:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2067",
    "body": "`tsc --sourceMap --mapRoot maproot/ --out a.js t.ts`\n\nIt simply places the .js.map files in the same directory as the --out file.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2067/comments",
    "author": "danihodovic",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-02-26T07:00:24Z",
        "body": "maproot does not place the files in a different place, it just controls the reference to the map file in the .js file. the assumption here is that you will move the map files to a different location, possibly a local directory, where as the other .js files are on your server, or a different server, etc.. it just tells the debugger where to look for the map files instead of next to the .js files.\n"
      },
      {
        "user": "danihodovic",
        "created_at": "2015-02-27T11:28:52Z",
        "body": "So the maproot command is there for the debugger to locate the map files, not for moving them anywhere? \n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-02-27T18:33:18Z",
        "body": "correct. if you look at the javascript output, last line of your file, you will find the reference to the map file. this is what maproot controls. e.g.:\n\n``` TypeScript\n//# sourceMappingURL=rooot\\t1.js.map\n```\n"
      },
      {
        "user": "danihodovic",
        "created_at": "2015-02-28T11:13:44Z",
        "body": "I see. Thanks! Closing.\n"
      }
    ],
    "satisfaction_conditions": [
      "Clarifies the purpose of --mapRoot in controlling source map references rather than file placement",
      "Explains how source map URLs are generated relative to the debugger's expected path structure",
      "Differentiates between file system paths and debugger-accessible URL paths"
    ]
  },
  {
    "number": 1877,
    "title": "Different rules for function parameter compatibility when assignment is on a different line to variable declaration.",
    "created_at": "2015-01-31T19:06:04Z",
    "closed_at": "2015-01-31T19:21:58Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1877",
    "body": "A function can choose to omit parameters defined in a signature, as shown by function `a` below. Callers of `a` must still supply arguments, but the function does not need to use them.\n\nDespite this, if the same function is assigned later in the program, this no longer applies and the identical function is now not compatible, as shown with function `b`.\n\n``` typescript\ninterface X {\n    (source: number): boolean;\n}\n\nvar a: X = function() { return true; }\n\nvar b: X;\n// Why is this an error?\nvar b = function() { return true; }\n```\n\nShouldn't both of these cases follow the same rules?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1877/comments",
    "author": "Steve-Fenton",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-01-31T19:21:58Z",
        "body": "This is an error because duplicate definitions of the same variable must have the _exact_ same type. This includes cases where the type of the variable is inferred from its initializer.\n\nIt's similar to if you had written\n\n``` ts\nvar x: Animal;\nvar x: Dog;\n```\n\nIf you removed the `var` keyword from the last line, you wouldn't see an error.\n"
      },
      {
        "user": "Steve-Fenton",
        "created_at": "2015-01-31T21:09:49Z",
        "body": "Sorry about that one... I spent too long staring at the right-hand side of the code to realise the problem was on the left! Thanks Ryan.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explain the TypeScript rule requiring identical types for variable redeclarations",
      "Differentiate between type inference in initial declarations vs subsequent assignments",
      "Clarify how assignment context affects function parameter compatibility checks"
    ]
  },
  {
    "number": 1763,
    "title": "Not generating output for exported const enum makes the enum useless from regular JavaScript",
    "created_at": "2015-01-21T20:56:39Z",
    "closed_at": "2015-01-21T22:08:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1763",
    "body": "Currently, no JavaScript is generated for const enum declarations (the language spec does not seem to address const enums).\n\nIs there a way to get the benefit of aggressive compile-time enum evaluation while still generating the JS enum object?\n\nIt would be nice if the computed values in the example below would be computed at compile-time like is done for const enum, but retain the generated JS so that the enum can be used from non-typescript applications:\n\n``` typescript\nexport enum Things {\n    ThingA = 0x1,\n    ThingB = 0x2,\n    ThingC = 0x4,\n    Mask = ThingA | ThingB | ThingC,\n}\n```\n\nDesired output:\n\n``` javascript\nvar Things;\n(function (Things) {\n    Things[Things[\"ThingA\"] = 1] = \"ThingA\";\n    Things[Things[\"ThingB\"] = 2] = \"ThingB\";\n    Things[Things[\"ThingC\"] = 4] = \"ThingC\";\n    Things[Things[\"Mask\"] = 7] = \"Mask\";\n})(Things || (Things = {}));\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1763/comments",
    "author": "sccolbert",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-01-21T21:29:44Z",
        "body": "The `--preserveConstEnums` flag does exactly this.\n"
      },
      {
        "user": "sccolbert",
        "created_at": "2015-01-21T22:08:23Z",
        "body": "Perfect. Thanks!\n"
      }
    ],
    "satisfaction_conditions": [
      "Preserves runtime enum structure for JavaScript interoperability",
      "Allows compile-time constant folding for enum values",
      "Maintains enum declaration in output while enabling optimizations"
    ]
  },
  {
    "number": 1739,
    "title": "how to uninstall 1.4",
    "created_at": "2015-01-20T10:33:48Z",
    "closed_at": "2015-01-20T19:48:05Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1739",
    "body": "",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1739/comments",
    "author": "v-vairam",
    "comments": [
      {
        "user": "DavidRigglemanININ",
        "created_at": "2015-01-20T16:05:21Z",
        "body": "I may be able to provide some help here since I had to do the same thing after encountering a bug in 1.4 that forced me to uninstall that version. You can uninstall version 1.4 from the Remove Programs functionality in the Control Panel. In my case, I then also had to right click on version 1.3 in the Control Panel, click Modify, and then select Repair in order to restore TypeScript integration back into Visual Studio for 1.3\n"
      },
      {
        "user": "danquirk",
        "created_at": "2015-01-20T19:48:05Z",
        "body": "As mentioned, if you've installed it on VS2013 then there should be a normal Add/Remove Programs entry you can uninstall it from. \n"
      }
    ],
    "satisfaction_conditions": [
      "Instructions for uninstalling a specific software version using standard OS uninstallation tools",
      "Guidance on restoring integration with development tools after uninstallation",
      "Clear distinction between version-specific uninstallation and system-wide removal"
    ]
  },
  {
    "number": 1565,
    "title": "Null calling pre-compile check",
    "created_at": "2014-12-26T18:06:20Z",
    "closed_at": "2014-12-27T13:25:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1565",
    "body": "Hi. I'm working on a bit bigger project that is fully driven by TS, and I noticed that compiler doesn't check if variables that have as type object, are filled with instances anywhere. I didn't realize that so now my project is full of variables that were never initialized. So I thought that this would help a lot, and it isn't that hard to check. But I'm a horrible JS programmer. I hate even look at JS. So... just an idea. \n\nThanks for reading.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1565/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2014-12-27T05:37:44Z",
        "body": "Have you looked into our `--noImplicitAny` flag?\n\nWhen an assignable entity has no context for which it can infer a type (either by initialization, or an explicit type annotation), our type system automatically infers the type (or types of its constituents) to be `any`.\n\nFor instance, our compiler would error (but still emit) on all of the following with `--noImplicitAny`:\n\n``` TypeScript\nvar a;                 // type: any\nvar b = null;          // type: any\nvar c = undefined;     // type: any\nvar d = [];            // type: any[]\nvar e = [[null]];      // type: any[][]\n```\n"
      },
      {
        "user": "ghost",
        "created_at": "2014-12-27T09:29:53Z",
        "body": "Oh. Ok... Thanks that helps. \n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2014-12-27T13:25:23Z",
        "body": "No problem. If that's not _actually_ helping you could simply use a regular expression on your codebase to see if you're not initializing a variable on declaration.\n\n```\nvar [^=]+$\n```\n\nThough, with this, you'll have to check instance members in classes separately.\n"
      }
    ],
    "satisfaction_conditions": [
      "Detects uninitialized variables declared with object types",
      "Works through TypeScript's type system rather than runtime checks",
      "Provides automated detection without manual code inspection"
    ]
  },
  {
    "number": 1487,
    "title": "Tuple type checking",
    "created_at": "2014-12-15T14:33:18Z",
    "closed_at": "2014-12-18T01:47:15Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1487",
    "body": "I haven't had the time to investigate yet, but was surprised to see the following compile without error with tsc.exe shipped in the VS extension v1.3:\n    var testingzetuple: [number, string] = [1, \"world\", \"foreva\"];\nor\n    var testingzetuple: [number, number] = [1, 2, 3];\nIs that the expected behaviour? Shouldn't tuple type [t1,...,tn] be limited to size n?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1487/comments",
    "author": "codespare",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2014-12-17T18:53:07Z",
        "body": "By the substitution principle, a longer tuple is a subtype of a shorter tuple (assuming their first _n_ elements are the same).\n"
      },
      {
        "user": "codespare",
        "created_at": "2014-12-18T01:47:15Z",
        "body": "That makes sense given it is defined as an interface. I was implicitly assuming something similar to .NET System.Tuple definition which doesn't have that flexibility. Thank you for the clarification.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of TypeScript's tuple subtyping rules",
      "Comparison with .NET System.Tuple behavior",
      "Confirmation of expected tuple length behavior"
    ]
  },
  {
    "number": 1481,
    "title": "Can an optional and required field of merged interfaces yield a required field?",
    "created_at": "2014-12-14T19:09:06Z",
    "closed_at": "2015-06-12T18:35:20Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1481",
    "body": "I have this case from using the mongoose library, in which my domain object, A, might have a DB _id, but the mongoose.Document always has an _id.\nI use type A when not in the mongoose portions of the app, and type ADocument only within those parts that deal directly with mongoose.  Note that mongoose defines Document to contain _id like this:\n\n```\ninterface Document {\n    _id: string;\n}\n```\n\nI tried to model the A - ADocument relationship like this:\n\n```\ninterface A {\n    _id?: string;\n}\ninterface ADoc extends A, mongoose.Document {   \n}\n```\n\nbut I get this error:\n_Interface 'ADoc' cannot simultaneously extend types 'A' and 'Document':\n Named properties '_id' of types 'A' and 'Document' are not identical._\n\nI can get around this error by making _id be either optional in both definitions, or required in both.\n\nI expect that the compiler can infer that _id is now required in ADoc. \nIs the current behavior of issuing an error the correct behavior? \nIf so, does it make sense to merge such fields so they become required?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1481/comments",
    "author": "psnider",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2014-12-14T20:32:57Z",
        "body": "Hm, I'm not sure about the actual semantics as per the spec behind this (a little hard for me to access it), but if you explicitly declare `_id` in `ADoc`, you should be able to get rid of this error.\n\n``` TypeScript\ninterface Document {\n    _id: string;\n}\n\ninterface A {\n    _id?: string;\n}\n\ninterface ADoc extends A, Document {\n    _id: string;\n}\n```\n"
      },
      {
        "user": "psnider",
        "created_at": "2014-12-14T22:00:25Z",
        "body": "I followed your advice, and placed _id in the merged classes explicitly, and this removed the errors.\nThanks.\n\nAs for the spec , I couldn't find anything in the spec that addresses this case.\nAnd regarding the semantics, it seems to me that optional may be satisfied by required, if\noptional is interpreted as \"might be present\", and required is interpreted as \"is present\".\nWhich is what your suggested fix does as well.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2014-12-15T03:36:13Z",
        "body": "The spec addresses this in section 7.1:\n\n> The following constraints must be satisfied by an interface declaration or otherwise a compile-time error occurs:\n> - [...]\n> - Inherited properties with the same name must be identical (section 3.8.2).\n\nThe relevant definition of \"identical member\" at 3.8.2 is:\n\n> Two members are considered identical when\n> - they are public properties with identical names, **optionality**, and types,\n\nIn general we only ever merge properties when they are completely identical.\n"
      },
      {
        "user": "Igorbek",
        "created_at": "2014-12-15T23:47:23Z",
        "body": "@RyanCavanaugh so how does having merging field in target interface fix the error? Does it only check convertibility to interfaces extended from?\n"
      },
      {
        "user": "danquirk",
        "created_at": "2015-01-06T02:55:56Z",
        "body": "@Igorbek You've now overridden the declarations from the inherited members. The compiler then checks that with the overridden declaration ADoc is a subtype of A and a subtype of Document.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-06-12T18:35:20Z",
        "body": "looks like no further information required. closing.\n"
      },
      {
        "user": "shrishailya",
        "created_at": "2018-02-28T14:01:24Z",
        "body": "Thanks @DanielRosenwasser "
      }
    ],
    "satisfaction_conditions": [
      "Explanation of TypeScript's interface merging rules regarding optional vs required properties",
      "Clarification of how property overrides in derived interfaces resolve conflicts",
      "Validation of TypeScript's compiler behavior being spec-compliant",
      "Guidance on maintaining type safety when combining domain objects with library-specific types"
    ]
  },
  {
    "number": 958,
    "title": "Support prototype extension of built-in types",
    "created_at": "2014-10-24T21:48:08Z",
    "closed_at": "2014-10-24T23:24:37Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/958",
    "body": "I can extend the `String` interface like so:\n\n``` ts\ninterface String {\n  upper(): String;\n}\n```\n\nI would expect that I could then do:\n\n``` ts\nString.prototype.upper = String.prototype.toUpperCase;\n```\n\nOr:\n\n``` ts\nString.prototype.upper = String.prototype.upper || function() {\n  return this.toUpperCase();\n};\n```\n\nOr even this:\n\n``` ts\nvar foo: String = 'bar'; // Type 'String' is missing property 'upper' from type 'String'.\n```\n\nIt would be nice if the `string` keyword would, of course, accommodate this change as well.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/958/comments",
    "author": "jednano",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2014-10-24T22:04:22Z",
        "body": "All the code you wrote compiles without error.\n\nDid you write `interface String {` inside a module (internal or external)? That would declare a new type instead of extending the existing one.\n"
      },
      {
        "user": "jednano",
        "created_at": "2014-10-24T23:24:36Z",
        "body": "Ah, you are right. Sorry. Looks like I have to create a `d.ts` file and just extend the interface there. Now it all makes sense.\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how to correctly extend the global String interface in TypeScript",
      "Clarification on module context vs global declaration merging",
      "Guidance on proper type declaration file usage for built-in type extensions",
      "Ensuring string primitive type compatibility with extended interface"
    ]
  },
  {
    "number": 54956,
    "title": "'Convert named export to default export' removes type-information",
    "created_at": "2023-06-29T15:00:14Z",
    "closed_at": "2023-10-08T13:23:40Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/54956",
    "body": "Type: <b>Bug</b>\r\n\r\n1. select a  type annotated named export in a tsx file   \r\n1. hit `ctrl+.`\r\n1. select 'Convert named export to default export' \r\n1. observe how your type info is discarded \r\n\r\nbefore:\r\n```tsx \r\nexport const LabelList: React.FC<{ labelIds: number[] }> = ({ labelIds }) => {\r\n  const labels = useSelector<Types.RootState, LabelsState>(\r\n    ({ labels }) => labels,\r\n  );\r\n  return (\r\n    <div>\r\n      {labelIds.length ? (\r\n        labelIds.map(l => labels![l]).map(l => <LabelToken label={l} />)\r\n      ) : (\r\n        <small className={styles.noDescription}>No labels</small>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\nafter:\r\n```tsx\r\nexport default ({ labelIds }) => {\r\n  const labels = useSelector<Types.RootState, LabelsState>(\r\n    ({ labels }) => labels,\r\n  );\r\n\r\n  return (\r\n    <div>\r\n      {labelIds.length ? (\r\n        labelIds.map(l => labels![l]).map(l => <LabelToken label={l} />)\r\n      ) : (\r\n        <small className={styles.noDescription}>No labels</small>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n```\r\n \r\ninlining the type-annotations in a default export may not be possible (im not sure), but an intemediate variable can be exported as a default  \r\n\r\nVS Code version: Code 1.79.2 (695af097c7bd098fbf017ce3ac85e09bbc5dda06, 2023-06-14T08:59:55.818Z)\r\nOS version: Linux x64 6.2.6-76060206-generic\r\nModes:\r\n\r\n<details>\r\n<summary>System Info</summary>\r\n\r\n|Item|Value|\r\n|---|---|\r\n|CPUs|AMD Ryzen 7 5800U with Radeon Graphics (16 x 3547)|\r\n|GPU Status|2d_canvas: enabled<br>canvas_oop_rasterization: disabled_off<br>direct_rendering_display_compositor: disabled_off_ok<br>gpu_compositing: enabled<br>multiple_raster_threads: enabled_on<br>opengl: enabled_on<br>rasterization: enabled<br>raw_draw: disabled_off_ok<br>video_decode: enabled<br>video_encode: disabled_software<br>vulkan: disabled_off<br>webgl: enabled<br>webgl2: enabled<br>webgpu: disabled_off|\r\n|Load (avg)|2, 1, 1|\r\n|Memory (System)|13.49GB (1.87GB free)|\r\n|Process Argv|--unity-launch --crash-reporter-id f14012b5-d0f7-448a-910a-706fee85982f|\r\n|Screen Reader|no|\r\n|VM|0%|\r\n|DESKTOP_SESSION|pop|\r\n|XDG_CURRENT_DESKTOP|Unity|\r\n|XDG_SESSION_DESKTOP|pop|\r\n|XDG_SESSION_TYPE|x11|\r\n</details><details><summary>Extensions (46)</summary>\r\n\r\nExtension|Author (truncated)|Version\r\n---|---|---\r\njest-snippets|and|1.9.1\r\nvscode-zipfs|arc|3.0.0\r\nvscode-toggle-quotes|Bri|0.3.6\r\nvscode-eslint|dba|2.4.2\r\nes7-react-js-snippets|dsz|4.4.3\r\nprettier-vscode|esb|9.16.0\r\ncode-runner|for|0.12.0\r\nshell-format|fox|7.2.5\r\ngitlab-workflow|Git|3.68.0\r\neasy-snippet|inu|0.6.3\r\nplantuml|jeb|2.17.5\r\nbetter-shellscript-syntax|jef|1.6.1\r\nbash-ide-vscode|mad|1.37.0\r\ndirenv|mkh|0.14.0\r\nvscode-docker|ms-|1.25.1\r\nisort|ms-|2022.8.0\r\npython|ms-|2023.10.1\r\nvscode-pylance|ms-|2023.6.40\r\njupyter|ms-|2023.5.1101742258\r\njupyter-keymap|ms-|1.1.2\r\njupyter-renderers|ms-|1.0.15\r\nvscode-jupyter-cell-tags|ms-|0.1.8\r\nvscode-jupyter-slideshow|ms-|0.1.5\r\nremote-containers|ms-|0.295.0\r\nremote-ssh|ms-|0.102.0\r\nremote-ssh-edit|ms-|0.86.0\r\nremote-explorer|ms-|0.4.0\r\nsqltools|mtx|0.28.0\r\nvscode-jest|Ort|5.2.3\r\nvscode-versionlens|pfl|1.5.0\r\nbash-extension-pack|pin|2.0.0\r\nvscode-react-refactor|pla|1.1.3\r\nansible|red|2.4.78\r\nvscode-yaml|red|1.13.0\r\nvscode-gitweblinks|red|2.9.2\r\nbash-debug|rog|0.3.9\r\nshebang-snippets|rpi|0.1.4\r\njs-snippets|run|0.2.6\r\nrust-analyzer|rus|0.3.1566\r\nvscode-taskexplorer|spm|2.13.2\r\nshellcheck|tim|0.32.6\r\njinja|who|0.0.8\r\nchange-case|wma|1.0.0\r\nJavaScriptSnippets|xab|1.8.0\r\ncursor-align|yo1|1.1.0\r\nmarkdown-pdf|yza|1.4.4\r\n\r\n\r\n</details><details>\r\n<summary>A/B Experiments</summary>\r\n\r\n```\r\nvsliv368:30146709\r\nvsreu685:30147344\r\npython383:30185418\r\nvspor879:30202332\r\nvspor708:30202333\r\nvspor363:30204092\r\nvslsvsres303:30308271\r\nvserr242cf:30382550\r\npythontb:30283811\r\nvsjup518:30340749\r\npythonptprofiler:30281270\r\nvshan820:30294714\r\nvstes263:30335439\r\nvscod805:30301674\r\nbinariesv615:30325510\r\nbridge0708:30335490\r\nbridge0723:30353136\r\nvsaa593:30376534\r\npythonvs932:30410667\r\npy29gd2263:30776702\r\nvsclangdc:30486549\r\nc4g48928:30535728\r\ndsvsc012:30540252\r\npynewext54:30695312\r\nazure-dev_surveyone:30548225\r\nvscccc:30610679\r\n3biah626:30602489\r\npyind779:30671433\r\n89544117:30613380\r\npythonsymbol12:30671437\r\n2i9eh265:30646982\r\nshowlangstatbar:30737416\r\nvsctsb:30748421\r\npythonms35:30701012\r\n03d35959:30757346\r\n57b77579:30736110\r\npythonfmttext:30731395\r\npythoncmv:30756943\r\nfixshowwlkth:30771522\r\npythongtdpath:30769146\r\ni26e3531:30769768\r\ndh2dc718:30776458\r\npythonidxpt:30772539\r\npythondjangotscf:30772537\r\npythonnoceb:30776495\r\n\r\n```\r\n\r\n</details>\r\n\r\n<!-- generated by issue reporter -->",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/54956/comments",
    "author": "midgethoen",
    "comments": [
      {
        "user": "midgethoen",
        "created_at": "2023-06-30T07:52:17Z",
        "body": "I can give fixing/improving this a go if someone can give me a little guidance on where to start :)"
      },
      {
        "user": "awareness481",
        "created_at": "2023-10-07T09:58:04Z",
        "body": "I think this has been fixed, using the refactor test for the following code\r\n\r\n```ts\r\ntype A = any;\r\n\r\nexport const LabelList: A = () => {};\r\n```\r\n\r\nresults in\r\n\r\n```ts\r\ntype A = any;\r\n\r\nconst LabelList: A = () => {};\r\nexport default LabelList;\r\n```\r\n\r\nThe code from OP also seems to be formatted correctly."
      },
      {
        "user": "midgethoen",
        "created_at": "2023-10-08T13:23:40Z",
        "body": "@awareness481 , thnx for the headsup. i upgraded and verified that it now works as expected. awesome!"
      }
    ],
    "satisfaction_conditions": [
      "Preserves type annotations when converting named exports to default exports",
      "Maintains equivalent type safety after refactoring",
      "Uses valid TypeScript patterns for default exports",
      "Works with React component patterns"
    ]
  },
  {
    "number": 22364,
    "title": "Extra comma left by CodeFixAll unused variables",
    "created_at": "2018-03-06T21:03:41Z",
    "closed_at": "2018-05-30T20:32:17Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Domain: Quick Fixes"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/22364",
    "body": "Code Fix All unused variables\r\n```ts\r\nimport { a, b, c, d} from \"./helpers\";\r\na;\r\n```\r\n\r\nExpected:\r\n\r\n```ts\r\nimport { a } from \"./helpers\";\r\na; \r\n```\r\n\r\nActual:\r\n```ts\r\nimport { a,  } from \"./helpers\";\r\na; \r\n```\r\nRelated Issues:\r\n#22330 and #22352\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/22364/comments",
    "author": "mhegazy",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-03-07T07:58:28Z",
        "body": "#featureNotBug \ud83d\ude09 "
      },
      {
        "user": "Kingwl",
        "created_at": "2018-03-09T10:23:27Z",
        "body": "need some help ("
      },
      {
        "user": "vpukhanov",
        "created_at": "2018-05-30T20:12:15Z",
        "body": "@mhegazy Can't reproduce this issue on the latest \"master\" branch build. It was probably fixed."
      },
      {
        "user": "mhegazy",
        "created_at": "2018-05-30T20:32:42Z",
        "body": "thanks!"
      }
    ],
    "satisfaction_conditions": [
      "The code fix must remove all unused imports without leaving trailing commas",
      "The solution must handle multiple unused variables in a single import statement",
      "The fix should produce valid TypeScript syntax after refactoring",
      "The fix must work consistently across multiple related scenarios"
    ]
  },
  {
    "number": 19761,
    "title": "Class 'AnotherProductService' incorrectly implements interface 'ProductService'.",
    "created_at": "2017-11-06T09:58:29Z",
    "closed_at": "2017-11-07T02:54:00Z",
    "labels": [
      "Suggestion",
      "Help Wanted",
      "Domain: Error Messages"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19761",
    "body": "I create a project with angular/cli , when I try used service, I get an error.\r\n-----\r\n\r\n**TypeScript Version:**  2.4.2\r\n**Angular CLI Version:** 1.5.0\r\n**NPM Version:** 5.0.3\r\n**Node.js Version:**  8.1.0\r\n**OS Version:**  Winwods 10 Professional Edition x64\r\n---------\r\n**Code**\r\n\r\n```ts\r\nimport { Injectable } from '@angular/core';\r\nimport { LoggerService } from './logger.service';\r\n\r\n\r\n@Injectable()\r\nexport class ProductService {\r\n\r\n  constructor(private logger: LoggerService) { }\r\n\r\n  getProduct(): Product {\r\n    this.logger.log('getProduct function');\r\n    return new Product(0, 'iphone7', 5899, 'apple phone');\r\n  }\r\n}\r\n\r\nexport class Product {\r\n\r\n  constructor(\r\n    public id: number,\r\n    public title: string,\r\n    public price: number,\r\n    public desc: string\r\n  ) {\r\n\r\n  }\r\n}\r\n```\r\n-------------\r\n```ts\r\nimport { Injectable } from '@angular/core';\r\nimport { Product, ProductService } from './product.service';\r\n\r\n@Injectable()\r\nexport class AnotherProductService implements ProductService {\r\n\r\n  getProduct(): Product {\r\n    return new Product(1, 'sunsumg7', 4899, 'sunsumg phone');\r\n  }\r\n\r\n  constructor() { }\r\n\r\n}\r\n```\r\n------------\r\n```ts\r\nimport { Injectable } from '@angular/core';\r\n\r\n@Injectable()\r\nexport class LoggerService {\r\n\r\n  constructor() { }\r\n\r\n  log(message: string) {\r\n    console.log(message);\r\n  }\r\n\r\n}\r\n```\r\n----------------\r\n```ts\r\nimport { BrowserModule } from '@angular/platform-browser';\r\nimport { NgModule } from '@angular/core';\r\n\r\nimport { AppComponent } from './app.component';\r\nimport { Product1Component } from './product1/product1.component';\r\nimport { ProductService } from './shared/product.service';\r\nimport { Product2Component } from './product2/product2.component';\r\nimport { LoggerService } from './shared/logger.service';\r\n\r\n@NgModule({\r\n  declarations: [\r\n    AppComponent,\r\n    Product1Component,\r\n    Product2Component\r\n  ],\r\n  imports: [\r\n    BrowserModule\r\n  ],\r\n  providers: [ProductService, LoggerService],\r\n  bootstrap: [AppComponent]\r\n})\r\nexport class AppModule { }\r\n```\r\n------\r\n\r\n**Expected behavior:**\r\n- If it is work, the Product where be get and show on the html.\r\n--------------\r\n\r\n**Actual behavior:**\r\n- I get an error.\r\n```\r\nERROR in src/app/shared/another-product.service.ts(5,14): error TS2420: Class 'AnotherProductService' incorrectly implements interface 'ProductService'.Property 'logger' is missing in type 'AnotherProductService'.\r\n\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19761/comments",
    "author": "dingziyang",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2017-11-06T15:24:11Z",
        "body": "You probably meant `extends` instead of `implements`.\r\nYou can never `implement` a class with private members, so we should probably improve the error message here."
      },
      {
        "user": "dingziyang",
        "created_at": "2017-11-07T01:47:08Z",
        "body": "@andy-ms I understand what you main. Everything in interface must be public. \r\nBut, I'm sure I use implements here. Because I downloaded a study video, the teacher is doing this and it's worked. He also used Angular4 and TypeScript. \r\n**Oh! It drives me crazy!**"
      },
      {
        "user": "ghost",
        "created_at": "2017-11-07T02:08:33Z",
        "body": "It is possible to \"implement\" a class -- but it means treating the class as an interface, so you'll have to create an implementation of every one of its members.\r\nHowever, if the class you're implementing has a private member, it's impossible to implement.\r\n```ts\r\nclass A {\r\n\tprivate x: number;\r\n}\r\n// Error: Types have separate declarations of a private property 'x'.\r\nclass B implements A {\r\n\tprivate x: number;\r\n}\r\n```\r\n\r\nIt's correct that we give you this error message, because if `B implements A`, you would expect to be able to assign a `B` to an `A`, but you can't assign anything to a class with a private member unless it's derived from that class via `extends`. So the error message should just tell you that instead of telling you to implement a property that you can't possibly implement.\r\n\r\nIn your case, if you really don't intend to use `extends`, you must define an interface and have both classes implement that."
      },
      {
        "user": "dingziyang",
        "created_at": "2017-11-07T02:53:54Z",
        "body": "@andy-ms Thanks for your help. In the next section, the teacher changed ```private``` to ```public```\u3002\r\n\uff08\uff03\uff0d.\uff0d\uff09"
      },
      {
        "user": "ghost",
        "created_at": "2017-11-07T03:20:39Z",
        "body": "Moved the error message issue to #19793."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why implementing a class with private members causes TypeScript errors",
      "Clarification of interface vs class inheritance differences in TypeScript",
      "Solution pattern for creating interchangeable service implementations in Angular",
      "Understanding of Angular service visibility requirements"
    ]
  },
  {
    "number": 11205,
    "title": "Union Type made of two types of arrays fails to provide all array's methods",
    "created_at": "2016-09-28T09:05:56Z",
    "closed_at": "2016-12-30T22:28:16Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Domain: lib.d.ts"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11205",
    "body": "**TypeScript Version:**  1.8.0 / TypeScript playground\n\n**Code**\n\n``` ts\nlet x1: number[];\nlet x2: number[][];\nx1.splice(1, 1); // OK\nx2.splice(1, 1); // OK\nlet x: number[] | number[][];\nx.splice(1, 1); // Error: Supplied parameters do not match any signature of call target.\n```\n\n**Expected behavior:**\nTS tutorial states: \n\n>  If we have a value that has a union type, we can only access members that are common to all types in the union.\n\nSince both `x1: number[];` and `x2: number[][]` have `splice` method with two params, I expect the union of these two types also to have this method.\n\n**Actual behavior:** \nCompiler reports an error:  Supplied parameters do not match any signature of call target. However, it allows using another overload of `splice` function:\n\n``` ts\nlet x: number[] | number[][];\nx.splice(1); // OK\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11205/comments",
    "author": "OleksandrNechai",
    "comments": [
      {
        "user": "OleksandrNechai",
        "created_at": "2016-09-28T09:44:34Z",
        "body": "It is probably same issue as #10620 \n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-09-28T09:54:10Z",
        "body": "Yes, essentially it is the same, the subtle difference is that when matching the signature, it is matching one that it cannot union the overload:\n\n``` typescript\ninterface Array<T> {\n    splice(start: number): T[];\n    splice(start: number, deleteCount: number, ...items: T[]): T[];\n}\n```\n\nIt cannot union the type of the `...items: T[]` argument, therefore it causes an error.  Technically if there was anther overload, the code above would work, up until the point where you added arguments that you needed to insert:\n\n``` typescript\ninterface Array<T> {\n    splice(start: number): T[];\n    splice(start: number, deleteCount: number): T[];\n    splice(start: number, deleteCount: number, ...items: T[]): T[];\n}\n```\n\nBut it is better to have `(number | number[])[]` in the first place as mentioned in the issue you referenced.\n"
      },
      {
        "user": "OleksandrNechai",
        "created_at": "2016-09-28T10:46:13Z",
        "body": "> But it is better to have  (number | number[])[]  in the first place\n\nWell, then this code does not compile:\n\n``` ts\nlet x: (string[] | number[])[]\nx.forEach(e => e.splice(1, 1)); // The same error\n```\n\nUnfortunately I have both cases in my code. Whatever way I choose to describe my types I get this error :-(.\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-09-28T12:41:15Z",
        "body": "This will work, but I suspect this is not what you want:\n\n``` typescript\nlet x: (string | number)[][]\nx.forEach(e => e.splice(1, 1));\n```\n\nAs I suspect you want an array of array of all numbers or an array of arrays of all strings.\n\nThe other option would be to help TypeScript along:\n\n``` typescript\nlet x: (string[] | number[])[];\nx.forEach((e: any[]) => e.splice(1, 1));\n```\n"
      },
      {
        "user": "OleksandrNechai",
        "created_at": "2016-09-28T13:22:53Z",
        "body": "`x.forEach((e: any[]) => e.splice(1, 1));` is pretty neat! Thanks! \nI thought transition from C# would be much easier. TS turned out to be very different beast :-)\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-09-28T14:34:47Z",
        "body": "> TS turned out to be very different beast\n\nYou can thank JavaScript for that...  Coming from JavaScript to TypeScript (my path) is like finally getting medication to treat your insanity.  Coming from C# must be like taking medical marijuana for the first time.  Please don't let TypeScript be a gateway drug to the acid trip that is JavaScript though.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-09-28T16:38:37Z",
        "body": "I think we should rewrite the signatures to be\n\n```\ninterface Array<T> {\n    splice(start: number, deleteCount?: number): T[];\n    splice(start: number, deleteCount: number, ...items: T[]): T[];\n}\n```\n\nwith the observation that generic types should have signatures split according to their input use of their type parameters\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why TypeScript fails to recognize common splice overloads in array union types",
      "Solution preserves type safety while working with array unions",
      "Addresses method overload resolution in union types",
      "Works for nested array union scenarios",
      "Maintains intended array element type specificity"
    ]
  },
  {
    "number": 9947,
    "title": "Go to definition from new this",
    "created_at": "2016-07-26T10:27:46Z",
    "closed_at": "2016-10-25T09:47:54Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9947",
    "body": "Since go to definition for super methods goes to the super methods. I expect \"new this\" should go to the super constructor(provided that there is no extending/overriding declaration):\n\n``` ts\nclass A {\n    /*to here*/constructor() {\n    }\n}\n\nclass B extends A {\n    static create() {\n        return new this/*from here*/; // Doesn't go anywhere\n    }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9947/comments",
    "author": "tinganho",
    "comments": [
      {
        "user": "arusakov",
        "created_at": "2016-10-25T00:45:33Z",
        "body": "In current `master` branch `go to definition` in this case just works. Cannot reproduce bug.\n"
      },
      {
        "user": "tinganho",
        "created_at": "2016-10-25T09:47:54Z",
        "body": "Confirmed it works now.\n"
      }
    ],
    "satisfaction_conditions": [
      "Go-to-definition functionality must resolve 'new this' in a subclass to the superclass constructor when there's no overriding constructor",
      "Solution must handle static context inheritance correctly",
      "Implementation must respect TypeScript's constructor inheritance rules"
    ]
  },
  {
    "number": 8742,
    "title": "tsc truncates type errors longer than 100 chars with triple-dots",
    "created_at": "2016-05-22T20:18:05Z",
    "closed_at": "2017-10-02T11:59:53Z",
    "labels": [
      "Suggestion",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8742",
    "body": "I'd like to see the entire error message.\n\nIn `tsc.js`:\n\n```\n        function typeToString(type, enclosingDeclaration, flags) {\n            var writer = ts.getSingleLineStringWriter();\n            getSymbolDisplayBuilder().buildTypeDisplay(type, writer, enclosingDeclaration, flags);\n            var result = writer.string();\n            ts.releaseStringWriter(writer);\n            var maxLength = compilerOptions.noErrorTruncation || flags & 4 ? undefined : 100;\n            if (maxLength && result.length >= maxLength) {\n                result = result.substr(0, maxLength - \"...\".length) + \"...\";\n            }\n            return result;\n        }\n```\n\nBut adding in `tsconfig.json`:\n\n```\n{\n  \"compilerOptions\": {\n    \"noErrorTruncation\": true\n  }\n}\n```\n\nhas no effect.\n\nIt seems that there's no other mention of that `noErrorTruncation` in the file -- I assume it's simply undefined (and I could also find no documentation about it).\n\nAdding to `ts.optionDeclarations` this entry:\n\n```\n        {\n            name: \"noErrorTruncation\",\n            type: \"boolean\"\n        },\n\n```\n\nmakes it work.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8742/comments",
    "author": "nh2",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-05-23T16:59:58Z",
        "body": "noErrorTrunction was meant for the API users calling directly into the API with CompilerOptions object, e.g. IDE's, and not from the commandline. \nThe asumption is on the commandline no one wants to see the full error, as serlized types can be huge. \nSo can you elaborate on why this is needed? and would you use this all the time? do you use `--pretty` as well?\n"
      },
      {
        "user": "nh2",
        "created_at": "2016-05-23T17:32:51Z",
        "body": "@mhegazy I definitely want to see the full error. The types I'm using (provided by others, so I cannot change them easily) are very long, and typically contain the `... & type & type` unions I care about at the end. It's OK if the errors are shortened by default, but when trying to solve type errors like in my case, it can be really hard if you can only see the first 100 chars of a 200 char type.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-05-23T17:36:01Z",
        "body": "A PR to add the compiler option would be appreciated.\n\n\n---\n\nso do you use an IDE? would getting the errors there be a better option?\n"
      },
      {
        "user": "nicksnyder",
        "created_at": "2017-04-27T17:13:53Z",
        "body": "@nh2 can you clarify how you worked around this? I have a similar error that I want to see the full error for.\n\n---\n\nOh, it looks like adding this to `tsconfig.json` works now\r\n\r\n```\r\n{\r\n  \"compilerOptions\": {\r\n    \"noErrorTruncation\": true\r\n  }\r\n}\r\n```\r\n\r\nI think this issue can be closed."
      },
      {
        "user": "another-guy",
        "created_at": "2017-10-02T05:15:44Z",
        "body": "@nicksnyder I confirm that the compiler option you mentioned is working for me too. I can't speak for @nh2 but IMO this issue is fixed in the compiler."
      },
      {
        "user": "nh2",
        "created_at": "2017-10-02T11:59:53Z",
        "body": "OK great, let's close this then -- we can reopen it if we find that something doesn't work yet."
      }
    ],
    "satisfaction_conditions": [
      "Full type error messages must be displayed without truncation",
      "Official support for disabling error truncation through standard configuration",
      "Solution must work in command-line compiler context",
      "Persistent configuration option for error display"
    ]
  }
]