[
  {
    "number": 24996,
    "title": "myokx : place stop-limit order",
    "created_at": "2025-01-22T19:41:22Z",
    "closed_at": "2025-01-29T09:27:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/24996",
    "body": "### Operating System\n\nwindows\n\n### Programming Languages\n\nJavaScript\n\n### CCXT Version\n\nlast\n\n### Description\n\nHi,\n\nI'm testing the myokx exchange, and try to place a \"stop limit\" order. The code seems to work and the \"response\" tell me the order is well placed.\nBut, I can't see this order in the history (I have also checked in the web dashboard and I do not see the order).\n\nNoticed that I'm in sandbox mode!\n\nAny idea of the problem ?\n\n### Code\n\n```\n(async () => {\n  try { \n    const params = Object.assign({\"stopPrice\":104000.0});\n\n    const order = await globalThis.exchange.createOrder(\n      'BTC/USDC',\n      'limit',\n      'buy',\n      0.001,\n      106000.0,\n      params\n    );\n    return order;\n  } catch (error) {\n    console.error(\"Error creating stop order:\", error);\n    throw error;\n  }\n})()\n\n\n```\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/24996/comments",
    "author": "vd3d",
    "comments": [
      {
        "user": "sc0Vu",
        "created_at": "2025-01-24T10:26:31Z",
        "body": "@vd3d Could you set option `trigger: true` when use fetch order?"
      },
      {
        "user": "vd3d",
        "created_at": "2025-01-24T16:44:10Z",
        "body": "Thanks @sc0Vu \n\nIt seems fetchOrders() + \"trigger:true\" does bring the missing orders, which is great, but I expected it to return all orders in one call.\n\n### Questions\n- Does this mean multiple API calls are required for this broker? Is this behavior documented somewhere?\n- I need a generic function to fetch all orders across (almost) all brokers. Is it feasible to create one, or should each broker's specific behavior be handled individually?\n- In the current scenario, multiple calls seem necessary. Are there alternatives to parameters like triggerPrice? I\u2019ve found other possible values like {'stop': true, 'trigger': true, 'trailing': true, 'marginMode': true}.\n\nPS: For Binance, I\u2019ve already managed this by fetching orders per symbol.\n\nThanks for your help"
      }
    ],
    "satisfaction_conditions": [
      "Clarification of broker-specific API requirements for fetching stop-limit orders",
      "Guidance on creating cross-exchange compatible order management",
      "Documentation of exchange-specific parameter requirements",
      "Explanation of parameter variations for advanced order types"
    ]
  },
  {
    "number": 24673,
    "title": "Hyperliquid fetch_trades not able to return trade data without a wallet address or user",
    "created_at": "2024-12-28T00:56:10Z",
    "closed_at": "2024-12-28T14:51:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/24673",
    "body": "### Operating System\r\n\r\ndebian\r\n\r\n### Programming Languages\r\n\r\nPython\r\n\r\n### CCXT Version\r\n\r\n4.3.89, 4.4.43\r\n\r\n### Description\r\n\r\nTrying to understand some differences between how ccxt fetches public data from hyperliquid vs other exchanges. For example, either ccxt or Hyperliquid requires a user | address in order to return trade data. Other exchanges, such as binance, return public trade data as expected.\r\n\r\nIs this a limitation of Hyperliquid's public API?\r\n\r\nExamples are provided, below.\r\n\r\nWhen trying to fetch trade data from hyperliquid, the following was observed:\r\n\r\n`\r\n>>> import ccxt  # noqa: E402 \r\n>>> h = ccxt.hyperliquid()\r\n>>> h.fetch_trades('ETH:USDC/USDC')\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"/home/ndms/hype/hypenv/lib/python3.10/site-packages/ccxt/hyperliquid.py\", line 887, in fetch_trades\r\n    userAddress, params = self.handle_public_address('fetchTrades', params)\r\n  File \"/home/ndms/hype/hypenv/lib/python3.10/site-packages/ccxt/hyperliquid.py\", line 2563, in handle_public_address\r\n    raise ArgumentsRequired(self.id + ' ' + methodName + '() requires a user parameter inside \\'params\\' or the wallet address set')\r\nccxt.base.errors.ArgumentsRequired: **hyperliquid fetchTrades() requires a user parameter inside 'params' or the wallet address set**\r\n`\r\n\r\nIn contrast, using binance, recent historical trades for the selected contract are returned, as expected:\r\n\r\n`\r\n>>> import ccxt  # noqa: E402                                                                                                                    \r\n>>> b = ccxt.binanceusdm()                                                                                                                       \r\n>>> b.fetch_trades('ETH/USDT:USDT') \r\n[{'info': {'a': '1948039310', 'p': '3337.77', 'q': '0.063', 'f': '4922008929', 'l': '4922008930', 'T': '1735346579940', 'm': False}, 'timestamp': 1735346579940, 'datetime': '2024-12-28T00:42:59.940Z', 'symbol': 'ETH/USDT:USDT', 'id': '1948039310', 'order': None, 'type': None, 'side': 'buy', 'takerOrMaker': None, 'price': 3337.77, 'amount': 0.063, 'cost': 210.27951, 'fee': {'cost': None, 'currency': None}, 'fees': []},\r\n...\r\n'info': {'a': '1948039809', 'p': '3338.42', 'q': '0.011', 'f': '4922010284', 'l': '4922010284', 'T': '1735346624827', 'm': True}, 'timestamp': 1735346624827, 'datetime': '2024-12-28T00:43:44.827Z', 'symbol': 'ETH/USDT:USDT', 'id': '1948039809', 'order': None, 'type': None, 'side': 'sell', 'takerOrMaker': None, 'price': 3338.42, 'amount': 0.011, 'cost': 36.72262, 'fee': {'cost': None, 'currency': None}, 'fees': []}]\r\n`\r\n\r\nAny clarity that the ccxt team can provide would be greatly appreciated.",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/24673/comments",
    "author": "block-13",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2024-12-28T11:08:07Z",
        "body": "Hello @block-13,\r\n\r\n> Is this a limitation of Hyperliquid's public API?\r\n\r\nYes, although the information is completely public and accessible you can't fetch all trades from every wallet, you always need to specify a wallet.\r\n\r\n"
      },
      {
        "user": "block-13",
        "created_at": "2024-12-28T14:51:33Z",
        "body": "That is unfortunate, but many thanks for the clarification. Keep up the fantastic work."
      }
    ],
    "satisfaction_conditions": [
      "Confirmation of whether the wallet address requirement stems from Hyperliquid's API design rather than CCXT implementation",
      "Clarification about mandatory parameters for Hyperliquid API interactions through CCXT",
      "Differentiation between exchange-specific API constraints vs CCXT library limitations"
    ]
  },
  {
    "number": 24442,
    "title": "Issue with auth on Paradex",
    "created_at": "2024-12-04T10:02:40Z",
    "closed_at": "2024-12-04T11:38:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/24442",
    "body": "### Operating System\r\n\r\nwidows\r\n\r\n### Programming Languages\r\n\r\nPython\r\n\r\n### CCXT Version\r\n\r\n4.3.35\r\n\r\n### Description\r\n\r\nParadex on ccxt uses privateKey to auth, create JWT token etc.\r\nSometimes the starknet privatekey can be 63 length (65 with \"0x\" prefix). I believe it can causes issues with ccxt code that expects an hexadecimal key : \"binascii.Error: Non-base16 digit found\" when trying to retrieve balance of the account.\r\n\r\nccxt\\async_support\\paradex.py\", line 914 :\r\n```\r\n    def sign_message(self, message, privateKey):\r\n        return self.sign_hash(self.hash_message(message), privateKey[-64:])\r\n```\r\nyou can see the [-64] that doesn't work with 65 len privatekeys\r\nI tried replacing \"0x\" by \"0x0\" to have a hexadecimal key but it leads to an error : ccxt.base.errors.BadRequest: paradex {\"error\":\"NOT_ONBOARDED\",\"message\":\"user has never called the /onboarding endpoint\"}\r\nwhile the paradex account already exists so the user should be already onboarded I guess.\r\n\r\nI don't understand everything of this but what I am almost sure is that I get a privateKey with a length of 65 and without any modifications, it may not be suited for the signature fonctions that expects a 66 length:\r\n\r\nccxt\\async_support\\paradex.py\"\r\n```\r\n    def sign_hash(self, hash, privateKey):\r\n        signature = self.ecdsa(hash[-64:], privateKey[-64:], 'secp256k1', None)\r\n        r = signature['r']\r\n        s = signature['s']\r\n        v = self.int_to_base16(self.sum(27, signature['v']))\r\n        return '0x' + r.rjust(64, '0') + s.rjust(64, '0') + v\r\n\r\n    def sign_message(self, message, privateKey):\r\n        return self.sign_hash(self.hash_message(message), privateKey[-64:])\r\n```\r\n\r\nthank you\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/24442/comments",
    "author": "Scribulus",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2024-12-04T10:26:21Z",
        "body": "Hello @Scribulus,\r\n\r\nThanks for reporting it, we will take a look and get back to you asap.  cc/ @sc0Vu \n\n---\n\n@Scribulus Btw, can you try to provide the private key of the ETH address and not the paradex private key?"
      },
      {
        "user": "Scribulus",
        "created_at": "2024-12-04T11:03:31Z",
        "body": "@carlosmiei oh, you are right, it requires the ETH private key, not the paradex private Key.  It was making sense to me to use the privateKey given by the paradex account I want to connect to.\r\n\r\n now it works ^^'\r\n \r\n Sorry it was confused by this"
      },
      {
        "user": "carlosmiei",
        "created_at": "2024-12-04T11:09:16Z",
        "body": "@Scribulus Right now we're using the ETH PK to derive the starknet private key, but ideally we should support both and we're checking if that is possible. "
      },
      {
        "user": "Scribulus",
        "created_at": "2024-12-04T11:21:53Z",
        "body": "@carlosmiei ok,  I guess the ETH private key is required for \"onboarding\" to paradex from ccxt.  but if the user onboard manually on the paradex app and can sign transaction with the paradex private key and the ETH wallet address only it could be better for the wallet security."
      },
      {
        "user": "carlosmiei",
        "created_at": "2024-12-04T11:36:27Z",
        "body": "@Scribulus I agree,  we will do our best to support both and avoid having to use the main wallet pk"
      },
      {
        "user": "Scribulus",
        "created_at": "2024-12-04T11:38:55Z",
        "body": "thank you for the fast support !"
      },
      {
        "user": "carlosmiei",
        "created_at": "2024-12-04T11:40:40Z",
        "body": "@Scribulus Np, just let us know if anything! \ud83d\ude42 "
      },
      {
        "user": "Scribulus",
        "created_at": "2024-12-05T19:32:27Z",
        "body": "@carlosmiei Do you know if subaccounts and/or vault are available with ccxt. tried a few keys in options dict  like \"account\", \"subaccount\" when connecting or using get balance but nothing.\r\nIs it the right place to ask ?"
      }
    ],
    "satisfaction_conditions": [
      "Clarify which private key type (ETH vs. Paradex) should be used for authentication",
      "Ensure compatibility with different private key formats/lengths (e.g., 64 vs 66 characters)",
      "Provide clear documentation about authentication requirements for Paradex integration",
      "Support both ETH-derived and native Paradex private keys for authentication",
      "Handle key format validation/transformation internally to prevent user-side manipulation"
    ]
  },
  {
    "number": 24399,
    "title": "[Question] Managing Multiple API Keys with WebSocket in ccxt.pro (TypeScript)",
    "created_at": "2024-11-28T13:50:08Z",
    "closed_at": "2024-11-28T15:46:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/24399",
    "body": "### Operating System\n\nios\n\n### Programming Languages\n\n_No response_\n\n### CCXT Version\n\n_No response_\n\n### Description\n\nHi ccxt team,\r\nFirst, I\u2019d like to express my gratitude for your continued hard work and swift updates to this amazing library! \ud83d\ude4f\r\nI\u2019m using TypeScript and exploring a way to calculate PnL for different assets by managing multiple sub-accounts. My approach is to create a new ccxt.pro.binance instance for each sub-account, initializing it with a unique API key and secret.\r\nWhile calling REST API functions seems to work fine, I\u2019m unsure about the WebSocket-related functions. Will each instance handle WebSocket connections independently and function properly in this setup? Or is there anything specific I should be aware of when managing multiple WebSocket connections using ccxt.pro with different API keys?\r\nThank you for your time and for maintaining this awesome library!\n\n### Code\n\n_No response_",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/24399/comments",
    "author": "cozy-hn",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2024-11-28T15:28:10Z",
        "body": "Hello @cozy-hn,\r\n\r\nThanks for your kind words and support.\r\n\r\n> Will each instance handle WebSocket connections independently and function properly in this setup?\r\n\r\nYes that's correct, each instance is independent."
      }
    ],
    "satisfaction_conditions": [
      "Confirmation that multiple WebSocket connections can operate independently across different API key instances",
      "Clarification about instance isolation in WebSocket operations"
    ]
  },
  {
    "number": 24373,
    "title": "Error setting margin type and leverage setting",
    "created_at": "2024-11-25T23:33:43Z",
    "closed_at": "2024-11-26T20:03:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/24373",
    "body": "### Operating System\n\nWin10\n\n### Programming Languages\n\nPython\n\n### CCXT Version\n\n4.4.33\n\n### Description\n\nError setting margin type and leverage setting 1- 'binance' object has no attribute 'fapiPrivate_post_margintype' 2- 'binance' object has no attribute 'fapiPrivate_post_leverage'\n\n### Code\n\n```# Setting margin\r\ndef set_margin_type(symbol, margin_type='ISOLATED'):\r\n    try:\r\n        market = binance.market(symbol)\r\n        params = {\r\n            'symbol': market['id'],\r\n            'marginType': margin_type,\r\n        }\r\n        response = binance.fapiPrivate_post_margintype(params)\r\n        print(f\"Margin type for {symbol} set at {margin_type}\")\r\n    except Exception as e:\r\n        print(f\"Error when setting margin type: {e}\")\r\n\r\n# leverage setting\r\ndef set_leverage(symbol, leverage):\r\n    try:\r\n        market = binance.market(symbol)\r\n        params = {\r\n            'symbol': market['id'],\r\n            'leverage': leverage,\r\n        }\r\n        response = binance.fapiPrivate_post_leverage(params)\r\n        print(f\"Leverage for {symbol} set at {leverage}x\")\r\n    except Exception as e:\r\n        print(f\"Error leverage setting : {e}\")\r\n\r\n# TESTS\r\ndef run_tests():\r\n    sync_time()\r\n    test_balance()  # Balance check\r\n    fetch_ohlcv('ETH/USDT', '1H')  \r\n    test_order('ETH/USDT', 0.05) \r\n    set_margin_type('ETH/USDT', 'ISOLATED')  \r\n    set_leverage('ETH/USDT', 10)  \r\n\r\nif __name__ == '__main__':\r\n    run_tests()\r\n\u2002\u2002\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/24373/comments",
    "author": "Borodacmd",
    "comments": [
      {
        "user": "sc0Vu",
        "created_at": "2024-11-26T03:20:10Z",
        "body": "@Borodacmd You can use `fapiprivate_post_leverage` and `fapiprivate_post_margintype` directly, or call the unified methods `set_leverage` and `set_margin_mode`."
      },
      {
        "user": "Borodacmd",
        "created_at": "2024-11-26T20:03:04Z",
        "body": "> @Borodacmd\u0412\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c `fapiprivate_post_leverage`\u0438 `fapiprivate_post_margintype`\u043d\u0430\u043f\u0440\u044f\u043c\u0443\u044e \u0438\u043b\u0438 \u0432\u044b\u0437\u044b\u0432\u0430\u0442\u044c \u0443\u043d\u0438\u0444\u0438\u0446\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0435 \u043c\u0435\u0442\u043e\u0434\u044b `set_leverage`\u0438 `set_margin_mode`.\r\n\r\nYes, thank you"
      }
    ],
    "satisfaction_conditions": [
      "Demonstrates correct method invocation for Binance Futures API margin/leverage endpoints",
      "Explains usage of CCXT's unified margin/leverage methods",
      "Clarifies distinction between private API endpoints and unified methods"
    ]
  },
  {
    "number": 24358,
    "title": "bybit perpetual contract unable to fetch ohlcv",
    "created_at": "2024-11-24T13:30:57Z",
    "closed_at": "2024-11-25T04:59:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/24358",
    "body": "### Operating System\n\nWindows\n\n### Programming Languages\n\nPython\n\n### CCXT Version\n\n_No response_\n\n### Description\n\nUnable to retrieve ohlcv for ticker in linear but no spot.\r\n\r\nticker sample: MAJORUSDT , USUALUSDT\r\nBoth ticker was able to extract from exchange.fetch_tickers but getting error \"ccxt.base.errors.BadSymbol: bybit does not have market symbol MAJORUSDT\"\r\n\n\n### Code\n\n```python\r\nimport ccxt\r\nimport pprint\r\n\r\n# Initialize Bybit exchange\r\nexchange = ccxt.bybit({\r\n    'enableRateLimit': True,\r\n})\r\n\r\n# Function to get the symbol list ending with USDT\r\ndef get_symbol_list():\r\n    try:\r\n        # Fetch all tickers with category 'linear'\r\n        tickers = exchange.fetch_tickers(params={'category': 'linear'})\r\n\r\n        processed_symbols = [symbol for symbol in tickers.keys() if symbol.endswith(\"USDT\")]\r\n\r\n        return processed_symbols\r\n\r\n    except ccxt.NetworkError as e:\r\n        print(f\"Network error: {e}\")\r\n    except ccxt.ExchangeError as e:\r\n        print(f\"Exchange error: {e}\")\r\n    except Exception as e:\r\n        print(f\"An error occurred: {e}\")\r\n\r\n# Get the list of linear symbols with USDT\r\nsymbols = get_symbol_list()\r\ndef get_kline_data(symbol, interval='1m', limit=1):\r\n    exchange.load_markets()\r\n    return exchange.fetch_ohlcv(symbol, timeframe=interval, limit=limit,params={'category': 'linear'})\r\nfor symbol in symbols:\r\n    pprint.pprint(get_kline_data(symbol))\r\n```",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/24358/comments",
    "author": "amiglesia",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2024-11-24T14:13:50Z",
        "body": "Hello @amiglesia,\r\n\r\nFirst of all I would suggest using the unified symbols instead to avoid clashes\r\n\r\nIn this case\r\n```\r\nMAJOR/USDT => spot\r\nMAJOR/USDT:USDT => linear perp\r\n```\r\n\r\nRegarding your issue, I don't think that bybit provides the spot `MAJOR/USDT` market hence the error you're getting"
      },
      {
        "user": "amiglesia",
        "created_at": "2024-11-24T14:32:00Z",
        "body": "Hi @carlosmiei \r\nThank you for quick response.\r\n\r\nYes, i also tried the unified symbol manually.\r\n```python\r\npprint.pprint(exchange.fetch_ohlcv('MAJOR/USDT:USDT'))\r\npprint.pprint(exchange.fetch_ohlcv('MAJOR/USDT'))\r\npprint.pprint(exchange.fetch_ohlcv('MAJORUSDT'))\r\n```\r\nbut all instances leads to error.\r\n```\r\nccxt.base.errors.BadSymbol: bybit does not have market symbol MAJORUSDT\r\nccxt.base.errors.BadSymbol: bybit does not have market symbol MAJOR/USDT:USDT\r\nccxt.base.errors.BadSymbol: bybit does not have market symbol MAJOR/USDT\r\n```\r\n\r\nalso using the exchange.fetch_tickers(params={'category': 'linear'})\r\nreturn the ticker MAJORUSDT while other in their linear perp symbol\r\n```\r\n'MAGIC/USDT:USDT'\r\n'MAJORUSDT'\r\n'MANA/USDT:USDT'\r\n'MANEKI/USDT:USDT'\r\n```"
      },
      {
        "user": "carlosmiei",
        "created_at": "2024-11-24T14:59:25Z",
        "body": "@amiglesia \r\n\r\nAre you sure that your markets are updated? If you have a long running instance can you please try to do `exchange.load_markets(True)` to refresh the cache?\r\n\r\nI just tested it and seems to be working as expected\r\n\r\n```\r\n p bybit fetchOHLCV \"MAJOR/USDT:USDT\" 1h None 5 --no-keys\r\nPython v3.12.3\r\nCCXT v4.4.33\r\nbybit.fetchOHLCV(MAJOR/USDT:USDT,1h,None,5)\r\n[[1732442400000, 1.3969, 1.4178, 1.366, 1.3681, 5493.3],\r\n [1732446000000, 1.3681, 1.4353, 1.3236, 1.33, 12656.7],\r\n [1732449600000, 1.33, 1.379, 1.02, 1.13, 130550.8],\r\n [1732453200000, 1.13, 1.241, 1.13, 1.182, 44810.0],\r\n [1732456800000, 1.182, 1.1952, 1.1179, 1.1585, 22694.8]]\r\n```\r\n"
      },
      {
        "user": "gcheng24",
        "created_at": "2024-11-25T01:27:38Z",
        "body": "@amiglesia I got this error too and updating the ccxt module fixed it"
      },
      {
        "user": "amiglesia",
        "created_at": "2024-11-25T04:59:58Z",
        "body": "confirm, updating the ccxt module fixed this. thank you. "
      },
      {
        "user": "carlosmiei",
        "created_at": "2024-11-25T10:05:18Z",
        "body": "@gcheng24 @amiglesia Thanks for confirming it!"
      }
    ],
    "satisfaction_conditions": [
      "Solution must ensure compatibility with Bybit's linear perpetual contract symbol format",
      "Answer must address proper market data refresh mechanisms",
      "Solution requires using a CCXT version that supports Bybit's current API structure",
      "Must handle distinction between spot and linear perpetual markets"
    ]
  },
  {
    "number": 24323,
    "title": "Futures disabled for Spanish accounts",
    "created_at": "2024-11-20T19:35:09Z",
    "closed_at": "2024-11-21T18:33:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/24323",
    "body": "### Operating System\n\n_No response_\n\n### Programming Languages\n\n_No response_\n\n### CCXT Version\n\n_No response_\n\n### Description\n\nIt seems that futures are not allowed anymore in Spain, so I can\u00b4t access to the fapi anymore. It is possible to configure ccxt to use sapi instead?\n\n### Code\n\n```\r\n\u2002\u2002\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/24323/comments",
    "author": "jmunozvalencia",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2024-11-20T21:59:23Z",
        "body": "Hello @jmunozvalencia,\r\n\r\nsapi should only be used to trade spot markets whereas fapi is the API for futures trading. \r\n\r\nIf you can't access it from spain, you have to find an alternative if you still want to trade futures but that alternative is not related to CCXT there's nothing we can do on our side to lift that block. \r\n\r\n"
      },
      {
        "user": "jmunozvalencia",
        "created_at": "2024-11-21T18:02:53Z",
        "body": "It seems that fetch_my_trades uses fapi by  default and that\u015b is able to return the spot trades, however it is not longer working anymore because futures are not allowed anymore. My question is if it is possible to change fetch_my_trades to use sapi instead. Thanks"
      },
      {
        "user": "carlosmiei",
        "created_at": "2024-11-21T18:17:26Z",
        "body": "@jmunozvalencia \r\n\r\nIf you provide a `spot` symbol, then ccxt will use `sapi`, if you provide a perp/future `symbol` ccxt will use `fapi` "
      },
      {
        "user": "jmunozvalencia",
        "created_at": "2024-11-21T18:24:52Z",
        "body": "You are right, I was getting all the trades for the symbols returned in exchange.symbols. That includes the perp/future symbols and was failing because I don\u00b4t have access to fapi. However, if I only use the spot symbols, it uses sapi and it works fine. Thanks, problem solved!"
      },
      {
        "user": "carlosmiei",
        "created_at": "2024-11-21T18:33:02Z",
        "body": "@jmunozvalencia Np \ud83d\ude42 "
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how CCXT selects API endpoints (sapi/fapi) based on symbol type",
      "Method to filter/select only spot market symbols when making API calls",
      "Solution must work without modifying CCXT's internal code",
      "Clear distinction between spot and futures symbol handling in CCXT"
    ]
  },
  {
    "number": 23650,
    "title": "Gateio futures does not work with CCXT Pro",
    "created_at": "2024-09-05T22:51:29Z",
    "closed_at": "2024-09-08T15:10:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/23650",
    "body": "### Operating System\n\nWindows 11\n\n### Programming Languages\n\nPHP\n\n### CCXT Version\n\n4.3.96\n\n### Description\n\nHello! When I use 'defaultType' => 'swap' in the constructor parameters and then use the create_order_ws method, I get an open position on spot market instead of futures. Is this a bug? Thank you.\n\n### Code\n\n```\r\n$config = [\r\n    'apiKey' => $this->key,\r\n    'secret' => $this->secret,\r\n    'options' => [\r\n        'defaultType' => 'swap' // for perpetual futures\r\n    ],\r\n];\r\n$this->gateWs = new \\ccxt\\pro\\gateio($config);\r\n\r\n/* some other code*/\r\n\r\n$data = yield $this->gateWs->create_order_ws(\r\n    'XRP/USDT',\r\n    'market',\r\n    'buy',\r\n    10,\r\n    $this->tickers['XRP']\r\n); // This opens an order on the spot market, not futures\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/23650/comments",
    "author": "Jekamajor",
    "comments": [
      {
        "user": "sc0Vu",
        "created_at": "2024-09-05T23:04:00Z",
        "body": "@Jekamajor The symbol represents spot market. The market id would be XRP/USDT:USDT for swap. Could you try this market?"
      },
      {
        "user": "Jekamajor",
        "created_at": "2024-09-06T08:50:43Z",
        "body": "> @Jekamajor The symbol represents spot market. The market id would be XRP/USDT:USDT for swap. Could you try this market?\r\n\r\nYes, thanks, with XRP/USDT:USDT  the request goes to futures, but now I'm getting this exception message after calling the create_order_ws method \r\n\r\n`{\"header\":{\"response_time\":\"1725612393633\",\"status\":\"400\",\"channel\":\"futures.order_place\",\"event\":\"api\",\"client_id\":\"11.22.33.44-0xc13d915541\"},\"data\":{\"errs\":{\"label\":\"INVALID_REQUEST\",\"message\":\"Mismatch type string with value number \\\"at index 58: mismatched type with value\\\\n\\\\n\\\\t:\\\\\\\"usdt\\\\\\\",\\\\\\\"price\\\\\\\":0,\\\\\\\"tif\\\\\\\":\\\\\\\"ioc\\\\\\\",\\\\\\\"t\\\\n\\\\t................^...............\\\\n\\\"\"}},\"request_id\":\"10\"}`"
      },
      {
        "user": "carlosmiei",
        "created_at": "2024-09-06T11:10:55Z",
        "body": "@Jekamajor Can you show us the message sent to the exchange please?\n\n---\n\n@Jekamajor managed to reproduce the issue, working on a fix right now"
      },
      {
        "user": "Jekamajor",
        "created_at": "2024-09-06T11:31:05Z",
        "body": "> @Jekamajor Can you show us the message sent to the exchange please?\r\n\r\nIf I understood you correctly, here is the log after enabling verbose mode after calling create_order_ws method\r\n\r\n```2024-09-06T13:25:09+02:00 sending {\"id\":\"authenticated\",\"time\":1725621907,\"channel\":\"futures.login\",\"event\":\"api\",\"payload\":{\"req_id\":\"authenticated\",\"timestamp\":\"1725621907\",\"api_key\":\"xxx\",\"signature\":\"yyy\",\"req_param\":[]}}\r\n2024-09-06T13:25:09+02:00 on_message {\"header\":{\"response_time\":\"1725621911059\",\"status\":\"200\",\"channel\":\"futures.login\",\"event\":\"api\",\"client_id\":\"11.22.33.44-0xc2ebc55e00\"},\"data\":{\"result\":{\"uid\":\"7385430\",\"api_key\":\"xxx\"}},\"request_id\":\"authenticated\"}\r\n2024-09-06T13:25:09+02:00 sending {\"id\":\"8\",\"time\":1725621909,\"channel\":\"futures.order_place\",\"event\":\"api\",\"payload\":{\"req_id\":\"8\",\"timestamp\":\"1725621909\",\"api_key\":\"xxx\",\"signature\":\"yyy\",\"req_param\":{\"contract\":\"XRP_USDT\",\"size\":10,\"settle\":\"usdt\",\"price\":0,\"tif\":\"ioc\",\"text\":\"t-8aa266b5785551c5\",\"textIsRequired\":true}}}\r\n2024-09-06T13:25:10+02:00 on_message {\"header\":{\"response_time\":\"1725621911413\",\"status\":\"200\",\"channel\":\"futures.order_place\",\"event\":\"api\",\"client_id\":\"11.22.33.44-0xc2ebc55e00\",\"conn_id\":\"56932c...83\",\"trace_id\":\"9b4ad1d0...a010d03cbbcf6cc\"},\"data\":{\"result\":{\"req_id\":\"8\",\"api_key\":\"xxx\",\"timestamp\":\"1725621909\",\"signature\":\"yyy\",\"trace_id\":\"9b4ad1d0...f6cc\",\"text\":\"\",\"req_header\":{\"trace_id\":\"9b4ad1d...bcf6cc\"},\"req_param\":{\"size\":10,\"settle\":\"usdt\",\"price\":0,\"tif\":\"ioc\",\"text\":\"t-8aa266b5785551c5\",\"textIsRequired\":true,\"contract\":\"XRP_USDT\"}}},\"request_id\":\"8\",\"ack\":true}\r\n2024-09-06T13:25:10+02:00 on_message {\"header\":{\"response_time\":\"1725621911413\",\"status\":\"400\",\"channel\":\"futures.order_place\",\"event\":\"api\",\"client_id\":\"11.22.33.44-0xc2ebc55e00\"},\"data\":{\"errs\":{\"label\":\"INVALID_REQUEST\",\"message\":\"Mismatch type string with value number \\\"at index 35: mismatched type with value\\\\n\\\\n\\\\t:\\\\\\\"usdt\\\\\\\",\\\\\\\"price\\\\\\\":0,\\\\\\\"tif\\\\\\\":\\\\\\\"ioc\\\\\\\",\\\\\\\"t\\\\n\\\\t................^...............\\\\n\\\"\"}},\"request_id\":\"8\"}```"
      },
      {
        "user": "carlosmiei",
        "created_at": "2024-09-08T13:22:47Z",
        "body": "@Jekamajor Thanks, the issue will be fixed in the linked PR.\n\n---\n\n@Jekamajor Can you please update your ccxt version and try again? It should be working now"
      },
      {
        "user": "Jekamajor",
        "created_at": "2024-09-08T14:59:34Z",
        "body": "@carlosmiei Yes, now the market order works. Thank you!!! "
      }
    ],
    "satisfaction_conditions": [
      "Correctly identifies the required market symbol format for Gateio futures trading",
      "Ensures proper parameter serialization for API requests",
      "Validates library compatibility with Gateio's futures WebSocket endpoint",
      "Provides working market order execution on futures contracts"
    ]
  },
  {
    "number": 23352,
    "title": "load_markets().keys() differ from fetch_tickers()",
    "created_at": "2024-08-07T13:52:52Z",
    "closed_at": "2024-08-07T15:30:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/23352",
    "body": "### Operating System\n\nWin 10\n\n### Programming Languages\n\nPython\n\n### CCXT Version\n\n4.3.73\n\n### Description\n\nI expect the code below to produce the same numbers (2542/2542), but it actually prints (2542/437). Why is this happening? It\u2019s particularly strange because the markets from load_markets are currently trading, yet fetch_tickers does not display them. This function (fetch_tickers) should be used for active tickers.\n\n### Code\n\n```\r\nasync def debug():\r\n    exchange = ccxt.bybit({logging_data})\r\n    markets = await exchange.load_markets(True)\r\n    tickers = await exchange.fetch_tickers()\r\n    print(len(markets.keys()))\r\n    print(len(tickers))\r\n    await exchange.close()\r\nasyncio.run(debug())\r\n\r\n```\r\nresult\r\n```\r\n2542\r\n437\r\n```",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/23352/comments",
    "author": "kapedalex",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2024-08-07T15:20:39Z",
        "body": "Hello @kapedalex, `loadMarkets/fetchMarkets` is a \"special\" function that performs several calls to load all the available markets (swap, spot, options, etc) and currencies.  (most of the markets you see are options and delivery futures)\r\n\r\n`fetchTicker/fetchTickers` only performs one rest call, so they can only load one part of the markets. If you want to load all of them you need to call `fetch_tickers` multiple types using `type` in `params`, example:\r\n\r\n\r\n```Python\r\nswap_tickers = await bybit.fetch_tickers() # by default returns linear swaps\r\nspot_tickers = await bybit.fetch_tickers(params = {'type':'spot'})\r\ninverse_tickers = await bybit.fetch_tickers(params = {'subType':'inverse'})\r\noption_tickers = await bybit.fetch_tickers(params = {'type':'option'})\r\n```\r\n(ofc you can use asyncio.gather and do them concurrently)\r\n\r\n"
      },
      {
        "user": "kapedalex",
        "created_at": "2024-08-07T15:30:18Z",
        "body": "Ah, ok, thanks a lot!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why `load_markets()` and `fetch_tickers()` return different counts",
      "Clarification about API endpoint limitations for fetching tickers",
      "Guidance on retrieving full market coverage through multiple calls",
      "Differentiation between market loading vs real-time data fetching mechanics"
    ]
  },
  {
    "number": 22871,
    "title": "What is the best way to re-connect",
    "created_at": "2024-06-23T09:55:43Z",
    "closed_at": "2024-07-20T08:49:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/22871",
    "body": "### Operating System\n\nlinux\n\n### Programming Languages\n\nPython\n\n### CCXT Version\n\nAll\n\n### Description\n\nWhen I have any error in a webscoket stream or any forever loop what is the best practice to re-connect with exchange, for eg a network error.\r\nRight Now I am doing this: closing in case of exception and again instantiation ccxt.okx for eg.\n\n### Code\n\n```\r\n\u2002\u2002    async def stream_balance_update(self, symbol,cb):\r\n        while True:\r\n            bl = None\r\n            try:\r\n                bal = await self.exch.watch_balance(params={\"extraParams\": '{\"updateInterval\": 0}'})\r\n                bl = {}\r\n                for d in list(bal[\"free\"].keys()):\r\n                    d = Balance().load(d, bal)\r\n                    bl[d.asset] = d\r\n                # logger.info(bl)\r\n                await cb(bl) if cb else None\r\n            except Exception as e:\r\n                logger.info(type(e).__name__, e)\r\n                logger.info('stream_account_update:', bal)\r\n                logger.info(traceback.format_exc())\r\n                await self.exch.close()\r\n                self.connect()\r\n\r\n    def connect(self):\r\n        if self.exchange_name == 'okx':\r\n            self.exch = ccxt.okx({\r\n                'enableRateLimit': True,\r\n                'logger': None,\r\n                'apiKey': self.api_key,\r\n                'secret': self.secret,\r\n                \"password\": self.passphrase,\r\n            })\r\n        else:\r\n            raise Exception('Exchange not supported')\r\n\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/22871/comments",
    "author": "duggar",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2024-06-23T16:43:57Z",
        "body": "Hello @duggar, \r\n\r\nYou don't need to call `self.connect` here because you don't need to recreate the instance, `self.exc.close()` should be enough to close all pending WS connections, and then the next iteration of the loop will call `watchX` again and reconnect automatically.  "
      }
    ],
    "satisfaction_conditions": [
      "Explains how to properly handle WebSocket reconnections in CCXT after network errors",
      "Clarifies whether exchange instance recreation is required for reconnection",
      "Identifies best practices for error recovery in persistent WebSocket connections",
      "Addresses resource management for WebSocket connections in CCXT"
    ]
  },
  {
    "number": 22779,
    "title": "C# WatchOrders Hyperliquid Subscriptions",
    "created_at": "2024-06-11T08:33:28Z",
    "closed_at": "2024-06-11T10:28:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/22779",
    "body": "### Operating System\r\n\r\nUbuntu 22.04\r\n\r\n### Programming Languages\r\n\r\n_No response_\r\n\r\n### CCXT Version\r\n\r\n4.3.42\r\n\r\n### Description\r\n \r\nNone of following code results in order status being received for Hyperliquid. I am using C#. I am providing walletAddress to exchange in parameters of exchange object. Has this function been tested? Does it work properly? May there be something that I am missing?\r\n\r\n### Code\r\n\r\n```\r\n\u2002\u2002var ordersTask = this.exchange.WatchOrders();\r\n   ordersTask.Wait();\r\n   Logger.Debug($\"Orders received: {ordersTask.Result.Count()}.\");\r\n\r\n   var ordersTask = this.exchange.WatchOrders(\"SOL/USDC:USDC\");\r\n   ordersTask.Wait();\r\n   Logger.Debug($\"Orders received: {ordersTask.Result.Count()}.\");\r\n\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/22779/comments",
    "author": "JakubMartinovicHusar",
    "comments": [
      {
        "user": "JakubMartinovicHusar",
        "created_at": "2024-06-11T09:07:16Z",
        "body": "I ran the same code for binance futures and it worked just fine."
      },
      {
        "user": "carlosmiei",
        "created_at": "2024-06-11T09:46:46Z",
        "body": "Hello @JakubMartinovicHusar, we will take a look and revert\n\n---\n\n@JakubMartinovicHusar I just tested and it seems to be working\r\n\r\n```\r\n npm run cli.cs -- hyperliquid WatchOrders \"SOL/USDC:USDC\" --verbose --sandbox\r\n\r\n> ccxt@4.3.42 cli.cs\r\n> dotnet run --project \"./cs/cli/cli.csproj\" hyperliquid WatchOrders SOL/USDC:USDC --verbose --sandbox\r\n\r\n[\r\n  \"SOL/USDC:USDC\"\r\n]\r\nWebSocket connected to wss://api.hyperliquid-testnet.xyz/ws\r\nSending message: {\"method\":\"subscribe\",\"subscription\":{\"type\":\"orderUpdates\",\"user\":\"0x3B3741c0EFf9C6b556Ec813e70589161F416662A\"}}\r\nOn message: {\"channel\":\"subscriptionResponse\",\"data\":{\"method\":\"subscribe\",\"subscription\":{\"type\":\"orderUpdates\",\"user\":\"0x3b3741c0eff9c6b556ec813e70589161f416662a\"}}}\r\nOn message: {\"channel\":\"orderUpdates\",\"data\":[{\"order\":{\"coin\":\"SOL\",\"side\":\"B\",\"limitPx\":\"183.75\",\"sz\":\"0.1\",\"oid\":9893803368,\"timestamp\":1718099116378,\"origSz\":\"0.1\"},\"status\":\"open\",\"statusTimestamp\":1718099116378},{\"order\":{\"coin\":\"SOL\",\"side\":\"B\",\"limitPx\":\"183.75\",\"sz\":\"0.0\",\"oid\":9893803368,\"timestamp\":1718099116378,\"origSz\":\"0.1\"},\"status\":\"filled\",\"statusTimestamp\":1718099116378}]}\r\n[\r\n  {\r\n    \"id\": \"9893803368\",\r\n    \"clientOrderId\": null,\r\n    \"timestamp\": 1718099116378,\r\n    \"datetime\": \"2024-06-11T09:45:16.378Z\",\r\n    \"lastTradeTimestamp\": null,\r\n    \"symbol\": \"SOL/USDC:USDC\",\r\n    \"type\": null,\r\n    \"side\": \"buy\",\r\n    \"price\": 183.75,\r\n    \"cost\": null,\r\n    \"average\": null,\r\n    \"amount\": null,\r\n    \"filled\": null,\r\n    \"triggerPrice\": null,\r\n    \"stopLossPrice\": null,\r\n    \"takeProfitPrice\": null,\r\n    \"remaining\": 0.0,\r\n    \"status\": \"closed\",\r\n    \"reduceOnly\": false,\r\n    \"postOnly\": false,\r\n    \"fee\": {\r\n      \"rate\": null,\r\n      \"cost\": null\r\n    },\r\n    \"trades\": [],\r\n    \"info\": {\r\n      \"order\": {\r\n        \"coin\": \"SOL\",\r\n        \"side\": \"B\",\r\n        \"limitPx\": \"183.75\",\r\n        \"sz\": \"0.0\",\r\n        \"oid\": 9893803368,\r\n        \"timestamp\": 1718099116378,\r\n        \"origSz\": \"0.1\"\r\n      },\r\n      \"status\": \"filled\",\r\n      \"statusTimestamp\": 1718099116378\r\n    }\r\n  }\r\n]\r\n```\r\n\r\n@JakubMartinovicHusar If you enable the verbose mode can you check which wallet is being used to subscribe?\r\n"
      },
      {
        "user": "JakubMartinovicHusar",
        "created_at": "2024-06-11T10:12:36Z",
        "body": "@carlosmiei thank you for answer. \r\n\r\nI have investigated it further as you suggested and it indeed works. I had to add explicit user parameter. I was using only walletAddress parameter when instantiating exchange which is eventual API wallet key. You need to specify user - wallet address to watch orders. \r\nvar ordersTask = this.exchange.WatchOrders(\r\n                        parameters: new Dictionary<string, object>(){{\"user\", \"0x...4\"}}\r\n                    );\r\n\r\n@carlosmiei thank your for your help!"
      },
      {
        "user": "carlosmiei",
        "created_at": "2024-06-11T10:23:46Z",
        "body": "@JakubMartinovicHusar Glad it worked now, but just to make it clear you just need to specify `user` if it's different from the `walletAddress`. Alternatively, you can set it in the options so you don't need to provide it manually every single time, example:\r\n\r\n```C#\r\nexchange.options[\"user\"] = \"new address\"; // will override `walletAddress` whenever it's needed\r\n```\r\n"
      },
      {
        "user": "JakubMartinovicHusar",
        "created_at": "2024-06-11T10:27:28Z",
        "body": "Even better! Thank you @carlosmiei!"
      },
      {
        "user": "carlosmiei",
        "created_at": "2024-06-11T10:28:58Z",
        "body": "@JakubMartinovicHusar No problem! Will close this issue then, feel free to re-open it if needed. \r\nThanks!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of required parameters for Hyperliquid order subscriptions",
      "Clarification on relationship between walletAddress and user parameters",
      "Guidance on persistent configuration of exchange options",
      "Verification of WatchOrders functionality for Hyperliquid"
    ]
  },
  {
    "number": 22447,
    "title": "Cancelling orders does not work on OKX",
    "created_at": "2024-05-09T14:17:59Z",
    "closed_at": "2024-05-10T11:49:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/22447",
    "body": "### Operating System\r\n\r\nMac OS Sonoma 14.1.1\r\n\r\n### Programming Languages\r\n\r\nPython\r\n\r\n### CCXT Version\r\n\r\n4.3.18\r\n\r\n### Description\r\n\r\nUsing the test code to open and cancel an order, it leaves an order uncancelled. Thank you for your help ahead of time.\r\n\r\n### Code\r\n\r\n```\r\n\u2002\u2002\r\ndef close_positions():\r\n    # Fetch open orders\r\n    open_orders = exchange.fetch_open_orders()\r\n\r\n    # Cancel all open orders\r\n    for order in open_orders:\r\n        exchange.cancel_order(order['id'], order['symbol'])\r\n\r\n\r\ndef test_orders():\r\n    order = exchange.create_order(symbol= symbol, type = \"market\", side = \"buy\", amount=10.0)\r\n    time.sleep(10)\r\n    #exchange.cancel_order(order['id'], symbol)\r\n    close_positions()\r\n    print(\"test complete\")\r\n\r\ntest_orders()\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/22447/comments",
    "author": "MrMechanical",
    "comments": [
      {
        "user": "MrMechanical",
        "created_at": "2024-05-09T14:32:05Z",
        "body": "after debugging I believe the issue is with fetch_open_orders as open_orders is empty during testing\r\nopen_orders\r\n[]"
      },
      {
        "user": "sc0Vu",
        "created_at": "2024-05-10T05:23:21Z",
        "body": "@MrMechanical because the order type is market, and it would be matched when you create. You can use `fetchClosedOrders` instead."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why market orders don't appear in open orders",
      "Clarification on order lifecycle differences between order types",
      "Guidance on proper order status verification methods",
      "Differentiation between cancellable and non-cancellable order states"
    ]
  },
  {
    "number": 21862,
    "title": "ClosedOrders does not work on Binance Swap - ExchangeError: binance {\"code\":-4166,\"msg\":\"Search window is restricted to recent 90 days only.\"}",
    "created_at": "2024-03-21T17:19:33Z",
    "closed_at": "2024-03-22T11:56:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/21862",
    "body": "### Operating System\r\n\r\n_No response_\r\n\r\n### Programming Languages\r\n\r\n_No response_\r\n\r\n### CCXT Version\r\n\r\n4.2.79 \r\n\r\n### Description\r\n\r\nTry to load closed orders but doesn't work for me\r\n\r\n### Code\r\n\r\n```\r\nfetchCanceledAndClosedOrders('FET/USDT:USDT', 1705857391, 10)\r\nor\r\nfetchClosedOrders('FET/USDT:USDT', 1705857391, 10)\r\n\r\nbut SPOT pair \r\nfetchClosedOrders('FET/USDT', 1705857391, 10)\r\ndoes work\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/21862/comments",
    "author": "tom-teamcoda",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2024-03-21T18:06:00Z",
        "body": "Hello @tom-teamcoda, unfortunately that's a restriction on the exchange side (spot and swap use different apis so they might have different limits/restrictions).\r\n\r\nWith that said, there's nothing ccxt can do about it. \r\n"
      },
      {
        "user": "tom-teamcoda",
        "created_at": "2024-03-21T18:07:10Z",
        "body": "I'm sorry but even with timestamp from 1 day ago it does not work "
      },
      {
        "user": "carlosmiei",
        "created_at": "2024-03-21T18:35:42Z",
        "body": "@tom-teamcoda That's because you're providing the timestamp in seconds instead of milliseconds (the unified format accepted by ccxt).\r\n\r\nCan you try that?"
      },
      {
        "user": "tom-teamcoda",
        "created_at": "2024-03-22T19:57:49Z",
        "body": "Yeah works. Also without Params"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of timestamp format requirements for Binance Swap API",
      "Clarification of parameter handling differences between Spot and Swap markets",
      "Guidance on default parameter behavior when not specified"
    ]
  },
  {
    "number": 21707,
    "title": " probit access token expired",
    "created_at": "2024-03-14T02:07:32Z",
    "closed_at": "2024-03-14T03:06:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/21707",
    "body": "### Operating System\n\nxampp, win10\n\n### Programming Languages\n\nPHP\n\n### CCXT Version\n\nlastest\n\n### Description\n\nHi;\r\nI've made create_order in probit exchange but got error:\r\n\r\nFatal error: Uncaught ccxt\\AuthenticationError: probit access token expired, call signIn() method in C:\\xampp\\htdocs\\main\\ccxt11t3\\php\\probit.php:1777 Stack trace: #0 C:\\xampp\\htdocs\\main\\ccxt11t3\\php\\Exchange.php(4404): ccxt\\probit->sign('new_order', 'private', 'POST', Array, NULL, NULL) #1 C:\\xampp\\htdocs\\main\\ccxt11t3\\php\\Exchange.php(4412): ccxt\\Exchange->fetch2('new_order', 'private', 'POST', Array, NULL, NULL, Array) #2 C:\\xampp\\htdocs\\main\\ccxt11t3\\php\\abstract\\probit.php(92): ccxt\\Exchange->request('new_order', 'private', 'POST', Array, NULL, NULL, Array) #3 C:\\xampp\\htdocs\\main\\ccxt11t3\\php\\probit.php(1240): ccxt\\abstract\\probit->privatePostNewOrder(Array) #4 C:\\xampp\\htdocs\\main\\ccxt11t3\\probitORDER.php(52): ccxt\\probit->create_order('BTC-USDT', 'LIMIT', 'buy', 0.0003, 50000.0) #5 {main} thrown in C:\\xampp\\htdocs\\main\\ccxt11t3\\php\\probit.php on line 1777\r\n\r\nHow can i get this worked? thank for your support!\r\n\n\n### Code\n\n```\r\n\u2002\u2002$poloniex   = new \\ccxt\\probit   (array (\r\n    'apiKey' => 'xxx',\r\n    'secret' => 'xxxx',\r\n));\r\n\r\n\r\n$poloniex_markets = $poloniex->load_markets ();\r\n$poloniex->create_order ('BTC-USDT', 'LIMIT', 'buy', 0.0001, 50000, array ('client_order_id' => '123'));\r\n\r\n\r\n\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/21707/comments",
    "author": "haitokt",
    "comments": [
      {
        "user": "sc0Vu",
        "created_at": "2024-03-14T02:12:22Z",
        "body": "@haitokt I think you can signIn to retrieve another token."
      },
      {
        "user": "haitokt",
        "created_at": "2024-03-14T03:06:09Z",
        "body": "thank you, it worked!"
      }
    ],
    "satisfaction_conditions": [
      "Handling of expired access tokens through re-authentication",
      "Automatic or manual token refresh integration with API calls",
      "Clear guidance on authentication workflow for Probit exchange"
    ]
  },
  {
    "number": 21595,
    "title": " calculate_fee() missing 1 required positional argument: 'self'",
    "created_at": "2024-03-07T18:33:35Z",
    "closed_at": "2024-03-07T18:40:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/21595",
    "body": "### Operating System\n\nubuntu 20.04\n\n### Programming Languages\n\nPython\n\n### CCXT Version\n\n4.2.48\n\n### Description\n\nExample to reproduce : \r\n\r\nTraceback (most recent call last):\r\n  File \"/home/localuser/calculation.py\", line 30, in <module>\r\n    returned=ccxt.binance.calculate_fee(symbol=symbol, type=type, side=side,\r\nTypeError: calculate_fee() missing 1 required positional argument: 'self'\r\n\n\n### Code\n\n```\r\n\u2002exchange = ccxt.binance({\r\n    \"apiKey\": API_KEY,\r\n    \"secret\": API_SECRET\r\n})\r\n\r\nexchange.load_markets()\r\n\r\n\r\n#BUY BUY SELL\r\nsymbol = 'ETH/BTC'\r\ntype = 'limit'\r\nside = 'buy'\r\namount=0.1\r\nprice=0.05704\r\ntotal=float(amount*price)\r\n\r\nreturned=ccxt.binance.calculate_fee(symbol=symbol, type=type, side=side, amount=amount, price=price)\r\nprint(returned)\u2002\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/21595/comments",
    "author": "VeilleurTrytoFix",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2024-03-07T18:40:57Z",
        "body": "Hello @VeilleurTrytoFix,\r\n\r\nYou're calling it as a static method (ccxt.binance.calculate_fee) but it's not, you should do it instead\r\n\r\n`exchange.calculate_fee(symbol=symbol, type=type, side=side, amount=amount, price=price)`\n\n---\n\nJust tested and worked\r\n\r\n```\r\nPython v3.11.7\r\nCCXT v4.2.64\r\nbinanceusdm.calculateFee(BTC/USDT:USDT,limit,buy,0.1,50)\r\n{'cost': 4e-05, 'currency': 'USDT', 'rate': 0.0004, 'type': 'taker'}\r\n```\r\n"
      },
      {
        "user": "VeilleurTrytoFix",
        "created_at": "2024-03-07T18:50:12Z",
        "body": "it works thank guy !\r\n\r\ncan you explain \"rate\" returned value ? cannot find anything in doc"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why instance methods require an instance context in Python",
      "Clarification of the 'rate' field in calculate_fee() return value",
      "Documentation of fee calculation parameters and return structure",
      "Guidance on proper CCXT exchange instance usage"
    ]
  },
  {
    "number": 21290,
    "title": "How to update pair list for specific exchange ?",
    "created_at": "2024-02-20T09:25:47Z",
    "closed_at": "2024-02-20T11:25:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/21290",
    "body": "### Operating System\r\n\r\nubuntu 20.04\r\n\r\n### Programming Languages\r\n\r\nPython\r\n\r\n### CCXT Version\r\n\r\nccxt-4.2.47\r\n\r\n### Description\r\n\r\nHi all,\r\n\r\nI'm looking for how to update the pair available on spot market for binance exchange : \r\n\r\nCCXT trying to post an order on : XMR/ETH,XMR/BTC,PAXG/BNB or these pair are not available on binance spot market\r\n\r\nHow can i update the available pair ?\r\n\r\nin my below example :  **'spot': True,** its wrong, binance deleted XMR from market list\r\n\r\nThanks\r\n\r\n### Code\r\n\r\n```py\r\nexchange.load_markets()\r\nprint(exchange.markets['XMR/ETH'])\r\n\u2002\r\n{'id': 'XMRETH', 'lowercaseId': 'xmreth', 'symbol': 'XMR/ETH', 'base': 'XMR', 'quote': 'ETH', 'settle': None, 'baseId': 'XMR', 'quoteId': 'ETH', 'settleId': None, 'type': 'spot', 'spot': True, 'margin': False, 'swap': False, 'future': False, 'option': False, 'index': None, 'active': False, 'contract': False, 'linear': None, 'inverse': None, 'subType': None, 'taker': 0.001, 'maker': 0.001, 'contractSize': None, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 3, 'price': 5, 'cost': None, 'base': 8, 'quote': 8}, 'limits': {'leverage': {'min': None, 'max': None}, 'amount': {'min': 0.001, 'max': 9000000.0}, 'price': {'min': 1e-05, 'max': 1000.0}, 'cost': {'min': 0.001, 'max': 9000000.0}, 'market': {'min': 0.0, 'max': 225.56396694}}, 'created': None, 'info': {'symbol': 'XMRETH', 'status': 'BREAK', 'baseAsset': 'XMR', 'baseAssetPrecision': '8', 'quoteAsset': 'ETH', 'quotePrecision': '8', 'quoteAssetPrecision': '8', 'baseCommissionPrecision': '8', 'quoteCommissionPrecision': '8', 'orderTypes': ['LIMIT', 'LIMIT_MAKER', 'MARKET', 'STOP_LOSS_LIMIT', 'TAKE_PROFIT_LIMIT'], 'icebergAllowed': True, 'ocoAllowed': True, 'quoteOrderQtyMarketAllowed': True, 'allowTrailingStop': True, 'cancelReplaceAllowed': True, 'isSpotTradingAllowed': True, 'isMarginTradingAllowed': False, 'filters': [{'filterType': 'PRICE_FILTER', 'minPrice': '0.00001000', 'maxPrice': '1000.00000000', 'tickSize': '0.00001000'}, {'filterType': 'LOT_SIZE', 'minQty': '0.00100000', 'maxQty': '9000000.00000000', 'stepSize': '0.00100000'}, {'filterType': 'ICEBERG_PARTS', 'limit': '10'}, {'filterType': 'MARKET_LOT_SIZE', 'minQty': '0.00000000', 'maxQty': '225.56396694', 'stepSize': '0.00000000'}, {'filterType': 'TRAILING_DELTA', 'minTrailingAboveDelta': '10', 'maxTrailingAboveDelta': '2000', 'minTrailingBelowDelta': '10', 'maxTrailingBelowDelta': '2000'}, {'filterType': 'PERCENT_PRICE_BY_SIDE', 'bidMultiplierUp': '5', 'bidMultiplierDown': '0.2', 'askMultiplierUp': '5', 'askMultiplierDown': '0.2', 'avgPriceMins': '5'}, {'filterType': 'NOTIONAL', 'minNotional': '0.00100000', 'applyMinToMarket': True, 'maxNotional': '9000000.00000000', 'applyMaxToMarket': False, 'avgPriceMins': '5'}, {'filterType': 'MAX_NUM_ORDERS', 'maxNumOrders': '200'}, {'filterType': 'MAX_NUM_ALGO_ORDERS', 'maxNumAlgoOrders': '5'}], 'permissions': ['SPOT', 'TRD_GRP_015', 'TRD_GRP_016', 'TRD_GRP_023', 'TRD_GRP_024', 'TRD_GRP_025'], 'defaultSelfTradePreventionMode': 'EXPIRE_MAKER', 'allowedSelfTradePreventionModes': ['EXPIRE_TAKER', 'EXPIRE_MAKER', 'EXPIRE_BOTH']}, 'percentage': True, 'feeSide': 'get', 'tierBased': False}\r\n\u2002\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/21290/comments",
    "author": "VeilleurTrytoFix",
    "comments": [
      {
        "user": "samgermain",
        "created_at": "2024-02-20T10:16:35Z",
        "body": "I'm not entirely sure what your asking, but if you want to refresh the markets that you've loaded from the exchange, you can can `load_markets` and assign `reload` to `True`\r\n\r\n```py\r\nload_markets(reload=True)\r\n```"
      },
      {
        "user": "VeilleurTrytoFix",
        "created_at": "2024-02-20T10:17:58Z",
        "body": "> I'm not entirely sure what your asking, but if you want to refresh the markets that you've loaded from the exchange, you can can `load_markets` and assign `reload` to `True`\r\n> \r\n> ```python\r\n> load_markets(reload=True)\r\n> ```\r\n\r\ni updated my comment with an example : \r\n\r\nprint(exchange.markets['XMR/ETH'])\r\n\r\nreturn : 'spot': True\r\n\r\nbinance deleted all XMR pair for trading on spot"
      },
      {
        "user": "samgermain",
        "created_at": "2024-02-20T10:38:37Z",
        "body": "> binance deleted all XMR pair for trading on spot\r\n\r\nYou can check if trading is enabled by checking the value of `active` on a market. If `active` is equal to `false` then trading is no longer enabled\r\n\r\n```py\r\n{\r\n  id: 'XMRETH',\r\n  lowercaseId: 'xmreth',\r\n  symbol: 'XMR/ETH',\r\n  base: 'XMR',\r\n  quote: 'ETH',\r\n  settle: undefined,\r\n  baseId: 'XMR',\r\n  quoteId: 'ETH',\r\n  settleId: undefined,\r\n  type: 'spot',\r\n  spot: true,\r\n  margin: false,\r\n  swap: false,\r\n  future: false,\r\n  option: false,\r\n  index: undefined,\r\n  active: false,                                            ##################### Here ####################\r\n  contract: false,\r\n  linear: undefined,\r\n  inverse: undefined,\r\n  subType: undefined,\r\n  taker: 0.001,\r\n  maker: 0.001,\r\n  contractSize: undefined,\r\n  expiry: undefined,\r\n  expiryDatetime: undefined,\r\n  strike: undefined,\r\n  optionType: undefined,\r\n  precision: { amount: 3, price: 5, base: 8, quote: 8 },\r\n  limits: {\r\n    leverage: { min: undefined, max: undefined },\r\n    amount: { min: 0.001, max: 9000000 },\r\n    price: { min: 0.00001, max: 1000 },\r\n    cost: { min: 0.001, max: 9000000 },\r\n    market: { min: 0, max: 225.56396694 }\r\n  },\r\n  created: undefined,\r\n  info: {\r\n    symbol: 'XMRETH',\r\n    status: 'BREAK',\r\n    baseAsset: 'XMR',\r\n    baseAssetPrecision: '8',\r\n    quoteAsset: 'ETH',\r\n    quotePrecision: '8',\r\n    quoteAssetPrecision: '8',\r\n    baseCommissionPrecision: '8',\r\n    quoteCommissionPrecision: '8',\r\n    orderTypes: [\r\n      'LIMIT',\r\n      'LIMIT_MAKER',\r\n      'MARKET',\r\n      'STOP_LOSS_LIMIT',\r\n      'TAKE_PROFIT_LIMIT'\r\n    ],\r\n    icebergAllowed: true,\r\n    ocoAllowed: true,\r\n    quoteOrderQtyMarketAllowed: true,\r\n    allowTrailingStop: true,\r\n    cancelReplaceAllowed: true,\r\n    isSpotTradingAllowed: true,\r\n    isMarginTradingAllowed: false,\r\n    filters: [\r\n      {\r\n        filterType: 'PRICE_FILTER',\r\n        minPrice: '0.00001000',\r\n        maxPrice: '1000.00000000',\r\n        tickSize: '0.00001000'\r\n      },\r\n      {\r\n        filterType: 'LOT_SIZE',\r\n        minQty: '0.00100000',\r\n        maxQty: '9000000.00000000',\r\n        stepSize: '0.00100000'\r\n      },\r\n      { filterType: 'ICEBERG_PARTS', limit: '10' },\r\n      {\r\n        filterType: 'MARKET_LOT_SIZE',\r\n        minQty: '0.00000000',\r\n        maxQty: '225.56396694',\r\n        stepSize: '0.00000000'\r\n      },\r\n      {\r\n        filterType: 'TRAILING_DELTA',\r\n        minTrailingAboveDelta: '10',\r\n        maxTrailingAboveDelta: '2000',\r\n        minTrailingBelowDelta: '10',\r\n        maxTrailingBelowDelta: '2000'\r\n      },\r\n      {\r\n        filterType: 'PERCENT_PRICE_BY_SIDE',\r\n        bidMultiplierUp: '5',\r\n        bidMultiplierDown: '0.2',\r\n        askMultiplierUp: '5',\r\n        askMultiplierDown: '0.2',\r\n        avgPriceMins: '5'\r\n      },\r\n      {\r\n        filterType: 'NOTIONAL',\r\n        minNotional: '0.00100000',\r\n        applyMinToMarket: true,\r\n        maxNotional: '9000000.00000000',\r\n        applyMaxToMarket: false,\r\n        avgPriceMins: '5'\r\n      },\r\n      { filterType: 'MAX_NUM_ORDERS', maxNumOrders: '200' },\r\n      { filterType: 'MAX_NUM_ALGO_ORDERS', maxNumAlgoOrders: '5' }\r\n    ],\r\n    permissions: [\r\n      'SPOT',\r\n      'TRD_GRP_015',\r\n      'TRD_GRP_016',\r\n      'TRD_GRP_023',\r\n      'TRD_GRP_024',\r\n      'TRD_GRP_025'\r\n    ],\r\n    defaultSelfTradePreventionMode: 'EXPIRE_MAKER',\r\n    allowedSelfTradePreventionModes: [ 'EXPIRE_TAKER', 'EXPIRE_MAKER', 'EXPIRE_BOTH' ]\r\n  },\r\n  tierBased: false,\r\n  percentage: true,\r\n  feeSide: 'get'\r\n}\r\n2024-02-20T10:32:58.334Z iteration 1 passed in 0 ms\r\n```"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how to refresh CCXT's market data to reflect current exchange offerings",
      "Clarification on how to identify inactive/removed trading pairs programmatically",
      "Differentiation between market type (spot) and trading availability status",
      "Method to verify current tradable pairs directly from exchange API"
    ]
  },
  {
    "number": 20372,
    "title": "fetch_bids_asks not working for Bitrue exchange",
    "created_at": "2023-12-14T10:20:29Z",
    "closed_at": "2023-12-14T11:02:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/20372",
    "body": "### Operating System\n\nMacOS\n\n### Programming Languages\n\nPython\n\n### CCXT Version\n\n4.1.83\n\n### Description\n\nThe executing the function call fetch_bids_asks it is throwing an exception error.\r\n\r\nException has occurred: BadSymbol       (note: full exception trace is shown but execution is paused at: _run_module_as_main)\r\nbitrue does not have market symbol W\r\n  File \"/python3.11/site-packages/ccxt/base/exchange.py\", line 3905, in market\r\n    raise BadSymbol(self.id + ' does not have market symbol ' + symbol)\r\n  File \"/python3.11/site-packages/ccxt/base/exchange.py\", line 2979, in market_symbols\r\n    market = self.market(symbols[i])\r\n             ^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/3.11.7/lib/python3.11/site-packages/ccxt/bitrue.py\", line 1419, in fetch_bids_asks\r\n    symbols = self.market_symbols(symbols, None, False)\r\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/trader_bot/trader_bot.py\", line 53, in main\r\n    bids_asks = exchange.fetch_bids_asks(\"WTK/USDT\")\r\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n### Code\n\n# Initialise the ccxt exchange for bitrue\r\n  exchange = ccxt.bitrue({\r\n    \"apiKey\": bitrue_key,\r\n    \"secret\": bitrue_secret\r\n  })\r\n\r\n#Get bids and asks\r\n    bids_asks = exchange.fetch_bids_asks(\"WTK/USDT\")\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/20372/comments",
    "author": "juber01",
    "comments": [
      {
        "user": "sc0Vu",
        "created_at": "2023-12-14T10:43:49Z",
        "body": "Hi @juber01 \r\n\r\nThe symbols is list for fetch_bids_asks, try this: `exchange.fetch_bids_asks(['WTK/USDT'])`"
      },
      {
        "user": "juber01",
        "created_at": "2023-12-14T10:54:56Z",
        "body": "Thank you that works.  Can this take this param {\"limit\":5} to return bids and asks instead of just the latest?"
      },
      {
        "user": "carlosmiei",
        "created_at": "2023-12-14T11:01:08Z",
        "body": "@juber01, that is not possible, if you want to get multiple bids/asks you should use fetchOrderBook Instead"
      }
    ],
    "satisfaction_conditions": [
      "Correct parameter format for fetch_bids_asks method",
      "Clarification of method capabilities vs alternative approaches"
    ]
  },
  {
    "number": 20028,
    "title": "Transfer from subacc to main on okex",
    "created_at": "2023-11-17T21:00:39Z",
    "closed_at": "2023-11-18T07:56:32Z",
    "labels": [
      "question",
      "python"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/20028",
    "body": "### Operating System\n\nLinux\n\n### Programming Languages\n\nPython\n\n### CCXT Version\n\n4.1.56\n\n### Description\n\nhi can u help with transfer from subacc to main on okex pls, i try use 2 methods, and got the same error\n\n### Code\n\n#1 \r\n```\r\nexchange.private_post_asset_transfer({\"ccy\": symbolWithdraw, \"amt\": str(sub_balance), \"from\": '6', \"to\": '6', \"type\": \"2\", \"subAcct\": name_sub})\r\n```\r\n#2 \r\n```\r\nexchange.transfer(code=symbolWithdraw, amount=sub_balance, fromAccount=name_sub, toAccount='main', params={\"type\": \"2\", \"from\": '6', \"to\": '6'})\u2002\u2002\r\n```\r\n#ERROR\r\n```\r\nccxt.base.errors.ExchangeError: okx {\"msg\":\"This API key doesn't have permission to use this function\",\"code\":\"50120\"}\r\n```",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/20028/comments",
    "author": "WhereIsMyMindDL",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2023-11-17T21:56:15Z",
        "body": "Have you have enabled the transfer permission on your API key in the okx website settings?"
      },
      {
        "user": "WhereIsMyMindDL",
        "created_at": "2023-11-18T07:56:32Z",
        "body": "oh shit, sry, its work"
      }
    ],
    "satisfaction_conditions": [
      "Identifies API key permission requirements for transfers on OKEx",
      "Addresses platform-specific authorization requirements for subaccount transfers"
    ]
  },
  {
    "number": 19666,
    "title": "Bitmex fetch positions doesn't show information anymore",
    "created_at": "2023-10-25T13:07:11Z",
    "closed_at": "2023-10-25T14:02:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/19666",
    "body": "### Operating System\n\nWindows 10\n\n### Programming Languages\n\nPython\n\n### CCXT Version\n\n4.1.20\n\n### Description\n\nHello,\r\n\r\nsuddenly, probably after ccxt update I get no Information from \r\n\r\nBitmex.fetch.positions anymore. \r\n\r\nOutput is --> []  None\r\n\r\nWas there any change on ccxt for Bitmex or is it a bug? \r\n\r\nMy account was liquidated because of this problem. Luckily it was just play money :-)... \r\n\r\n\n\n### Code\n\n```\r\nbitmex = ccxt.bitmex({'enableRateLimit': True,\r\n                       'apiKey': bitmexconfig.api_key,\r\n                       'secret': bitmexconfig.api_secret,})\r\n\r\n\r\nsymbol = 'XBTUSD'\r\nparams={\"type\":\"swap\",\"code\":\"XBT\"}\r\n\r\nbitmex_pos = bitmex.fetch_positions([symbol], params)\r\nprint(bitmex_pos)\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/19666/comments",
    "author": "Nitrix321",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2023-10-25T13:46:00Z",
        "body": "Hello @Nitrix321,\r\n\r\nRecently we just improved the filtering because if you called `fetch_positions([A,B,C])` it would return all the positions regardless of the symbols provided. The filtering might not be working correctly with exchange-specific ids and I will fix it ASAP but in the meantime, you can either not provide any symbol or provide the unified one (BTC/USD:BTC)\r\n\r\nExample:\r\n```Python\r\npos = bitmex.fetch_positions(params = params)\r\n# or\r\npos = bitmex.fetch_positions(['BTC/USD:BTC'] ,params = params)\r\n```\r\n\n\n---\n\n@Nitrix321 Sorry I think what I said is wrong, exchange-specific symbols are also working,  but due to the filtering it will only return positions from the symbols in the symbols array, so I would suggest calling `fetch_positions` without any argument. "
      },
      {
        "user": "Nitrix321",
        "created_at": "2023-10-25T14:02:36Z",
        "body": "hi @carlosmiei thanks, its working now without any argument as you said. I already tried without symbol or only symbol and no param but without any argument I was not thinking about that...  "
      }
    ],
    "satisfaction_conditions": [
      "Ensures fetch_positions() returns valid position data for Bitmex after CCXT update",
      "Explains correct parameter usage for fetch_positions() in latest CCXT version",
      "Addresses compatibility between symbol formats and CCXT's filtering logic",
      "Provides workaround for immediate use while maintaining forward compatibility"
    ]
  },
  {
    "number": 19595,
    "title": "Python fetch_markets() does not return future markets",
    "created_at": "2023-10-17T05:16:14Z",
    "closed_at": "2023-10-18T03:52:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/19595",
    "body": "### Operating System\r\n\r\nWindows 11\r\n\r\n### Programming Languages\r\n\r\nPython 3.11.6\r\n\r\n### CCXT Version\r\n\r\n4.1.14\r\n\r\n### Description\r\n\r\nI wanna get all Binance Future USDT markets. I think there is 100+ future markets, but most of them are missing in fetch_markets()\r\n\r\n### Code\r\n```\r\nbinance = ccxt.binance(config={\r\n    'apiKey': config['ACCESS_KEY'],\r\n    'secret': config['SECRET_KEY'],\r\n    'enableRateLimit': True,\r\n    'options': {'defaultType': 'future'}\r\n})\r\n\r\nmarkets = binance.fetch_markets()\r\ncount = 0\r\nfor coin_info in markets:\r\n    if coin_info['quote'] != 'USDT':\r\n        continue\r\n    if not coin_info['active']:\r\n        continue\r\n    if coin_info['future'] or coin_info['type'] == 'future':\r\n        count += 1\r\n\r\nprint(f\"Count: {count}\") # Count: 4\r\n```",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/19595/comments",
    "author": "Mechatrony",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2023-10-17T09:05:24Z",
        "body": "Hello @Mechatrony,\r\nBy `future` do you mean delivery futures or perpetual swaps? At CCXT, we call the latter `swaps`.\r\n\r\nCan you try this?\r\n```Python\r\n markets = await exchange.load_markets()\r\nfuture_markets = [m for m in markets.values() if m['future']] # 27 markets\r\nswap_markets = [m for m in markets.values() if m['swap']] # 298 swaps\r\n```\r\n"
      },
      {
        "user": "Mechatrony",
        "created_at": "2023-10-18T03:52:10Z",
        "body": "Hello @carlosmiei \r\nI meant perpetual swaps. I've been used my code with previous CCXT version(at least 6 months ago) and just updated CCXT. I didn't noted that changed. Your code works good. Thank you."
      }
    ],
    "satisfaction_conditions": [
      "Clarification of CCXT's market type terminology",
      "Correct identification of perpetual swap markets",
      "Accurate market filtering methodology"
    ]
  },
  {
    "number": 19588,
    "title": "Bybit: Invalid Order, reduce-only rule not satisfied",
    "created_at": "2023-10-16T14:21:26Z",
    "closed_at": "2023-10-17T09:28:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/19588",
    "body": "### Operating System\r\n\r\nWindows 10\r\n\r\n### Programming Languages\r\n\r\nPython\r\n\r\n### CCXT Version\r\n\r\n4.1.13\r\n\r\n### Description\r\n\r\nIf in a long position, and try to make limit sell order.\r\nThe limit order has been placed but the following error message occurs.\r\n\r\nInvalidOrder: bybit {\"retCode\":110017,\"retMsg\":\"Reduce-only rule not satisfied\",\"result\":{},\"retExtInfo\":{},\"time\":1697464683996}\r\n\r\n### Code\r\n\r\n```python\r\nsymbol = 'ETH/USDT:USDT'\r\n\r\nexitprice = 1650  # --> as example\r\n\r\n# if I create params without 'reduce_only': True entry the same issue occurs \r\n\r\nparams={'reduce_only': True,        \r\n            'close_on_trigger': True,}\r\n\r\npos_size = 0.35\r\n\r\nbybit.create_limit_sell_order(symbol, pos_size, exitprice, params=params)\r\n\r\n```\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/19588/comments",
    "author": "Nitrix321",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2023-10-16T16:31:25Z",
        "body": "Hello @Nitrix321,\r\n`reduce_only` (snake_case) is not the correct format, you should always use the camelCase version `reduceOnly`.\r\n\r\nCan you try that?"
      },
      {
        "user": "Nitrix321",
        "created_at": "2023-10-17T09:28:38Z",
        "body": "Hi @carlosmiei, thank you.  It's working now but it was another issue, it was not the wrong format. But I will use the format version you recommend in future. \r\n\r\nThanks again. "
      },
      {
        "user": "carlosmiei",
        "created_at": "2023-10-17T09:38:00Z",
        "body": "@Nitrix321 now, after the V5 migration, the snake_case version is not supported (it was previously but not anymore) so I highly recommend sticking to the camelCase one \ud83d\ude42 "
      }
    ],
    "satisfaction_conditions": [
      "Correct parameter naming convention for Bybit API V5",
      "Compatibility with Bybit's reduce-only order rules",
      "Clear documentation of API parameter requirements"
    ]
  },
  {
    "number": 19437,
    "title": "Class krakenfutures not found. ",
    "created_at": "2023-10-03T11:59:20Z",
    "closed_at": "2023-10-03T14:37:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/19437",
    "body": "### Operating System\n\nubuntu\n\n### Programming Languages\n\nPHP\n\n### CCXT Version\n\n2.5\n\n### Description\n\nError when implementing kraken futures: \r\nClass krakenfutures not found\r\n\r\n\r\nI am trying to setup krakenfutures (using PHP) but the class does not exist in the library. \r\n\r\nI used composer require ccxt/ccxt to install. Here is the version \r\n \"require\": {\r\n        \"ccxt/ccxt\": \"^2.5\",\r\n\r\nIf I try:\r\n\r\n $exchange = '\\\\ccxt\\\\krakenfutures';\r\n        $exchange = new $exchange(array(\r\n            'apiKey' => 'my api key',\r\n            'secret' => 'my secret',\r\n        ));\r\n\r\nI have: Class krakenfutures not found. \r\n\r\nI checked in the files of ccxt, I have a kraken.php but no krakenfutures.php. \r\n\r\nWhen I check on the documentation is says it is supported in ccxt pro. \r\nWhen I try to go to ccxt.pro I am redirected to github pages saying that ccxt pro is now merged to ccxt. \r\n\r\nMaybe I misunderstood something because I saw some people saying that they implemented it. I tried to search if I could buy ccxt pro but all I found is that it is now merged.\r\n\r\nCan you please help ?\r\n\r\nThanks\n\n### Code\n\n```\r\n\u2002\u2002 $exchange = '\\\\ccxt\\\\krakenfutures';\r\n        $exchange = new $exchange(array(\r\n            'apiKey' => 'my api key',\r\n            'secret' => 'my secret',\r\n        ));\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/19437/comments",
    "author": "smamet",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2023-10-03T13:25:03Z",
        "body": "Hello @smamet,\r\n`KrakenFutures` was added at a later version, so you need to update your CCXT version to access it. "
      },
      {
        "user": "smamet",
        "created_at": "2023-10-03T14:37:52Z",
        "body": "Oh, I didn't notice that sorry. Thanks for your help !"
      }
    ],
    "satisfaction_conditions": [
      "Clarification on version requirements for KrakenFutures support",
      "Confirmation that KrakenFutures is available in the main CCXT library post-Pro merger",
      "Resolution of class existence ambiguity"
    ]
  },
  {
    "number": 19177,
    "title": "symbol BTC/FDUSD leverage not working",
    "created_at": "2023-09-11T09:13:01Z",
    "closed_at": "2023-09-12T06:10:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/19177",
    "body": "### Operating System\r\n\r\nWindows11\r\n\r\n### Programming Languages\r\n\r\nPython\r\n\r\n### CCXT Version\r\n\r\n4.0.78\r\n\r\n### Description\r\n\r\nHi, \r\n\r\nWe are working on binance BTC/FDUSD symbol trading with leverage. \r\nThis symbol is working totally fine without leveraging (e.g. binance.fetch_ticker, binance.create_market_buy_order), while when calling binance.markets[ 'BTC/FDUSD' ], the return leverage limit is None.\r\n\r\nWe've checked that the return of leverage with binance.markets[ 'BTC/USDT' ] is working while binance.markets[ 'BTC/FDUSD' ] and binance.markets[ 'FDUSD/BTC' ] are not (returns None), also binance.fapiPrivate_post_leverage is not working with 'FDUSD' symbols.\r\n\r\nWe've also confirmed with binance support that 'FDUSD' symbols endpoints are fine on binance side, so we suppose the issue is on the ccxt tool, thanks.\r\n\r\n### Code\r\n\r\n```\r\nsymbol = 'BTC/FDUSD'\r\nself.binance = ccxt.binance({ })\r\n\r\nresult = float(self.binance.fetch_ticker(symbol)['bid']) # Works\r\norder = self.binance.create_market_buy_order(symbol, amount) # Works\r\norder = self.binance.create_market_sell_order(symbol, amount) # Works\r\n\r\nself.binance.load_markets()\r\nmarket = self.binance.markets[ symbol ]  # returns None in leverage limit\r\nself.binance.fapiPrivate_post_leverage(symbol) # Not working\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/19177/comments",
    "author": "cO-Oe",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2023-09-11T10:57:19Z",
        "body": "Hello @cO-Oe,\r\n\r\nThe main issue is that you're calling a derivatives endpoint (fapiPrivate_post_leverage) using a spot symbol. "
      },
      {
        "user": "cO-Oe",
        "created_at": "2023-09-12T06:10:38Z",
        "body": "Hi @carlosmiei, \r\n\r\nAppreciated! We've switched to margin trading for spot symbols and worked as what we would liked to, thanks!"
      }
    ],
    "satisfaction_conditions": [
      "Clarification of endpoint types (spot vs. derivatives vs. margin)",
      "Explanation of CCXT's market type configuration requirements",
      "Differentiation between spot symbols and derivatives contracts in CCXT",
      "Documentation of margin trading requirements for FDUSD pairs"
    ]
  },
  {
    "number": 19023,
    "title": "Kucoin Symbol Does not Exist",
    "created_at": "2023-08-28T11:42:26Z",
    "closed_at": "2023-08-28T11:54:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/19023",
    "body": "### Operating System\r\n\r\nWindows 10\r\n\r\n### Programming Languages\r\n\r\nPython\r\n\r\n### CCXT Version\r\n\r\n4.0.77\r\n\r\n### Description\r\n\r\nI am unable to change the margin for BTCUSDT, see code below to reproduce\r\n\r\n### Code\r\n\r\n```\r\nclient = ccxt.kucoinfutures({'apiKey': strategy.public,\r\n                                      'secret': strategy.private,\r\n                                      'password': password})\r\n\r\nticker = \"BTC/USDT:USDT\"\r\nticker = ticker.replace(\"/USDT:USDT\", \"USDTM\")\r\nclient.futuresprivate_post_position_margin_auto_deposit_status(\r\n    params={'symbol': ticker, 'status': True})\r\n```\r\nFile ~\\anaconda3\\lib\\site-packages\\ccxt\\base\\types.py:26, in Entry.__init__.<locals>.unbound_method(_self, \r\nparams)\r\n     25 def unbound_method(_self, params={}):\r\n---> 26     return _self.request(self.path, self.api, self.method, params, config=self.config)\r\n\r\nFile ~\\anaconda3\\lib\\site-packages\\ccxt\\base\\exchange.py:3019, in Exchange.request(self, path, api, method, params, headers, body, config)\r\n   3018 def request(self, path, api: Any = 'public', method='GET', params={}, headers: Optional[Any] = None, body: Optional[Any] = None, config={}):\r\n-> 3019     return self.fetch2(path, api, method, params, headers, body, config)\r\n\r\nFile ~\\anaconda3\\lib\\site-packages\\ccxt\\base\\exchange.py:3016, in Exchange.fetch2(self, path, api, method, \r\nparams, headers, body, config)\r\n   3014 self.lastRestRequestTimestamp = self.milliseconds()\r\n   3015 request = self.sign(path, api, method, params, headers, body)\r\n-> 3016 return self.fetch(request['url'], request['method'], request['headers'], request['body'])\r\n\r\nFile ~\\anaconda3\\lib\\site-packages\\ccxt\\base\\exchange.py:644, in Exchange.fetch(self, url, method, headers, body)\r\n    641     else:\r\n    642         raise ExchangeError(details) from e\r\n--> 644 self.handle_errors(http_status_code, http_status_text, url, method, headers, http_response, json_response, request_headers, request_body)\r\n    645 if json_response is not None:\r\n    646     return json_response\r\n\r\nFile ~\\anaconda3\\lib\\site-packages\\ccxt\\kucoin.py:3871, in kucoin.handle_errors(self, code, reason, url, method, headers, body, response, requestHeaders, requestBody)\r\n   3869 self.throw_broadly_matched_exception(self.exceptions['broad'], body, feedback)\r\n   3870 if errorCode != '200000':\r\n-> 3871     raise ExchangeError(feedback)\r\n   3872 return None\r\n\r\nExchangeError: kucoinfutures Contract symbol[BTCUSDTM] does not exist",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/19023/comments",
    "author": "Tomas-MP",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2023-08-28T11:51:04Z",
        "body": "Hello @Tomas-MP, I think you're using the wrong exchange-specific market id, it should be `XBTUSDTM`\r\n\r\nYou can easily check it by doing\r\n```Python\r\nawait ex.loadMarkets()\r\nmarket = ex.market('BTC/USDT:USDT')\r\nprint(market['id'])\r\n```\r\n"
      },
      {
        "user": "Tomas-MP",
        "created_at": "2023-08-28T11:54:29Z",
        "body": "Works indeed, thank you!"
      }
    ],
    "satisfaction_conditions": [
      "Identifies the correct exchange-specific market ID format for KuCoin Futures margin operations",
      "Provides a method to programmatically retrieve valid market identifiers",
      "Addresses symbol formatting differences between CCXT's unified interface and exchange-specific requirements"
    ]
  },
  {
    "number": 18975,
    "title": "binance {\"code\":-5000,\"msg\":\"GET /fapi/v1/positionRisk is retired, please use GET /fapi/v2/positionRisk\"}",
    "created_at": "2023-08-23T13:48:25Z",
    "closed_at": "2023-08-24T09:51:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/18975",
    "body": "### Operating System\n\nMacOS\n\n### Programming Languages\n\nJavaScript\n\n### CCXT Version\n\n4.0.3\n\n### Description\n\nbinance {\"code\":-5000,\"msg\":\"GET /fapi/v1/positionRisk is retired, please use GET /fapi/v2/positionRisk\"}\r\n\r\nWe are not calling this enpoint anywhere in our code so this must be ccxt internal error.\n\n### Code\n\n```\r\n\u2002\u2002\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/18975/comments",
    "author": "filipzupancic",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2023-08-23T14:12:18Z",
        "body": "Hello @filipzupancic, we upgraded the endpoint a few versions ago (it is used by fetchPositions btw), if you upgrade your ccxt version to the latest it should work"
      }
    ],
    "satisfaction_conditions": [
      "Resolve usage of deprecated Binance API endpoint in CCXT",
      "Maintain existing position risk functionality without code changes"
    ]
  },
  {
    "number": 18857,
    "title": "Bybit stop limit orders cannot be canceled",
    "created_at": "2023-08-11T09:05:59Z",
    "closed_at": "2023-08-11T14:12:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/18857",
    "body": "### Operating System\n\nWindows\n\n### Programming Languages\n\nJavaScript\n\n### CCXT Version\n\n4.0.57\n\n### Description\n\nWhen placing stop loss orders, using the CCXT unified method, on Bybit spot market (using a Unified Bybit account), it is not possible to cancel those orders. As an example, this is what I did:\r\n\r\n`await exchange.createOrder('BTC/USDT', 'limit', 'sell', 0.001, 28500, { stopLossPrice: 29000 });`\r\n\r\nWhen using `exchange.cancelAllOrders('BTC/USDT')`, the order is not canceled. No exception is thrown, but I still see the open order on the exchange.\r\n\r\nWhen using `exchange.cancelOrder(<id>, 'BTC/USDT')`, using the id that is returned when creating the order, does not work either. In that case I get the following exception:\r\n\r\nOrderNotFound: bybit {\"retCode\":170213,\"retMsg\":\"Order does not exist.\",\"result\":{},\"retExtInfo\":{},\"time\":1691743905604}\r\n    at bybit.throwExactlyMatchedException (C:\\code\\crypto-coding-course\\code\\cc-bot\\node_modules\\ccxt\\dist\\cjs\\src\\base\\Exchange.js:3087:19)\r\n    at bybit.handleErrors (C:\\code\\crypto-coding-course\\code\\cc-bot\\node_modules\\ccxt\\dist\\cjs\\src\\bybit.js:9161:18)\r\n    at C:\\code\\crypto-coding-course\\code\\cc-bot\\node_modules\\ccxt\\dist\\cjs\\src\\base\\Exchange.js:766:51\r\n    at processTicksAndRejections (node:internal/process/task_queues:96:5)\r\n    at async bybit.fetch2 (C:\\code\\crypto-coding-course\\code\\cc-bot\\node_modules\\ccxt\\dist\\cjs\\src\\base\\Exchange.js:2666:16)\r\n    at async bybit.request (C:\\code\\crypto-coding-course\\code\\cc-bot\\node_modules\\ccxt\\dist\\cjs\\src\\base\\Exchange.js:2669:16)\r\n    at async bybit.cancelUnifiedAccountOrder (C:\\code\\crypto-coding-course\\code\\cc-bot\\node_modules\\ccxt\\dist\\cjs\\src\\bybit.js:4690:26)\r\n    at async bybit.cancelOrder (C:\\code\\crypto-coding-course\\code\\cc-bot\\node_modules\\ccxt\\dist\\cjs\\src\\bybit.js:4874:20)\r\n\r\n\r\nAm I doing something wrong, or is this a bug?\n\n### Code\n\n```\r\n\u2002\u2002\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/18857/comments",
    "author": "hodlerhacks",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2023-08-11T13:36:07Z",
        "body": "Hello @hodlerhacks,\r\nHave you tried to provide `stop:true` inside `params`? \r\n\r\nExample:\r\n```Python\r\nexchange.cancelAllOrders('BTC/USDT', {'stop': true})\r\n```\r\n"
      },
      {
        "user": "hodlerhacks",
        "created_at": "2023-08-11T13:48:25Z",
        "body": "Oh wow, that solves it indeed, thanks! :-)\r\n\r\nI couldn't find this in the documentation. What exactly does this parameter do? When should I use it? Is it Bybit-specific and/or can I safely use that with other exchanges as well? (I'm developing an application that works with many different exchanges, and I'm trying to keep the code as generic as possible, hence the question.)"
      },
      {
        "user": "carlosmiei",
        "created_at": "2023-08-11T13:57:32Z",
        "body": "> I couldn't find this in the documentation. What exactly does this parameter do? When should I use it? Is it Bybit-specific and/or can I safely use that with other exchanges as well? (I'm developing an application that works with many different exchanges, and I'm trying to keep the code as generic as possible, hence the question.)\r\n\r\n@hodlerhacks Some exchanges have different endpoints to handle stop/trigger orders, so the `stop` parameter tells ccxt to use that endpoint instead, and yes it is unified across exchanges so you should be able to use it with other exchanges as well.\r\n\r\nAdditionally, we will try to improve our documentation, thanks for letting us know. \r\n\r\n"
      },
      {
        "user": "hodlerhacks",
        "created_at": "2023-08-11T13:59:43Z",
        "body": "Thanks for clarifying and your quick response, appreciate it!"
      },
      {
        "user": "carlosmiei",
        "created_at": "2023-08-11T14:12:04Z",
        "body": "@hodlerhacks no problem, feel free to reach out any time."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how CCXT handles stop/trigger order cancellation across exchanges",
      "Clarification on when to use exchange-specific parameters vs unified methods",
      "Identification of required parameters for interacting with stop orders in CCXT",
      "Documentation of endpoint differences for order types across exchanges",
      "Guidance on maintaining exchange-agnostic code while handling special cases"
    ]
  },
  {
    "number": 18768,
    "title": "Binanceusm testnet error on fetch_positions ",
    "created_at": "2023-08-03T16:22:24Z",
    "closed_at": "2023-08-09T20:32:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/18768",
    "body": "### Operating System\n\nMac M1\n\n### Programming Languages\n\nPython\n\n### CCXT Version\n\n3.1.60\n\n### Description\n\nReceived exchange error on binanceusdm (testnet):\r\nExchangeError('binanceusdm {\\\"code\\\":-5000,\\\"msg\\\":\\\"GET /fapi/v1/positionRisk is retired, please use GET /fapi/v2/positionRisk\\\"}')\n\n### Code\n\n```\r\nawait exchange.fetch_open_orders(symbol)\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/18768/comments",
    "author": "idan-ben-ami",
    "comments": [
      {
        "user": "sc0Vu",
        "created_at": "2023-08-04T01:25:00Z",
        "body": "Hi @idan-ben-ami \r\n\r\nWe already update fapi to v2, would you like to upgrade ccxt?\r\n\r\nLet me know if you have other issues."
      },
      {
        "user": "FelipeJz",
        "created_at": "2023-08-08T15:38:56Z",
        "body": "I'm running the latest version with the same issue"
      },
      {
        "user": "Algo-Tradings",
        "created_at": "2023-08-09T14:55:58Z",
        "body": "> I'm running the latest version with the same issue\r\n\r\nI was with the same problem. \r\nAnyway after `pip install ccxt --force`, I reinstalled the lib and it's working fine now.\r\nHope it helps!"
      },
      {
        "user": "FelipeJz",
        "created_at": "2023-08-09T15:07:12Z",
        "body": "Sorry, i'm running nodejs, version 4.0.3. I deleted the node_modules folder and reinstalled, but the issue still remains :("
      },
      {
        "user": "Algo-Tradings",
        "created_at": "2023-08-09T18:26:19Z",
        "body": "ccxt need resources from other modules that may causing conflict. I guess you have npm installed, so instead of deleting ccxt folder try:\r\n`npm uninstall -g ccxt`"
      },
      {
        "user": "FelipeJz",
        "created_at": "2023-08-09T19:12:32Z",
        "body": "That did not work, but crazy enough, installing @latest, instead of the specific version updated other packages and that worked. Thank you for pointing me in the right direction! Cheers"
      },
      {
        "user": "idan-ben-ami",
        "created_at": "2023-08-09T20:32:58Z",
        "body": "I'm sorry, my bad.\r\nI managed to update to CCXT v4.0.* (uninstalled and reinstalled), and it all works well now.\r\nThanks a lot!\r\n\r\n(Using poetry remove ccxt && poetry add ccxt - instead of poetry update ccxt)"
      },
      {
        "user": "LAGD1979",
        "created_at": "2023-08-14T02:31:53Z",
        "body": "Hi!\r\ni have the same issue, i already upgrade ccxt version, but i'm getting the same error message:\r\nAPIError(code=-5000): GET /fapi/v1/positionRisk is retired, please use GET /fapi/v2/positionRisk\r\nI printed the versi\u00f3n: CCXT Version: 4.0.58"
      }
    ],
    "satisfaction_conditions": [
      "Solution ensures the CCXT library uses the updated Binance API endpoint (/fapi/v2/positionRisk)",
      "Verification of a clean installation process for CCXT updates",
      "Clear confirmation of CCXT version compatibility with Binance's API changes",
      "Resolution path works across different package managers (pip/npm/poetry)"
    ]
  },
  {
    "number": 18633,
    "title": "Bybit.fetch_tickers() return data with colon",
    "created_at": "2023-07-24T07:26:50Z",
    "closed_at": "2023-07-26T15:12:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/18633",
    "body": "### Operating System\n\nWindows 10 \n\n### Programming Languages\n\n_No response_\n\n### CCXT Version\n\n2.8.31\n\n### Description\n\nWhen I call fetch_tickers() function I get something like '10000LADYS/USDT:USDT':{} And this is rather strange considering that bybit.markets() will return the data in a different format, which is my preferred ('BTC/USDT':{} ). I tried to change the params and put a spot there, etc., but this does not help me. I checked the bybit documentation and didn't find anything there. Perhaps you can advise me. Because such a difference in the returned data from only 1 exchange interferes very much\n\n### Code\n\n```\r\n\u2002\u2002\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/18633/comments",
    "author": "AlwxDavydov",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2023-07-24T09:27:29Z",
        "body": "Hello @AlwxDavydov,\r\n\r\nFirst and foremost, I noticed that you have a pretty outdated ccxt version I would suggest upgrading it because we did a lot of meaningful updates in the meantime.\r\n\r\nRegarding your question, bybit will return the swap tickers by default if no symbol/type is provided but you can easily provide a type in params if you want to retrieve spot tickers only, example:\r\n\r\n```Python\r\ntickers = await bybit.fetch_tickers(params = {'type':'spot'})\r\n```"
      },
      {
        "user": "ttodua",
        "created_at": "2023-07-24T14:50:43Z",
        "body": "@carlosmiei if you are not against, for cleanup purposes I'll close this issue, as your response covers it correctly.\r\n@AlwxDavydov if you still face any issue, feel free to post a follow-up and reopen the issue, so we could answer further."
      },
      {
        "user": "AlwxDavydov",
        "created_at": "2023-07-26T10:58:54Z",
        "body": "@carlosmiei Thanks, your answer helped but not completely. As it turned out, not all tokens return by params = {'type':'spot'}), just like 1INCH, it will shown only if I use code with deafult params and looked like '1INCH/USDT:USDT. To be honest, I don't understand why. Initially, I thought that spot is only spot pairs, and default is those pairs that include margin trading, but no. For example WLD/USDC will be returned by params = spot, but in includes margin. So when I call a fetch_tickers() I want to got all pairs and I want it in some format like got all other exchanges.(without :USDT) Moreover I check type of some coins and both 1INCH and CAPO is type:spot but first is shown only without params second is shown only with params = {'type':'spot'}.\n\n---\n\n@ttodua @carlosmiei  The problem was reopened but for 2 days there is no answer. Do I need to write another topic to get an answer? I'm sorry if I'm asking something stupid, I just want an answer and I don't understand if it is visible at all and why there is no answer."
      },
      {
        "user": "carlosmiei",
        "created_at": "2023-07-26T11:10:27Z",
        "body": "@AlwxDavydov Sorry don't know exactly why was re-opened. Have you updated your ccxt version as suggested?"
      },
      {
        "user": "AlwxDavydov",
        "created_at": "2023-07-26T11:16:46Z",
        "body": "@carlosmiei Yes, the old version was added by autocomplete. I just didn't notice it\n\n---\n\n@carlosmiei I'll even add the problem. The fact is that len(bybit.markets) will return 669, but fetch_tickers(\r\n            params={'type': 'spot'}) will return around 280, and  fetch_tickers() will return around 250 pairs. So bybit.markets will include some derivatives and there are around 550 real spot markets, but they can only be obtained by different calls (with fetch_tickers(params={'type': 'spot'}) and without this pararms). I really hope I was able to explain well, but if you do not understand, please tell me and I will try again"
      },
      {
        "user": "carlosmiei",
        "created_at": "2023-07-26T11:55:45Z",
        "body": "@AlwxDavydov Sorry I still don't get what the problem is here.\r\n\r\n> The fact is that len(bybit.markets) will return 669,\r\n\r\nyes, bybit loads all markets buy default now (spot, swap, futures, options)\r\n\r\n> fetch_tickers(\r\nparams={'type': 'spot'}) will return around 280,\r\n\r\nThat is because only returns spot tickers\r\n\r\n>  fetch_tickers() will return around 250 pairs\r\n\r\nAs explained, by default will return only swap tickers\r\n\r\n\r\n\r\n"
      },
      {
        "user": "AlwxDavydov",
        "created_at": "2023-07-26T12:39:32Z",
        "body": "@carlosmiei Once again, I apologize for my stupidity and English. To be clearer, I will explain my task. I get tickers on many exchanges, on all but bybit it will return me all available pairs for spot (what I need) trading. But on bybit, the ticker call needs to be called 2 times to get all the pairs I need. This is annoying, but not such a big problem, the problem is that in spot trading pairs it will return data to me in a different format, namely the last coin and the colon before it(\"BTC/USDT:USDT\"). And I'm rather asking for advice on how I can get my 550 spot pairs (after all, their real number is about it) in the same format, without the last character with a colon."
      },
      {
        "user": "ttodua",
        "created_at": "2023-07-26T13:07:33Z",
        "body": "@AlwxDavydov please post your ccxt version.\r\nalso, tell us an example, which spot symbol that you are missing from bybit response when doing `fetch_tickers (None, {'type':'spot'})`"
      },
      {
        "user": "carlosmiei",
        "created_at": "2023-07-26T13:12:02Z",
        "body": "@AlwxDavydov Yeah the problem might be with the ccxt version, you might have installed a buggy outdated one. \r\n\r\nBtw if you see `:USDT` in the symbol that means it is a swap/derivative market not a spot one.  \r\n\r\nAs I said, I tested it on the latest version of ccxt and by doing `fetch_tickers(\r\nparams={'type': 'spot'})` I only get spot markets (with the symbol BASE/QUOTE)"
      },
      {
        "user": "AlwxDavydov",
        "created_at": "2023-07-26T15:11:58Z",
        "body": "@ttodua @carlosmiei I completely reinstalled ccxt and all is well now. Apparently I have some kind of bug. Thank you very much for your help"
      }
    ],
    "satisfaction_conditions": [
      "Ensures all Bybit spot trading pairs are retrieved in a unified BASE/QUOTE format without colon suffixes",
      "Provides a method to retrieve all relevant spot markets in a single API call",
      "Clarifies the relationship between market types (spot/swap) and symbol formatting in Bybit's API",
      "Addresses version compatibility issues affecting market data retrieval"
    ]
  },
  {
    "number": 18616,
    "title": "Bitget Stop market",
    "created_at": "2023-07-21T23:59:45Z",
    "closed_at": "2023-07-24T15:25:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/18616",
    "body": "This feature available in a near future?",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/18616/comments",
    "author": "ZETECdev",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2023-07-22T09:24:29Z",
        "body": "Hello @ZetZ1, I think you can place stop markets order there as well. You just need to provide type=market and `triggerPrice` inside `params`. "
      },
      {
        "user": "ZETECdev",
        "created_at": "2023-07-22T17:05:28Z",
        "body": "Oh.,.. ok thanks and sorry"
      },
      {
        "user": "ttodua",
        "created_at": "2023-07-24T15:25:23Z",
        "body": "i'll close this, if you have any further notes/issues, let us know anytime"
      }
    ],
    "satisfaction_conditions": [
      "Confirmation that the requested feature (Bitget stop market orders) is already available through existing functionality"
    ]
  },
  {
    "number": 18498,
    "title": "fetchPositionsRisk() requires an array argument for symbols",
    "created_at": "2023-07-07T13:03:59Z",
    "closed_at": "2023-07-07T13:07:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/18498",
    "body": "### Operating System\n\nLinux\n\n### Programming Languages\n\npython\n\n### CCXT Version\n\n4.0.13\n\n### Description\n\nSeems like the bug from 18131 is still not solved in 4.0.13. Below code gives \r\n>binance fetchPositionsRisk() requires an array argument for symbols\r\n\r\nSame error when one adds params={'type': 'future'} \r\n\r\n\n\n### Code\n\n```\r\nsymbol = \"LTC/USDT:USDT\"\r\nposResult = await exchange.fetchPositions(symbols = symbol)\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/18498/comments",
    "author": "spc789",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2023-07-07T13:07:04Z",
        "body": "@spc789 the error says itself, the argument must be an array of symbols, not a single symbol:\r\n\r\n```\r\nsymbol = \"LTC/USDT:USDT\"\r\nposResult = await exchange.fetchPositions(symbols = [symbol])\r\n```\r\n\r\nor \r\n\r\n```\r\nsymbols = [\"LTC/USDT:USDT\"]\r\nposResult = await exchange.fetchPositions(symbols)\r\n```\n\n---\n\n@spc789 feel free to reopen this issue or just ask further questions here if the above does not work."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of the required data type for the 'symbols' parameter in fetchPositions()",
      "Clarification that the method accepts multiple symbols even when querying one position"
    ]
  },
  {
    "number": 18359,
    "title": "CCXT Pro 'create_order_ws' on Kraken",
    "created_at": "2023-06-27T11:14:56Z",
    "closed_at": "2023-06-27T14:11:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/18359",
    "body": "### Operating System\n\nMacOS\n\n### Programming Languages\n\n_No response_\n\n### CCXT Version\n\nCCXT Pro 1.0.33\n\n### Description\n\nI am trying to submit an order with CCXT Pro on Kraken using web socket (Python).\r\n\r\n`order = await exchange.create_order_ws(symbol=\"UNI/USD\", type=\"market\", side=\"buy\", amount=1 )`\r\n\r\nBut I receive the following error:\r\n\r\n`AttributeError: 'kraken' object has no attribute 'create_order_ws'`\r\n\r\nDoes it mean that not all the WS methods in CCXT Pro work for supported exchanges or am I missing something?\r\n\r\nThank you for your help!\n\n### Code\n\n```\r\n\u2002\u2002\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/18359/comments",
    "author": "AntoBr96",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2023-06-27T11:19:33Z",
        "body": "Hello @AntoBr96, Are you still using the old package? The latest ccxt version is 3.1.53, which is very distant from yours.\r\n\r\nRegarding your question, for now `kraken` is the only exchange with `create_order_Ws/cancel_order_ws/etc` available but we will be adding it to different exchanges in the future. \r\n\r\nIn short, if you update your ccxt version you should be able to use that method. "
      },
      {
        "user": "AntoBr96",
        "created_at": "2023-06-27T14:11:22Z",
        "body": "Thank you @carlosmiei! Your answer solved my question!"
      },
      {
        "user": "reverendrenegade",
        "created_at": "2023-09-09T14:00:42Z",
        "body": "Are there any updates on exchange coverage beyond Kraken regarding the aforementioned web socket streams? \r\n\r\n\"create_order_Ws/cancel_order_ws/etc\""
      }
    ],
    "satisfaction_conditions": [
      "Identify whether the CCXT Pro version in use supports the `create_order_ws` method for the specified exchange",
      "Confirm that the exchange (Kraken) explicitly supports WebSocket-based order methods like `create_order_ws`",
      "Clarify whether WebSocket method availability varies by exchange in CCXT Pro"
    ]
  },
  {
    "number": 17822,
    "title": "watch_ohlcv always returns a single value",
    "created_at": "2023-05-07T06:51:04Z",
    "closed_at": "2023-05-07T21:59:12Z",
    "labels": [
      "bug",
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/17822",
    "body": "### Operating System\n\nEndeavourOS\n\n### Programming Languages\n\npython\n\n### CCXT Version\n\nCCXT Pro 3.0.79\n\n### Description\n\nI've been trying to run the `binance-watch-ohlcv.py` example and expected it to return more candles, however, it only seems to return one, no matter the limits I set. As I've understood, this method should return more candles, depending on the limit parameter that is set.\n\n### Code\n\n```\r\n\u2002\u2002\r\n\r\nimport ccxt.pro\r\nfrom asyncio import run\r\n\r\nprint('CCXT Pro version', ccxt.pro.__version__)\r\n\r\n\r\ndef table(values):\r\n    first = values[0]\r\n    keys = list(first.keys()) if isinstance(first, dict) else range(0, len(first))\r\n    widths = [max([len(str(v[k])) for v in values]) for k in keys]\r\n    string = ' | '.join(['{:<' + str(w) + '}' for w in widths])\r\n    return \"\\n\".join([string.format(*[str(v[k]) for k in keys]) for v in values])\r\n\r\n\r\nasync def main():\r\n    exchange = ccxt.pro.binance({\r\n        'options': {\r\n            'OHLCVLimit': 1000, # how many candles to store in memory by default\r\n        },\r\n    })\r\n    symbol = 'ETH/USDT'  # or BNB/USDT, etc...\r\n    timeframe = '1m'  # 5m, 1h, 1d\r\n    limit = 10  # how many candles to return max\r\n    method = 'watchOHLCV'\r\n    if (method in exchange.has) and exchange.has[method]:\r\n        max_iterations = 100000  # how many times to repeat the loop before exiting\r\n        for i in range(0, max_iterations):\r\n            try:\r\n                ohlcvs = await exchange.watch_ohlcv(symbol, timeframe, None, limit)\r\n                now = exchange.milliseconds()\r\n                print('\\n===============================================================================')\r\n                print('Loop iteration:', i, 'current time:', exchange.iso8601(now), symbol, timeframe)\r\n                print('-------------------------------------------------------------------------------')\r\n                print(table([[exchange.iso8601(o[0])] + o[1:] for o in ohlcvs]))\r\n            except Exception as e:\r\n                print(type(e).__name__, str(e))\r\n                break\r\n        await exchange.close()\r\n    else:\r\n        print(exchange.id, method, 'is not supported or not implemented yet')\r\n\r\n\r\nrun(main())\r\n```\r\nOutput looks like this\r\n```\r\nCCXT Pro version 3.0.79\r\n\r\n===============================================================================\r\nLoop iteration: 0 current time: 2023-05-07T06:42:00.151Z ETH/USDT 1m\r\n-------------------------------------------------------------------------------\r\n2023-05-07T06:41:00.000Z | 1902.53 | 1902.59 | 1902.52 | 1902.59 | 30.4667\r\n\r\n===============================================================================\r\nLoop iteration: 1 current time: 2023-05-07T06:42:03.130Z ETH/USDT 1m\r\n-------------------------------------------------------------------------------\r\n2023-05-07T06:42:00.000Z | 1902.58 | 1902.59 | 1902.58 | 1902.59 | 17.8681\r\n```",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/17822/comments",
    "author": "AndreiMihalea",
    "comments": [
      {
        "user": "pcriadoperez",
        "created_at": "2023-05-07T20:16:55Z",
        "body": "Hi @AndreiMihalea , by default the watch methods only return the updates it receives from the exchange, that's why you only receive one message at a time.\r\nWe do however cache all the messages, so if you wish to see them you can set the option. `exchange.newUpdates = false` so it returns the full cache.\r\nAlso if you want the historic ohlcv you can use `fetchOHLCV`\r\n\r\nLet me know if you have any questions, if not feel free to close the issue."
      },
      {
        "user": "AndreiMihalea",
        "created_at": "2023-05-07T21:59:04Z",
        "body": "Thank you for the reply, @pcriadoperez. It indeed works with the `fetchOHLCV` method."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of the difference between real-time updates and historical data retrieval in CCXT Pro",
      "Clarification on how to access cached historical OHLCV data through watch methods",
      "Guidance on configuring cache behavior for OHLCV streaming",
      "Differentiation between watchOHLCV's real-time purpose vs fetchOHLCV's historical purpose"
    ]
  },
  {
    "number": 17769,
    "title": "Bybit watch_ticker() does not return values",
    "created_at": "2023-05-03T17:29:26Z",
    "closed_at": "2023-11-22T19:49:44Z",
    "labels": [
      "enhancement",
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/17769",
    "body": "### Operating System\n\nlinux\n\n### Programming Languages\n\npython\n\n### CCXT Version\n\n3.0.90\n\n### Description\n\nHi,\r\n\r\nBybit watch_ticker() seems broken for spot. Works fine for perpetual swaps. \n\n### Code\n\n```\r\nimport asyncio\r\nimport ccxt.pro as ccxt\r\n\r\nbybit = ccxt.bybit()\r\nasyncio.run(bybit.watch_ticker(\"BTC/USDT\"))  # this hangs forever\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/17769/comments",
    "author": "mrpouley",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2023-05-03T17:36:53Z",
        "body": "Hello @mrpouley,\r\nYou need to set `defaultType = spot` because bybit has conflicting ids. "
      },
      {
        "user": "mrpouley",
        "created_at": "2023-05-03T18:01:11Z",
        "body": "It works, thanks.\r\nSo it's not possible to call watch_ticker() on both spot and futures using the same exchange object, am i correct?"
      },
      {
        "user": "carlosmiei",
        "created_at": "2023-05-04T10:44:28Z",
        "body": "> It works, thanks. So it's not possible to call watch_ticker() on both spot and futures using the same exchange object, am i correct?\r\n\r\n@mrpouley As of now it is not possible, but we will try to fix this issue in the future"
      },
      {
        "user": "philipperemy",
        "created_at": "2023-11-22T12:29:40Z",
        "body": "It would be good if this issue could be addressed. Not being able to use bybit spot with ccxt pro is not ideal."
      },
      {
        "user": "carlosmiei",
        "created_at": "2023-11-22T12:55:47Z",
        "body": "@philipperemy @mrpouley After the v5 migration, this should work, you should be able to do\r\n```Python\r\nawait bybit.watch_ticker('BTC/USDT')\r\nawait bybit.watch_ticker('BTC/USDT:USDT')\r\n```\r\nwith no issues as long as you have an updated version of ccxt"
      },
      {
        "user": "frosty00",
        "created_at": "2023-11-22T19:49:40Z",
        "body": "yep, ccxt 3.0 is very old..."
      },
      {
        "user": "philipperemy",
        "created_at": "2023-11-23T00:04:50Z",
        "body": "@carlosmiei so it works but the `bid` and the `ask` are equal to `None` when it comes to spot instruments.\n\n---\n\nLatest ccxt (ccxt-4.1.61)\r\n*code*\r\n```python\r\nimport asyncio\r\n\r\nimport ccxt.pro\r\n\r\nbybit = ccxt.pro.bybit()\r\nprint(asyncio.run(bybit.watch_ticker('BTC/USDT')))\r\n```\r\n\r\n*result*\r\n```\r\n{'symbol': 'BTC/USDT', 'timestamp': 1700697865426, 'datetime': '2023-11-23T00:04:25.426Z', 'high': None, 'low': 35822.01, 'bid': None, 'bidVolume': None, 'ask': None, 'askVolume': None, 'vwap': 36870.1403687674, 'open': 35829.61, 'close': 37445.77, 'last': 37445.77, 'previousClose': None, 'change': 1616.16, 'percentage': 4.51, 'average': 36637.69, 'baseVolume': 11610.147233, 'quoteVolume': 428067758.18276644, 'info': {'symbol': 'BTCUSDT', 'lastPrice': '37445.77', 'highPrice24h': '37864.94', 'lowPrice24h': '35822.01', 'prevPrice24h': '35829.61', 'volume24h': '11610.147233', 'turnover24h': '428067758.18276642', 'price24hPcnt': '0.0451', 'usdIndexPrice': '37451.710000000001'}}\r\n```\r\n\r\nAdding `{'options': {'defaultType': 'spot'}}` does nothing to it."
      }
    ],
    "satisfaction_conditions": [
      "Support simultaneous monitoring of both spot and futures markets using a single exchange instance",
      "Ensure complete ticker data (including bid/ask prices) is returned for spot markets",
      "Provide clear configuration requirements for market type differentiation",
      "Maintain compatibility with Bybit's API v5 migration requirements"
    ]
  },
  {
    "number": 17753,
    "title": "unsupported operand type(s) for %: 'int' and 'NoneType' in watchTicker",
    "created_at": "2023-05-02T16:52:55Z",
    "closed_at": "2023-05-02T17:38:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/17753",
    "body": "### Operating System\r\n\r\nLinux\r\n\r\n### Programming Languages\r\n\r\npython\r\n\r\n### CCXT Version\r\n\r\n3.0.78\r\n\r\n### Description\r\n\r\nThe *complete* (just fill in an api and secret) code below throws the \r\n\r\n> unsupported operand type(s) for %: 'int' and 'NoneType' \r\n\r\nerror.\r\n\r\nCould it be there's an error somewhere in the watchTicker function ?\r\n\r\nI tried with symbol = 'ETH/USDT', symbol = 'ETH/USDT:USDT' and 'ETH-USDT'\r\n\r\n### Code\r\n\r\n```\r\n#!/usr/bin/python3.8\r\nimport ccxt\r\nimport ccxt.pro as ccxtpro\r\nimport os, sys, platform, traceback\r\nimport socket, requests\r\nimport pprint\r\nimport asyncio, aiohttp\r\nimport uvloop\r\n\r\nasync def watch_ticker(exchange):\r\n    while True:\r\n        try:\r\n            symbol = 'ETH/USDT'\r\n            print (symbol)\r\n            tck = await exchange.watchTicker(symbol)\r\n            pp.pprint(tck)\r\n        except Exception as e:\r\n            print(f\"{e}\")\r\n            exc_type, exc_obj, exc_tb = sys.exc_info()\r\n            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]\r\n            print(exc_type, fname, exc_tb.tb_lineno)\r\n            await exchangepro.close()\r\n\r\n######################################\r\n### MAIN PROGRAM STARTS HERE \r\nasync def main():\r\n    tasks = []\r\n\r\n    tasks.append(asyncio.create_task(watch_ticker(exchangepro)))\r\n\r\n    try:\r\n        await asyncio.gather(*tasks)\r\n\r\n    except (ccxt.RequestTimeout, ccxt.NetworkError) as e:\r\n        print(f\"Request error occurred: {e} ...\")\r\n\r\n    except Exception as e:\r\n        print(f\"{e}\")\r\n        exc_type, exc_obj, exc_tb = sys.exc_info()\r\n        fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]\r\n        print(exc_type, fname, exc_tb.tb_lineno)\r\n        await exchangepro.close()\r\n\r\n########################################\r\n### WRAPPER FOR MAIN PROGRAM\r\n\r\nexchangepro = ccxtpro.binance({\r\n    'apiKey': api_key,\r\n    'secret': api_secret,\r\n    'enableRateLimit': False,\r\n})\r\n\u2002\u2002\r\nexchangepro.options = {\r\n    'defaultType': 'future', # or 'margin' or 'spot'\r\n    'adjustForTimeDifference': True,\r\n    'newOrderRespType': 'FULL',\r\n    'defaultTimeInForce': 'GTC'}\r\n\r\ntry:\r\n    if os.name.upper() != 'NT':\r\n        uvloop.install()\r\n    if os.name.upper() == 'NT':\r\n        asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())\r\n\r\n    asyncio.run(main(), debug=False)\r\n\r\nexcept KeyboardInterrupt:\r\n    print(\"Program interrupted by user\")\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/17753/comments",
    "author": "spc789",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2023-05-02T17:10:33Z",
        "body": "Hello  @spc789 is it possible to share the complete stacktrace? \r\nAlso, do you get that error immediately? \r\n"
      },
      {
        "user": "spc789",
        "created_at": "2023-05-02T17:16:10Z",
        "body": "Error comes immediately\r\nComplete stack trace : \r\n\r\nTraceback (most recent call last):\r\n>  File \"./CCXT\", line 20, in watch_ticker\r\n>    tck = await exchange.watchTicker(symbol)\r\n>  File \"/usr/local/lib/python3.8/dist-packages/ccxt/pro/binance.py\", line 702, in watch_ticker\r\n>    url = self.urls['api']['ws'][type] + '/' + self.stream(type, messageHash)\r\n>  File \"/usr/local/lib/python3.8/dist-packages/ccxt/pro/binance.py\", line 108, in stream\r\n>    normalizedIndex = streamIndex % streamLimit\r\n>TypeError: unsupported operand type(s) for %: 'int' and 'NoneType'\r\n><class 'NameError'> selfGrid-CCXT-WS-TICKERTEST 23\r\n\r\n"
      },
      {
        "user": "carlosmiei",
        "created_at": "2023-05-02T17:26:14Z",
        "body": "@spc789 Ok found the issue, basically you can't do this:\r\n\r\n```Python\r\nexchangepro.options = {\r\n    'defaultType': 'future', # or 'margin' or 'spot'\r\n    'adjustForTimeDifference': True,\r\n    'newOrderRespType': 'FULL',\r\n    'defaultTimeInForce': 'GTC'}\r\n```\r\nbecause you override and delete all the other options, you should be doing this instead:\r\n\r\n```Python\r\ncustomOptions = {\r\n    'defaultType': 'future', # or 'margin' or 'spot'\r\n    'adjustForTimeDifference': True,\r\n    'newOrderRespType': 'FULL',\r\n    'defaultTimeInForce': 'GTC'\r\n}\r\n\r\nexchangepro = ccxtpro.binance({\r\n    'apiKey': os.environ['BINANCEUSDM_APIKEY'],\r\n    'secret': os.environ['BINANCEUSDM_SECRET'],\r\n    'enableRateLimit': False,\r\n    'options': customOptions\r\n})\r\n```\r\n"
      },
      {
        "user": "spc789",
        "created_at": "2023-05-02T17:31:09Z",
        "body": "Works like a charm ... obrigado senhor for the quick reply !"
      },
      {
        "user": "carlosmiei",
        "created_at": "2023-05-02T17:38:31Z",
        "body": "> Works like a charm ... obrigado senhor for the quick reply !\r\n\r\n@spc789 no problem \ud83d\ude01 let us know if anything!"
      }
    ],
    "satisfaction_conditions": [
      "Identifies why 'streamLimit' parameter becomes NoneType in the Binance WebSocket implementation",
      "Explains proper method to configure exchange options without overriding critical defaults",
      "Ensures preservation of CCXT Pro's internal WebSocket connection management parameters",
      "Demonstrates correct option merging strategy for CCXT exchange instances"
    ]
  },
  {
    "number": 17718,
    "title": "load_markets v/s fetch_markets (pairs dict differences)",
    "created_at": "2023-04-30T08:22:43Z",
    "closed_at": "2023-05-01T22:47:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/17718",
    "body": "### \u061c\n\nCCXT ver 2.2.36 / Win-10 / python 3.7\r\n\r\nGetting available trading-pairs via load_markets may bring less results compared to fetch_markets for some exchanges.\r\nSo far I noticed two types of differences:\r\n\r\nA) Duplicate-pairs (totally identical records) are brought by fetch_market (while load_market doesn't). Example: For bitFlier exchange BTC_JPY and ETH_BTC pairs, occuring 3 times each in fetch_market result.\r\n\r\nB) Multiple pairs of the same symbol with different id are all brought by fetch_markets (while load_market brings only one of them). Example: For Binance exchange fetch_markets brings symbol BCH/BTC with 2 different ids (BCHBTC and BCHABCBTC), while load_markets brings only one id (BCHBTC). ",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/17718/comments",
    "author": "avmarko",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2023-04-30T10:41:35Z",
        "body": "Hello @avmarko,\r\n\r\n`fetchMarkets` returns an array of parsed markets whereas `loadMarkets` returns a dictionary indexed by the unified symbol, which is why you don't see repeated entries. For instance, binance has conflicting ids between spot and linear swap markets, so it is expected to see `id: BTCUSDT` twice on the array returned by `fetchMarkets` . The same does not happen with `loadMarkets` because our unified symbols do not have this ambiguity so you will get one entry with `key = 'BTC/USDT` referring to the spot market and another with `key = 'BTC/USDT:USDT` referring to the linear swap market. "
      },
      {
        "user": "avmarko",
        "created_at": "2023-04-30T17:32:46Z",
        "body": "Understood :-) \r\nThank you @carlosmiei "
      }
    ],
    "satisfaction_conditions": [
      "Explain the structural difference between fetch_markets and load_markets outputs",
      "Clarify how unified symbols prevent market ambiguity",
      "Differentiate between raw exchange data and CCXT's unified structure"
    ]
  },
  {
    "number": 17631,
    "title": "[Question] FetchStatus",
    "created_at": "2023-04-21T21:59:45Z",
    "closed_at": "2023-04-22T12:43:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/17631",
    "body": "### \u061c\n\nHi, \r\n\r\nI have been having trouble to find the answer by myself through the ccxt documentation. So I have no choice to ask it here. \r\nI would like to use exchange.fetchStatus() to do a initial check before running my script. \r\n\r\nBut I wonder, what will be expected response if an exchange goes into maintenance mode? \r\nHow will the 'eta' response be like? In seconds or date time? \r\n\r\nBecause i am implementing a loop that will sleep until the ETA time before running the remaining code if it goes into maintenance mode. \r\n\r\nSorry if this answer can be found, because i really didn't manage to find it. ",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/17631/comments",
    "author": "300Gram",
    "comments": [
      {
        "user": "sc0Vu",
        "created_at": "2023-04-22T01:12:04Z",
        "body": "Hi @300Gram \r\n\r\nIf the exchange start maintenance mode, the statue would be `maintenance`.\r\n\r\nIt seems not so much exchange response  `eta` (only see bitmart), and the data would be timestamp in ms.\r\n\r\nLet me know if you have any other issues."
      },
      {
        "user": "300Gram",
        "created_at": "2023-04-22T12:23:06Z",
        "body": "Thank you so much! "
      }
    ],
    "satisfaction_conditions": [
      "Clarifies possible status values returned by fetchStatus() when an exchange enters maintenance mode",
      "Specifies the format/type of the 'eta' value (timestamp vs relative time)",
      "Addresses exchange-specific variations in status responses",
      "Provides guidance for implementing maintenance mode detection and handling"
    ]
  },
  {
    "number": 17514,
    "title": "Opening stop loss and take profit orders on Bybit",
    "created_at": "2023-04-09T10:11:46Z",
    "closed_at": "2023-05-06T10:33:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/17514",
    "body": "### Operating System\r\n\r\nWindows 10\r\n\r\n### Programming Languages\r\n\r\npython\r\n\r\n### CCXT Version\r\n\r\n3.0.9\r\n\r\n### Description\r\n\r\nI'm trying to create a stop loss and take profit for my order on bybit with ccxt.\r\n\r\n\r\n\r\n### Code\r\n\r\nI've tried the following:\r\n(1)\r\n```\r\n        side = direction\r\n        order_type = 'market'\r\n        entry_price = last_price\r\n        size = 1\r\n        params = {\r\n            'leverage': 1,\r\n            'marginMode': 'cross',\r\n            'stopLoss' : stop_loss,\r\n            'takeProfit' : take_profit\r\n        }\r\n\r\n        order = exchange.create_order(symbol, order_type, side, size, entry_price, params)\r\n```\r\n\r\n(2)\r\n```\r\n        side = direction\r\n        order_type = 'market'\r\n        entry_price = last_price\r\n        size = 1\r\n        params = {\r\n            'leverage': 1,\r\n            'marginMode': 'cross',\r\n            'stopLossPrice' : stop_loss,\r\n            'takeProfitPrice' : take_profit\r\n        }\r\n\r\n        order = exchange.create_order(symbol, order_type, side, size, entry_price, params)\r\n```\r\n\r\n(3)\r\n```\r\n        side = direction\r\n        order_type = 'market'\r\n        entry_price = last_price\r\n        size = 1\r\n        params = {\r\n            'leverage': 1,\r\n            'marginMode': 'cross',\r\n            'stop_loss' : stop_loss,\r\n            'take_profit' : take_profit\r\n        }\r\n\r\n        order = exchange.create_order(symbol, order_type, side, size, entry_price, params)\r\n```\r\n\r\n\r\n\r\n(4)\r\n```\r\n        side = direction\r\n        order_type = 'market'\r\n        entry_price = last_price\r\n        size = 1\r\n        params = {\r\n            'leverage': 1,\r\n            'marginMode': 'cross',\r\n            'stopPrice' : stop_loss,\r\n            'triggerPrice' : take_profit\r\n        }\r\n\r\n        order = exchange.create_order(symbol, order_type, side, size, entry_price, params)\r\n```\r\n\r\nI'm either getting the following error:\r\n```\r\nError: bybit {\"retCode\":10001,\"retMsg\":\"Request parameter error.\",\"result\":{},\"retExtInfo\":{},\"time\":1681034354617}\r\n```\r\n\r\nOr it opens a limit order for the stop loss and it ignores the take profit limit order and market order.",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/17514/comments",
    "author": "ambiflextrous",
    "comments": [
      {
        "user": "sc0Vu",
        "created_at": "2023-04-10T04:48:10Z",
        "body": "Hi @weslienlive\r\n\r\nThe bug was incorrect data type of stopLoss/takeProfit (should be string). We already fixed last week. Please update ccxt. Let me know if you have any other issues."
      },
      {
        "user": "ambiflextrous",
        "created_at": "2023-04-10T07:18:34Z",
        "body": "Thank you, it works now.  Got another question, why when I set the leverage to 1 in the exchange it's 10?"
      }
    ],
    "satisfaction_conditions": [
      "Correct parameter format specification for stopLoss/takeProfit in CCXT for Bybit",
      "Proper handling of leverage parameter synchronization between CCXT and Bybit",
      "Clear documentation of Bybit-specific parameter requirements through CCXT"
    ]
  },
  {
    "number": 17479,
    "title": "Fetch oldest candles on BitGet, no response",
    "created_at": "2023-04-04T21:23:55Z",
    "closed_at": "2023-04-06T06:21:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/17479",
    "body": "### Operating System\n\nlinux\n\n### Programming Languages\n\nJS\n\n### CCXT Version\n\n3.0.52\n\n### Description\n\nHi @carlosmiei,\r\n\r\nI'm trying to retrieve the oldest candles for a symbol on BitGet.\r\nI use a large time frame to estimate the first market time.\r\nBut no candle is returned.\r\nSee example.\r\nWork fine on Binance and ByBit.\n\n### Code\n\n```\r\n\u2002\u2002    const exchange = new ccxt['bitget']()\r\n\r\n    // big time frame\r\n    let ohlcvRawList = await exchange.fetchOHLCV('ETH/USDT:USDT', '1w')\r\n\r\n    let firstMonthCandle = ohlcvRawList[0]\r\n    const timeStart = firstMonthCandle[0]\r\n\r\n    const timeStartTenMonthAfter = timeStart + 60 * 60 * 24 * 30 * 10 * 1000\r\n\r\n    console.log('first month candle', firstMonthCandle)\r\n    ohlcvRawList = await exchange.fetchOHLCV('ETH/USDT:USDT', '1h', timeStart)\r\n    console.log(ohlcvRawList.length) // 0\r\n\r\n    // try 10 months after\r\n    ohlcvRawList = await exchange.fetchOHLCV('ETH/USDT:USDT', '1h', timeStartTenMonthAfter)\r\n    console.log(ohlcvRawList.length) // 0\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/17479/comments",
    "author": "dawadam",
    "comments": [
      {
        "user": "sc0Vu",
        "created_at": "2023-04-05T02:30:43Z",
        "body": "Hi @dawadam \r\n\r\nAfter test, it seems you can fetch data within 30 days for 1h (the documentations said for `1m` candles)"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of BitGet's API limitations for historical candle data",
      "Clarification of valid time ranges for different candle intervals on BitGet",
      "Method to determine the earliest available timestamp for historical data",
      "Workaround for fetching older data beyond API limitations"
    ]
  },
  {
    "number": 17307,
    "title": "exchange.loadMarkets() returns unsupported TUSD pairs for Binance",
    "created_at": "2023-03-22T20:01:41Z",
    "closed_at": "2023-03-23T12:39:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/17307",
    "body": "### Operating System\n\nWindows\n\n### Programming Languages\n\nJS\n\n### CCXT Version\n\n3.0.23\n\n### Description\n\nThe symbols returned when using exchange.loadMarkets() with Binance returns the following TUSD trading pairs:\r\n\r\nADA/TUSD\r\nALGO/TUSD\r\nANKR/TUSD\r\nATOM/TUSD\r\nBAT/TUSD\r\nBCH/TUSD\r\nBCPT/TUSD\r\nBNB/TUSD\r\nBSV/TUSD\r\nBTC/TUSD\r\nBTT/TUSD\r\nEOS/TUSD\r\nETC/TUSD\r\nETH/TUSD\r\nFTM/TUSD\r\nGTO/TUSD\r\nLINK/TUSD\r\nLTC/TUSD\r\nNEO/TUSD\r\nONE/TUSD\r\nPAX/TUSD\r\nPHB/TUSD\r\nTFUEL/TUSD\r\nTRX/TUSD\r\nTUSD/BNB\r\nTUSD/BTC\r\nTUSD/BUSD\r\nTUSD/ETH\r\nTUSD/USDT\r\nTUSDB/TUSD\r\nUSDC/TUSD\r\nUSDS/TUSD\r\nWAVES/TUSD\r\nXLM/TUSD\r\nXRP/TUSD\r\nZEC/TUSD\r\n\r\nOf these, only the following are actually available on Binance:\r\nBNB/TUSD\r\nBTC/TUSD\r\nETH/TUSD\r\nTUSD/USDT\r\n\r\nPerhaps this is a problem on the Binance side, but reporting it just in case.\r\n\n\n### Code\n\n```\r\n\u2002\u2002\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/17307/comments",
    "author": "hodlerhacks",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2023-03-23T12:39:32Z",
        "body": "Hello @hodlerhacks,\r\nThanks but if you look closely the market has `active:false` meaning that the market exists but is not available for trading"
      },
      {
        "user": "hodlerhacks",
        "created_at": "2023-03-23T12:55:35Z",
        "body": "Ah, I learned something new, thanks!!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of inactive market status indicators",
      "Clarification of CCXT's market data structure",
      "Differentiation between existing markets and tradable markets"
    ]
  },
  {
    "number": 17170,
    "title": "watch_ohlcv function not working for Bybit exchange",
    "created_at": "2023-03-14T15:40:00Z",
    "closed_at": "2023-03-14T19:25:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/17170",
    "body": "### Operating System\n\nWindows 11\n\n### Programming Languages\n\npython\n\n### CCXT Version\n\n2.8.89\n\n### Description\n\nI am trying to connect with Bybit using the watch_ohlcv function to stream live data, but it returns an array with no values. The same code works fine for Binance Exchange.\r\n\r\nOutput ---\r\n\r\n[[None, None, None, None, None, None]]\r\n[[None, None, None, None, None, None]]\r\n[[None, None, None, None, None, None]]\r\n[[None, None, None, None, None, None]]\r\n[[None, None, None, None, None, None]]\n\n### Code\n\n```\r\nimport asyncio\r\nimport ccxt.pro\r\n\r\n\r\nmarket = \"future\"\r\napi_key = \"api_key\"\r\napi_sec = \"api_secret\"\r\n\r\nexchange = ccxt.pro.bybit({\r\n    'enableRateLimit': True,\r\n    'options': {\r\n        'defaultType': market,\r\n        'adjustForTimeDifference': True\r\n    },\r\n    \"apiKey\" : api_key,\r\n    \"secret\" : api_sec\r\n})\r\n\r\n\r\n\r\nasync def fetch_kline():\r\n\r\n    while True:\r\n\r\n        live_feed = await exchange.watch_ohlcv(\"ETH/USDT\", \"1m\")\r\n\r\n        print(live_feed)\r\n\r\n\r\n\r\nasyncio.run(fetch_kline())\r\n```",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/17170/comments",
    "author": "sumitgautam0101",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2023-03-14T15:41:49Z",
        "body": "Hello @sumitgautam0101,\r\nDo you mind updating your ccxt version? I think this issue was fixed in the meantime."
      },
      {
        "user": "sumitgautam0101",
        "created_at": "2023-03-14T19:13:35Z",
        "body": "Thank You, it works now !! "
      },
      {
        "user": "carlosmiei",
        "created_at": "2023-03-14T19:25:33Z",
        "body": "@sumitgautam0101 nice, will close this issue then. Let us know if anything!"
      }
    ],
    "satisfaction_conditions": [
      "Solution resolves compatibility between CCXT version and Bybit's OHLCV streaming implementation",
      "Ensures watch_ohlcv returns valid numerical data instead of null values for Bybit",
      "Maintains equivalent functionality to working Binance implementation",
      "Addresses version-specific bugs in CCXT's Bybit WebSocket implementation"
    ]
  },
  {
    "number": 17160,
    "title": "FetchLedger Coinbase",
    "created_at": "2023-03-13T23:07:55Z",
    "closed_at": "2023-03-15T14:00:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/17160",
    "body": "### Operating System\r\n\r\nlinux\r\n\r\n### Programming Languages\r\n\r\nJS\r\n\r\n### CCXT Version\r\n\r\n3.0.3\r\n\r\n### Description\r\n\r\nUnable to add repo to project. get error\r\n```\r\nExit code: 1\r\nCommand: node postinstall.js\r\nOutput:\r\nnode:internal/errors:490\r\n    ErrorCaptureStackTrace(err);\r\n    ^\r\n\r\nError [ERR_MODULE_NOT_FOUND]: Cannot find package 'data-uri-to-buffer' imported from <project>/node_modules/ccxt/js/src/static_dependencies/node-fetch/index.js\r\n```\r\n\r\n### Code\r\n\r\n```\r\n\u2002\u2002\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/17160/comments",
    "author": "naward-cs",
    "comments": [
      {
        "user": "sc0Vu",
        "created_at": "2023-03-14T09:10:21Z",
        "body": "Hi @naward-cs \r\n\r\nI think the issue was fixed in the latest release. Let me know if you have any other issue."
      },
      {
        "user": "naward-cs",
        "created_at": "2023-03-15T14:01:04Z",
        "body": "It did fix it"
      }
    ],
    "satisfaction_conditions": [
      "Resolves the missing 'data-uri-to-buffer' dependency error",
      "Ensures compatibility with CCXT 3.0.3 installation process",
      "Provides a working Node.js environment for CCXT",
      "Maintains CCXT functionality after fix"
    ]
  },
  {
    "number": 17114,
    "title": "watchOrderBookSnapshot has error in ascendex",
    "created_at": "2023-03-10T18:18:33Z",
    "closed_at": "2023-03-16T15:26:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/17114",
    "body": "### Operating System\r\n\r\nwindows 64bit\r\n\r\n### Programming Languages\r\n\r\nJS\r\n\r\n### CCXT Version\r\n\r\n2.8.75\r\n\r\n### Description\r\n\r\n```js\r\nError in watchOrderBookSnapshot method in the ascendex:\r\n\r\nC:\\Bots\\jsTest\\node_modules\\ccxt\\js\\pro\\ascendex.js:270\r\n        orderbook.reset (snapshot);\r\n                  ^\r\n\r\nTypeError: Cannot read properties of undefined (reading 'reset')\r\n    at ascendex.handleOrderBookSnapshot (C:\\Bots\\jsTest\\node_modules\\ccxt\\js\\pro\\ascendex.js:270:19)\r\n    at ascendex.handleMessage (C:\\Bots\\jsTest\\node_modules\\ccxt\\js\\pro\\ascendex.js:892:20)\r\n    at WsClient.onMessage (C:\\Bots\\jsTest\\node_modules\\ccxt\\js\\pro\\base\\Client.js:283:14)\r\n    at callListener (C:\\Bots\\jsTest\\node_modules\\ws\\lib\\event-target.js:290:14)\r\n    at WebSocket.onMessage (C:\\Bots\\jsTest\\node_modules\\ws\\lib\\event-target.js:209:9)\r\n    at WebSocket.emit (node:events:512:28)\r\n    at Receiver.receiverOnMessage (C:\\Bots\\jsTest\\node_modules\\ws\\lib\\websocket.js:1180:20)\r\n    at Receiver.emit (node:events:512:28)\r\n    at Receiver.dataMessage (C:\\Bots\\jsTest\\node_modules\\ws\\lib\\receiver.js:541:14)\r\n    at Receiver.getData (C:\\Bots\\jsTest\\node_modules\\ws\\lib\\receiver.js:459:17)\r\n\r\nNode.js v19.7.0\r\n```\r\n\r\n### Code\r\n\r\n```js\r\nconst ccxt = require('ccxt')\r\n\r\nconst exchange = new ccxt.pro.ascendex({\r\n    'apiKey': apiKey,\r\n    'secret': secret,\r\n    'options': {\r\n        'account-category': 'margin', // 'cash', 'margin', 'futures' // obsolete\r\n        'account-group': accountGroup,\r\n        'defaultType': 'margin', // 'spot', 'margin', 'swap'\r\n        'accountCategories': {\r\n            'margin': 'margin',\r\n        }\r\n    },\r\n})\r\n\r\nexchange.verbose = false\r\n\r\nasync function watchOrderBookSnapshot(symbol) {\r\n    while (true) {\r\n        try {\r\n            const orderbook = await exchange.watchOrderBookSnapshot(symbol)\r\n            console.log(new Date(), exchange.id, symbol, orderbook)\r\n        } catch (e) {\r\n            console.log(symbol, e)\r\n        }\r\n    }\r\n}\r\n\r\nwatchOrderBookSnapshot('MATIC/USDT')\u2002\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/17114/comments",
    "author": "fotrosi",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2023-03-11T14:28:40Z",
        "body": "Hello @fotrosi,\r\n`watchOrderBookSnaphot` is an internal method and not meant to be used independently. You should be using `watchOrderBook` instead. "
      }
    ],
    "satisfaction_conditions": [
      "Clarification of proper CCXT API usage for order book monitoring",
      "Explanation of internal vs public methods in CCXT architecture",
      "Working example of real-time order book subscription pattern"
    ]
  },
  {
    "number": 16952,
    "title": "Create Order in ccxt bybit Testnet position idx not match position mode",
    "created_at": "2023-02-24T13:43:11Z",
    "closed_at": "2023-02-24T14:13:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/16952",
    "body": "### \u061c\n\nI want create a simple order in Derivates -> USDT Perpetual -> BTCUSDT. \r\n\r\nI have following Balance:\r\n'coin': 'BTC', 'equity': '1.07893293', 'walletBalance': '1.07893293'\r\n\r\nHere is my code:\r\n\r\nimport ccxt\r\n\r\nexchange = ccxt.bybit({\r\n    'apiKey': 'apiKey',\r\n    'secret': 'secretKey',\r\n    'enableRateLimit': True,\r\n    'options': {\r\n        'recvWindow': 10000,\r\n    }\r\n})\r\nexchange.set_sandbox_mode(True)\r\nexchange.options[\"defaultType\"] = 'swap'\r\nsymbol = 'BTC/USDT:USDT'\r\norder = exchange.createOrder(symbol=symbol, type='Market', side='buy', amount=0.01)\r\n\r\nBut i get this error:\r\nbybit {\"retCode\":10001,\"retMsg\":\"position idx not match position mode\",\"result\":{},\"retExtInfo\":{},\"time\":1677246036932}\r\n\r\nHave somebody a solution?\r\nThanks",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/16952/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2023-02-24T14:04:40Z",
        "body": "Hello @hambi44,\r\nYes you just need to provide `positionIdx` inside params.\r\n\r\nExample:\r\n```Python\r\nparams = {\r\n    'positionIdx': 1 #  0 One-Way Mode, 1 Buy-side, 2 Sell-side\r\n}\r\nsymbol = 'BTC/USDT:USDT'\r\norder = exchange.createOrder(symbol=symbol, type='Market', side='buy', amount=0.01, params = params)\r\n```\r\n"
      },
      {
        "user": "ghost",
        "created_at": "2023-02-24T14:13:25Z",
        "body": "Best thanks. It works"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of required position index parameter for Bybit's position mode",
      "Clarification of position mode configuration requirements",
      "Guidance on parameter placement in CCXT structure"
    ]
  },
  {
    "number": 16898,
    "title": "Kucoinfutures fetch open orders shows no data anymore",
    "created_at": "2023-02-19T15:55:05Z",
    "closed_at": "2023-02-20T13:10:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/16898",
    "body": "### \u061c\n\nOS: Windows 10\r\nProgramming Language version: Python\r\nCCXT version: 2.8.16\r\n\r\n\r\nHello, \r\n\r\nsince a few days kucoinfutures doesn't show any data if I try to fetch open orders when STOP ORDER is placed. Issue occurs at linear and inverse contracts.   If a limit order above price is placed it works. \r\nAlso here I didn't change anything, it has worked fine for months now, but suddenly it doesn't work anymore. \r\n\r\n\r\nkucoin = ccxt.kucoinfutures({'enableRateLimit': True,\r\n                       'apiKey': kucoinconfig.api_key,\r\n                       'secret': kucoinconfig.api_secret,\r\n                       'password' : 'xxxxxxxxxxx',})\r\n\r\nsymbol = 'ETH/USDT:USDT'\r\npos_size = 1\r\n\r\norders = kucoin.fetch_open_orders(symbol)\r\n        print(orders)\r\n\r\nOutput is this --> []\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/16898/comments",
    "author": "Nitrix321",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2023-02-20T09:58:19Z",
        "body": "Hello @Nitrix321,\r\n\r\nIf you want to fetch open `stop` orders you should provide `stop:True` inside `params`.\r\nExample:\r\n```\r\nparams = {\r\n   'stop': True\r\n}\r\nstop_open_orders = kucoin.fetch_open_orders(symbol, params=params)\r\n```\r\n\r\n"
      },
      {
        "user": "Nitrix321",
        "created_at": "2023-02-20T13:10:32Z",
        "body": "Hi @carlosmiei,\r\nyou are right, now it's working. I could have sworn it worked all along. \r\nBut ok, now it is.\r\n\r\nThank you again :-)"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how to retrieve stop orders specifically when fetching open orders",
      "Clarification on filtering mechanisms for different order types (stop vs limit)",
      "Documentation of required API parameters for specialized order queries"
    ]
  },
  {
    "number": 16878,
    "title": "The parameters of orders are null",
    "created_at": "2023-02-17T11:53:11Z",
    "closed_at": "2023-02-17T13:38:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/16878",
    "body": "### \u061c\n\nhello, this is what I get after calling\r\n\r\n`write(order=exchange.create_market_order(symbol, side, size, params))`\r\n\r\nwhere write is a function that dumps a json in a json file\r\n\r\n`{\r\n    \"info\": {\r\n        \"orderId\": \"2c471e2c-7160-40e0-842b-6234a0333e2a\",\r\n        \"orderLinkId\": \"\"\r\n    },\r\n    \"id\": \"2c471e2c-7160-40e0-842b-6234a0333e2a\",\r\n    \"clientOrderId\": null,\r\n    \"timestamp\": null,\r\n    \"datetime\": null,\r\n    \"lastTradeTimestamp\": null,\r\n    \"symbol\": null,\r\n    \"type\": null,\r\n    \"timeInForce\": null,\r\n    \"postOnly\": null,\r\n    \"side\": null,\r\n    \"price\": null,\r\n    \"stopPrice\": null,\r\n    \"triggerPrice\": null,\r\n    \"amount\": null,\r\n    \"cost\": null,\r\n    \"average\": null,\r\n    \"filled\": null,\r\n    \"remaining\": null,\r\n    \"status\": null,\r\n    \"fee\": null,\r\n    \"trades\": [],\r\n    \"fees\": [],\r\n    \"reduceOnly\": null\r\n}`\r\n\r\nwhy are all the attributes null? what am I doing wrong?",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/16878/comments",
    "author": "SequoiaB",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2023-02-17T12:11:44Z",
        "body": "Hello @SequoiaB,\r\nYou're doing nothing wrong. Some exchanges, upon creating an order return only its id immediately (some order creation processes are async so they don't have the information available right away). Using that id you can fetch all the information by using the unified method `fetchOrder` "
      },
      {
        "user": "SequoiaB",
        "created_at": "2023-02-17T13:38:27Z",
        "body": "thx"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why order parameters are null immediately after creation",
      "Identification of asynchronous order creation processes",
      "Clarification of exchange API limitations"
    ]
  },
  {
    "number": 16650,
    "title": "python async speed slower",
    "created_at": "2023-01-27T07:36:29Z",
    "closed_at": "2023-01-27T18:00:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/16650",
    "body": "### Operating System\n\nubuntu\n\n### Programming Languages\n\npython\n\n### CCXT Version\n\n2.6.94\n\n### Description\n\nWhile I was trying to migrate my code to async I noticed that my execution was slower.\r\n\r\nI wrote a small code to compare the async vs sync speed. \r\n\r\nAverage execution time of both is written below in seconds in one of my test runs. On average async takes rougly 2x longer . Similar results when tested in other methods such as \"fetch_tickers\".\r\n\r\nasync mean: 1.1664345026016236\r\nsync mean: 0.5469205617904663\n\n### Code\n\n```\r\nimport asyncio\r\nimport time\r\n\r\nimport ccxt.async_support as ccxta  \r\nimport ccxt\r\nimport os\r\nfrom dotenv import load_dotenv\r\nload_dotenv()\r\n\r\nbinance_keys = {\r\n        \"apikey\" : os.getenv(\"BINANCE_APIKEY\"),\r\n        \"secret\" : os.getenv(\"BINANCE_SECRET\")\r\n    }\r\n\r\nasync def get_balance_async(exchange):\r\n    balance = await exchange.fetch_balance()\r\n    await exchange.close()\r\n    return balance\r\n\r\nexchange_async = ccxta.binance({\r\n        'apiKey': binance_keys[\"apikey\"],\r\n        'secret': binance_keys[\"secret\"],\r\n    })\r\n\r\nexchange_sync = ccxt.binance({\r\n        'apiKey': binance_keys[\"apikey\"],\r\n        'secret': binance_keys[\"secret\"],\r\n    })\r\n\r\ntime_sync = []\r\ntime_async = []\r\n\r\nloop = asyncio.get_event_loop()\r\nfor i in range(10):\r\n\r\n    start = time.time()\r\n    loop.run_until_complete(get_balance_async(exchange_async))\r\n    time_async.append(time.time() - start)\r\n    time.sleep(0.2)\r\n\r\n    start = time.time()\r\n    balance = exchange_sync.fetch_balance()\r\n    time_sync.append(time.time() - start)\r\n    time.sleep(0.2)\r\n\r\nprint(\"Async data: \", time_async)\r\nprint(\"Sync data: \", time_sync)\r\nprint(f\"async mean: {sum(time_async)/len(time_async)}\")\r\nprint(f\"sync mean: {sum(time_sync)/len(time_sync)}\")\r\n\u2002\u2002\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/16650/comments",
    "author": "akasimo",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2023-01-27T11:23:45Z",
        "body": "Hello @akasimo,\r\nThe difference is not related to the sync vs async approach, but the default RateLimiter ccxt async has in place. You can disable it if you want by providing this option: `enableRateLimit: False`. "
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why async implementation is slower than sync in this specific CCXT context",
      "Identification of configuration differences between async and sync CCXT implementations",
      "Guidance on optimizing async performance to match/exceed sync approach",
      "Clarification of CCXT's async architecture decisions",
      "Best practices for fair comparison between sync/async approaches in CCXT"
    ]
  },
  {
    "number": 16500,
    "title": "How to fetchCurrencies workes?",
    "created_at": "2023-01-15T21:24:48Z",
    "closed_at": "2023-01-16T04:24:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/16500",
    "body": "### Operating System\r\n\r\nWindows 10 \r\n\r\n### Programming Languages\r\n\r\nNodejs\r\n\r\n### CCXT Version\r\n\r\n2.5.47\r\n\r\n### Description\r\n\r\nThis is not exactly a bug request, more of a question. I'm sorry, I couldn't find the question section. The thing is, I can't get the currency structure. In the documentation, this method is listed as public, but I saw a similar question where the developers said that the structure of the token, the commission and the network can only be obtained with an API key. How can I get Currency Structure? I also tried the example directly from the documentation, but it's most likely for python, or I'm using it incorrectly\r\n\r\n### Code\r\n\r\n```\r\n\u2002\u2002\r\nconst ccxt = require(\"ccxt\");\r\n\r\n(async function () {\r\n  let binance = new ccxt.binance();\r\n  await binance.loadMarkets;\r\n  let cur= await binance.fetchCurrencies[\"ETH\"];\r\n  console.log(cur);  // undefined\r\n})();\r\n\r\n// Example from docs\r\n(async function () {\r\n  let binance = new ccxt.binance();\r\n  await binance.loadMarkets();\r\n  let cur= binance.currencies[\"ETH\"][\"fee\"];\r\n  console.log(cur);  // undefined\r\n})(); /\r\n\r\n//I want this Currency Structure\r\n\r\n{\r\n    'id':       'btc',       \r\n    'code':     'BTC',       \r\n    'name':     'Bitcoin',   \r\n    'active':    true,       \r\n    'fee':       0.123,      \r\n    'precision': 8,         \r\n    'deposit':   true      \r\n    'withdraw':  true        \r\n    'limits': {              \r\n        'amount': {\r\n            'min': 0.01,     \r\n            'max': 1000,     \r\n        },\r\n        'withdraw': { ... },\r\n        'deposit': {...},\r\n    },\r\n    'networks': {...}        \r\n    'info': { ... },    \r\n}",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/16500/comments",
    "author": "AlwxDavydov",
    "comments": [
      {
        "user": "sc0Vu",
        "created_at": "2023-01-16T04:23:19Z",
        "body": "Hi @AlwxDavydov \r\n\r\nAfter loadMarkets, you can get currency:\r\n\r\n`let cur= binance.currency('ETH')`"
      },
      {
        "user": "AlwxDavydov",
        "created_at": "2023-01-16T05:07:17Z",
        "body": "Thank you!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how to properly access currency structure data in CCXT",
      "Demonstration of proper method chaining after loadMarkets",
      "Validation that solution retrieves nested currency properties"
    ]
  },
  {
    "number": 16406,
    "title": "[Python] set TP and SL in Bybit ",
    "created_at": "2023-01-10T03:11:55Z",
    "closed_at": "2023-01-10T13:09:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/16406",
    "body": "### Operating System\r\n\r\nLinux\r\n\r\n### Programming Languages\r\n\r\npython\r\n\r\n### CCXT Version\r\n\r\n2.5.56\r\n\r\n### Description\r\n\r\nAny way to set TP and SL with bybit in python?\r\nI keep getting errors like\r\n\r\n```\r\nERROR:root:bybit {\"retCode\":10001,\"retMsg\":\"expect Failling, but trigger_price[5980000] \\u003e= current[1361500]??1\",\"result\":{},\"retEx\r\n``` \r\n\r\nor \r\n\r\n```\r\nERROR:root:bybit {\"retCode\":10001,\"retMsg\":\"expect Rising, but trigger_price[1249500] \\u003c= current[1363000]??1\",\"result\":{},\"retExtI\r\n```\r\nboth for shorts and longs\r\n\r\n### Code\r\n\r\n```\r\n\u2002\u2002bybit.create_order(symbol=position.symbol,\r\n                                   type='limit',\r\n                                   side=position.direction,\r\n                                   amount=size,\r\n                                   price=float(position.entry),\r\n                                   params={\r\n                                    'leverage': LEVER,\r\n                                    'stopLossPrice': float(position.sl),\r\n                                    'takeProfitPrice': float(position.tp),\r\n                                    })\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/16406/comments",
    "author": "3ntr0phy",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2023-01-10T09:56:07Z",
        "body": "Hello @3ntr0phy,\r\n\r\nActually, `stopLossPrice` and `takeProfitPrice` params are incompatible params, because they're meant to be used when you want your order or behave as a `stopLoss` **or** `takeProfit` orders. \r\n\r\nIf you want to attach a takeProfit and stopLoss order to the position being opened, you should use the `stopLoss` and `takeProfit` params.\r\n\r\nExample:\r\n\r\n```Python\r\nparams = {\r\n    'stopLoss': str(float(position.sl)), # stringified number\r\n    'takeProfi': str(float(position.tp)), # stringified number\r\n}\r\nbybit.create_order(...., params = params)\r\n```\r\n"
      }
    ],
    "satisfaction_conditions": [
      "Clarify correct parameter names for attaching TP/SL to positions",
      "Specify required value formatting for TP/SL parameters",
      "Explain parameter compatibility with order types"
    ]
  },
  {
    "number": 16348,
    "title": "CCXT OKEX fetchorders not showing stoploss orders",
    "created_at": "2023-01-05T20:25:58Z",
    "closed_at": "2023-01-06T08:37:21Z",
    "labels": [
      "bug",
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/16348",
    "body": "### Operating System\r\n\r\n\r\n_No response_\r\n\r\n### Programming Languages\r\nPython3\r\n\r\n### CCXT Version\r\n1.79.95\r\n\r\n### Description\r\nfor okex, fetch_open_orders() outputs my limit orders but not my stoploss/takeprofit orders\r\n\r\nhow can i get my stoploss/takeprofit orders? it's driving me nuts!\r\n\r\n### Code\r\nokex = ccxt.okex({\r\n     \"apiKey\": xxx,\r\n     \"secret\": xxx,\r\n     \"password\": xxx,\r\n     'enableRateLimit': True,\r\n     'options': {\r\n         'defaultType': 'swap',\r\n         'swap': True# \u2190-------------- quotes and 'future'\r\n     }\r\n})\r\n\r\n```\r\nokex.fetch_open_orders() #shows limit orders but not SL/TP orders\r\n\r\nparams = {'stop':True} \r\nokex.fetch_open_orders(params=params) \r\n\r\n#outputs ccxt.base.errors.BadRequest: okex {\"code\":\"51000\",\"data\":[],\"msg\":\"Parameter ordType  error\"}\r\n\u2002\u2002\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/16348/comments",
    "author": "pachinkopirate",
    "comments": [
      {
        "user": "sc0Vu",
        "created_at": "2023-01-06T08:28:13Z",
        "body": "Hi @pachinkopirate \r\n\r\nThe `ordType` is required.\r\nordType | String | Yes | Order typeconditional: One-way stop orderoco: One-cancels-the-other ordertrigger: Trigger ordermove_order_stop: Trailing ordericeberg: Iceberg ordertwap: TWAP order\r\n-- | -- | -- | --\r\n\r\neg:\r\n\r\n```python\r\nsymbol = 'ETH/USDT:USDT'\r\nparams = {'stop':True,'ordType':'oco'} \r\nokex.fetch_open_orders(symbol, None, None, params) \r\n```\r\n\r\nLet me know if you have other questions."
      },
      {
        "user": "pachinkopirate",
        "created_at": "2023-01-06T17:51:57Z",
        "body": "omg - works perfectly.  thank you so much!! @sc0Vu "
      }
    ],
    "satisfaction_conditions": [
      "Identifies required order type parameters for OKEX stop/take-profit orders",
      "Handles exchange-specific parameter requirements for derivative order types"
    ]
  },
  {
    "number": 16193,
    "title": "CCXT Ascendex Stopped Working (fetch_markets())",
    "created_at": "2022-12-24T18:04:51Z",
    "closed_at": "2022-12-25T01:43:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/16193",
    "body": "Hi all.\r\n\r\nHave been using CCXT for Ascendex successfully for months.  Recently it stopped working.\r\nIt's failing in 'load_markets'.  Base currency & quote currency for some trading pair I don't even care about are both Null, this leads to a Type error during concatenation.    I would guess some bad/null data coming from the exchange, or that Null's are not being filtered/handled properly in CCXT Ascendex.\r\n\r\n- OS:  AWS EC2 (Windows)\r\n- Programming Language version:  Python 3.9 ( 3.9.5 I think)\r\n- CCXT version:  latest, 2.2.89\r\n\r\nYOUR_CODE_TO_REPRODUCE_THE_ISSUE_WITHOUT_YOUR_KEYS\r\n\r\nascendex.py, line 573, 'fetch_markets()'\r\n\r\nERROR LINE>>>symbol = base + '/' + quote \r\n \r\nFails with Type error, because base & quote are both = None.\r\nThe symbol is XMR5S/USDT, which I am not even interested in.\r\n\r\n----\r\nThe calling code is standard set up:\r\n```\r\nself.exchange_class = getattr(mod, exchange_id)\u2028\u2028\r\nself.ccxt = self.exchange_class({\u2028    'apiKey': config['apiKey'],\u2028    'secret': config['secret'],\u2028    'uid': config['uid'],\u2028    'password': config['password'],\u2028    'options': {\u2028        'defaultType': 'spot',\u2028    },\u2028    'enableRateLimit': True,\u2028})\u2028 \r\nself.ccxt.set_sandbox_mode(\u2028config['is_sandbox']\u2028)\u2028\r\n\u2028self.ccxt.load_markets()\r\n\r\n```\r\n\r\nYOUR_OUTPUT_ERROR_EXCEPTION_IN_TEXT_NO_SCREENSHOTS\r\n```\r\nNot very useful is it doesn't cast light on WHY they are None value.\r\n\"unsupported operand type(s) for +: 'NoneType' and 'str'\"\r\n```\r\n\r\nPlease advise, thank you\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/16193/comments",
    "author": "SpenTappy",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2022-12-24T18:10:39Z",
        "body": "Hello @SpenTappy,\r\nYes, we detected this issue recently, but it should already be fixed. Can you try updating to the latest version?\r\n\r\nThanks!"
      },
      {
        "user": "SpenTappy",
        "created_at": "2022-12-24T19:15:43Z",
        "body": "Thanks so much for quick response.  Turns out my 'latest' version wasn't as latest as I thought it was..\r\nConfirmed this is running well in `ccxt     2.4.55`\r\nHappy holidays."
      }
    ],
    "satisfaction_conditions": [
      "Resolves the NoneType error in symbol concatenation during market loading",
      "Handles invalid market data from Ascendex exchange",
      "Maintains compatibility with existing CCXT initialization patterns",
      "Requires no manual filtering of unwanted trading pairs"
    ]
  },
  {
    "number": 16040,
    "title": "Asyncio workflow",
    "created_at": "2022-12-10T11:14:02Z",
    "closed_at": "2022-12-13T05:20:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/16040",
    "body": "- Programming Language version: Python 3.10.5\r\n- CCXT version: 2.2.91\r\n\r\nIf I understand the asyncio functionality correctly , the workflow for this code is as following:\r\n```\r\nimport asyncio\r\nimport ccxt.pro\r\n\r\n\r\nasync def loop(exchange, symbol):\r\n    while True:\r\n        orderbook = await exchange.fetch_order_book(symbol)\r\n        # code without call exchange method\r\n        if condition:\r\n            await exchange.create_order(symbol, ...)\r\n\r\n\r\nasync def main():\r\n    exchange = ccxt.pro.binance()\r\n    symbols = ['symbol1', 'symbol2', 'symbolN']\r\n    await asyncio.gather(*[loop(exchange, symbol) for symbol in symbols])\r\n\r\n\r\nasyncio.run(main())\r\n```\r\n1. All loop functions execute code until 'fetch_order_book' call.\r\n2. Execute 'fetch_order_book' and execute code until 'fetch_order_book' if condition not True else until 'create_order'\r\n3. From symbol1 to symbolN in the order, execute 'fetch_order_book' or 'create_order'\r\n\r\nIs it right? \r\nSo my question is how can I execute the 'create_order' function immediately after 'fetch_order_book' if condition is True.\r\n\r\nThe purpose of my question is in case of you have lot of symbol in symbols list. If only the last symbol has condition True, you need to wait all symbol to fetch him orderbook before post your order. I would like to minimize the time between the execution of 'fetch_order_book_ and the execution of the trade.\r\n\r\nThanks you very much for your help.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/16040/comments",
    "author": "Hadevmin",
    "comments": [
      {
        "user": "pcriadoperez",
        "created_at": "2022-12-13T03:33:40Z",
        "body": "Hi @Hadevmin ,\r\n\r\nNot exactly. So asyncio will run all the loop functions in parallel and independently.\r\nEach loop function will first wait for `fetch_order_book`, check the condition and if true immediately call create_order. And continuously do so.\r\n\r\nSo this code should meet your needs of executing the 'create_order' function immediately after 'fetch_order_book' if condition is True.\r\n\r\nAlso for this case I'd recommend using `watch_order_book` which will provide order book updates, instead of having to fetch the full order book.\r\n\r\nPlease let me know if you have any further questions, if not feel free to close the issue"
      },
      {
        "user": "Hadevmin",
        "created_at": "2022-12-13T05:20:47Z",
        "body": "Hi @pcriadoperez,\r\n\r\nI probably made some mistakes in my tests because I was not observing this scenario....\r\nThanks for your help! And for the method, it is the case! ;)\r\nI use this condition before calling the order book or the account balance.\r\n```\r\nif exchange.has['watchOrderBook']:\r\n   exchange.watch_order_book\r\n   ...\r\nelif exchange.has['fetchOrderBook']:\r\n   exchange.fetch_order_book\r\n   ...\r\n```"
      }
    ],
    "satisfaction_conditions": [
      "Ensures immediate execution of 'create_order' after 'fetch_order_book' when condition is met",
      "Maintains concurrent processing of multiple symbols without sequential blocking",
      "Explains asynchronous execution model of asyncio.gather",
      "Recommends real-time data handling strategies",
      "Addresses exchange capability detection"
    ]
  },
  {
    "number": 16006,
    "title": "Kraken's response has little information",
    "created_at": "2022-12-07T18:04:53Z",
    "closed_at": "2022-12-07T21:01:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/16006",
    "body": "- OS:\r\n- Programming Language version:\r\n- CCXT version:\r\n\r\n```\r\n order = kraken.createOrder(symbol_name, type,side,quantity, price)\r\n```\r\nThis is the response I get:\r\n```\r\n{'id': 'XXXXXXXXXXX', 'clientOrderId': None, 'info': {'txid': ['XXXXXXXXX'], 'descr': {'order': 'sell 0.00178900 XBTUSD @ limit 16776.3'}}, 'timestamp': None, 'datetime': None, 'lastTradeTimestamp': None, 'status': None, 'symbol': 'BTC/USD', 'type': 'limit', 'timeInForce': None, 'postOnly': None, 'side': 'sell', 'price': 16776.3, 'stopPrice': None, 'cost': None, 'amount': 0.001789, 'filled': None, 'average': None, 'remaining': None, 'fee': None, 'trades': [], 'fees': []} \r\n```\r\nI looked up Kraken's REST API and they seem to have information about the trade when it's open and when it's closed but the response inside CCXT is just all NONE which does not help at all.\r\n\r\nThe following is the open orders response from Kraken:\r\n{\r\n  \"result\": {\r\n    \"open\": {\r\n      \"txid1\": {\r\n        \"refid\": \"string\",\r\n        \"userref\": \"string\",\r\n        \"status\": \"pending\",\r\n        \"opentm\": 0,\r\n        \"starttm\": 0,\r\n        \"expiretm\": 0,\r\n        \"descr\": {\r\n          \"pair\": \"string\",\r\n          \"type\": \"buy\",\r\n          \"ordertype\": \"market\",\r\n          \"price\": \"string\",\r\n          \"price2\": \"string\",\r\n          \"leverage\": \"string\",\r\n          \"order\": \"string\",\r\n          \"close\": \"string\"\r\n        },\r\n        \"vol\": \"string\",\r\n        \"vol_exec\": \"string\",\r\n        \"cost\": \"string\",\r\n        \"fee\": \"string\",\r\n        \"price\": \"string\",\r\n        \"stopprice\": \"string\",\r\n        \"limitprice\": \"string\",\r\n        \"trigger\": \"last\",\r\n        \"misc\": \"string\",\r\n        \"oflags\": \"string\",\r\n        \"trades\": [\r\n          \"string\"\r\n        ]\r\n      },\r\n      \"txid2\": {\r\n        \"refid\": \"string\",\r\n        \"userref\": \"string\",\r\n        \"status\": \"pending\",\r\n        \"opentm\": 0,\r\n        \"starttm\": 0,\r\n        \"expiretm\": 0,\r\n        \"descr\": {\r\n          \"pair\": \"string\",\r\n          \"type\": \"buy\",\r\n          \"ordertype\": \"market\",\r\n          \"price\": \"string\",\r\n          \"price2\": \"string\",\r\n          \"leverage\": \"string\",\r\n          \"order\": \"string\",\r\n          \"close\": \"string\"\r\n        },\r\n        \"vol\": \"string\",\r\n        \"vol_exec\": \"string\",\r\n        \"cost\": \"string\",\r\n        \"fee\": \"string\",\r\n        \"price\": \"string\",\r\n        \"stopprice\": \"string\",\r\n        \"limitprice\": \"string\",\r\n        \"trigger\": \"last\",\r\n        \"misc\": \"string\",\r\n        \"oflags\": \"string\",\r\n        \"trades\": [\r\n          \"string\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"error\": [\r\n    \"EGeneral:Invalid arguments\"\r\n  ]\r\n}\r\n\r\nIt seems like you guys have a lot on your plate so I do appreciate any help possible. Thank you",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/16006/comments",
    "author": "MotivaoCrypto",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2022-12-07T18:49:30Z",
        "body": "Hello @bonetjoshua, upon creating the order Kraken returns little information but you can use `fetchOrder` after creating it to get the full data. "
      },
      {
        "user": "MotivaoCrypto",
        "created_at": "2022-12-07T21:01:24Z",
        "body": "I appreciate the work around, I wish CCXT could fix this in the future. I'll close this issue"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how to retrieve complete order status information from Kraken through CCXT",
      "Clarification on data availability timing in CCXT order responses",
      "Guidance on tracking order lifecycle state changes",
      "Documentation of CCXT's Kraken integration limitations"
    ]
  },
  {
    "number": 15696,
    "title": "Can we dynamic the exchange selection on npm library",
    "created_at": "2022-11-15T13:35:07Z",
    "closed_at": "2022-11-16T03:35:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/15696",
    "body": "I'm working on a project where we need to implement a function that lets users choose which exchange to select from the api; is there any way we can dynamically update the exchange selection procedure in the library?\r\n\r\nThis is the method i applyed and i want that `ccxt.{someExchange}({})` part dynamic if there is a way please help me.\r\n` const binanceData = new ccxt.binance({})`\r\n`        let binanceTicker = await binanceData.fetchTicker(pair);`\r\n\r\n\r\nOS: Ubuntu\r\nProgramming Language version: Node.JS latest\r\nCCXT version: latest\r\nExchange: All\r\nMethod: All",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/15696/comments",
    "author": "lovepareek",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2022-11-15T14:29:44Z",
        "body": "Hello @LovePareek,\r\nYes you can.\r\n\r\nExample:\r\n```Javascript\r\nconst myDynamicVar = \"binance\"; // assuming this is the variable the user will fill in\r\nconst exchange = new ccxt[myDynamicVar]({});\r\n```\r\n\r\n"
      }
    ],
    "satisfaction_conditions": [
      "Dynamic exchange selection using runtime-determined values",
      "Support for all CCXT exchanges",
      "Proper instantiation pattern for CCXT exchanges",
      "Node.js implementation compatibility"
    ]
  },
  {
    "number": 15377,
    "title": "bybit Can't get any info of usdc perp",
    "created_at": "2022-10-21T13:57:03Z",
    "closed_at": "2022-10-24T09:27:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/15377",
    "body": "Hi, I have search and try method about options type already but still no clue. I can't access to any USDC perpetual symbol or balance. Its only show future balance&pair(USDT). I want to trade in usdc perpetual sir but \r\n```\r\nccxt.base.errors.BadSymbol: bybit does not have market symbol BTCPERP\r\n```\r\n\r\nThis is header\r\n```\r\nbybit = ccxt.bybit({\r\n\"apiKey\": \"xxxx\",\r\n\"secret\": \"xxxx\",\r\n\"options\": {'defaultType': 'future'}\r\n})\r\nprint(bybit.fetchMarkets())\r\n```\r\n\r\nIs bybit USDC perp contracts have some specific type for it?\r\n\r\nps. Sorry for trouble",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/15377/comments",
    "author": "croissantty",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2022-10-21T14:25:38Z",
        "body": "Hello @croissantty, Bybit has conflicting ids between USDT settle derivatives and the USDC one (BTC-PERP), so I would recommend using the unified symbol, in this case `BTC/USD:USDC`\r\n\r\nExample:\r\n```Python\r\nticker = await exchange.fetch_ticker('BTC/USD:USDC')\r\n```\r\n\r\nRegarding the balance, by default  will return the usdt based wallet balance, to change it, you have two options\r\n- settle the `defaultSettle` option as `USDC` `exchange.options['defaultSettle`] = 'USDC' `\r\n- add `settle` to `params` \r\n\r\nExample:\r\n\r\n```Python\r\nparams = {\r\n    'settle': 'USDC'\r\n}\r\nbalance = await exchange.fetch_balance(params)\r\n```\r\n\r\n\r\n"
      },
      {
        "user": "croissantty",
        "created_at": "2022-10-21T19:38:24Z",
        "body": "Very thank you @carlosmiei, with your help now I can access balance and symbol. but look like `fetchMyTrades()` is not working with this exchange or I'm missing something?\r\n\r\n```\r\nccxt.base.errors.NotSupported: bybit fetchMyTrades() is not supported for market BTC/USD:USDC\r\n```"
      },
      {
        "user": "ttodua",
        "created_at": "2022-10-24T09:27:18Z",
        "body": "> is not supported for market\r\n\r\nYou are right, seems the current implementation doesn't have any endpoint to access it, so it seems bybit is lacking that endpoint, we can't do anything in such case (if anyone finds out that that bybit added/supports it now and we have a missing implementation, let us know)"
      }
    ],
    "satisfaction_conditions": [
      "Correct symbol format specification for USDC perpetual contracts",
      "Explicit settlement currency specification for balance checks",
      "Clear documentation of Bybit's API limitations for USDC products"
    ]
  },
  {
    "number": 15306,
    "title": "How to implement fetchCurrency?",
    "created_at": "2022-10-15T11:25:48Z",
    "closed_at": "2022-10-18T08:51:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/15306",
    "body": "- OS: Windows 10 (Version 21H2)\r\n- Programming Language version: Node.js (version 18.10.0)\r\n- CCXT version: 2.0.19\r\n\r\n```JavaScript\r\nuse strict';\r\nconst ccxt = require('ccxt');\r\n\r\n(async function () {\r\n    console.log(ccxt.version)\r\n    const exchange = new ccxt.binance({\r\n        apiKey: 'My_API_Key',\r\n        secret: 'My_Secret_Key',\r\n        verbose: false,\r\n        defaultType: 'spot',\r\n        adjustForTimeDifference: true,\r\n        'options': {\r\n            'fetchCurrencies': true,\r\n        },\r\n    })\r\n    try \r\n    {\r\n    const currencies = await exchange.fetchCurrencies();\r\n    console.log(currencies);\r\n    } catch (error) {\r\n        console.log(error)\r\n    }\r\n})();\r\n```\r\n\r\nHello:\r\nI want to know if I can use `fetchCurrencies()` to implement `fetchCurrency()` for a single currency.\r\nFor example, in exchange Binance, it has so many currencies, but only a few of them are important, like: BTC, USDT, ETH.\r\nThe other currencies are not used often, so I want to know if I can implement `fetchCurrency()` to get information for only one currency, like \u2018USDT\u2019.\r\nPlease advise,\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/15306/comments",
    "author": "zydjohnHotmail",
    "comments": [
      {
        "user": "sc0Vu",
        "created_at": "2022-10-16T15:42:14Z",
        "body": "Hi @zydjohnHotmail \r\n\r\nThere are `currency(code)` and `safeCurrency(currencyId, currency` in Exchange class, you can use them to get currency."
      },
      {
        "user": "samgermain",
        "created_at": "2022-10-18T08:34:43Z",
        "body": "@zydjohnHotmail \r\n\r\nHere's an example of how you would use the currency method to get the info for a currency. You need to provide your `apiKey` and `secret` to binance, or else you will get different results\r\n\r\n```JavaScript\r\nconst ccxt = require('ccxt');\r\nconst keys = require('./keys.local.json');\r\n\r\n(async function () {\r\n    const exchange = new ccxt.binance({\r\n        ...keys.binance,\r\n        'options': {\r\n            'fetchCurrencies': true,\r\n        },\r\n    });\r\n    await exchange.loadMarkets ();\r\n    const currency = exchange.currency ('USDT');\r\n    console.log (currency);\r\n})();\r\n```\r\n\r\n## Output\r\n\r\n```JavaScript\r\n{\r\n  id: 'USDT',\r\n  name: 'TetherUS',\r\n  code: 'USDT',\r\n  precision: undefined,\r\n  info: {\r\n    coin: 'USDT',\r\n    depositAllEnable: true,\r\n    withdrawAllEnable: true,\r\n    name: 'TetherUS',\r\n    free: '0',\r\n    locked: '0',\r\n    freeze: '0',\r\n    withdrawing: '0',\r\n    ipoing: '0',\r\n    ipoable: '0',\r\n    storage: '0',\r\n    isLegalMoney: false,\r\n    trading: true,\r\n    networkList: [\r\n      [Object], [Object],\r\n      [Object], [Object],\r\n      [Object], [Object],\r\n      [Object], [Object]\r\n    ]\r\n  },\r\n  active: true,\r\n  deposit: true,\r\n  withdraw: true,\r\n  networks: [\r\n    {\r\n      network: 'BSC',\r\n      coin: 'USDT',\r\n      withdrawIntegerMultiple: '0.00000001',\r\n      isDefault: false,\r\n      depositEnable: true,\r\n      withdrawEnable: true,\r\n      depositDesc: '',\r\n      withdrawDesc: '',\r\n      specialTips: '',\r\n      specialWithdrawTips: 'The network you have selected is BSC. Please ensure that the withdrawal address supports the Binance Smart Chain network. You will lose your assets if the chosen platform does not support retrievals.',\r\n      name: 'BNB Smart Chain (BEP20)',\r\n      resetAddressStatus: false,\r\n      addressRegex: '^(0x)[0-9A-Fa-f]{40}$',\r\n      addressRule: '',\r\n      memoRegex: '',\r\n      withdrawFee: '0.29',\r\n      withdrawMin: '10',\r\n      withdrawMax: '10000000000',\r\n      depositDust: '0.01',\r\n      minConfirm: '15',\r\n      unLockConfirm: '0',\r\n      sameAddress: false,\r\n      estimatedArrivalTime: '5',\r\n      busy: false,\r\n      country: 'AE,BINANCE_BAHRAIN_BSC'\r\n    },\r\n    ...\r\n  ],\r\n  fee: 3.2,\r\n  fees: {\r\n    BSC: 0.29,\r\n    AVAXC: 0.8,\r\n    BNB: 0.8,\r\n    ETH: 3.2,\r\n    MATIC: 0.8,\r\n    SOL: 0.8,\r\n    XTZ: 0.8,\r\n    TRX: 0.8\r\n  },\r\n  limits: {\r\n    leverage: { min: undefined, max: undefined },\r\n    amount: { min: undefined, max: undefined },\r\n    price: { min: undefined, max: undefined },\r\n    cost: { min: undefined, max: undefined }\r\n  }\r\n}\r\n```"
      },
      {
        "user": "zydjohnHotmail",
        "created_at": "2022-10-18T08:51:05Z",
        "body": "Thank you very much, your code works!"
      }
    ],
    "satisfaction_conditions": [
      "Demonstrate how to retrieve information for a single currency without fetching all currencies",
      "Show how to access currency metadata through CCXT's existing methods",
      "Provide currency details including active status, fees, networks, and withdrawal/deposit capabilities",
      "Work with the user's existing Binance exchange configuration"
    ]
  },
  {
    "number": 15234,
    "title": "Fetching orders on Bybit futures",
    "created_at": "2022-10-09T16:35:32Z",
    "closed_at": "2022-10-10T15:21:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/15234",
    "body": "\r\n\r\n- OS: macOS 12.6\r\n- Programming Language version: python 3.8.13\r\n- CCXT version: 1.95.28\r\n\r\n```\r\nbybit = ccxt.bybit({\r\n    'apiKey': ***,\r\n    'secret': ***,\r\n    'options': {\r\n        'defaultType': 'future',\r\n    },\r\n})\r\n\r\npair_order = 'BTC/USDT:USDT'\r\nenter_amount_in_symbol = 20\r\nopen_order_price = 19555\r\n\r\norder = bybit.create_order(pair_order, 'LIMIT', 'sell', enter_amount_in_symbol, open_order_price, {'base_price': open_order_price, 'stop_px': open_order_price})\r\n\r\nprint(bybit.fetch_order(order['id'], pair_order))\r\n\r\nprint(bybit.fetch_order_trades(order['id'], pair_order))\r\n\r\n```\r\n\r\n```\r\nOrderNotFound: bybit fetchOrder() order 91a5eefa-4345-4ec6-8f06-a1b997eb6ab7 not found\r\n\r\n\r\n[{'id': '9cd501fa-b6b8-59ae-ac38-6bf068b49ed1',\r\n  'info': {'order_id': '91a5eefa-4345-4ec6-8f06-a1b997eb6ab7',\r\n   'order_link_id': '',\r\n   'side': 'Sell',\r\n   'symbol': 'BTCUSDT',\r\n   'exec_id': '9cd501fa-b6b8-59ae-ac38-6bf068b49ed1',\r\n   'price': '18502',\r\n   'order_price': '18502',\r\n   'order_qty': '0.001',\r\n   'order_type': 'Market',\r\n   'fee_rate': '0.0006',\r\n   'exec_price': '19476.5',\r\n   'exec_type': 'Trade',\r\n   'exec_qty': '0.001',\r\n   'exec_fee': '0.0116859',\r\n   'exec_value': '19.4765',\r\n   'leaves_qty': '0',\r\n   'closed_size': '0',\r\n   'last_liquidity_ind': 'RemovedLiquidity',\r\n   'trade_time': '1665332280',\r\n   'trade_time_ms': '1665332280182'},\r\n  'timestamp': 1665332280182,\r\n  'datetime': '2022-10-09T16:18:00.182Z',\r\n  'symbol': 'BTC/USDT:USDT',\r\n  'order': '91a5eefa-4345-4ec6-8f06-a1b997eb6ab7',\r\n  'type': 'market',\r\n  'side': 'sell',\r\n  'takerOrMaker': 'taker',\r\n  'price': 19476.5,\r\n  'amount': 0.001,\r\n  'cost': 19.4765,\r\n  'fee': {'cost': 0.0116859, 'currency': 'USDT', 'rate': 0.0006},\r\n  'fees': [{'currency': 'USDT', 'cost': 0.0116859, 'rate': 0.0006}]}]\r\n\r\n```\r\n\r\nHello,\r\n\r\ni'm trying to get information about filled order on Bybit, but here's something strange. Fetch_order doesn't see an order id and I can't find it in fetch_orders request too. But when I try to call fetch_order_trades, I can see all data about this order. How can I receive this information via fetch_order?\r\n\r\nOn Binance such request worked perfectly.\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/15234/comments",
    "author": "ddtask2",
    "comments": [
      {
        "user": "sc0Vu",
        "created_at": "2022-10-10T08:17:45Z",
        "body": "Hi @ddtask2 \r\n\r\nIMHO, you used stop order. Try this one:\r\n\r\n```python\r\nprint(bybit.fetch_order(order['id'], pair_order, { 'stop': True }))\r\n```"
      },
      {
        "user": "ddtask2",
        "created_at": "2022-10-10T15:02:13Z",
        "body": "> \r\n\r\n\r\n\r\n> Hi @ddtask2\r\n> \r\n> IMHO, you used stop order. Try this one:\r\n> \r\n> ```python\r\n> print(bybit.fetch_order(order['id'], pair_order, { 'stop': True }))\r\n> ```\r\n\r\nThanks a lot, this helped. But is there any solution to get order info regardless of it's type?"
      },
      {
        "user": "carlosmiei",
        "created_at": "2022-10-10T15:17:58Z",
        "body": "Hello @ddtask2, not with a single request because bybit uses different endpoints depending on the order type"
      }
    ],
    "satisfaction_conditions": [
      "Handles different order types (regular vs. stop orders) when fetching order information",
      "Explains Bybit's API limitations regarding order type endpoints",
      "Clarifies exchange-specific differences in order handling between Bybit and Binance"
    ]
  },
  {
    "number": 15212,
    "title": "MBX_WEIGHT_1M header parameter, know your 1min limits ",
    "created_at": "2022-10-07T07:43:49Z",
    "closed_at": "2022-10-09T17:35:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/15212",
    "body": "Hi, I am using ccxt version 1.81.14 in php. I just talk to Binance customer support and find out that I can know whenever I am going to hit the hard-limits like 1200 weight per 1min. There is a parameter in header, MBX_WEIGHT_1M, from Binance api's response. \r\n\r\nSo my question is, how can we get the header parameter response from ccxt? \r\n\r\nbtw i am using this list of functions:\r\nfor future, i am using $exchange->market, $exchange->fapiPrivate_post_leverage, $exchange->fetchTicker, and $exchange->create_order()\r\n\r\nfor spot, i am just using $exchange->create_market_buy_order\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/15212/comments",
    "author": "ngdekhai",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2022-10-07T14:17:46Z",
        "body": "Hello @ngdekhai, You can activate the `last_response_headers` option to access that information, example:\r\n\r\n```Python\r\nexchange = ccxt.binance({\r\n    # 'apiKey': 'YOUR_API_KEY',\r\n    # 'secret': 'YOUR_SECRET_KEY',\r\n    'last_response_headers': True,\r\n})\r\n\r\nmarkets = await exchange.load_markets()\r\n\r\norder = await exchange.create_order(your params here)\r\n## Get headers from the last call\r\nheaders = exchange.last_response_headers\r\nprint(headers)\r\n```\r\n"
      }
    ],
    "satisfaction_conditions": [
      "Method to access HTTP response headers in CCXT",
      "Solution works with CCXT's unified API methods",
      "Mechanism to track rate limit metrics in real-time",
      "Persistent header availability across API calls"
    ]
  },
  {
    "number": 15160,
    "title": "Fetching balance state on Bybit returns an empty list",
    "created_at": "2022-10-01T11:52:12Z",
    "closed_at": "2022-10-01T14:04:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/15160",
    "body": "- OS: Windows 10 (WSL2 Ubuntu 20.04)\r\n- Programming Language version: Node.js 18\r\n- CCXT version: 1.92.89\r\n\r\nFetching a balance returns all 0. It does not work both on mainnet and testnet.\r\n\r\nBalance amount for all symbols is returned as 0. API key and secret is a correct one.\r\nSwitching from bybit to binance exchange successfully returns a correct amount of balance, but not on bybit.\r\n\r\nMy actual balance on testnet is: 112,294.98 USD (\u22485.82435910 BTC)\r\n\r\n```\r\nconst ccxt = require('ccxt')\r\n\r\n(async () => {\r\n  const exchange = new ccxt.bybit({\r\n    apiKey: 'xxx',\r\n    secret: 'xxx'\r\n  })\r\n  \r\n  const balance = await exchange.fetchBalance()\r\n  console.log(balance)\r\n})()\r\n```\r\n\r\n```\r\n{\r\n  info: {\r\n    ret_code: '0',\r\n    ret_msg: 'OK',\r\n    result: {\r\n      USDT: [Object],\r\n      DOT: [Object],\r\n      LTC: [Object],\r\n      BIT: [Object],\r\n      MANA: [Object],\r\n      BTC: [Object],\r\n      ETH: [Object],\r\n      EOS: [Object],\r\n      XRP: [Object],\r\n      SOL: [Object],\r\n      ADA: [Object]\r\n    },\r\n    ext_code: '',\r\n    ext_info: '',\r\n    time_now: '1664624408.371975',\r\n    rate_limit_status: '117',\r\n    rate_limit_reset_ms: '1664624408367',\r\n    rate_limit: '120'\r\n  },\r\n  USDT: { free: 0, used: 0, total: 0 },\r\n  DOT: { free: 0, used: 0, total: 0 },\r\n  LTC: { free: 0, used: 0, total: 0 },\r\n  BIT: { free: 0, used: 0, total: 0 },\r\n  MANA: { free: 0, used: 0, total: 0 },\r\n  BTC: { free: 0, used: 0, total: 0 },\r\n  ETH: { free: 0, used: 0, total: 0 },\r\n  EOS: { free: 0, used: 0, total: 0 },\r\n  XRP: { free: 0, used: 0, total: 0 },\r\n  SOL: { free: 0, used: 0, total: 0 },\r\n  ADA: { free: 0, used: 0, total: 0 },\r\n  free: {\r\n    USDT: 0,\r\n    DOT: 0,\r\n    LTC: 0,\r\n    BIT: 0,\r\n    MANA: 0,\r\n    BTC: 0,\r\n    ETH: 0,\r\n    EOS: 0,\r\n    XRP: 0,\r\n    SOL: 0,\r\n    ADA: 0\r\n  },\r\n  used: {\r\n    USDT: 0,\r\n    DOT: 0,\r\n    LTC: 0,\r\n    BIT: 0,\r\n    MANA: 0,\r\n    BTC: 0,\r\n    ETH: 0,\r\n    EOS: 0,\r\n    XRP: 0,\r\n    SOL: 0,\r\n    ADA: 0\r\n  },\r\n  total: {\r\n    USDT: 0,\r\n    DOT: 0,\r\n    LTC: 0,\r\n    BIT: 0,\r\n    MANA: 0,\r\n    BTC: 0,\r\n    ETH: 0,\r\n    EOS: 0,\r\n    XRP: 0,\r\n    SOL: 0,\r\n    ADA: 0\r\n  }\r\n}\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/15160/comments",
    "author": "danieltorscho",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2022-10-01T13:06:06Z",
        "body": "Hello @danieltorscho,\r\nBybit is one of the only exchanges loading derivative features (markets, balances, etc) by default. I suspect that your funds are under the spot wallet, so I'd suggest instantiating bybit like this:\r\n\r\n```Python\r\nexchange = ccxt.bybit({\r\n    'apiKey': 'YOUR_API_KEY',\r\n    'secret': 'YOUR_SECRET_KEY',\r\n    'options': {\r\n       'defaultType': 'spot', # very important set spot as default type\r\n    }\r\n})\r\nbalances = await exchange.fetch_balance()\r\n```\r\n```\r\n\r\n\r\n"
      },
      {
        "user": "danieltorscho",
        "created_at": "2022-10-01T14:04:20Z",
        "body": ">     'options': {\r\n>        'defaultType': 'spot', # very important set spot as default type\r\n>     }\r\n\r\n@carlosmiei thank you, it works now !"
      }
    ],
    "satisfaction_conditions": [
      "Solution must address correct account type configuration for Bybit API access",
      "Answer must explain how to properly configure wallet type for balance retrieval",
      "Solution should resolve discrepancy between actual balance and API response"
    ]
  },
  {
    "number": 15097,
    "title": "ccxt.base.errors.ExchangeError: bybit markets not loaded",
    "created_at": "2022-09-24T07:14:43Z",
    "closed_at": "2022-09-30T19:22:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/15097",
    "body": "Hello,\r\n\r\nHow come this doesnt work, and get error : ccxt.base.errors.ExchangeError: bybit markets not loaded\r\n\r\nimport ccxt\r\nsymbol = 'BTCUSDT'\r\nprint(exchange.market(symbol)['precision']['amount'])\r\n\r\nbut this works:\r\n\r\nimport ccxt\r\nsymbol = 'BTCUSDT'\r\nprint(exchange.fetch_ohlcv(symbol, timeframe='1m', limit=1))\r\nprint(exchange.market(symbol)['precision']['amount'])\r\n\r\n- OS: win10\r\n- Programming Language version: python 3.8\r\n- CCXT version: 1.93.43",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/15097/comments",
    "author": "Smartromain",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2022-09-24T11:12:32Z",
        "body": "Hello @Smartromain, markets will be automatically loaded after the first call to a unified method, if you want to access it right away, you can do this:\r\n\r\n```Python\r\nsymbol = 'BTCUSDT'\r\nexchange.load_markets() # Trigger market loading\r\nprint(exchange.market(symbol)['precision']['amount'])\r\n```\r\n"
      },
      {
        "user": "Smartromain",
        "created_at": "2022-09-24T12:00:39Z",
        "body": "Thanks, amazing. I will try it"
      },
      {
        "user": "samgermain",
        "created_at": "2022-09-30T00:16:46Z",
        "body": "> Thanks, amazing. I will try it\r\n\r\nDid this work for you?"
      },
      {
        "user": "Smartromain",
        "created_at": "2022-09-30T19:22:25Z",
        "body": "yes it worked"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why market data must be explicitly loaded before accessing precision information",
      "Identification of required initialization step before accessing market metadata",
      "Clear method to ensure market data is loaded synchronously"
    ]
  },
  {
    "number": 15004,
    "title": "Question - Is USDT TetherUS-ERC20 the same USDT used by the BTC/USDT symbol?",
    "created_at": "2022-09-14T23:10:18Z",
    "closed_at": "2022-09-15T21:52:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/15004",
    "body": "\r\n- OS: Windows 11\r\n- Programming Language version: Javascript\r\n- CCXT version: 8.15.0\r\n\r\nHi,\r\n\r\nCan you please tell me if USDT TetherUS-ERC20 is the same USDT used by the BTC/USDT symbol?  I couldn't find an answer in the closed issues.\r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/15004/comments",
    "author": "zoomzoomgithub",
    "comments": [
      {
        "user": "sc0Vu",
        "created_at": "2022-09-15T02:59:57Z",
        "body": "Hi @zoomzoomgithub \r\n\r\nYes, I think so. Also, TetherUSDT had deployed on different blockchain (Tron, BSC or AVAX)."
      }
    ],
    "satisfaction_conditions": [
      "Confirmation of whether USDT TetherUS-ERC20 and BTC/USDT's USDT represent the same underlying asset",
      "Clarification about cross-chain consistency of stablecoin symbols in exchange listings"
    ]
  },
  {
    "number": 14890,
    "title": "bibox fetch_withdrawals has error",
    "created_at": "2022-09-06T16:46:01Z",
    "closed_at": "2022-09-16T22:03:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/14890",
    "body": "hi\r\nsince = None\r\nlimit = 200\r\nend_time = connection.milliseconds()\r\nparams = {\r\n     'end_time': int(end_time / 1000),\r\n}\r\nwithdrawals = connection.fetch_withdrawals(\"TRX\", since, limit, params)\r\n\r\nerror :\r\nbibox {\"error\":{\"code\":\"3000\",\"msg\":\"\u8bf7\u6c42\u53c2\u6570\u9519\u8bef\"},\"cmd\":\"transfer/transferInList\"}",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/14890/comments",
    "author": "hosseinab",
    "comments": [
      {
        "user": "kubeat",
        "created_at": "2022-09-07T09:55:41Z",
        "body": "i try to debug your code.the param 'limit' too big\uff0cyou can try change 'limit ' to 100 \u3002bibox Api have update to v3 ,v4,the ccxt is v1"
      },
      {
        "user": "hosseinab",
        "created_at": "2022-09-08T14:39:29Z",
        "body": "@kubeat \r\nThanks for your guidance . My problem is solved. Is there a library for version 3?"
      }
    ],
    "satisfaction_conditions": [
      "Handles API parameter constraints for Bibox withdrawals endpoint",
      "Compatibility with Bibox API version requirements"
    ]
  },
  {
    "number": 14664,
    "title": "Get FTX Future coins list?",
    "created_at": "2022-08-12T04:47:05Z",
    "closed_at": "2022-08-13T00:40:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/14664",
    "body": "Hi I'm looking for a list of coins ending with -PERP for the FTX exchange. \r\n\r\nI tried \r\n\r\n```\r\ncoins = ccxt.ftx({'options': { 'defaultType': 'future', }}).load_markets()\r\n```\r\n\r\nbut it just gives a list of coins with USDT and USD and it's 800 length as opposed to FTX amount of futures (less than 150). \r\n\r\nThis code works for binance, if I just switch ftx() to binance().",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/14664/comments",
    "author": "leonfresh",
    "comments": [
      {
        "user": "samgermain",
        "created_at": "2022-08-12T05:48:05Z",
        "body": "There are no coins that end in `-PERP` only market ids that end in `-PERP`. I would also suggest using the unified symbol names, because they are the same between exchanges.\r\n\r\n```\r\nimport ccxt  # noqa: E402\r\nfrom pprint import pprint\r\n\r\nexchange = ccxt.ftx()\r\nexchange.load_markets()\r\nmarkets = exchange.markets\r\n# coins = [market['id'] for symbol, market in markets.items() if market['swap']] // uncomment if you want to use the -PERP market ids\r\ncoins = [symbol for symbol, market in markets.items() if market['swap']]\r\n\r\npprint(coins)\r\npprint(len(coins))\r\n```\r\nprints\r\n```\r\n['1INCH/USD:USD',\r\n 'AAVE/USD:USD',\r\n 'ADA/USD:USD',\r\n 'AGLD/USD:USD',\r\n 'ALCX/USD:USD',\r\n 'ALGO/USD:USD',\r\n 'ALICE/USD:USD',\r\n 'ALPHA/USD:USD',\r\n ...\r\n 'XRP/USD:USD',\r\n 'XTZ/USD:USD',\r\n 'YFI/USD:USD',\r\n 'YFII/USD:USD',\r\n 'ZEC/USD:USD',\r\n 'ZIL/USD:USD',\r\n 'ZRX/USD:USD']\r\n177\r\n```"
      },
      {
        "user": "leonfresh",
        "created_at": "2022-08-12T08:19:41Z",
        "body": "> There are no coins that end in `-PERP` only market ids that end in `-PERP`. I would also suggest using the unified symbol names, because they are the same between exchanges.\r\n> \r\n> ```\r\n> import ccxt  # noqa: E402\r\n> from pprint import pprint\r\n> \r\n> exchange = ccxt.ftx()\r\n> exchange.load_markets()\r\n> markets = exchange.markets\r\n> # coins = [market['id'] for symbol, market in markets.items() if market['swap']] // uncomment if you want to use the -PERP market ids\r\n> coins = [symbol for symbol, market in markets.items() if market['swap']]\r\n> \r\n> pprint(coins)\r\n> pprint(len(coins))\r\n> ```\r\n> \r\n> prints\r\n> \r\n> ```\r\n> ['1INCH/USD:USD',\r\n>  'AAVE/USD:USD',\r\n>  'ADA/USD:USD',\r\n>  'AGLD/USD:USD',\r\n>  'ALCX/USD:USD',\r\n>  'ALGO/USD:USD',\r\n>  'ALICE/USD:USD',\r\n>  'ALPHA/USD:USD',\r\n>  ...\r\n>  'XRP/USD:USD',\r\n>  'XTZ/USD:USD',\r\n>  'YFI/USD:USD',\r\n>  'YFII/USD:USD',\r\n>  'ZEC/USD:USD',\r\n>  'ZIL/USD:USD',\r\n>  'ZRX/USD:USD']\r\n> 177\r\n> ```\r\n\r\n\r\nThank you that worked perfectly. Is the code you gave me using unified symbol names already?"
      },
      {
        "user": "samgermain",
        "created_at": "2022-08-13T00:40:45Z",
        "body": "> Thank you that worked perfectly. Is the code you gave me using unified symbol names already?\r\n\r\nYes it is"
      }
    ],
    "satisfaction_conditions": [
      "Identifies perpetual swap markets (markets ending with -PERP equivalent) on FTX",
      "Uses CCXT's unified symbol format for cross-exchange consistency",
      "Filters markets based on their 'swap' property rather than defaultType parameter",
      "Distinguishes between market IDs and trading symbols in CCXT"
    ]
  },
  {
    "number": 14608,
    "title": "FTX websockets stream on perpetual very slow ",
    "created_at": "2022-08-06T17:01:12Z",
    "closed_at": "2022-08-07T13:15:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/14608",
    "body": "- OS: Windows\r\n- Programming Language version: Python 3.9.13\r\n- CCXT version: ccxtpro 1.2.10\r\n\r\nThe data recieved from ftx perp pairs is once every 2 seconds(roughly). Which is extremely slow comparing it to the regular BTC/USD pair on FTX which averaged out to 0.053 seconds over a 20 min sample (which in my experience is still on the slow side). I was wondering why it is taking roughly 2 seconds per tick and if i could do anything to make this a lot quicker. Let me know, appreciate your time.\r\n\r\n```\r\nimport ccxtpro\r\nfrom asyncio import run\r\n\r\nasync def main():\r\n    FTX = ccxtpro.ftx({'newUpdates': True})\r\n    while x == True:\r\n        start = time.time()\r\n        orderbook = await FTX.watch_order_book('BTC-PERP') #also used BTC/USD:USD same effect\r\n        print(FTX.iso8601(FTX.milliseconds()), 'BTC/USD:USD', orderbook['bids'][0], orderbook['asks'][0])\r\n        await FTX.close()\r\n\r\nrun(main())\r\n```\r\n\r\n```\r\n2022-08-06T16:59:55.505Z BTC/USD:USD [23157.0, 8.5341] [23158.0, 5.0993]\r\n2022-08-06T16:59:57.518Z BTC/USD:USD [23157.0, 4.196] [23158.0, 15.8474]\r\n2022-08-06T16:59:59.539Z BTC/USD:USD [23157.0, 2.615] [23158.0, 11.1582]\r\n2022-08-06T17:00:01.573Z BTC/USD:USD [23157.0, 0.099] [23158.0, 18.0891]\r\n2022-08-06T17:00:03.598Z BTC/USD:USD [23151.0, 8.7448] [23152.0, 34.0551]\r\n2022-08-06T17:00:05.668Z BTC/USD:USD [23145.0, 0.6389] [23146.0, 18.9104]\r\n2022-08-06T17:00:07.693Z BTC/USD:USD [23142.0, 6.9215] [23143.0, 32.0178]\r\n2022-08-06T17:00:09.728Z BTC/USD:USD [23138.0, 19.8388] [23139.0, 0.2147]\r\n2022-08-06T17:00:11.772Z BTC/USD:USD [23138.0, 22.1469] [23139.0, 0.4077]\r\n2022-08-06T17:00:13.754Z BTC/USD:USD [23142.0, 2.4671] [23143.0, 23.4715]\r\n2022-08-06T17:00:15.797Z BTC/USD:USD [23142.0, 3.4958] [23143.0, 20.8941]\r\n2022-08-06T17:00:17.827Z BTC/USD:USD [23138.0, 3.3549] [23139.0, 30.4348]\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/14608/comments",
    "author": "zerconn",
    "comments": [
      {
        "user": "pcriadoperez",
        "created_at": "2022-08-07T02:05:06Z",
        "body": "Hi @zerconn , The issue is you are clossing the connection, so it takes a second or two to reconnect again.\r\nIf you remove the line `await FTX.close()`  you should get updates about every 30 ms\r\n\r\nHere was the code I used: \r\n```python\r\nimport ccxtpro\r\nfrom asyncio import run\r\nimport time\r\n\r\nasync def main():\r\n    FTX = ccxtpro.ftx({'newUpdates': True})\r\n    while True:\r\n        start = time.time()\r\n        orderbook = await FTX.watch_order_book('BTC-PERP') #also used BTC/USD:USD same effect\r\n        print(FTX.iso8601(FTX.milliseconds()), 'BTC/USD:USD', orderbook['bids'][0], orderbook['asks'][0])\r\n        #await FTX.close()\r\n\r\nrun(main())\r\n```\r\nHere was my output:\r\n```\r\n2022-08-07T02:02:55.328Z BTC/USD:USD [22929.0, 22.6859] [22930.0, 3.2098]\r\n2022-08-07T02:02:55.352Z BTC/USD:USD [22929.0, 22.6859] [22930.0, 3.2098]\r\n2022-08-07T02:02:55.381Z BTC/USD:USD [22929.0, 22.0459] [22930.0, 4.2098]\r\n2022-08-07T02:02:55.403Z BTC/USD:USD [22929.0, 21.7259] [22930.0, 4.5298]\r\n2022-08-07T02:02:55.430Z BTC/USD:USD [22929.0, 21.5259] [22930.0, 4.9298]\r\n2022-08-07T02:02:55.454Z BTC/USD:USD [22929.0, 21.5259] [22930.0, 4.9298]\r\n2022-08-07T02:02:55.486Z BTC/USD:USD [22929.0, 21.5259] [22930.0, 4.9298]\r\n```\r\n\r\nI hope that solves the issues!"
      }
    ],
    "satisfaction_conditions": [
      "Identification of connection management issues affecting update frequency",
      "Guidance on maintaining WebSocket connection efficiency",
      "Clarification of CCXT Pro's connection lifecycle requirements"
    ]
  },
  {
    "number": 14584,
    "title": "Phemex `fetch_positions` does not support phemex official symbol",
    "created_at": "2022-08-03T15:05:36Z",
    "closed_at": "2022-08-04T08:11:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/14584",
    "body": "Phemex `fetch_positions` does not support phemex official symbol\r\n\r\n## versions\r\n* OS: Debian 11\r\n* Programming Language version: python 3.8.12\r\n* CCXT version: 1.91.68\r\n\r\n## code to reproduce\r\n\r\n### setup\r\n```\r\nimport ccxt\r\n\r\nccxt_exchange = ccxt.phemex({\r\n    'apiKey': ...,\r\n    'secret': ...,\r\n})\r\n```\r\n\r\n### fetch_positions does not support uXXXUSD format\r\n```\r\nccxt_exchange.fetch_positions(symbols=['uBTCUSD']) # => returns `[]`\r\nccxt_exchange.fetch_positions(symbols=['BTC/USD:USD']) # => returns position structured response\r\n```\r\n\r\n### fetch_positions does not support neither inverse formats\r\n```\r\nccxt_exchange.fetch_positions(symbols=['BTCUSD']) # => returns `[]`\r\nccxt_exchange.fetch_positions(symbols=['BTC/USD:BTC']) # => returns `[]`\r\n```",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/14584/comments",
    "author": "takami-ml",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2022-08-03T16:53:27Z",
        "body": "Hello @takami-ml \r\n\r\n> ccxt_exchange.fetch_positions(symbols=['uBTCUSD']) # => returns `[]`\r\n> ccxt_exchange.fetch_positions(symbols=['BTC/USD:USD']) # => returns position structured response\r\n\r\nCan you double-check this? I've just tested and worked fine with both formats, unified and exchange-specific.\r\n\r\n\r\n> fetch_positions does not support neither inverse formats\r\n> ccxt_exchange.fetch_positions(symbols=['BTCUSD']) # => returns `[]`\r\n> ccxt_exchange.fetch_positions(symbols=['BTC/USD:BTC']) # => returns `[]`\r\n\r\nBy default will try to load \"linear contracts\" to fetch inverse contracts (BTC settled in this case), please provide the settle currency as `code` inside params.\r\n\r\nSomething like this:\r\n```Python\r\nccxt_exchange.fetch_positions(symbols=['BTC/USD:BTC'], {'code':'BTC'})\r\n```\r\n\r\n\r\n"
      },
      {
        "user": "takami-ml",
        "created_at": "2022-08-03T23:39:58Z",
        "body": "@carlosmiei \r\n\r\nThank you for the information.\r\n\r\n> Can you double-check this? I've just tested and worked fine with both formats, unified and exchange-specific.\r\n\r\nI'm sorry,  this one was my mistake. (I just had an inverse position, not linear.)\r\nI confirmed it worked as expected.\r\n\r\n> By default will try to load \"linear contracts\" to fetch inverse contracts (BTC settled in this case), please provide the settle currency as code inside params.\r\n\r\nWhen I set `code` to BTC, it worked.\r\nI did not understand the `defaultSubType` option and `code` params. Thanks for the information.\r\n\r\nIn conclusion, in both cases, there was no problem. I am very sorry to have used your time!\r\n"
      },
      {
        "user": "carlosmiei",
        "created_at": "2022-08-04T08:11:13Z",
        "body": "@takami-ml no problem at all, I'll close this issue then, let us know if anything! \ud83d\ude42 "
      }
    ],
    "satisfaction_conditions": [
      "Support for both unified (CCXT) and exchange-specific symbol formats in position fetching",
      "Clear documentation/explanation of settlement currency requirements for inverse contracts",
      "Proper handling of linear vs inverse contract types through parameters"
    ]
  },
  {
    "number": 14556,
    "title": "upbit createDepositAddress Error",
    "created_at": "2022-07-31T17:11:34Z",
    "closed_at": "2022-08-01T14:07:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/14556",
    "body": "OS:Windows 10\r\nProgramming Language version:Python\r\nCCXT version:1.90.66\r\nExchange: Upbit\r\nMethod: createDepositAddress\r\n\r\n\r\nAddressPending: upbit is generating BTC deposit address, call fetchDepositAddress or createDepositAddress one more time later to retrieve the generated address\r\n\r\n\r\nI'd like to know why the code exits with that message when generating an address.\r\n\r\nAfter the code ends, I can check in Upbit that the address has been created\r\nBut I can't check it when I create it in python\r\n\r\nI couldn't find it after searching after #6452 for this problem.\r\nI'm a beginner in programming, so I don't know if it's a bug or my skill problem.\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/14556/comments",
    "author": "newbienoobnoob",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2022-08-01T09:13:43Z",
        "body": "@newbienoobnoob Hello, so when you call `createDepositAdress` there are two things that might happen:\r\n- First, the exchange immediately responds with an address, and you're ready to go\r\n- Second, the exchange warns that it will create an address, but since this is an asynchronous process it can't return it right now, you have to wait a few seconds and request it again.\r\n\r\nYou can do simple polling until the address is ready, for example:\r\n\r\n```Python\r\n    address = None\r\n    while True:\r\n        try:\r\n            address = await exchange.create_deposit_address(\"BTC\")\r\n            break\r\n        except ccxt.AddressPending as e:\r\n            print(\"Address not ready yet, will wait and try again\")\r\n            await exchange.sleep(1000) # sleeps 1 second before trying again\r\n```\r\n\r\n\r\n\r\n"
      },
      {
        "user": "newbienoobnoob",
        "created_at": "2022-08-01T14:07:26Z",
        "body": "Thank you it was a great hint\r\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of asynchronous address generation process",
      "Polling mechanism for pending address status",
      "Clarification of normal exchange behavior vs error state",
      "Error handling strategy for AddressPending exceptions"
    ]
  },
  {
    "number": 14512,
    "title": "okx default type does not change",
    "created_at": "2022-07-28T11:52:05Z",
    "closed_at": "2022-07-28T14:24:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/14512",
    "body": "i'm using the latest version of ccxt\r\nin okx, when i change defaultType to swap or any other kinds it does not change and when i call an order it still shows spot mode price and ..... .\r\nand when I wanna create a swap order it shows error which i don't have when i use binance and change defaultType to future.\r\n\r\n\r\nokex = ccxt.okx({\r\n    'apiKey': config.API_KEY,\r\n    'secret': config.API_SECRET,\r\n    'password' : config.API_PASS,\r\n    'options':{\r\n        'defaultType' : 'swap'\r\n        },\r\n\r\n})\r\nokex.set_sandbox_mode(True)\r\n\r\n\r\nleve = okex.set_leverage(10 , 'ETH-USDT' ,  params = {'mgnMode' : 'isolated'} , )\r\norder1 = okex.create_market_buy_order('ETH-USDT' , 6 )\r\nprint(order1)\r\n\r\n\r\n\r\nbut when i use this code i can get swap price but i can't open an order with swap symbol :\r\n\r\nokex = ccxt.okx({\r\n    'apiKey': config.API_KEY,\r\n    'secret': config.API_SECRET,\r\n    'password' : config.API_PASS,\r\n})\r\n\r\nticker = okex.fetch_ticker('ETH-USDT-SWAP')\r\nprint(ticker)\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/14512/comments",
    "author": "ar3sla",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2022-07-28T12:02:02Z",
        "body": "Hello @ar3sla you're mixing up spot and swap market ids.\r\n\r\nIf you want to place an order for the linear ETH/USDT swap you should be using `ETH-USDT-SWAP` as an argument for `createMarketBuyOrder` instead of `ETH-USDT`, the latter represents the spot symbol. \r\n\r\n\r\n\r\n\r\n\r\n\r\n"
      },
      {
        "user": "ar3sla",
        "created_at": "2022-07-28T12:23:42Z",
        "body": "hi @carlosmiei, thanks for your answer\r\nbut when i change it to ETH-USDT-SWAP with this code:\r\nokex = ccxt.okx({\r\n    'apiKey': config.API_KEY,\r\n    'secret': config.API_SECRET,\r\n    'password' : config.API_PASS,\r\n    'options':{\r\n        'defaultType' : 'swap'\r\n        },\r\n\r\n})\r\nokex.set_sandbox_mode(True)\r\n\r\nparams1 = {\r\n    \"instId\":\"ETH-USDT-SWAP\",\r\n    \"tdMode\":\"isolated\",\r\n    \"side\":\"buy\",\r\n    'posSide':\"SWAP\",\r\n    \"ordType\":\"market\",\r\n    \"sz\":\"6\"\r\n}\r\norder1 = okex.create_market_buy_order('ETH-USDT-SWAP' , 6 , params=params1)\r\nprint(order1)\r\n\r\nit shows me this error :\r\nccxt.base.errors.BadRequest: okx {\"code\":\"1\",\"data\":[{\"clOrdId\":\"e847386590ce4dBC2ffbe9c12cb175e0\",\"ordId\":\"\",\"sCode\":\"51000\",\"sMsg\":\"Parameter posSide  error \",\"tag\":\"\"}],\"msg\":\"Operation failed.\"}\r\n\r\n\r\n\r\nand if i use ETH-USDT in this code :\r\nokex = ccxt.okx({\r\n    'apiKey': config.API_KEY,\r\n    'secret': config.API_SECRET,\r\n    'password' : config.API_PASS,\r\n\r\n\r\n})\r\nokex.set_sandbox_mode(True)\r\n\r\n\r\norder1 = okex.create_market_buy_order('ETH-USDT' , 6 )\r\nprint(order1)\r\n\r\nit shows me this error :\r\n\r\nccxt.base.errors.InsufficientFunds: okx {\"code\":\"1\",\"data\":[{\"clOrdId\":\"e847386590ce4dBCb25a7bde230285b0\",\"ordId\":\"\",\"sCode\":\"51008\",\"sMsg\":\"Order placement failed due to insufficient balance \",\"tag\":\"\"}],\"msg\":\"Operation failed.\"}"
      },
      {
        "user": "carlosmiei",
        "created_at": "2022-07-28T13:06:15Z",
        "body": "Hello @ar3sla,\r\n\r\n> order1 = okex.create_market_buy_order('ETH-USDT' , 6 )\r\n> print(order1)\r\n\r\nthis is not what you want, as said earlier 'ETH-USDT' is a spot symbol, so you're saying \"I want to buy 6 ETH with USDT\"\r\n\r\n> order1 = okex.create_market_buy_order('ETH-USDT-SWAP' , 6 , params=params1)\r\n> print(order1)\r\n\r\nYou're almost there, you're just missing the `postSide` parameter required by OKX.\r\n\r\nSomething like this:\r\n```Python\r\n\r\nparams1 = {\r\n    \"marginMode\":\"isolated\", # or cross\r\n    \"posSide\":\"long\", # long or short depending on your intent\r\n}\r\nsymbol = \"ETH-USDT-SWAP\"\r\namount = 6 # number of contracts\r\norder1 = okex.create_market_buy_order(symbol , amount , params=params1)\r\nprint(order1)\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
      },
      {
        "user": "ar3sla",
        "created_at": "2022-07-28T13:40:22Z",
        "body": "thanks a lot @carlosmiei\r\nthe posside solved my problem.\r\nI'm really thankful"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of required parameters for OKX swap order creation",
      "Clarification on symbol format differences between spot and swap markets",
      "Differentiation between OKX and Binance API behavior",
      "Documentation of margin mode parameter requirements"
    ]
  },
  {
    "number": 14457,
    "title": "Kucoin Futures error retrieving data",
    "created_at": "2022-07-23T23:56:13Z",
    "closed_at": "2022-07-24T17:43:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/14457",
    "body": "- OS: Windows 10\r\n- Programming Language version: Python 3.1\r\n- CCXT version: 1.91.2\r\n\r\n\r\ntrying to fetch my current positing contractsize, amount of contracts and current margin value:\r\n\r\n\r\n```\r\ndef open_positions():\r\n    params = {'type':'swap', 'code':'USD'}\r\n    symbol = 'BTC/USDT:USDT'\r\n    ku_bal = kucoin.fetch_positions(symbols=[symbol], params=params)\r\n    open_positions = ku_bal[0]\r\n    open_positions = ku_bal['info']['data']['maintMargin']\r\n    openpos_side = open_positions[0]['contracts']\r\n    openpos_size = open_positions[0]['contractSize']\r\n```\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"reeee\", line 310, in <module>\r\n    bot()\r\n  File \"reeeee\", line 251, in bot\r\n    pnl_close() #checking if we hit pnl\r\n  File \"reeeeee\", line 233, in pnl_close\r\n    kill_switch()\r\n  File \"reeeeeee\", line 136, in kill_switch\r\n    openposi = open_positions()[1]\r\n  File \"reeeeee\", line 112, in open_positions\r\n    open_positions = ku_bal['info']['data']['maintMargin']\r\nTypeError: list indices must be integers or slices, not str\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/14457/comments",
    "author": "ysonitis5",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2022-07-24T10:14:39Z",
        "body": "Hello @ysonitis5,\r\n\r\nYou're trying to access a non-existent field in the raw response, which is why it's crashing.\r\n\r\nTo fix it you can either search for the unified `maintenanceMargin` field, like this:\r\n```Python\r\npositions = kucoin.fetch_positions(symbols=[symbol], params=params)\r\nmaintenance_margin = positions[0]['maintenanceMargin'] # the advisable way to get it\r\n```\r\nor access the correct raw value inside `info`, \r\n\r\n```Python\r\npositions = kucoin.fetch_positions(symbols=[symbol], params=params)\r\nmaintenance_margin = positions[0]['info']['posMaint'] # not recommended because APIs are always changing\r\n```\r\n\r\n\r\n"
      },
      {
        "user": "ysonitis5",
        "created_at": "2022-07-24T16:28:21Z",
        "body": "thank you very much  @carlosmiei "
      },
      {
        "user": "carlosmiei",
        "created_at": "2022-07-24T17:43:16Z",
        "body": "@ysonitis5  You're welcome, since the problem seems resolved I will close the issue, let us know if anything!"
      }
    ],
    "satisfaction_conditions": [
      "Correctly accesses maintenance margin value from Kucoin Futures API response",
      "Uses CCXT's unified API fields rather than exchange-specific raw responses",
      "Properly handles nested data structures in API responses"
    ]
  },
  {
    "number": 13831,
    "title": "How to set market take profit?",
    "created_at": "2022-06-13T18:47:53Z",
    "closed_at": "2022-06-15T06:46:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/13831",
    "body": "The code as follows:\r\n```\r\nimport ccxt\r\nimport time\r\nfrom pprint import pprint\r\nftx = ccxt.ftx({\r\n    'apiKey': 'my_apikey',\r\n    'secret': 'my_secret',\r\n})\r\n\r\nsymbol = 'BTC/USD:USD'\r\nftx.load_markets()\r\nmarket = ftx.market(symbol)\r\nbtc_maket_price = float(market['info']['price'])\r\nbtc_amount = 20 / btc_maket_price\r\ncreate_order = ftx.create_order(symbol, 'market', 'buy', btc_amount)\r\n\r\ntype = 'takeProfit'\r\nside = 'sell'\r\nrise_btc_price = btc_maket_price + btc_maket_price * 0.015\r\nparams = {\r\n    'stopPrice': rise_btc_price,\r\n}\r\norder = ftx.create_order(symbol, type, side, btc_amount, params)\r\n```\r\n\r\nThe errors as follows:\r\nTraceback (most recent call last):\r\n  File \"C:\\Users\\fxu50\\PycharmProjects\\pythonProject1\\contract.py\", line 26, in <module>\r\n    order = ftx.create_order(symbol, type, side, btc_amount, params)\r\n  File \"C:\\Users\\fxu50\\PycharmProjects\\pythonProject1\\ccxt\\ftx.py\", line 1625, in create_order\r\n    raise InvalidOrder(self.id + ' createOrder() does not support order type ' + type + ', only limit, market, stop, trailingStop, or takeProfit orders are supported')\r\nccxt.base.errors.InvalidOrder: ftx createOrder() does not support order type takeProfit, only limit, market, stop, trailingStop, or takeProfit orders are supported",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/13831/comments",
    "author": "qwe231cvb",
    "comments": [
      {
        "user": "frosty00",
        "created_at": "2022-06-14T01:58:51Z",
        "body": "please update to the latest version of ccxt, this issue should be fixed."
      },
      {
        "user": "qwe231cvb",
        "created_at": "2022-06-14T18:10:40Z",
        "body": "> please update to the latest version of ccxt, this issue should be fixed.\r\n\r\nI have downloaded version 1.87.24 and still the problem persists.\n\n---\n\nWho anyone knows how to do?"
      },
      {
        "user": "kroitor",
        "created_at": "2022-06-14T20:03:07Z",
        "body": "@qwe231cvb you have to upgrade to the most recent version of CCXT, but not only that, you also have to make sure that you have upgraded correctly by printing the actual CCXT version that you are using in runtime. \r\n\r\nLet us know if this does not work:\r\n\r\n```Python\r\nimport ccxt\r\nfrom pprint import pprint\r\n\r\n\r\nprint(\"CCXT Version:\", ccxt.__version__)\r\n\r\n\r\nftx = ccxt.ftx({\r\n    'apiKey': 'my_apikey',\r\n    'secret': 'my_secret',\r\n})\r\n\r\nmarkets = exchange.load_markets()\r\n\r\n# exchange.verbose = True  # uncomment for debugging purposes if necessary, after loading the markets\r\n\r\nsymbol = 'BTC/USD:USD'\r\nftx.load_markets()\r\nmarket = ftx.market(symbol)\r\nbtc_maket_price = float(market['info']['price'])\r\nbtc_amount = 20 / btc_maket_price\r\ncreate_order = ftx.create_order(symbol, 'market', 'buy', btc_amount)\r\n\r\ntype = 'takeProfit'\r\nside = 'sell'\r\nrise_btc_price = btc_maket_price + btc_maket_price * 0.015\r\nparams = {\r\n    'stopPrice': rise_btc_price,\r\n}\r\norder = ftx.create_order(symbol, type, side, btc_amount, params)\r\n```"
      },
      {
        "user": "qwe231cvb",
        "created_at": "2022-06-15T06:04:06Z",
        "body": "> @qwe231cvb you have to upgrade to the most recent version of CCXT, but not only that, you also have to make sure that you have upgraded correctly by printing the actual CCXT version that you are using in runtime.\r\n> \r\n> Let us know if this does not work:\r\n> \r\n> ```python\r\n> import ccxt\r\n> from pprint import pprint\r\n> \r\n> \r\n> print(\"CCXT Version:\", ccxt.__version__)\r\n> \r\n> \r\n> ftx = ccxt.ftx({\r\n>     'apiKey': 'my_apikey',\r\n>     'secret': 'my_secret',\r\n> })\r\n> \r\n> markets = exchange.load_markets()\r\n> \r\n> # exchange.verbose = True  # uncomment for debugging purposes if necessary, after loading the markets\r\n> \r\n> symbol = 'BTC/USD:USD'\r\n> ftx.load_markets()\r\n> market = ftx.market(symbol)\r\n> btc_maket_price = float(market['info']['price'])\r\n> btc_amount = 20 / btc_maket_price\r\n> create_order = ftx.create_order(symbol, 'market', 'buy', btc_amount)\r\n> \r\n> type = 'takeProfit'\r\n> side = 'sell'\r\n> rise_btc_price = btc_maket_price + btc_maket_price * 0.015\r\n> params = {\r\n>     'stopPrice': rise_btc_price,\r\n> }\r\n> order = ftx.create_order(symbol, type, side, btc_amount, params)\r\n> ```\r\n\r\nThe problem persists, here is the printout:\r\nCCXT Version: 1.87.24\r\nTraceback (most recent call last):\r\n  File \"C:\\Users\\fxu50\\PycharmProjects\\pythonProject1\\contract.py\", line 30, in <module>\r\n    order = ftx.create_order(symbol, type, side, btc_amount, params)\r\n  File \"C:\\Users\\fxu50\\PycharmProjects\\pythonProject1\\ccxt\\ftx.py\", line 1625, in create_order\r\n    raise InvalidOrder(self.id + ' createOrder() does not support order type ' + type + ', only limit, market, stop, trailingStop, or takeProfit orders are supported')\r\nccxt.base.errors.InvalidOrder: ftx createOrder() does not support order type takeProfit, only limit, market, stop, trailingStop, or takeProfit orders are supported\r\n"
      },
      {
        "user": "kroitor",
        "created_at": "2022-06-15T06:46:05Z",
        "body": "@qwe231cvb you're making a market takeProfit order, so you have to specify price=None or the actual limit price:\r\n\r\n```Python\r\nimport ccxt\r\nfrom pprint import pprint\r\n\r\n\r\nprint(\"CCXT Version:\", ccxt.__version__)\r\n\r\n\r\nftx = ccxt.ftx({\r\n    'apiKey': 'my_apikey',\r\n    'secret': 'my_secret',\r\n})\r\n\r\nmarkets = exchange.load_markets()\r\n\r\n# exchange.verbose = True  # uncomment for debugging purposes if necessary, after loading the markets\r\n\r\nsymbol = 'BTC/USD:USD'\r\nftx.load_markets()\r\nmarket = ftx.market(symbol)\r\nbtc_maket_price = float(market['info']['price'])\r\nbtc_amount = 20 / btc_maket_price\r\ncreate_order = ftx.create_order(symbol, 'market', 'buy', btc_amount)\r\n\r\ntype = 'takeProfit'\r\nside = 'sell'\r\nrise_btc_price = btc_maket_price + btc_maket_price * 0.015\r\nparams = {\r\n    'stopPrice': rise_btc_price,\r\n}\r\nprice = None  # or your takeProfit limit price  # -------- \u2193\r\norder = ftx.create_order(symbol, type, side, btc_amount, price, params)\r\n```\r\n\r\nHope that answers your question."
      },
      {
        "user": "qwe231cvb",
        "created_at": "2022-06-15T07:35:56Z",
        "body": "> @qwe231cvb you're making a market takeProfit order, so you have to specify price=None or the actual limit price:\r\n> \r\n> ```python\r\n> import ccxt\r\n> from pprint import pprint\r\n> \r\n> \r\n> print(\"CCXT Version:\", ccxt.__version__)\r\n> \r\n> \r\n> ftx = ccxt.ftx({\r\n>     'apiKey': 'my_apikey',\r\n>     'secret': 'my_secret',\r\n> })\r\n> \r\n> markets = exchange.load_markets()\r\n> \r\n> # exchange.verbose = True  # uncomment for debugging purposes if necessary, after loading the markets\r\n> \r\n> symbol = 'BTC/USD:USD'\r\n> ftx.load_markets()\r\n> market = ftx.market(symbol)\r\n> btc_maket_price = float(market['info']['price'])\r\n> btc_amount = 20 / btc_maket_price\r\n> create_order = ftx.create_order(symbol, 'market', 'buy', btc_amount)\r\n> \r\n> type = 'takeProfit'\r\n> side = 'sell'\r\n> rise_btc_price = btc_maket_price + btc_maket_price * 0.015\r\n> params = {\r\n>     'stopPrice': rise_btc_price,\r\n> }\r\n> price = None  # or your takeProfit limit price  # -------- \u2193\r\n> order = ftx.create_order(symbol, type, side, btc_amount, price, params)\r\n> ```\r\n> \r\n> Hope that answers your question.\r\n\r\nIt is ok now."
      }
    ],
    "satisfaction_conditions": [
      "Correct specification of required parameters for takeProfit orders in CCXT",
      "Compatibility with the latest CCXT version's API requirements",
      "Clear distinction between stopPrice and limit price parameters",
      "Verification of runtime environment configuration"
    ]
  },
  {
    "number": 13712,
    "title": "Total balance of a account",
    "created_at": "2022-06-08T14:40:50Z",
    "closed_at": "2022-06-09T12:20:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/13712",
    "body": "Hi, I am not very good in programming so I tried googling on how to use CCXT to get the overall account balance using the \"balance\" function, but no luck. \n\nSo I wonder if anyone can help me out. \nI am trying to get the overall account balance of any exchange, instead of just 1 assets. \n\nThank you in advance.",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/13712/comments",
    "author": "300Gram",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2022-06-08T14:49:40Z",
        "body": "Hello @300Gram, which exchange do you use?\r\n\r\nAlso, I would suggest reading the manual carefully you will find most of the things you might need there. "
      },
      {
        "user": "FabLK",
        "created_at": "2022-06-08T14:59:46Z",
        "body": "@300Gram Hello, I'm doing that for my project and this is how I proceed:\r\n\r\n1/Getting balances of every token\r\n2/For every token, find the price against USDT (if not available against BTC or ETH then against USDT) of course you can do this against USD or every currency you want\r\n3/Convert my token balances into usdEquivalent balances\r\n4/Sum all usdEquivalent balances \r\n\r\nThis is how I proceed for Binance (this code may be not optimal but it gives you an idea): \r\n**The ccxt object is self.exchange**\r\n```py\r\n        def get_balance(self):\r\n            start = time.time()\r\n            balances = self.exchange.fetch_balance()['info']['balances']\r\n            self.balance = 0\r\n\r\n            for i in balances:\r\n                if float(i['free'])!=0 or float(i['locked'])!=0:\r\n                    if i['asset'] != 'USDT':\r\n                        request = i['asset']+'/USDT'\r\n                        try:\r\n                            price = float(self.exchange.fetchTicker(request)['last'])\r\n                        except:\r\n                            try:\r\n                                request = i['asset']+'/BTC'\r\n                                price = float(self.exchange.fetchTicker(request)['last'])\r\n                                val_btc = (float(i['free'])+float(i['locked']))*price\r\n                                price = float(self.exchange.fetchTicker('BTC/USDT')['last'])\r\n                                self.balance += val_btc*price\r\n                            except:\r\n                                try:\r\n                                    request = i['asset']+'/ETH'\r\n                                    price = float(self.exchange.fetchTicker(request)['last'])\r\n                                    val_btc = (float(i['free'])+float(i['locked']))*price\r\n                                    price = float(self.exchange.fetchTicker('ETH/USDT')['last'])\r\n                                    self.balance += val_btc*price\r\n                                except:\r\n                                    print(i['asset'])\r\n\r\n                        self.balance += (float(i['free'])+float(i['locked']))*price\r\n                    else:\r\n                        self.balance += float(i['free'])+float(i['locked'])\r\n            self.latency = time.time()-start\r\n```"
      },
      {
        "user": "300Gram",
        "created_at": "2022-06-09T12:20:56Z",
        "body": "Thanks! I wonder if there is any shorter way to get this done. (i mean the simpler the better). \r\n\r\nBut thank you! Appreciate it, will try to implement into my code (: \n\n---\n\n> @300Gram Hello, I'm doing that for my project and this is how I proceed:\r\n> \r\n> 1/Getting balances of every token 2/For every token, find the price against USDT (if not available against BTC or ETH then against USDT) of course you can do this against USD or every currency you want 3/Convert my token balances into usdEquivalent balances 4/Sum all usdEquivalent balances\r\n> \r\n> This is how I proceed for Binance (this code may be not optimal but it gives you an idea): **The ccxt object is self.exchange**\r\n> \r\n> ```python\r\n>         def get_balance(self):\r\n>             start = time.time()\r\n>             balances = self.exchange.fetch_balance()['info']['balances']\r\n>             self.balance = 0\r\n> \r\n>             for i in balances:\r\n>                 if float(i['free'])!=0 or float(i['locked'])!=0:\r\n>                     if i['asset'] != 'USDT':\r\n>                         request = i['asset']+'/USDT'\r\n>                         try:\r\n>                             price = float(self.exchange.fetchTicker(request)['last'])\r\n>                         except:\r\n>                             try:\r\n>                                 request = i['asset']+'/BTC'\r\n>                                 price = float(self.exchange.fetchTicker(request)['last'])\r\n>                                 val_btc = (float(i['free'])+float(i['locked']))*price\r\n>                                 price = float(self.exchange.fetchTicker('BTC/USDT')['last'])\r\n>                                 self.balance += val_btc*price\r\n>                             except:\r\n>                                 try:\r\n>                                     request = i['asset']+'/ETH'\r\n>                                     price = float(self.exchange.fetchTicker(request)['last'])\r\n>                                     val_btc = (float(i['free'])+float(i['locked']))*price\r\n>                                     price = float(self.exchange.fetchTicker('ETH/USDT')['last'])\r\n>                                     self.balance += val_btc*price\r\n>                                 except:\r\n>                                     print(i['asset'])\r\n> \r\n>                         self.balance += (float(i['free'])+float(i['locked']))*price\r\n>                     else:\r\n>                         self.balance += float(i['free'])+float(i['locked'])\r\n>             self.latency = time.time()-start\r\n> ```\r\n\r\nThanks for your code! I referred some of your code and make it my own with a much simpler code (I am a beginner, so the simpler the better).  "
      }
    ],
    "satisfaction_conditions": [
      "Aggregates total account balance across all assets into a single value",
      "Handles conversion of non-base currency assets (e.g., through USDT/BTC/ETH pairs)",
      "Works across multiple exchanges generically",
      "Prioritizes simplicity over optimization",
      "Accounts for both free and locked balances"
    ]
  },
  {
    "number": 13302,
    "title": "Can you help me with getting number of max leverage of contract on gateio?",
    "created_at": "2022-05-17T12:52:52Z",
    "closed_at": "2022-05-17T13:40:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/13302",
    "body": "Doing\r\n\r\n```\r\nprint(gateio_futures.fetch_contract_markets())\r\n```\r\nGetting\r\n```\r\nTypeError: gateio.fetch_contract_markets() missing 1 required positional argument: 'params'\r\n```\r\nDont know what to do with it. Can you show the example of code how to get max leverage for pair GMT/USDT on futures?",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/13302/comments",
    "author": "KindSpidey",
    "comments": [
      {
        "user": "carlosmiei",
        "created_at": "2022-05-17T13:40:14Z",
        "body": "Hello @KindSpidey,\r\n\r\nYou should refrain from using the implicit API/ internal helper methods whenever possible, if you carefully read CCXT manual you will see that most of the information you might wanna consult is available through our unified methods in a simple and organized way.\r\n\r\nFor instance, to check the leverage limits for a certain market pair you can simply do something like this:\r\n\r\n```Python\r\nexchange = ccxt.gateio({\r\n    'apiKey': 'YOUR_API_KEY',\r\n    'secret': 'YOUR_SECRET_KEY',\r\n    'options': {\r\n        'defaultType': 'swap',\r\n    },\r\n})\r\n\r\nmarkets = exchange.load_markets()\r\ntarget_market = markets['BTC/USDT:USDT']\r\nprint(target_market['limits']['leverage'])\r\n````\r\n"
      }
    ],
    "satisfaction_conditions": [
      "Demonstrates correct usage of CCXT unified methods to retrieve market data",
      "Shows how to access leverage limits within market data structure",
      "Includes proper market symbol formatting for futures contracts",
      "Avoids requiring additional parameters beyond standard initialization"
    ]
  },
  {
    "number": 13255,
    "title": "Is it a joke? MECX futures login",
    "created_at": "2022-05-15T10:50:23Z",
    "closed_at": "2022-05-15T10:53:23Z",
    "labels": [
      "bug",
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/13255",
    "body": "I have code\r\n```\r\nmexc_futures = ccxt.mexc({\r\n    \"apiKey\": config.MEXC_API_KEY,\r\n    \"secret\": config.MEXC_SECRET_KEY,\r\n    \"options\": {'defaultType': 'future' }\r\n})\r\n```\r\nAnd got\r\n```\r\nccxt.base.errors.ExchangeError: mexc does not support 'future' type, set exchange.options['defaultType'] to 'spot', 'margin', 'delivery' or 'future'\r\n```\r\nWhat am i supposed to do?)",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/13255/comments",
    "author": "KindSpidey",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2022-05-15T10:52:16Z",
        "body": "@KindSpidey sorry, it's a misleading erroneous message, it actually supports either `spot` or `swap` (for perpetual futures aka swaps). In this case, you should use `swap` instead of `future`. Will fix the message in the upcoming build. Thank you for pointing it out."
      },
      {
        "user": "KindSpidey",
        "created_at": "2022-05-15T10:55:08Z",
        "body": "Thanks, now it works"
      },
      {
        "user": "kroitor",
        "created_at": "2022-05-15T10:57:07Z",
        "body": "@KindSpidey i've pushed a fix to that message in CCXT 1.82.53 (the new build will arrive in 20 minutes). Thank you for your feedback!"
      }
    ],
    "satisfaction_conditions": [
      "Identifies the correct supported exchange type for MEXC futures trading",
      "Clarifies valid options for exchange.options['defaultType']",
      "Acknowledges the error message's inaccuracy"
    ]
  },
  {
    "number": 12943,
    "title": "Why fee an trades aren't reported when an order is filled at Binance ?",
    "created_at": "2022-04-22T10:50:23Z",
    "closed_at": "2022-04-22T11:50:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/12943",
    "body": "Hello,\r\n\r\nI try to understand why `fee`, `fees` and `trades` keys are empty in the dictionary returned by the exchange after an order is filled (method `fetchOrder`). Sometime the keys contain data. Please find below two orders executed on ETH/USDT spot market of Binance. One order has values but not the other. What could be the reason ?\r\n\r\nAs you can see both orders have status `FILLED`. One is `sell` the other is `buy`.\r\n\r\n`fee` is null\r\n\r\n`{\"id\": \"8664222318\", \"fee\": null, \"cost\": 18.07068, \"fees\": [], \"info\": {\"side\": \"SELL\", \"time\": \"1650610804472\", \"type\": \"LIMIT\", \"price\": \"3011.78000000\", \"status\": \"FILLED\", \"symbol\": \"ETHUSDT\", \"orderId\": \"8664222318\", \"origQty\": \"0.00600000\", \"isWorking\": true, \"stopPrice\": \"0.00000000\", \"icebergQty\": \"0.00000000\", \"updateTime\": \"1650610829617\", \"executedQty\": \"0.00600000\", \"orderListId\": \"-1\", \"timeInForce\": \"GTC\", \"clientOrderId\": \"6qgr8\", \"origQuoteOrderQty\": \"0.00000000\", \"cummulativeQuoteQty\": \"18.07068000\"}, \"side\": \"sell\", \"type\": \"limit\", \"price\": 3011.78, \"amount\": 0.006, \"filled\": 0.006, \"status\": \"closed\", \"symbol\": \"ETH/USDT\", \"trades\": [], \"average\": 3011.78, \"datetime\": \"2022-04-22T07:00:04.472Z\", \"postOnly\": false, \"remaining\": 0.0, \"stopPrice\": null, \"timestamp\": 1650610804472, \"timeInForce\": \"GTC\", \"clientOrderId\": \"6qgr8\", \"lastTradeTimestamp\": null}`\r\n\r\n`fee` contains data \r\n\r\n`{\"id\": \"8665290466\", \"fee\": {\"cost\": 2.99e-05, \"currency\": \"ETH\"}, \"cost\": 89.71196, \"fees\": [{\"cost\": 2.99e-05, \"currency\": \"ETH\"}], \"info\": {\"side\": \"BUY\", \"type\": \"LIMIT\", \"fills\": [{\"qty\": \"0.02990000\", \"price\": \"3000.40000000\", \"tradeId\": \"807983332\", \"commission\": \"0.00002990\", \"commissionAsset\": \"ETH\"}], \"price\": \"3000.40000000\", \"status\": \"FILLED\", \"symbol\": \"ETHUSDT\", \"orderId\": \"8665290466\", \"origQty\": \"0.02990000\", \"executedQty\": \"0.02990000\", \"orderListId\": \"-1\", \"timeInForce\": \"GTC\", \"transactTime\": \"1650618004892\", \"clientOrderId\": \"8iMM1\", \"cummulativeQuoteQty\": \"89.71196000\"}, \"side\": \"buy\", \"type\": \"limit\", \"price\": 3000.4, \"amount\": 0.0299, \"filled\": 0.0299, \"status\": \"closed\", \"symbol\": \"ETH/USDT\", \"trades\": [{\"id\": \"807983332\", \"fee\": {\"cost\": 2.99e-05, \"currency\": \"ETH\"}, \"cost\": 89.71196, \"fees\": [{\"cost\": \"0.00002990\", \"currency\": \"ETH\"}], \"info\": {\"qty\": \"0.02990000\", \"price\": \"3000.40000000\", \"tradeId\": \"807983332\", \"commission\": \"0.00002990\", \"commissionAsset\": \"ETH\"}, \"side\": \"buy\", \"type\": \"limit\", \"order\": \"8665290466\", \"price\": 3000.4, \"amount\": 0.0299, \"symbol\": \"ETH/USDT\", \"datetime\": null, \"timestamp\": null, \"takerOrMaker\": null}], \"average\": 3000.4, \"datetime\": \"2022-04-22T09:00:04.892Z\", \"postOnly\": false, \"remaining\": 0.0, \"stopPrice\": null, \"timestamp\": 1650618004892, \"timeInForce\": \"GTC\", \"clientOrderId\": \"8iMM1\", \"lastTradeTimestamp\": null}`\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/12943/comments",
    "author": "Kinzowa",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2022-04-22T10:52:17Z",
        "body": "@Kinzowa do you always use fetchOrder in all cases, or do you get those orders from different methods (say, fetchOrder / fetchOrders, or fetchOrder/createOrder, etc) ?"
      },
      {
        "user": "Kinzowa",
        "created_at": "2022-04-22T11:01:38Z",
        "body": "Hi @kroitor , thanks for your answer. Yes I use different methods. When an order is placed with `createOrder` I catch the response and, if the status is still `open` then I periodically check it with `fetchOrder`.\n\n---\n\nNow I understand, fee and trades are only reported by the exchange with `createOrder` if the order is executed.\r\n\r\nIf I understand correctly, Binance returns `fee` and `commission` keys when the order takes liquidity (taker), but not if it's a maker."
      },
      {
        "user": "kroitor",
        "created_at": "2022-04-22T11:50:57Z",
        "body": "> Now I understand, fee and trades are only reported by the exchange with `createOrder` if the order is executed.\r\n>\r\n> If I understand correctly, Binance returns `fee` and `commission` keys when the order takes liquidity (taker), but not if it's a maker.\r\n\r\nBasically, the fee is a property of a trade, not a property of an order. Most of the exchanges will return those fees with trades from fetchMyTrades. Some exchanges will also return those fees in the orders, but not all of them. That is because a single order can be filled with multiple trades, and then you have to sum up those fees to get the total fee. When the exchange does not specify a total fee on the order, ccxt can calculate it, if the exchange returns the trade information within the order. However, Binance exchange will only return that trade+fee information within createOrder upon placing it. And when you query it later, the trade+fee info is not available from the fetchOrder-endpoint. Hence, you have to fetchMyTrades, filter those trades by the order id and sum up their fees by currency. Hope that answers your question. Feel free to reopen this issue or just ask further questions if any."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of when Binance includes fee/trade data in order responses",
      "Clarification on fee data being tied to trades rather than orders",
      "Guidance on retrieving complete fee information through alternative methods",
      "Explanation of API endpoint limitations for historical order data"
    ]
  },
  {
    "number": 12576,
    "title": "Transfer USDT between spot and futures",
    "created_at": "2022-03-31T13:52:37Z",
    "closed_at": "2022-04-01T11:07:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/12576",
    "body": "- OS: Windows \r\n- Programming Language version: 3.10\r\n- CCXT version: 1.77.62\r\n\r\n```\r\nimport time\r\nstart = time.time()\r\nexchange.sapi_post_futures_transfer({\r\n    'asset': 'USDT',\r\n    'amount': '10',\r\n    'type': 2,\r\n})\r\nend = time.time()\r\n```\r\nI want to take a long position in the spot market and a short position in the future market. To do that, I have to make a USDT transfer between spot and future wallets. My question is:\r\n\r\nExecution time of the above transfer code is around 1 second. Except for USDT transfer between wallets, my entire code, including creating orders, takes milliseconds. Since USDT transfer takes 1 second, is there a risk that the order execution code runs before USDT transfer so the order can not be implemented due to lack of funds? If so, what would be the best solution?\r\n\r\nMaybe I should clarify my question\r\nLet's say that I am in full long position and I receive short signal. So I have to close all long positions, transfer USDT to future wallet and open short positions. Transferring USDT takes around 1 second. I wonder if there is a risk that execution order code(opening short positions) runs before money transfer? If it happens there wont be enough funds to open short position.\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/12576/comments",
    "author": "euphrates85",
    "comments": [
      {
        "user": "ttodua",
        "created_at": "2022-04-01T07:48:31Z",
        "body": "as I assume, you are using synchronous code. If so, it doesn't matter if transfer takes 800MS, 1200MS or 1000MS , as long as you execute trade after transfering. \r\nif you run asynchronous code, then right - it will need some extra steps - when you get the 'short' signal, then you can asynchronously initiate the transfer, and paralelly, i.e. every 200MS, check the balance to ensure the funds are received.\r\n\r\nBut again, if you run synchronous code, then I don't see why it would be an issue, i.e.:\r\n````\r\nif (short_signal_received) {\r\n    exchange.sapi_post_futures_transfer({...});\r\n    exchange.create_order(.....); //so, order will be only fired after the above line finishes its work.\r\n}\r\n````\r\nLet me know if i misunderstood the question."
      },
      {
        "user": "samgermain",
        "created_at": "2022-04-01T07:48:57Z",
        "body": "If you're using async ccxt, you would need to `await` the completion of the transfer before making your order, otherwise, you can just use the unified `transfer` method and not worry about it\r\n\r\n```\r\nimport ccxt\r\nimport pprint\r\n\r\nprint('CCXT Version:', ccxt.__version__)\r\n\r\nbinance = ccxt.binance()\r\ntransfer = binance.transfer(USDT, 0.01, spot, future)\r\norder = binance.createOrder( ... )\r\npprint(transfer)\r\npprint(order)\r\n```"
      },
      {
        "user": "euphrates85",
        "created_at": "2022-04-01T10:30:09Z",
        "body": "Thank you very much.  I am using synchronous code. I was worried that the code would continue to run without waiting for the money to be physically transferred between wallets. But it seems i shouldn't worry about that"
      }
    ],
    "satisfaction_conditions": [
      "Ensures transfer completion before order execution",
      "Addresses synchronous execution flow"
    ]
  },
  {
    "number": 12512,
    "title": "In using CCXT for FTX exchange, is there a simple/smart way to retrieve the values of current account Leverage, Total collateral and Free collateral?",
    "created_at": "2022-03-27T11:12:40Z",
    "closed_at": "2022-05-07T00:57:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/12512",
    "body": "In using CCXT for FTX exchange, is there a simple/smart way to retrieve the values of current Leverage, Total collateral and Free collateral?",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/12512/comments",
    "author": "jamezun",
    "comments": [
      {
        "user": "micant",
        "created_at": "2022-03-28T23:49:26Z",
        "body": "Not sure how smart it is but this is my implementation:\r\n\r\nMy understanding is that (for the most part) futures trading is not implemented in the _unified api_\r\n\r\n```\r\n async setLeverage(exchange, config) {\r\n      const lev = await exchange.privatePostAccountLeverage({\r\n        leverage: config.leverage\r\n      });\r\n  }\r\n\r\n async getLeverage(exchange) {\r\n      const { result } = await exchange.privateGetAccount();\r\n      const { leverage } = result;\r\n      return leverage;\r\n  }\r\n\r\n  async fetchCollateral(exchange) {\r\n      const { result } = await exchange.privateGetAccount();\r\n      const { collateral, freeCollateral } = result;\r\n      return {\r\n        collateral: {\r\n          USD: {\r\n            free: freeCollateral,\r\n            used: collateral - freeCollateral,\r\n            total: collateral\r\n          }\r\n        }\r\n      };\r\n    }\r\n\r\n```\r\n"
      },
      {
        "user": "jamezun",
        "created_at": "2022-03-29T06:28:00Z",
        "body": "thanks! it helps a lot!"
      },
      {
        "user": "ttodua",
        "created_at": "2022-04-01T11:55:46Z",
        "body": "@jamezun if the provided post helped you, feel free to close the issue."
      },
      {
        "user": "samgermain",
        "created_at": "2022-05-07T00:57:54Z",
        "body": "@jamezun I'm going to close this issue, feel free to reopen it if you have any more questions"
      }
    ],
    "satisfaction_conditions": [
      "Demonstrates retrieval of current account leverage value using CCXT",
      "Shows how to obtain both total collateral and free collateral values",
      "Provides structured response format for collateral data"
    ]
  },
  {
    "number": 12034,
    "title": "Question: precision of assets",
    "created_at": "2022-02-20T07:29:48Z",
    "closed_at": "2022-02-20T11:13:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/12034",
    "body": "Got a question regarding precision of assets.\r\nIt's not clear to me if precision of the same asset/currency if always the same all exchange markets. Or can it be different?\r\nCan I use precision from Currency or should I always use precision from Market (base or quote depending where my currency is). \r\n\r\nFor example, is it possible that BTC on WAVES/BTC (as quote) has precision 8 and on BTC/LTC (as base) has precision 7? \r\nAnyone? Thank you in advance!\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/12034/comments",
    "author": "dar7man",
    "comments": [
      {
        "user": "AnimusXCASH",
        "created_at": "2022-02-20T10:44:08Z",
        "body": "Yes, the precision can vary amongst exchanges. \n\nBrg"
      },
      {
        "user": "dar7man",
        "created_at": "2022-02-20T11:09:29Z",
        "body": "Sorry, maybe I wasn't clear. \r\nI was asking if precision can very amongst markets on the same exchange?"
      },
      {
        "user": "kroitor",
        "created_at": "2022-02-20T11:13:34Z",
        "body": "@dar7man hi! Yes, that is very common, an exchange can have varying precision with different markets (on the same exchange). Hope that answers your question, let us know if not."
      },
      {
        "user": "dar7man",
        "created_at": "2022-02-20T11:16:24Z",
        "body": "I'm not sure. I was asking if one asset (for example BTC), can have different precision on the **same exchange** but on **different markets**?"
      },
      {
        "user": "kroitor",
        "created_at": "2022-02-20T11:25:53Z",
        "body": "@dar7man yes, that is possible, the same asset can have different precision within different market pairs on the same exchange."
      },
      {
        "user": "dar7man",
        "created_at": "2022-02-20T11:30:11Z",
        "body": "Thank you!\r\n\r\nSo, what's the point in CCTX of \"precision\" field in Currency structure?\r\nHow it corresponds to \"precision\" in Market structure?\r\n\r\n"
      },
      {
        "user": "kroitor",
        "created_at": "2022-02-20T11:35:07Z",
        "body": "@dar7man withdrawal precision is not always the same as trading precision. \r\n\r\n> How it corresponds to \"precision\" in Market structure?\r\n\r\nIf the exchange does not specify a per-currency precision or any currency info per se, then the highest precision from markets is taken for currencies.\r\n\r\nIf the exchange does define separate per-currency and per-market precision for BTC, then CCXT will use that where applicable."
      },
      {
        "user": "dar7man",
        "created_at": "2022-02-20T11:42:19Z",
        "body": "Got it! \r\nThank you very much for detailed explanation."
      }
    ],
    "satisfaction_conditions": [
      "Clarification of whether the same asset can have different precision values in different markets on the same exchange",
      "Explanation of the relationship between Currency-level precision and Market-level precision in CCXT's structure",
      "Differentiation between withdrawal precision (Currency) and trading precision (Market)",
      "Description of how CCXT handles exchanges that don't specify per-currency precision"
    ]
  },
  {
    "number": 11176,
    "title": "How to pass sub account argument to Binance exchange instantiation",
    "created_at": "2022-01-08T17:02:23Z",
    "closed_at": "2022-01-08T17:03:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/11176",
    "body": "I can't find anywhere the syntax to tell Binance to load data (.fetchBalance(), .fetch_positions()) only on a subaccount?\r\nOn FTX, I would add the below to the parameters dict:\r\n'headers': {'FTX-SUBACCOUNT': 'YOURSUBACCOUNTNAME'}\r\n\r\nI've tried replacing the headers key by 'BINANCE-SUBACCOUNT', or 'SUBACCOUNT', but everytime I get error 2015:\r\n{AuthenticationError}binance {\"code\":-2015,\"msg\":\"Invalid API-key, IP, or permissions for action.\"}",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/11176/comments",
    "author": "bsauvage1",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2022-01-08T17:03:41Z",
        "body": "@bsauvage1 with Binance the API keypair identifies the subaccount, i think, so if you pass the subaccount API key to it, it should fetch the subaccount balance. Let us know if that does not help."
      },
      {
        "user": "bsauvage1",
        "created_at": "2022-01-08T17:14:03Z",
        "body": "ha - it was an issue with my key! it's indeed working fine and directly pings the subaccount. Thank you!\r\n"
      }
    ],
    "satisfaction_conditions": [
      "Identifies the correct authentication mechanism for Binance subaccounts",
      "Explains how to configure API access for subaccount-specific data retrieval",
      "Clarifies Binance's subaccount authentication differs from FTX's header-based approach"
    ]
  },
  {
    "number": 10751,
    "title": "[okex] Networks indexed improperly",
    "created_at": "2021-12-01T13:27:01Z",
    "closed_at": "2021-12-01T13:29:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/10751",
    "body": "Dear fellows,\r\nokex.js -> options\r\n\r\n```                \r\n'networks': {\r\n    'ETH': 'ERC20',\r\n    'TRX': 'TRC20',\r\n    'OMNI': 'Omni',\r\n},\r\n```\r\nare indexed wrongly, the networks in other parts of ccxt (exchange.currencies.networks for example) are indexed by ERC20, TRC20, etc.\r\nI suggest to unify it (e.g. binance, kucoin, etc):\r\n```javascript\r\nbinance: \r\n                'networks': {\r\n                    'ERC20': 'ETH',\r\n                    'TRC20': 'TRX',\r\n                    'BEP2': 'BNB',\r\n                    'BEP20': 'BSC',\r\n                    'OMNI': 'OMNI',\r\n                    'EOS': 'EOS',\r\n                    'SPL': 'SOL',\r\n                },\r\nkucoin:\r\n\r\n                'networks': {\r\n                    'ETH': 'eth',\r\n                    'ERC20': 'eth',\r\n                    'TRX': 'trx',\r\n                    'TRC20': 'trx',\r\n                    'KCC': 'kcc',\r\n                    'TERRA': 'luna',\r\n                },\r\n```\r\n\r\nThere is also issue with default value in withdraw function, which allows invalid network ID to get into withdrawal requests:\r\n```javascript\r\n        network = this.safeString (networks, network, network); // handle ETH>ERC20 alias\r\n```\r\n\r\nEDIT: the options might just need to by extended with ERC20, TRC20, etc.",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/10751/comments",
    "author": "krychla1",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2021-12-01T13:29:55Z",
        "body": "That is actually a correct mapping:\r\n\r\n```JavaScript\r\n'networks': {\r\n    'ETH': 'ERC20',\r\n    'TRX': 'TRC20',\r\n    'OMNI': 'Omni',\r\n},\r\n```\r\n\r\n\u2191\u00a0That will work with all mappings ERC20, TRC20, OMNI, ETH, TRX, Omni due to how safeMethods are used with `networks`. That is done on purpose, so that all the following usages work:\r\n\r\n```\r\nfetchDepositAddress ('USDT', {'network':'ETH'})\r\nfetchDepositAddress ('USDT', {'network':'ERC20'})\r\n```\r\n\r\n\r\nHope that answers your question, let us know if not.\r\n"
      },
      {
        "user": "krychla1",
        "created_at": "2021-12-01T13:39:37Z",
        "body": "FetchDepositAddress handles it completely differently, because the network isn't part of the request, it is just filtered from the response (from a quick look).\r\n\r\nHowever check the withdrawal function:\r\n```javascript\r\n        const networks = this.safeValue (this.options, 'networks', {});\r\n        let network = this.safeStringUpper (params, 'network'); // this line allows the user to specify either ERC20 or ETH\r\n        network = this.safeString (networks, network, network); // handle ETH>ERC20 alias\r\n        if (network !== undefined) {\r\n            request['chain'] = currency['id'] + '-' + network;\r\n            params = this.omit (params, 'network');\r\n        }\r\n        const query = this.omit (params, [ 'fee', 'password', 'pwd' ]);\r\n        if (!('pwd' in request)) {\r\n            throw new ExchangeError (this.id + ' withdraw() requires a password parameter or a pwd parameter, it must be the funding password, not the API passphrase');\r\n        }\r\n        const response = await this.privatePostAssetWithdrawal (this.extend (request, query));\r\n```\r\nThis allows you to use ERC20 as a network only because it allows everything to be used as networks.\r\n\r\nEDIT:\r\nexample\r\n```javascript\r\nexchange.withdraw ('USDT', network: \"weirdInvalidNetwork\")\r\n```"
      },
      {
        "user": "kroitor",
        "created_at": "2021-12-01T13:51:54Z",
        "body": "> This allows you to use ERC20 as a network only because it allows everything to be used as networks.\r\n\r\nYes, that is correct. We will not reject params-overrides, if the user intentionally supplies an identifier for some new blockchain that is not listed out in `networks`. The user will get an exception from the exchange if the supplied network is incorrect.\r\n\r\nThe unified identifier for ERC20 is `ERC20`, for TRC20 it is `TRC20`.\r\nCCXT will allow the user to supply unified networks as well as exchange-specific networks by design."
      },
      {
        "user": "krychla1",
        "created_at": "2021-12-01T14:24:15Z",
        "body": "I thought you would want to sanitize the inputs. I've got your point, thanks for clarification."
      },
      {
        "user": "kroitor",
        "created_at": "2021-12-01T14:27:39Z",
        "body": "> I thought you would want to sanitize the inputs.\r\n\r\nYes, in general, we do sanitize it, but not in this specific case since the exchanges announce new listings every day, and if we hardcode that, it will be much harder to maintain. We do have some hardcode in the lib, but we would like to eventually get rid of it. Thanks for your understanding.\r\n\r\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how network identifier mappings are designed to handle both unified and exchange-specific formats",
      "Clarification on input validation strategy for network parameters",
      "Demonstration of balance between strict validation and forward compatibility",
      "Consistency with CCXT's philosophy of exchange-specific parameter tolerance"
    ]
  },
  {
    "number": 10495,
    "title": "what is the proper way to fetchfunctios with a single binance apikey",
    "created_at": "2021-11-05T19:03:13Z",
    "closed_at": "2021-12-14T21:47:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/10495",
    "body": "OS: Ubuntu 20.04\r\nProgramming Language version: Javascript Node js\r\nCCXT version: 1.60.10\r\n\r\nHow many cctx object I need to create to get all my positions. In the documentation to get the linear positions I need to create a \r\n`\r\n            exchangeusdm = new ccxt.binanceusdm\r\n`\r\n\r\nwhile for the coin base futures, I need to create a \r\n`\r\n           exchangecoinm = new ccxt.binancecoinm\r\n`\r\nI checked the code and I see that both extend from finance\r\nI am creating a code that needs to get all positions, balance, and all assets of a user\r\nmy questions are: \r\nDo I need to create both objects with the same API key to get the inverted and linear positions ?\r\nIs there a situation where I also need to create  the usual binance object\r\n`\r\n           exchangecoinm = new ccxt.binance\r\n`",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/10495/comments",
    "author": "israel-gonzalezmedina",
    "comments": [
      {
        "user": "ttodua",
        "created_at": "2021-12-14T21:47:00Z",
        "body": "At this moment, it seems to me the way (to create two separate objects), and as they inherit from binance, there is no need to create `new ccxt.binance` separately, as they will do everything whatever `binance` class can do. as you might seen in implementation, the `options` parts are only different in `binanceusdm/binancecoinm`:\r\n\r\nbinanceusdm:\r\n```\r\n            'options': {\r\n                'defaultType': 'future',\r\n                'marginTypes': {},\r\n                ...\r\n            },\r\n```\r\nbinancecoinm:\r\n```\r\n            'options': {\r\n                'defaultType': 'delivery',\r\n                ...\r\n            },\r\n```\r\n\r\nunfortunately, I can't see any simple way to initiate only one binance-object and manage switching from one to another type, because of the dependancy-chain (i.e. separate fetch-markets, permitted currencies, etc...), so viable way is to have 2 exchange objects.\r\n\r\nhowever, if you want to trade on spot too, then you will need 3rd initiated object (`new binance()`) as the above two only works with their fields and not on spot.\n\n---\n\n@kroitor lmk if anything needs to be mentioned too.\r\n@israel-gonzalezmedina feel free to re-open the issue if help still needed."
      },
      {
        "user": "israel-gonzalezmedina",
        "created_at": "2021-12-14T23:20:37Z",
        "body": "thanks @ttodua for the explanation "
      },
      {
        "user": "kroitor",
        "created_at": "2021-12-15T02:20:05Z",
        "body": "@israel-gonzalezmedina I would highly recommend to avoid mixing the defaultType in the runtime.\r\n\r\nInstead, the recommended way of dealing with binance market types is to create one exchange instance per type, as you explained in your opening post.\r\n\r\n> Do I need to create both objects with the same API key to get the inverted and linear positions ?\r\n\r\nYes, they're not interchangeable on the same instance, cause they require preloading either this or that set of markets.\r\nYou have to use several instances of Binance:\r\n\r\n```JavaScript\r\nconst binance = new ccxt.binance()\r\nconst binanceusdm = new ccxt.binanceusdm()\r\nconst binancecoinm = new ccxt.binancecoinm()\r\n```\r\n\r\nor\r\n\r\n```JavaScript\r\nconst binance = new ccxt.binance({ 'options': { 'defaultType':spot' }})\r\nconst binanceusdm = new ccxt.binance({ 'options': { 'defaultType':future' }})\r\nconst binancecoinm = new ccxt.binance({ 'options': { 'defaultType':delivery' }})\r\n```\r\n\r\nHope that helps."
      }
    ],
    "satisfaction_conditions": [
      "Clarifies whether multiple exchange instances are required for different Binance market types (spot, USD\u24c8-M, COIN-M)",
      "Explains API key sharing between different exchange instances",
      "Addresses the relationship between parent Binance class and specialized futures classes",
      "Identifies scenarios requiring spot market interaction",
      "Explains market type segregation rationale without technical jargon"
    ]
  },
  {
    "number": 10439,
    "title": "ByBit Close Position",
    "created_at": "2021-11-02T12:27:58Z",
    "closed_at": "2021-11-02T22:12:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/10439",
    "body": "\r\n- OS: MacOs\r\n- Programming Language version: Python 3.9.4\r\n- CCXT version: 1.60.9\r\n\r\n```\r\nsymbol = 'SOLUSDT'\r\ntrade_res = exchange.create_order(symbol, amount=1, type='Market', side='Buy')\r\n```\r\n\r\nThe above snippet buys 1 SOL against USDT. When I try to close the position by placing a sell order, I see that ByBit placed another Short position on SOL without closing the Long one (2 positions appear in the console)\r\n\r\nHow do I close a current open position on ByBit using ccxt?\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/10439/comments",
    "author": "mhd-adam",
    "comments": [
      {
        "user": "elitwilliams",
        "created_at": "2021-11-02T18:36:55Z",
        "body": "You need to set the `reduce_only` param to `True` to place a closing order on Bybit. To my knowledge there is unfortunately no way to set this as the default behavior on Bybit, and you will need to track your position on your end or use a try/except to catch and re-place an order as opening if a closing order attempt fails, but of course this will count as 2 API requests.\r\n\r\n```\r\nsymbol = 'SOLUSDT'\r\ntrade_res = exchange.create_order(symbol, amount=1, type='Market', side='Buy', params={\"reduce_only\": True})\r\n```"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how to configure orders to specifically close positions rather than open new ones",
      "Identification of required order parameters/flags for position reduction",
      "Clarification of exchange-specific position management behavior"
    ]
  },
  {
    "number": 9886,
    "title": "How to set leverage for Binance SPOT Trades  ?",
    "created_at": "2021-08-27T14:21:56Z",
    "closed_at": "2021-08-27T14:23:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/9886",
    "body": "\r\n- OS: WIndows\r\n- Programming Language version: Python\r\n- CCXT version: 1.55.15\r\n   \r\ncode:\r\n              leverage=exchange.set_leverage(symbol='BTC/USDT, leverage=2)\r\n              print(lev)\r\n\r\nError :\r\n              binance setLeverage() supports linear and inverse contracts only\r\n\r\n\r\nNote: It's working fine for future or delivery. ( 'defaultType':  'delivery', # 'future', )\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/9886/comments",
    "author": "SreekanthAvala",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2021-08-27T14:23:58Z",
        "body": "You can't set the leverage on spot trades in general. Leverage is only available with futures and perpetuals (delivery, future), in other words, it requires a notion of margin. It is not a limitation of CCXT, though, that is just how exchanges work."
      },
      {
        "user": "SreekanthAvala",
        "created_at": "2021-08-27T14:50:20Z",
        "body": "> You can't set the leverage on spot trades in general. Leverage is only available with futures and perpetuals (delivery, future), in other words, it requires a notion of margin. It is not a limitation of CCXT, though, that is just how exchanges work.\r\n\r\nThanks @kroitor "
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why leverage cannot be set for spot trades",
      "Clarification about margin requirements in different market types",
      "Differentiation between spot vs futures market mechanics",
      "Confirmation this is an exchange limitation rather than CCXT issue"
    ]
  },
  {
    "number": 9880,
    "title": "Python ratelimiter broken",
    "created_at": "2021-08-26T09:34:50Z",
    "closed_at": "2021-08-26T09:48:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/9880",
    "body": "The python rateLimiter is broken in the newest version.\r\nI tested this on python 3.7 and 3.8 (Debian and CentOS)\r\n\r\nThe following snippet should return, but it is stuck after the first loop.\r\n\r\n```\r\nimport asyncio\r\nimport ccxt.async_support\r\n\r\n\r\nasync def main():\r\n    exchange1 = ccxt.async_support.hitbtc({\"enableRateLimit\": True})\r\n    exchange2 = ccxt.async_support.hitbtc({\"enableRateLimit\": True})\r\n    for i in range(0, 20):\r\n        await exchange1.throttle(exchange1.rateLimit)\r\n        await exchange2.throttle(exchange2.rateLimit)\r\n        print(\"Round done\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    asyncio.run(main())\r\n```",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/9880/comments",
    "author": "brandsimon",
    "comments": [
      {
        "user": "brandsimon",
        "created_at": "2021-08-26T09:40:38Z",
        "body": "The snippet works for binance, so I changed the rateLimit to 50 (binance has 50, hitbtc 1500).\r\nThis works, but instead of waiting 50ms, it waits 5 seconds."
      },
      {
        "user": "frosty00",
        "created_at": "2021-08-26T09:44:24Z",
        "body": "@brandsimon the usage is wrong it should be:\r\n\r\n```\r\nimport asyncio\r\nimport ccxt.async_support\r\n\r\n\r\nasync def main():\r\n    exchange1 = ccxt.async_support.hitbtc({\"enableRateLimit\": True})\r\n    exchange2 = ccxt.async_support.hitbtc({\"enableRateLimit\": True})\r\n    for i in range(0, 20):\r\n        await exchange1.throttle(1)\r\n        await exchange2.throttle(1)\r\n        print(\"Round done\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    asyncio.run(main())\r\n```\n\n---\n\nthe argument exchange.rateLimit is deprecated now we have dynamic costs for calls in binance.js"
      },
      {
        "user": "kroitor",
        "created_at": "2021-08-26T09:48:10Z",
        "body": "@brandsimon the new version of `throttle()` accepts the call `cost` instead of `rateLimit`.\n\n---\n\n```Python\r\nimport asyncio\r\nimport ccxt.async_support\r\n\r\nasync def main():\r\n    exchange1 = ccxt.async_support.hitbtc({\"enableRateLimit\": True})\r\n    exchange2 = ccxt.async_support.hitbtc({\"enableRateLimit\": True})\r\n    for i in range(0, 20):\r\n        await asyncio.gather(*[\r\n            exchange1.throttle(1),\r\n            exchange2.throttle(1),\r\n        ])\r\n        print(\"Round done\")\r\n\r\nif __name__ == \"__main__\":\r\n    asyncio.run(main())\r\n```\r\nThis snippet prints a line every 1.5 sec, according to hitbtc's rate limit setting."
      },
      {
        "user": "brandsimon",
        "created_at": "2021-08-26T10:06:44Z",
        "body": "@kroitor @frosty00 \r\nThank you very much, this solves my issue.\r\nSo the CCXT `rateLimit` and `enableRateLimit` behavior stays the same, it is just the throttle API which changed?"
      },
      {
        "user": "kroitor",
        "created_at": "2021-08-26T10:07:35Z",
        "body": "@brandsimon yes, moreover, enableRateLimit is true by default now."
      },
      {
        "user": "brandsimon",
        "created_at": "2021-08-26T10:12:01Z",
        "body": "Great, thank you :)"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of API changes in throttle() method parameters",
      "Proper async execution pattern for multiple rate-limited exchanges",
      "Clarification of default rate-limiting behavior in new versions",
      "Demonstration of correct rate limit timing calculation"
    ]
  },
  {
    "number": 9371,
    "title": "help authenticating to KuCoin Exchange using ccxtPro",
    "created_at": "2021-06-13T07:52:53Z",
    "closed_at": "2021-06-13T18:19:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/9371",
    "body": "Hello Guys, \r\n\r\ni tried to authenticate to Kucoin using ccxtPro but it doesn't work, can someone please correct what i'm doing wrong here ?\r\n\r\nhere is my code:\r\n\r\n```\r\nexchange_kucoin = ccxtpro.kucoin({\r\n    'apiKey': const.API_KEY,\r\n    'secret': const.API_SECRET,\r\n    'password': const.API_PASSPHRASE,\r\n    'enableRateLimit': True,\r\n    'headers': {\r\n        'KC-API-KEY': const.API_KEY,\r\n    }\r\n})\r\n```\r\ni have also tried this without the \"header\" but still the same issue\r\n\r\nbut when i try to run a function to get some informations about my account, i get this error: \r\n\r\n`kucoin KC-API-KEY not exists`\r\n\r\n\r\nthe ccxtpro version i'm using is: print(ccxtpro.__version__) ==> 0.7.19",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/9371/comments",
    "author": "korchix",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2021-06-13T12:46:20Z",
        "body": "@korchix have you tried recreating your API Key? If not, please, try with a fresh new keypair and let us know if that does not help."
      },
      {
        "user": "korchix",
        "created_at": "2021-06-13T18:19:16Z",
        "body": "@kroitor it works now with the new key, thank you for the hint."
      }
    ],
    "satisfaction_conditions": [
      "Ensures API key validity and proper authentication setup",
      "Addresses KC-API-KEY existence error specifically",
      "Works with ccxtPro's authentication requirements for KuCoin"
    ]
  },
  {
    "number": 9321,
    "title": "Transfer between Binance wallets return status, datetime and timestamp = None",
    "created_at": "2021-06-05T10:17:15Z",
    "closed_at": "2021-06-05T10:20:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/9321",
    "body": "Hello all,\r\n\r\nI noticed that transfer between Binance wallets return some missing information, please find an example:\r\n\r\n```\r\nb.transfer('USDT', 1, 'future', 'spot')\r\n\r\n{'info': {'tranId': '65052934028'},\r\n 'id': '65052934028',\r\n 'timestamp': None,\r\n 'datetime': None,\r\n 'currency': 'USDT',\r\n 'amount': 1,\r\n 'fromAccount': 'future',\r\n 'toAccount': 'spot',\r\n 'status': None}\r\n```\r\n\r\nAs you can see status, timestamp and datetime are set to None even when transfer is successful. It's a minor issue but it's useful to have these data in order to monitor transfers.\r\n\r\nBest,\r\nKinzowa\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/9321/comments",
    "author": "Kinzowa",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2021-06-05T10:20:12Z",
        "body": "Hi! The `info` structure contains the response from the exchange \"as is\", untouched: `'info': {'tranId': '65052934028'},` \u2190 there's no timestamp there, therefore it's not populated. This is documented throughout the Manual \u2013\u00a0not all exchanges will provide all the fields in all the structures. If you need a timestamp, you can just call `exchange.milliseconds()` or `exchange.iso8601(exchange.milliseconds())`. Hope that answers your question. Let us know if not."
      },
      {
        "user": "Kinzowa",
        "created_at": "2021-06-05T10:22:23Z",
        "body": "Thanks Igor, I will do that"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how to obtain transfer timestamps for monitoring purposes",
      "Clarification on data availability from the exchange API",
      "Workaround for missing real-time status information"
    ]
  },
  {
    "number": 9207,
    "title": "FTX: Can't cancel opened Order / Can't get Order ID's of open Orders (PHP)",
    "created_at": "2021-05-18T20:15:36Z",
    "closed_at": "2021-05-18T20:33:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/9207",
    "body": "i can successfully create orders with :\r\n\r\n`$exchange->create_order($symbol, $type, $side, $amount, $price, $params);`\r\n```\r\nArray\r\n(\r\n    [info] => Array\r\n        (\r\n            [id] => 44022042\r\n            [market] => BTC-PERP\r\n            [future] => BTC-PERP\r\n            [side] => sell\r\n            [type] => take_profit\r\n            [orderPrice] => 48100.0\r\n            [triggerPrice] => 47000.0\r\n            [size] => 0.001\r\n            [status] => open\r\n            [createdAt] => 2021-05-18T20:09:03.654365+00:00\r\n            [triggeredAt] => \r\n            [orderId] => \r\n            [error] => \r\n            [reduceOnly] => \r\n            [trailValue] => \r\n            [trailStart] => \r\n            [cancelledAt] => \r\n            [cancelReason] => \r\n            [retryUntilFilled] => \r\n            [orderType] => limit\r\n        )\r\n\r\n    [id] => 44022042\r\n    [clientOrderId] => \r\n    [timestamp] => 1621368543654\r\n    [datetime] => 2021-05-18T20:09:03.654Z\r\n    [lastTradeTimestamp] => \r\n    [symbol] => BTC-PERP\r\n    [type] => take_profit\r\n    [timeInForce] => \r\n    [postOnly] => \r\n    [side] => sell\r\n    [price] => 47000\r\n    [stopPrice] => 47000\r\n    [amount] => 0.001\r\n    [cost] => \r\n    [average] => \r\n    [filled] => \r\n    [remaining] => \r\n    [status] => open\r\n    [fee] => \r\n    [trades] => \r\n)\r\n\r\n```\r\n\r\nbut if i want to close this order with\r\n`$exchange->cancel_order(44022042)`\r\n\r\n\r\ni get an error\r\n\r\n`ccxt\\OrderNotFound: ftx {\"success\":false,\"error\":\"Order not found\"}`\r\n\r\n\r\n\r\nalso \r\n\r\n`$exchange->fetch_open_orders() `returns an empty array even though i have open orders\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/9207/comments",
    "author": "hm291195",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2021-05-18T20:33:44Z",
        "body": "@hm291195 if you're canceling a conditional take_profit order, you have to add a `type` param override, otherwise it will attempt to cancel a regular order with that id instead of the conditional order:\r\n\r\n```PHP\r\n$exchange->cancel_order(44022042, null, array('type'=>'takeProfit'));\r\n```\r\n\r\nLet us know if that does not answer your question."
      },
      {
        "user": "hm291195",
        "created_at": "2021-05-18T20:39:51Z",
        "body": "ok this works.\r\n\r\nAnd regarding the second part - why does `$exchange->fetch_open_orders() `return an empty array even though i have open orders ? Is there also a param override neccessary ?\r\n\r\n\r\nLast but not least i just figured out another ambiguity:\r\n\r\nif i fetch my open positions with `$exchange->fetch_positions() `why does the array contain positions that are already closed ? Am i right, that the only way to find out my open positions is to check each key of the array if there is \"openSize\" which is then > 0 to find out if the position is still open or already closed ?"
      },
      {
        "user": "kroitor",
        "created_at": "2021-05-19T11:05:27Z",
        "body": "@hm291195 \r\n\r\n> And regarding the second part - why does $exchange->fetch_open_orders() return an empty array even though i have open orders ? Is there also a param override neccessary ?\r\n\r\nYes, you have to add a param override for conditionals: \r\n\r\n```PHP\r\n$since = null;\r\n$limit = null;\r\n$params = array('type'=>'takeProfit');\r\n$orders = $exchange->fetch_open_orders($symbol, $since, $limit, $params);\r\n```\r\n\r\n> Am i right, that the only way to find out my open positions is to check each key of the array if there is \"openSize\" which is then > 0 to find out if the position is still open or already closed ?\r\n\r\nYes, that is correct."
      },
      {
        "user": "hm291195",
        "created_at": "2021-05-19T12:25:06Z",
        "body": "sorry for the duplicate post, i thought my answer here might not show up since the question was closed yesterday after your answer!\r\n\r\nthanks for clarifying.\r\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of required parameter overrides for conditional order types",
      "Clarification on filtering mechanisms for order/position status checks",
      "Documentation of API endpoint-specific requirements",
      "Consistent pattern for handling order type variations"
    ]
  },
  {
    "number": 9188,
    "title": "What Time Does The Day Roll Over?",
    "created_at": "2021-05-16T09:57:11Z",
    "closed_at": "2021-05-16T10:07:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/9188",
    "body": "Quick question: When do daily 'candles' roll over in ccxt? I am pulling daily data on a US server and for my system I need to know when the date stamps roll over into the new day/date. My understanding thus far is that it happens at 0:00 GMT. \r\n\r\nIf correct then the roll over would be e.g. at 8:00pm in NYC, and 1:00am in London.\r\n\r\nCan you please confirm or correct?",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/9188/comments",
    "author": "mmehrle",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2021-05-16T10:07:26Z",
        "body": "Hi! Yes, all unified timestamps should be in UTC. Exchange-specific `info`s may have timestamps in other timezones, but CCXT converts them to UTC in the outer unified layer. If you find any inconsistencies, please let us know."
      },
      {
        "user": "mmehrle",
        "created_at": "2021-05-16T21:34:43Z",
        "body": "WOW - that was fast. You are the man. BTW, ccxt kicks ass - love it.\n\n---\n\nFollow up question. I'm setting up a cron job and my sys admin asked me if we are talking about UTC or GMT here. Because GMT accounts for DST while UTC does not. My 'guess' would be that exchanges use UTC but I just wanted to make sure.\r\n\r\nThanks in advance.\n\n---\n\nNever mind - you already answered that it's in UTC. My apologies - I have not gotten much sleep in the past few weeks :-}"
      }
    ],
    "satisfaction_conditions": [
      "Confirmation of whether daily candle timestamps use UTC timezone",
      "Clarification that timezone handling is consistent across exchanges"
    ]
  },
  {
    "number": 9103,
    "title": "exchange.timeframes['1d'] missing from ByBit",
    "created_at": "2021-05-01T10:27:21Z",
    "closed_at": "2021-05-01T19:44:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/9103",
    "body": "When i try using **exchange.timeframes['1d']** for ByBit exchange - i see this error: **[ExceptionsHandler] timeframe unit D is not supported**\r\n\r\n```typescript\r\n          for (const date of dates) {\r\n            await sleep(exchange.rateLimit); // milliseconds\r\n            const fData = await exchange.fetchOHLCV(\r\n              symbol,\r\n              exchange.timeframes['1d'],\r\n              exchange.parse8601(`${date}T00:00:00Z`),\r\n              1,\r\n            );\r\n```\r\nHow fix this problem, i need 1 day timeframe? I'm using last version of ccxt 1.49.21",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/9103/comments",
    "author": "wirwl",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2021-05-01T19:44:12Z",
        "body": "@wirwl you're sending `exchange.timeframes['1d']`, just send `'1d'` instead:\r\n\r\n```JavaScript\r\n            const fData = await exchange.fetchOHLCV(\r\n              symbol,\r\n              '1d', // \u2190-------------------------------------- HERE\r\n              exchange.parse8601(`${date}T00:00:00Z`),\r\n              1,\r\n            );\r\n```\r\n\r\nLet us know if that does not answer your question."
      },
      {
        "user": "wirwl",
        "created_at": "2021-05-02T11:54:27Z",
        "body": "> @wirwl you're sending `exchange.timeframes['1d']`, just send `'1d'` instead:\r\n> \r\n> ```js\r\n>             const fData = await exchange.fetchOHLCV(\r\n>               symbol,\r\n>               '1d', // \u2190-------------------------------------- HERE\r\n>               exchange.parse8601(`${date}T00:00:00Z`),\r\n>               1,\r\n>             );\r\n> ```\r\n> \r\n> Let us know if that does not answer your question.\r\n\r\nYes, '1d' it's work. Thank you!"
      }
    ],
    "satisfaction_conditions": [
      "Identifies the correct timeframe string format supported by ByBit exchange for daily intervals",
      "Provides a way to use 1-day OHLCV data retrieval without relying on exchange.timeframes mapping",
      "Addresses exchange-specific timeframe format requirements"
    ]
  },
  {
    "number": 9046,
    "title": "Stale Price Feed from Binance USDT Futures & FTX",
    "created_at": "2021-04-22T08:03:42Z",
    "closed_at": "2021-05-04T23:30:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/9046",
    "body": "Hi Kroitor,\r\n\r\nI think I'm getting a stale/delayed price feed from Binance USDT Futures and FTX. I only need the Best Bid & Offer from each of the exchanges pushed in real-time (I don't need orderbooks). Sometimes the FTX price or the Binance price just stops updating. Is there anything in the code you can see that would be causing this?\r\n\r\nimport threading\r\nimport asyncio\r\nimport ccxtpro\r\nimport loggin_util\r\nfrom definitions.exchanges import Exchanges\r\nfrom definitions.trading_util import ConnectionState\r\nimport ccxtpro_exchanges\r\nimport definitions.app_values as apv\r\n\r\n\r\n# from principal import Principal\r\n\r\n\r\nclass DataFeedManager(threading.Thread):\r\n    def __init__(self, exchange: Exchanges, symbol_name: str, data_coin_command, print_info: bool,\r\n                 entry_delta: float, exit_delta: float, entry_size: float, _data_feed_stopped,\r\n                 _executing_methods_event, assigned_pair_id):\r\n        threading.Thread.__init__(self)\r\n        self.exchange = exchange\r\n        self.symbol_name = symbol_name\r\n        self.print_info = print_info\r\n        self.print_info = False  # for testing\r\n        self.bid = 0.0\r\n        self.ask = 0.0\r\n        self.entry_delta = entry_delta\r\n        self.exit_delta = exit_delta\r\n        self.entry_size = entry_size\r\n        self.logger = loggin_util.create_logger(__name__ + '_' + self.exchange.name + '_' +\r\n                                                self.symbol_name.replace('/', ''))\r\n        self.conn_state = ConnectionState.DISCONNECTED\r\n        self.data_coin_command = data_coin_command\r\n        self.data_feed_enabled = True\r\n        self.data_feed_stopped = _data_feed_stopped\r\n        self.executing_methods_event = _executing_methods_event\r\n        self.binance_pro = ccxtpro.binance({'enableRateLimit': True,\r\n                                            'options': {\r\n                                                'defaultType': 'future',\r\n                                            }})\r\n        self.ftx_pro = ccxtpro.ftx({'enableRateLimit': True})\r\n        self.assigned_pair_id = assigned_pair_id\r\n\r\n        # print(self.symbol_id.replace('/', ''))\r\n\r\n    async def get_tick(self):\r\n        exchange_switcher = {\r\n            Exchanges.binance: ccxtpro.binance({'enableRateLimit': True,\r\n                                                'apiKey': apv.binance_api_key,\r\n                                                'secret': apv.binance_secret_key,\r\n                                                'options': {\r\n                                                    'defaultType': 'future',\r\n                                                    'watchTicker': {\r\n                                                        'name': 'bookTicker'\r\n                                                    }\r\n                                                }}),\r\n            Exchanges.ftx: ccxtpro.ftx({'enableRateLimit': True}),\r\n        }\r\n        exchange = exchange_switcher.get(self.exchange)\r\n        while self.data_feed_stopped.wait():\r\n\r\n            if not self.data_feed_enabled:\r\n                print(\"Stopping Data Feed\")\r\n                self.data_feed_stopped.clear()\r\n                print(\"Data Feed Stopped? %s\" % self.data_feed_stopped)\r\n                break\r\n\r\n            if self.print_info: print(\"----------------------\")\r\n            if self.print_info: print(\"data_feed_enabled: %s\" % self.data_feed_enabled)\r\n            if self.print_info: print(exchange.id)\r\n            if self.print_info: print(\"Symbol: \", self.symbol_name)\r\n\r\n            try:\r\n                # order_book = await exchange.watch_order_book(self.symbol_name)\r\n                order_book = await exchange.watch_ticker(self.symbol_name)\r\n            except Exception as e:\r\n                self.conn_state = ConnectionState.DISCONNECTED\r\n                self.logger.error('Disconnected')\r\n                print(\"Exception: \", e)\r\n                continue\r\n            if self.conn_state == ConnectionState.DISCONNECTED:\r\n                self.logger.info('Connected')\r\n                self.conn_state = ConnectionState.CONNECTED\r\n\r\n            # self.bid = order_book['bids'][0][0] if len(order_book['bids']) > 0 else None\r\n            # self.ask = order_book['asks'][0][0] if len(order_book['asks']) > 0 else None\r\n            self.bid = order_book['bid'] if order_book['bid'] is not None else self.bid\r\n            self.ask = order_book['ask'] if order_book['ask'] is not None else self.ask\r\n            spread = (self.ask - self.bid) if (self.bid and self.ask) else None\r\n            mid = (self.bid + self.ask) / 2 if (self.bid and self.ask) else None\r\n            if self.print_info: print(\"bid: \", self.bid)\r\n            if self.print_info: print(\"ask: \", self.ask)\r\n            if self.print_info: print(\"spread: \", spread)\r\n            if self.print_info: print(\"mid: \", mid)\r\n            self.data_coin_command(self.symbol_name,\r\n                                   self.bid,\r\n                                   self.ask,\r\n                                   self.entry_delta,\r\n                                   self.exit_delta,\r\n                                   self.entry_size,\r\n                                   self.executing_methods_event,\r\n                                   self.assigned_pair_id)\r\n\r\n    def run(self):\r\n        asyncio.run(self.get_tick())",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/9046/comments",
    "author": "deceneucapital",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2021-04-22T08:17:36Z",
        "body": "Hi @deceneucapital !\r\n\r\nDo you have this issue with the most recent version of CCXT Pro + the following script:\r\n\r\n```Python\r\n# -*- coding: utf-8 -*-\r\n\r\nimport ccxtpro\r\nfrom asyncio import gather, get_event_loop\r\n\r\n\r\nasync def exchange_symbol_loop(exchange, symbol):\r\n    print('Starting the', exchange.id, 'symbol loop with', symbol)\r\n    while True:\r\n        try:\r\n            ticker = await exchange.watch_ticker(symbol)\r\n            now = exchange.milliseconds()\r\n            print(exchange.iso8601(now), exchange.id, symbol, ticker['bid'], ticker['ask'])\r\n        except Exception as e:\r\n            print(str(e))\r\n            # raise e  # uncomment to break all loops in case of an error in any one of them\r\n            break  # you can break just this one loop if it fails\r\n\r\n\r\nasync def exchange_loop(asyncio_loop, exchange_id, symbols):\r\n    print('Starting the', exchange_id, 'exchange loop with', symbols)\r\n    exchange = getattr(ccxtpro, exchange_id)({\r\n        'enableRateLimit': True,\r\n        'asyncio_loop': asyncio_loop,\r\n        'options': {\r\n            'defaultType': 'future',\r\n            'watchTicker': {\r\n                'name': 'bookTicker',\r\n            },\r\n        },\r\n    })\r\n    loops = [exchange_symbol_loop(exchange, symbol) for symbol in symbols]\r\n    await gather(*loops)\r\n    await exchange.close()\r\n\r\n\r\nasync def main(asyncio_loop):\r\n    exchanges = {\r\n        'ftx': ['BTC/USDT', 'ETH/BTC'],\r\n        'binance': ['BTC/USDT', 'ETH/BTC'],\r\n    }\r\n    loops = [exchange_loop(asyncio_loop, exchange_id, symbols) for exchange_id, symbols in exchanges.items()]\r\n    await gather(*loops)\r\n\r\n\r\nif __name__ == '__main__':\r\n    asyncio_loop = get_event_loop()\r\n    asyncio_loop.run_until_complete(main(asyncio_loop))\r\n```\r\n\r\nDoes it get stale?\r\n"
      },
      {
        "user": "deceneucapital",
        "created_at": "2021-05-04T23:30:02Z",
        "body": "Will check and come back to you - thanks!\n\n---\n\nThat fixed it, thanks!"
      },
      {
        "user": "kroitor",
        "created_at": "2021-05-04T23:39:16Z",
        "body": "@deceneucapital thank you for your feedback! We appreciate it!"
      }
    ],
    "satisfaction_conditions": [
      "Ensures continuous real-time updates of Best Bid/Offer prices without interruptions",
      "Handles exchange API disconnections/reconnections automatically",
      "Maintains stable websocket connections to Binance Futures and FTX",
      "Uses correct API configuration for exchange-specific requirements",
      "Implements proper async/await patterns for concurrent data streams"
    ]
  },
  {
    "number": 8921,
    "title": "Coinbasepro watch_orders() fails with TypeError: 'Unicode-objects must be encoded before hashing'",
    "created_at": "2021-04-10T05:03:12Z",
    "closed_at": "2021-04-10T08:26:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/8921",
    "body": "I'm having this problem only with coinbasepro and only in watch_orders(). It works with ftx, and both watch_orderbook and watch_orders work with coinbasepro. My keys and passphrase are stored as strings, and they are being converted to bytes at some point before reaching hmac()\r\n\r\n \r\n- OS: macOS Catalina\r\n- Programming Language version: Python 3.8.6\r\n- CCXT version :ccxt==1.45.74, ccxtpro==0.6.33\r\n-\r\n\r\n```\r\ndef listen(self, callback=(lambda x: None)):\r\n        loop = asyncio.get_event_loop()\r\n        loop.create_task(self.watch_orderbook(callback))\r\n        loop.create_task(self.watch_orders(callback))\r\n        loop.create_task(self.slowly_watch_balance())\r\n\r\n```\r\nI also modified the hmac method for some debugging output, which indicates the string and request are bytes\r\n```\r\n@staticmethod\r\n    def hmac(request, secret, algorithm=hashlib.sha256, digest='hex'):\r\n        print('SECRET IS ' + str(secret))\r\n        print('REQUEST IS ' + str(request))\r\n        print('ALGORITHM IS ' + str(algorithm))\r\n        h = hmac.new(secret, request, algorithm)\r\n        binary = h.digest()\r\n        if digest == 'hex':\r\n            return Exchange.binary_to_base16(binary)\r\n        elif digest == 'base64':\r\n            return Exchange.binary_to_base64(binary)\r\n        return binary\r\n```\r\n\r\n```\r\nSECRET IS b'\\xd3\\xe1!...omitted...x9a'\r\nREQUEST IS b'16...omitted...86GET/accounts'\r\nALGORITHM IS <built-in function openssl_sha256>\r\n```\r\n\r\nThe traceback for the error is:\r\n```\r\nTraceback (most recent call last):\r\n  File \"/Users/nnsk/Desktop/scrypto/addthistowrappers.py\", line 130, in watch_orders\r\n    self.orders = await self.client.watch_orders(symbol=self.symbol, limit=200)\r\n  File \"/usr/local/lib/python3.8/site-packages/ccxtpro/coinbasepro.py\", line 101, in watch_orders\r\n    authentication = self.authenticate()\r\n  File \"/usr/local/lib/python3.8/site-packages/ccxtpro/coinbasepro.py\", line 46, in authenticate\r\n    signature = self.hmac(payload, self.base64_to_binary(self.secret), hashlib.sha256, 'base64')\r\n  File \"/usr/local/lib/python3.8/site-packages/ccxt/base/exchange.py\", line 1112, in hmac\r\n    h = hmac.new(secret, request, algorithm)\r\n  File \"/usr/local/Cellar/python@3.8/3.8.6/Frameworks/Python.framework/Versions/3.8/lib/python3.8/hmac.py\", line 153, in new\r\n    return HMAC(key, msg, digestmod)\r\n  File \"/usr/local/Cellar/python@3.8/3.8.6/Frameworks/Python.framework/Versions/3.8/lib/python3.8/hmac.py\", line 88, in __init__\r\n    self.update(msg)\r\n  File \"/usr/local/Cellar/python@3.8/3.8.6/Frameworks/Python.framework/Versions/3.8/lib/python3.8/hmac.py\", line 96, in update\r\n    self.inner.update(msg)\r\nTypeError: Unicode-objects must be encoded before hashing\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/8921/comments",
    "author": "nanaknihal",
    "comments": [
      {
        "user": "frosty00",
        "created_at": "2021-04-10T06:44:08Z",
        "body": "you need to update to the latest version of ccxtpro, this error has already been fixed\n\n---\n\nmy current version is `0.6.47`"
      },
      {
        "user": "kroitor",
        "created_at": "2021-04-10T08:26:42Z",
        "body": "@nanaknihal please, let us know if you have the same issue with the most recent version of CCXT + CCXT Pro. Feel free to reopen it or just ask further questions if any."
      },
      {
        "user": "nanaknihal",
        "created_at": "2021-04-10T20:47:50Z",
        "body": "Thanks, it worked after updating"
      },
      {
        "user": "kroitor",
        "created_at": "2021-04-10T20:49:34Z",
        "body": "@nanaknihal thx for reporting back!"
      }
    ],
    "satisfaction_conditions": [
      "Solution resolves Unicode encoding conflict in HMAC authentication for watch_orders()",
      "Compatibility with CoinbasePro's authentication requirements",
      "Validation through updated library version confirmation"
    ]
  },
  {
    "number": 8739,
    "title": "Is it safe to use prices from the orderdepths directly in regard of price precision",
    "created_at": "2021-03-28T20:10:02Z",
    "closed_at": "2021-03-28T20:11:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/8739",
    "body": "OS: Windows Server 2019 Datacenter\r\nProgramming Language version: Node.js 15.3.0\r\nCCXT version: 1.38.89\r\nExchange: All Exchanges\r\nMethod: precision and limits\r\n\r\nHello!\r\n\r\nI have a question about the precision when it comes to prices for a symbol when creating limit and marketorders.\r\n\r\nFor example we can get the orderbook like below:\r\n```\r\n(async () => {\r\nconst exchange = new ccxt.bitfinex({ enableRateLimit: true, agent, 'timeout': 10000 });\r\nconst orderbook = await exchange.fetchOrderBook(\"ETH/BTC\", 5);\r\nconsole.log(orderbook);\r\n})()\r\n```\r\nThis gives a structure like this with price and volume per orderdepth:\r\n```\r\n    [ 0.030365, 7.76077035 ],\r\n    [ 0.030366, 7 ],\r\n    [ 0.030368, 0.069 ],\r\n    [ 0.03037, 1.19718266 ],\r\n    [ 0.030376, 12 ]\r\n```\r\n\r\nMy question is how safe it would be to directly just use the price from any of the orderdepths when `createOrder(...)`\r\nWhat I mean, would it be safe to just take a price without using the `exchange.decimalToPrecision` to round it to correct precision.\r\n\r\nWould it be safe to just take the prices from the orderdepths from all exchanges or should one anyway use `exchange.decimalToPrecision` function for safety?\r\n\r\nThank you!\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/8739/comments",
    "author": "jackpotcityco",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2021-03-28T20:11:39Z",
        "body": "@jackpotcityco Hi! It should be safe to use those prices directly, CCXT will format those values according to exchange precision before sending them out. Let us know if you run into any issues with that."
      },
      {
        "user": "jackpotcityco",
        "created_at": "2021-03-28T20:15:02Z",
        "body": "Hi! Thank you, that is great. Then I will only focus on the precision for the amounts then.\r\n\r\nThank you for the help!"
      }
    ],
    "satisfaction_conditions": [
      "Confirmation that CCXT automatically handles price precision formatting when using orderbook prices for order creation",
      "Clarification about cross-exchange reliability of using raw orderbook prices",
      "Differentiation between price precision handling and amount precision requirements"
    ]
  },
  {
    "number": 8503,
    "title": "Error 'finance' object has no attribute 'amount_to_lots'",
    "created_at": "2021-02-22T19:18:15Z",
    "closed_at": "2021-02-22T19:19:41Z",
    "labels": [
      "duplicate",
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/8503",
    "body": "- OS: running in docker file using image `python:3`\r\n- Programming Language version: running in docker file using image `python:3`\r\n- CCXT version: 1.42.18\r\n\r\n```\r\n def place_order(self, order, ticker):\r\n        try:\r\n            # load order info\r\n            symbol = order.symbol\r\n            bid, ask = ticker['bid'], ticker['ask']\r\n            buy = order.buy  # boolean representing buy/sell\r\n\r\n            exchange = load_exchange(order.exchange)\r\n            if buy:\r\n                if order.exchange == 'binance':\r\n                    price = float(order.buy_max)\r\n                elif order.exchange == 'bittrex':\r\n                    price = exchange.amount_to_precision(ask * 1.05)\r\n                order.amount = self.config.btc / price\r\n            else:  # sell\r\n                price = bid\r\n                revenue = order.amount * price\r\n                revenue -= order.amount * order.bought_at\r\n                logging.info(\"bought at: {0} - sold at {1}\".format(order.bought_at, price))\r\n                logging.info(\"total revenue of order: {0}\".format(revenue))\r\n\r\n            logging.info('amount: {0}'.format(order.amount))\r\n            amount = exchange.amount_to_lots(symbol, order.amount)\r\n            logging.info('amount(lots): {0}'.format(amount))\r\n            self.create_order_on_market(buy, order.exchange, symbol, price, amount)\r\n        except Exception as e:\r\n            logging.error(e)\r\n            self.pushover.send_pushover(\r\n                \"{0} order failed for {1} on {2} with error {3}\".format(\r\n                    'Buy' if buy else 'Sell', order.coin, order.exchange, e\r\n                )\r\n            )\r\n```\r\n```\r\n2021-02-22T19:06:02.159814831Z ERROR:root:'binance' object has no attribute 'amount_to_lots'\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/8503/comments",
    "author": "dantheman0207",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2021-02-22T19:19:40Z",
        "body": "@dantheman0207 change `amount_to_lots` \u2192\u00a0`amount_to_precision` in your code. Let us know if that does not help."
      },
      {
        "user": "dantheman0207",
        "created_at": "2021-02-22T19:26:46Z",
        "body": "Thanks for the quick reply! I assume this happens a lot :)\r\nThat fixed it."
      }
    ],
    "satisfaction_conditions": [
      "Identifies the correct CCXT method for handling order amount precision",
      "Resolves attribute errors specific to exchange implementations in CCXT",
      "Maintains compatibility with multiple cryptocurrency exchanges"
    ]
  },
  {
    "number": 8492,
    "title": "pip install ccxt failed => error: command 'arm-linux-gnueabihf-gcc' failed with exit status 1",
    "created_at": "2021-02-20T21:55:11Z",
    "closed_at": "2021-02-20T22:20:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/8492",
    "body": "I tried to install ccxt on Ubuntu 20.10 (GNU/Linux 5.8.0-1013-raspi armv7l) and go this error:\r\n\r\n```\r\nERROR: Command errored out with exit status 1:\r\n     command: /usr/bin/python3 -c 'import sys, setuptools, tokenize; sys.argv[0] = '\"'\"'/tmp/pip-install-wptrvtsv/pycares/setup.py'\"'\"'; __file__='\"'\"'/tmp/pip-install-wptrvtsv/pycares/setup.py'\"'\"';f=getattr(tokenize, '\"'\"'open'\"'\"', open)(__file__);code=f.read().replace('\"'\"'\\r\\n'\"'\"', '\"'\"'\\n'\"'\"');f.close();exec(compile(code, __file__, '\"'\"'exec'\"'\"'))' egg_info --egg-base /tmp/pip-pip-egg-info-6eg7h048\r\n         cwd: /tmp/pip-install-wptrvtsv/pycares/\r\n    Complete output (73 lines):\r\n      ERROR: Command errored out with exit status 1:\r\n       command: /usr/bin/python3 -u -c 'import sys, setuptools, tokenize; sys.argv[0] = '\"'\"'/tmp/pip-wheel-9vn7c6c_/cffi/setup.py'\"'\"'; __file__='\"'\"'/tmp/pip-wheel-9vn7c6c_/cffi/setup.py'\"'\"';f=getattr(tokenize, '\"'\"'open'\"'\"', open)(__file__);code=f.read().replace('\"'\"'\\r\\n'\"'\"', '\"'\"'\\n'\"'\"');f.close();exec(compile(code, __file__, '\"'\"'exec'\"'\"'))' bdist_wheel -d /tmp/pip-wheel-iv1tnu4e\r\n           cwd: /tmp/pip-wheel-9vn7c6c_/cffi/\r\n      Complete output (36 lines):\r\n      running bdist_wheel\r\n      running build\r\n      running build_py\r\n      creating build\r\n      creating build/lib.linux-armv7l-3.8\r\n      creating build/lib.linux-armv7l-3.8/cffi\r\n      copying cffi/backend_ctypes.py -> build/lib.linux-armv7l-3.8/cffi\r\n      copying cffi/recompiler.py -> build/lib.linux-armv7l-3.8/cffi\r\n      copying cffi/cparser.py -> build/lib.linux-armv7l-3.8/cffi\r\n      copying cffi/ffiplatform.py -> build/lib.linux-armv7l-3.8/cffi\r\n      copying cffi/model.py -> build/lib.linux-armv7l-3.8/cffi\r\n      copying cffi/vengine_gen.py -> build/lib.linux-armv7l-3.8/cffi\r\n      copying cffi/error.py -> build/lib.linux-armv7l-3.8/cffi\r\n      copying cffi/verifier.py -> build/lib.linux-armv7l-3.8/cffi\r\n      copying cffi/lock.py -> build/lib.linux-armv7l-3.8/cffi\r\n      copying cffi/api.py -> build/lib.linux-armv7l-3.8/cffi\r\n      copying cffi/cffi_opcode.py -> build/lib.linux-armv7l-3.8/cffi\r\n      copying cffi/__init__.py -> build/lib.linux-armv7l-3.8/cffi\r\n      copying cffi/setuptools_ext.py -> build/lib.linux-armv7l-3.8/cffi\r\n      copying cffi/vengine_cpy.py -> build/lib.linux-armv7l-3.8/cffi\r\n      copying cffi/commontypes.py -> build/lib.linux-armv7l-3.8/cffi\r\n      copying cffi/pkgconfig.py -> build/lib.linux-armv7l-3.8/cffi\r\n      copying cffi/_cffi_include.h -> build/lib.linux-armv7l-3.8/cffi\r\n      copying cffi/parse_c_type.h -> build/lib.linux-armv7l-3.8/cffi\r\n      copying cffi/_embedding.h -> build/lib.linux-armv7l-3.8/cffi\r\n      copying cffi/_cffi_errors.h -> build/lib.linux-armv7l-3.8/cffi\r\n      running build_ext\r\n      building '_cffi_backend' extension\r\n      creating build/temp.linux-armv7l-3.8\r\n      creating build/temp.linux-armv7l-3.8/c\r\n      arm-linux-gnueabihf-gcc -pthread -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -DUSE__THREAD -DHAVE_SYNC_SYNCHRONIZE -I/usr/include/ffi -I/usr/include/libffi -I/usr/include/python3.8 -c c/_cffi_backend.c -o build/temp.linux-armv7l-3.8/c/_cffi_backend.o\r\n      c/_cffi_backend.c:15:10: fatal error: ffi.h: No such file or directory\r\n         15 | #include <ffi.h>\r\n            |          ^~~~~~~\r\n      compilation terminated.\r\n      error: command 'arm-linux-gnueabihf-gcc' failed with exit status 1\r\n      ----------------------------------------\r\n      ERROR: Failed building wheel for cffi\r\n    ERROR: Failed to build one or more wheels\r\n    Traceback (most recent call last):\r\n      File \"/usr/lib/python3/dist-packages/setuptools/installer.py\", line 128, in fetch_build_egg\r\n        subprocess.check_call(cmd)\r\n      File \"/usr/lib/python3.8/subprocess.py\", line 364, in check_call\r\n        raise CalledProcessError(retcode, cmd)\r\n    subprocess.CalledProcessError: Command '['/usr/bin/python3', '-m', 'pip', '--disable-pip-version-check', 'wheel', '--no-deps', '-w', '/tmp/tmpja9grf0o', '--quiet', 'cffi>=1.5.0']' returned non-zero exit status 1.\r\n    \r\n    The above exception was the direct cause of the following exception:\r\n    \r\n    Traceback (most recent call last):\r\n      File \"<string>\", line 1, in <module>\r\n      File \"/tmp/pip-install-wptrvtsv/pycares/setup.py\", line 15, in <module>\r\n        setup(name             = 'pycares',\r\n      File \"/usr/lib/python3/dist-packages/setuptools/__init__.py\", line 162, in setup\r\n        _install_setup_requires(attrs)\r\n      File \"/usr/lib/python3/dist-packages/setuptools/__init__.py\", line 157, in _install_setup_requires\r\n        dist.fetch_build_eggs(dist.setup_requires)\r\n      File \"/usr/lib/python3/dist-packages/setuptools/dist.py\", line 699, in fetch_build_eggs\r\n        resolved_dists = pkg_resources.working_set.resolve(\r\n      File \"/usr/lib/python3/dist-packages/pkg_resources/__init__.py\", line 779, in resolve\r\n        dist = best[req.key] = env.best_match(\r\n      File \"/usr/lib/python3/dist-packages/pkg_resources/__init__.py\", line 1064, in best_match\r\n        return self.obtain(req, installer)\r\n      File \"/usr/lib/python3/dist-packages/pkg_resources/__init__.py\", line 1076, in obtain\r\n        return installer(requirement)\r\n      File \"/usr/lib/python3/dist-packages/setuptools/dist.py\", line 758, in fetch_build_egg\r\n        return fetch_build_egg(self, req)\r\n      File \"/usr/lib/python3/dist-packages/setuptools/installer.py\", line 130, in fetch_build_egg\r\n        raise DistutilsError(str(e)) from e\r\n    distutils.errors.DistutilsError: Command '['/usr/bin/python3', '-m', 'pip', '--disable-pip-version-check', 'wheel', '--no-deps', '-w', '/tmp/tmpja9grf0o', '--quiet', 'cffi>=1.5.0']' returned non-zero exit status 1.\r\n    ----------------------------------------\r\nERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output.\r\n```",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/8492/comments",
    "author": "theMoe",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2021-02-20T21:58:45Z",
        "body": "Try `apt install libffi-dev` or `sudo apt install libffi-dev` and then retry to install ccxt."
      }
    ],
    "satisfaction_conditions": [
      "Resolve missing ffi.h header file dependency",
      "Identify system package dependencies for Python cryptography modules",
      "Provide working Python package installation path"
    ]
  },
  {
    "number": 8467,
    "title": "When does actually the watch_ticker function refresh?",
    "created_at": "2021-02-16T14:39:42Z",
    "closed_at": "2021-02-16T14:44:43Z",
    "labels": [
      "question",
      "ws"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/8467",
    "body": "Dear contributor,\r\n\r\nI have gone through the ccxt documentation and the answer to the following question is not clear to me. When the following code line (python) is executed:\r\norder_book = await exchange.watch_order_book(symbol)\r\nevery time the order book for that symbol is updated the function will return the whole new order book. However, if we type the following code line:\r\nticker = await exchange.watch_ticker(symbol)\r\nWhat does actually need to change in the market data so that something is returned in that function?\r\n\r\nThank you very much in advance,\r\n\r\nUnai\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/8467/comments",
    "author": "unaiasegi",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2021-02-16T14:44:43Z",
        "body": "Hi!\r\n\r\nIn general, WS is more about real-time. \r\nYou have two types of data:\r\n\r\n1. real-time fills + real-time orderbooks \u2013\u00a0this is the first-order data that is used to calculate everything else\r\n2. second-order data (tickers and ohlcvs) that is calculated from first-order data\r\n\r\nChanges on first-order data (1) are delivered as soon as the exchange can.\r\n\r\nIt takes time for the exchange to calculate the statistical second-order data, but you can also calculate it on your own (you don't have to wait for the exchange to do it for you). \r\n\r\nHow frequently to deliver the changes on second-order data (2) \u2013 depends on the exchange. Some exchanges will update you in regular intervals (like once or a few times every second), others will update the ticker more frequently. Some exchanges will send you delayed second-order data since it is not considered _\"important\"_ for a real-time trading operation.\r\n\r\nYou should not rely on the speed of tickers or OHLCVs if you wish to stay as close to real-time as possible.\r\n\r\nLet us know if that does not answer your question."
      },
      {
        "user": "unaiasegi",
        "created_at": "2021-02-16T15:04:35Z",
        "body": "It does, thank you very much.\r\n\r\nUnai"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of what market data changes trigger watch_ticker updates",
      "Clarification of how ticker data differs from order book updates in terms of update frequency",
      "Description of exchange-specific variability in ticker update policies",
      "Explanation of ticker data as calculated statistics rather than raw market events"
    ]
  },
  {
    "number": 8379,
    "title": "Issue with timestamp parse of data feed needs help",
    "created_at": "2021-02-02T05:15:59Z",
    "closed_at": "2021-02-02T07:42:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/8379",
    "body": "Hi,\r\nI have some problems to read the timestamp from the datafeed download from CCXT. No matter what I tried, it can't parse the datetime info.\r\n\r\nPandas code:\r\n\r\n> dataframe = pandas.read_csv(\r\n        datapath,\r\n        skiprows=1,\r\n        header=1,\r\n        date_parser=parsedate,\r\n        parse_dates=True,\r\n        index_col=0,\r\n    )\r\n\r\n\r\n\r\ndata feed format:\r\n>  Timestamp,Open,High,Low,Close,Volume\r\n    1611658800000,32247.2,32249.98,32105.36,32139.29,616.047753\r\n    1611659700000,32139.29,32186.61,31807.19,31968.65,804.456726\r\n    1611660600000,31968.65,32048.88,31733.0,32040.8,680.101376\r\n  \r\nFirstly, pandas default date parser couldn't process it and returned error\r\n```\r\n  dt = tstamp.to_pydatetime()\r\nAttributeError: 'numpy.int64' object has no attribute 'to_pydatetime'\r\n```\r\n\r\nSecondly I defined a parser function but returned error :\r\n```\r\nValueError: year 53041 is out of range\r\n```\r\n\r\n parser function:\r\n\r\n>  def parsedate(timestamp):\r\n    if type(timestamp) is str: timestamp = int(timestamp)  # put up with timestamp being in string format\r\n    if timestamp > 1e10: timestamp // 1000 # put up with timestamp being in microseconds\r\n    return datetime.utcfromtimestamp(float(timestamp)).replace(tzinfo=tz.tzutc())\r\n\r\n\r\n- OS: Mac\r\n- Programming Language version: python3\r\n- CCXT version: newest\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/8379/comments",
    "author": "lifengmds",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2021-02-02T07:42:28Z",
        "body": "Hi!\r\n\r\nChange your date-parsing to convert milliseconds to datetime:\r\n\r\n```Python\r\ndef parsedate(timestamp):\r\n    return datetime.utcfromtimestamp(timestamp / 1000)\r\n```\r\n\r\nLet us know if that does not help."
      },
      {
        "user": "lifengmds",
        "created_at": "2021-02-03T02:29:17Z",
        "body": "It worked well! thanks!"
      }
    ],
    "satisfaction_conditions": [
      "Correctly converts millisecond-based timestamps to datetime objects",
      "Works with pandas' date parsing requirements for DataFrame indexing"
    ]
  },
  {
    "number": 8374,
    "title": "'ccxt' has no attribute ...",
    "created_at": "2021-01-31T14:47:44Z",
    "closed_at": "2021-01-31T14:58:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/8374",
    "body": "Something wrong, just installed ccxt and tried demo code to print ccxt.version or ccxt.exchanges, but doesn't work\r\n\r\n- OS:\r\n- Programming Language version: python 3.9.1\r\n- CCXT version: ccxt-1.41.31\r\n\r\n```\r\nimport ccxt\r\nprint(ccxt.exchanges) # print a list of all available exchange classes\r\n```\r\n\r\n```\r\nAttributeError: partially initialized module 'ccxt' has no attribute 'version' (most likely due to a circular import)\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/8374/comments",
    "author": "lifengmds",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2021-01-31T14:49:11Z",
        "body": "@lifengmds do you have a filename `ccxt.py` in your project/folder? (that will cause conflicts like the above)"
      },
      {
        "user": "lifengmds",
        "created_at": "2021-01-31T15:06:12Z",
        "body": "> @lifengmds do you have a filename `ccxt.py` in your project/folder? (that will cause conflicts like the above)\r\n\r\noh, yes! that's why!!\n\n---\n\n> > @lifengmds do you have a filename `ccxt.py` in your project/folder? (that will cause conflicts like the above)\r\n> \r\n> oh, yes! that's why!!\r\n\r\nI should laugh at myself...\r\n\n\n---\n\n> @lifengmds do you have a filename `ccxt.py` in your project/folder? (that will cause conflicts like the above)\r\n\r\nI rename the file , and it's still the same error"
      },
      {
        "user": "kroitor",
        "created_at": "2021-01-31T15:06:52Z",
        "body": "@lifengmds how do you install it?"
      },
      {
        "user": "lifengmds",
        "created_at": "2021-01-31T15:08:04Z",
        "body": "> @lifengmds how do you install it?\r\n\r\npip3 install ccxt\r\n\r\nRequirement already satisfied: ccxt in /Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages (1.41.31)\r\nRequirement already satisfied: setuptools>=38.5.1 in /Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages (from ccxt) (49.2.1)\r\nRequirement already satisfied: yarl==1.1.0 in /Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages (from ccxt) (1.1.0)\r\nRequirement already satisfied: requests>=2.18.4 in /Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages (from ccxt) (2.25.1)\r\nRequirement already satisfied: certifi>=2018.1.18 in /Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages (from ccxt) (2020.12.5)\r\nRequirement already satisfied: aiodns<2.1,>=1.1.1 in /Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages (from ccxt) (2.0.0)\r\nRequirement already satisfied: cryptography>=2.6.1 in /Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages (from ccxt) (3.3.1)\r\nRequirement already satisfied: aiohttp<3.8,>=3.7.2 in /Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages (from ccxt) (3.7.3)\r\nRequirement already satisfied: multidict>=4.0 in /Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages (from yarl==1.1.0->ccxt) (5.1.0)\r\nRequirement already satisfied: idna>=2.0 in /Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages (from yarl==1.1.0->ccxt) (2.10)\r\nRequirement already satisfied: pycares>=3.0.0 in /Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages (from aiodns<2.1,>=1.1.1->ccxt) (3.1.1)\r\nRequirement already satisfied: async-timeout<4.0,>=3.0 in /Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages (from aiohttp<3.8,>=3.7.2->ccxt) (3.0.1)\r\nRequirement already satisfied: typing-extensions>=3.6.5 in /Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages (from aiohttp<3.8,>=3.7.2->ccxt) (3.7.4.3)\r\nRequirement already satisfied: chardet<4.0,>=2.0 in /Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages (from aiohttp<3.8,>=3.7.2->ccxt) (3.0.4)\r\nRequirement already satisfied: attrs>=17.3.0 in /Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages (from aiohttp<3.8,>=3.7.2->ccxt) (20.3.0)\r\nRequirement already satisfied: cffi>=1.12 in /Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages (from cryptography>=2.6.1->ccxt) (1.14.4)\r\nRequirement already satisfied: six>=1.4.1 in /Users/fng/Library/Python/3.9/lib/python/site-packages (from cryptography>=2.6.1->ccxt) (1.15.0)\r\nRequirement already satisfied: pycparser in /Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages (from cffi>=1.12->cryptography>=2.6.1->ccxt) (2.20)\r\nRequirement already satisfied: urllib3<1.27,>=1.21.1 in /Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages (from requests>=2.18.4->ccxt) (1.26.2)"
      },
      {
        "user": "kroitor",
        "created_at": "2021-01-31T15:12:03Z",
        "body": "@lifengmds what's the command you use to test it? What do you see if you run `ls -alh` in the same working directory?\n\n---\n\n@lifengmds try this short snippet (run `python3` and copypaste the snippet below):\r\n\r\n```Python\r\nimport ccxt\r\nprint('CCXT Version:', ccxt.__version__)\r\n```"
      },
      {
        "user": "lifengmds",
        "created_at": "2021-01-31T15:21:49Z",
        "body": "> @lifengmds try this short snippet (run `python3` and copypaste the snippet below):\r\n> \r\n> ```python\r\n> import ccxt\r\n> print('CCXT Version:', ccxt.__version__)\r\n> ```\r\n\r\nyes, this works"
      },
      {
        "user": "kroitor",
        "created_at": "2021-01-31T15:22:22Z",
        "body": "@lifengmds this should work as well as the rest of it:\r\n\r\n```Python\r\nimport ccxt\r\nprint(ccxt.exchanges)\r\n```"
      },
      {
        "user": "lifengmds",
        "created_at": "2021-01-31T15:36:38Z",
        "body": "> @lifengmds this should work as well as the rest of it:\r\n> \r\n> ```python\r\n> import ccxt\r\n> print(ccxt.exchanges)\r\n> ```\r\n\r\nThank you for your help!"
      }
    ],
    "satisfaction_conditions": [
      "Identify and resolve file naming conflicts with the ccxt module",
      "Ensure Python imports the installed ccxt module instead of local files",
      "Verify correct installation and accessibility of ccxt module attributes",
      "Address circular import issues caused by module naming conflicts"
    ]
  },
  {
    "number": 8366,
    "title": "Missing symbols on Binance",
    "created_at": "2021-01-29T17:10:43Z",
    "closed_at": "2021-01-29T17:38:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/8366",
    "body": "Hi there,\r\nthere seems to be missing symbols on Binance, specifically running `[s for s in exchange.symbols if 'BTC' in s]` in python returns only `['BTC/BUSD', 'BTC/USDT']`. The same holds for `[s for s in exchange.markets.keys() if 'BTC' in s]`. Other exchanges seem to be ok.\r\n\r\nccxt version: 1.41.19\r\npython: 3.8.7\r\nos: win 10",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/8366/comments",
    "author": "LukasUlrych",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2021-01-29T17:19:25Z",
        "body": "@LukasUlrych hi! Which specific market/symbol is missing?"
      },
      {
        "user": "LukasUlrych",
        "created_at": "2021-01-29T17:28:52Z",
        "body": "Well, `ADA/BTC`, `ETH/BTC`, `LTC/BTC` etc., pretty much any altcoin vs. BTC. I can see only USDT or BUSD pairs.\n\n---\n\n@kroitor I am not sure whether this is only local issue or not. I tried going back to version 1.41.10 and the symbols are all there. I noticed this after update today."
      },
      {
        "user": "kroitor",
        "created_at": "2021-01-29T17:31:09Z",
        "body": "@LukasUlrych always use the most recent version and make sure it's the most recent number by printing it in runtime (don't trust the pip output). Let me know if this does not help:\r\n\r\n```Python\r\nimport ccxt\r\nfrom pprint import pprint\r\nprint('CCXT Version:', ccxt.__version__)\r\nexchange = ccxt.binance({\r\n    'enableRateLimit': True,\r\n    'options': {'defaultType':'spot'},  # spot is the default\r\n})\r\nmarkets = exchange.load_markets()\r\npprint(exchange.symbols)\r\n```\r\n\r\n```Python\r\nimport ccxt\r\nfrom pprint import pprint\r\nprint('CCXT Version:', ccxt.__version__)\r\nexchange = ccxt.binance({\r\n    'enableRateLimit': True,\r\n    'options': {'defaultType':'future'},\r\n})\r\nmarkets = exchange.load_markets()\r\npprint(exchange.symbols)\r\n```\r\n\r\n```Python\r\nimport ccxt\r\nfrom pprint import pprint\r\nprint('CCXT Version:', ccxt.__version__)\r\nexchange = ccxt.binance({\r\n    'enableRateLimit': True,\r\n    'options': {'defaultType':'delivery'},\r\n})\r\nmarkets = exchange.load_markets()\r\npprint(exchange.symbols)\r\n```\r\n\r\n"
      },
      {
        "user": "LukasUlrych",
        "created_at": "2021-01-29T17:37:05Z",
        "body": "@kroitor Thank you, it helped! The issue seems to be that running just \r\n```\r\nexchange = ccxt.binance({\r\n    'enableRateLimit': True\r\n})\r\n```\r\ndefaults to defaultType = 'future' not defaultType = 'spot'."
      },
      {
        "user": "kroitor",
        "created_at": "2021-01-29T17:37:59Z",
        "body": "@LukasUlrych ah, i see, hold on, will fix that in 1.41.20."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how Binance market type configuration affects symbol availability",
      "Clarification of CCXT's default exchange configuration behavior",
      "Guidance on troubleshooting missing symbols across CCXT versions"
    ]
  },
  {
    "number": 8339,
    "title": "Inconsistent symbol names for Binance Futures",
    "created_at": "2021-01-24T17:00:22Z",
    "closed_at": "2021-01-25T20:58:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/8339",
    "body": "\r\n- OS: Linux\r\n- Programming Language version: Python 3.8.6 and Python 3.8.5\r\n- CCXT version: 1.40.83\r\n- \r\nCode:\r\n```\r\nexchange.load_markets()\r\nsymbols = exchange.symbols\r\nprint(symbols)\r\n```\r\nIn my workstation it gives: \r\n```\r\n['1INCHUSDT', 'AAVEUSDT', 'ADAUSDT', 'AKROUSDT', 'ALGOUSDT', 'ALPHAUSDT', 'ATOMUSDT', 'AVAXUSDT', 'AXSUSDT', 'BALUSDT', 'BANDUSDT', 'BATUSDT', 'BCHUSDT', 'BELUSDT', 'BLZUSDT', 'BNBUSDT', 'BTCBUSD', 'BTCUSDT', 'BZRXUSDT', 'CHZUSDT', 'COMPUSDT', 'CRVUSDT', 'CTKUSDT', 'CVCUSDT', 'DASHUSDT', 'DEFIUSDT', 'DOGEUSDT', 'DOTECOUSDT', 'DOTUSDT', 'EGLDUSDT', 'ENJUSDT', 'EOSUSDT', 'ETCUSDT', 'ETHUSDT', 'FILUSDT', 'FLMUSDT', 'FTMUSDT', 'GRTUSDT', 'HNTUSDT', 'ICXUSDT', 'IOSTUSDT', 'IOTAUSDT', 'KAVAUSDT', 'KNCUSDT', 'KSMUSDT', 'LINKUSDT', 'LRCUSDT', 'LTCUSDT', 'MATICUSDT', 'MKRUSDT', 'NEARUSDT', 'NEOUSDT', 'OCEANUSDT', 'OMGUSDT', 'ONTUSDT', 'QTUMUSDT', 'RENUSDT', 'RLCUSDT', 'RSRUSDT', 'RUNEUSDT', 'SKLUSDT', 'SNXUSDT', 'SOLUSDT', 'SRMUSDT', 'STORJUSDT', 'SUSHIUSDT', 'SXPUSDT', 'THETAUSDT', 'TOMOUSDT', 'TRBUSDT', 'TRXUSDT', 'UNIUSDT', 'VETUSDT', 'WAVESUSDT', 'XLMUSDT', 'XMRUSDT', 'XRPUSDT', 'XTZUSDT', 'YFIIUSDT', 'YFIUSDT', 'ZECUSDT', 'ZENUSDT', 'ZILUSDT', 'ZRXUSDT']\r\n\r\n```\r\nBut in the server (with same ccxt version but python 3.8.5) it gives:\r\n\r\n```\r\n['1INCH/USDT', 'AAVE/USDT', 'ADA/USDT', 'AKRO/USDT', 'ALGO/USDT', 'ALPHA/USDT', 'ATOM/USDT', 'AVAX/USDT', 'AXS/USDT', 'BAL/USDT', 'BAND/USDT', 'BAT/USDT', 'BCH/USDT', 'BEL/USDT', 'BLZ/USDT', 'BNB/USDT', 'BTC/BUSD', 'BTC/USDT', 'BZRX/USDT', 'CHZ/USDT', 'COMP/USDT', 'CRV/USDT', 'CTK/USDT', 'CVC/USDT', 'DASH/USDT', 'DEFI/USDT', 'DOGE/USDT', 'DOT/USDT', 'DOTECO/USDT', 'EGLD/USDT', 'ENJ/USDT', 'EOS/USDT', 'ETC/USDT', 'ETH/USDT', 'FIL/USDT', 'FLM/USDT', 'FTM/USDT', 'GRT/USDT', 'HNT/USDT', 'ICX/USDT', 'IOST/USDT', 'IOTA/USDT', 'KAVA/USDT', 'KNC/USDT', 'KSM/USDT', 'LINK/USDT', 'LRC/USDT', 'LTC/USDT', 'MATIC/USDT', 'MKR/USDT', 'NEAR/USDT', 'NEO/USDT', 'OCEAN/USDT', 'OMG/USDT', 'ONT/USDT', 'QTUM/USDT', 'REN/USDT', 'RLC/USDT', 'RSR/USDT', 'RUNE/USDT', 'SKL/USDT', 'SNX/USDT', 'SOL/USDT', 'SRM/USDT', 'STORJ/USDT', 'SUSHI/USDT', 'SXP/USDT', 'THETA/USDT', 'TOMO/USDT', 'TRB/USDT', 'TRX/USDT', 'UNI/USDT', 'VET/USDT', 'WAVES/USDT', 'XLM/USDT', 'XMR/USDT', 'XRP/USDT', 'XTZ/USDT', 'YFI/USDT', 'YFII/USDT', 'ZEC/USDT', 'ZEN/USDT', 'ZIL/USDT', 'ZRX/USDT']\r\n\r\n```\r\nThis is currently breaking my deployment, any idea how to fix?\r\n\r\nEdit:\r\n\r\nAlso on one place it's saying symbol is BTC/USDT and on another place it's saying the symbol is BTCUSDT:\r\n\r\n```\r\n'id': 'BTCUSDT',\r\n\t\t'lowercaseId': 'btcusdt',\r\n\t\t'symbol': 'BTC/USDT',\r\n\t\t'base': 'BTC',\r\n\t\t'quote': 'USDT',\r\n\t\t'baseId': 'BTC',\r\n\t\t'quoteId': 'USDT',\r\n\t\t'info': {\r\n\t\t\t'symbol': 'BTCUSDT',\r\n...\r\n\r\n```",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/8339/comments",
    "author": "projenix",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2021-01-24T18:19:21Z",
        "body": "Hi!\r\n\r\n> This is currently breaking my deployment, any idea how to fix?\r\n\r\nRun this on both of your machines and paste your runtime versions here please:\r\n\r\n```Python\r\nimport ccxt\r\nprint('CCXT Version:', ccxt.__version__)\r\n```\r\n\r\n"
      },
      {
        "user": "projenix",
        "created_at": "2021-01-25T20:22:58Z",
        "body": "Hey your intuition was correct!\r\n\r\nOn the workstation I've got version: 1.35.72\r\n\r\nWhereas on the server I've got version: 1.40.83\r\n\r\nSo I assume there was a change in symbol notation in CCXT, right? so is that change stable now, should I upgrade and stick to \"AAA/BBB\" notation from now on in all code?\r\n\r\nThanks a lot for your help,"
      },
      {
        "user": "kroitor",
        "created_at": "2021-01-25T20:58:26Z",
        "body": "@projenix \r\n\r\n> So I assume there was a change in symbol notation in CCXT, right? \r\n\r\nYes, Binance has updated their API recently.\r\n\r\n> so is that change stable now, should I upgrade and stick to \"AAA/BBB\" notation from now on in all code?\r\n\r\nThe unification of futures is a work in progress, so it may be subject to change, but we will of course do our best to avoid breaking changes, or will announce them beforehand.\r\n\r\nLet us know if that does not answer your question. Feel free to reopen it if needed or just ask further questions if any."
      },
      {
        "user": "projenix",
        "created_at": "2021-01-26T11:19:05Z",
        "body": "@kroitor That does answer my question, thank you very much for your help."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why symbol formats differ between CCXT versions",
      "Clarification about future stability of symbol notation formats"
    ]
  },
  {
    "number": 8310,
    "title": "Precision in markets where the buy order is given in quote currency",
    "created_at": "2021-01-19T13:50:26Z",
    "closed_at": "2021-01-19T13:54:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/8310",
    "body": "Hello,\r\n\r\nI have a question regarding the market precision dictionary in exchanges where the buy order amount must be provided in quote currency. \r\n\r\nEven if the buy amount must be provided in quote currency, the precision dictionary of these markets does not include the 'cost' key, which is basically the amount in quote currency. They only provide the 'amount' (the amount in base currency) and 'price' keys. Therefore, I do not understand which one should I pick (or transform) to check the precision of the market in quote currency.\r\n\r\nThis problem does not exist in exchanges where every (buy and sell) amount must be provided in base currency as the precision dictionary does include the 'amount' key which is expressed in base currency.\r\n\r\nThank you very much in advance,\r\n\r\nUnai\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/8310/comments",
    "author": "unaiasegi",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2021-01-19T13:54:13Z",
        "body": "Hi!\r\n\r\n> which one should I pick (or transform) to check the precision of the market in quote currency.\r\n\r\nBoth the price and the cost are usually expressed in the same currency, and have the same precision, so you can use the price precision to format your cost.\r\n\r\nLet us know if that does not answer your question."
      }
    ],
    "satisfaction_conditions": [
      "Clarification of which precision key ('amount' or 'price') applies to quote currency amounts when 'cost' is unavailable",
      "Explanation of the relationship between price precision and cost precision in quote-based markets",
      "Guidance on handling precision conversions between base/quote currencies in markets with different order requirements"
    ]
  },
  {
    "number": 8204,
    "title": "[kraken] trade cost isn't quiet correct",
    "created_at": "2021-01-03T18:58:05Z",
    "closed_at": "2021-01-03T19:37:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/8204",
    "body": "The following trade took my EUR balance from exactly zero to 68.26 EUR (not 68.42...).  I think the cost needs to have the fee removed (68.42692 - 0.16422 = 68.2627)\r\n\r\n```\r\n{\r\n  \"id\": \"TPPRE4-FQNIZ-2PXN7U\",\r\n  \"fee\": {\r\n    \"cost\": 0.16422,\r\n    \"currency\": \"EUR\"\r\n  },\r\n  \"cost\": 68.42692,\r\n  \"info\": {\r\n    \"id\": \"TPPRE4-FQNIZ-2PXN7U\",\r\n    \"fee\": \"0.16422\",\r\n    \"vol\": \"0.40000000\",\r\n    \"cost\": \"68.42692\",\r\n    \"misc\": \"\",\r\n    \"pair\": \"XETHZEUR\",\r\n    \"time\": 1501407063.1763,\r\n    \"type\": \"sell\",\r\n    \"price\": \"171.06730\",\r\n    \"margin\": \"0.00000\",\r\n    \"ordertxid\": \"OIZZ6C-H4QEZ-P5B7Z5\",\r\n    \"ordertype\": \"limit\"\r\n  },\r\n  \"side\": \"sell\",\r\n  \"type\": \"limit\",\r\n  \"order\": \"OIZZ6C-H4QEZ-P5B7Z5\",\r\n  \"price\": 171.0673,\r\n  \"amount\": 0.4,\r\n  \"symbol\": \"ETH/EUR\",\r\n  \"_source\": \"rest api\",\r\n  \"datetime\": \"2017-07-30T09:31:03.176Z\",\r\n  \"timestamp\": 1501407063176\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/8204/comments",
    "author": "npomfret",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2021-01-03T19:00:50Z",
        "body": "@npomfret the cost of the trade is always price * amount = 171.0673 * 0.4 = 68.42692. The fee is applied on top of that, afterwards. That looks consistent with the exchange output and the ccxt output, no?"
      },
      {
        "user": "npomfret",
        "created_at": "2021-01-03T19:28:44Z",
        "body": "Is it possible to price they give is net of fees?  \r\n\r\nEvery other exchange I've tested results in balance changes that are equal to the amount or the cost.  But not kraken."
      },
      {
        "user": "kroitor",
        "created_at": "2021-01-03T19:31:46Z",
        "body": "> Is it possible to price they give is net of fees?\r\n\r\nI don't think so.\r\n\r\n> Every other exchange I've tested results in balance changes that are equal to the amount or the cost. But not kraken.\r\n\r\nYou've got +68.42692 EUR (cost) - 0.16422 EUR (fee, applied afterwards) = 68.2627 to your account balance and that is consistent across ccxt and other exchanges, no?"
      },
      {
        "user": "npomfret",
        "created_at": "2021-01-03T19:37:03Z",
        "body": "ok, perhaps it's just a rounding issue.  Thanks for the input."
      },
      {
        "user": "kroitor",
        "created_at": "2021-01-03T19:38:32Z",
        "body": "@npomfret kraken will hide the lower decimals for EUR, but will store them in their internal db. So you might have +.0027 there, invisible, but summable with other dust."
      },
      {
        "user": "npomfret",
        "created_at": "2021-01-03T20:24:06Z",
        "body": "I've looked at some other examples and it seems that my balance is changing by the cost (not the cost + fee).  For example, this trade resulted in the balance changing from 69.94990000 to 0.69950000, a change of -69.2504.\r\n\r\n```\r\n{\r\n  \"id\": \"TBWKJZ-4TFJ5-Q67WZH\",\r\n  \"fee\": {\r\n    \"cost\": 0.1108,\r\n    \"currency\": \"EUR\"\r\n  },\r\n  \"cost\": 69.25036115,\r\n  \"info\": {\r\n    \"id\": \"TBWKJZ-4TFJ5-Q67WZH\",\r\n    \"fee\": \"0.11080\",\r\n    \"vol\": \"0.00841745\",\r\n    \"cost\": \"69.25036\",\r\n    \"misc\": \"\",\r\n    \"pair\": \"XXBTZEUR\",\r\n    \"time\": 1595601094.6442,\r\n    \"type\": \"buy\",\r\n    \"price\": \"8227.00000\",\r\n    \"margin\": \"0.00000\",\r\n    \"postxid\": \"TKH2SE-M7IF5-CFI7LT\",\r\n    \"ordertxid\": \"OD7XVS-ABA3I-2JULOT\",\r\n    \"ordertype\": \"limit\"\r\n  },\r\n  \"side\": \"buy\",\r\n  \"type\": \"limit\",\r\n  \"order\": \"OD7XVS-ABA3I-2JULOT\",\r\n  \"price\": 8227,\r\n  \"amount\": 0.00841745,\r\n  \"symbol\": \"BTC/EUR\",\r\n  \"_source\": \"rest api\",\r\n  \"datetime\": \"2020-07-24T14:31:34.644Z\",\r\n  \"timestamp\": 1595601094644\r\n}\r\n```\r\n\r\nthe balance change here was 1316.5597:\r\n\r\n```\r\n{\r\n  \"id\": \"T3VY4D-7NL7M-JAEQNW\",\r\n  \"fee\": {\r\n    \"cost\": 2.1065,\r\n    \"currency\": \"EUR\"\r\n  },\r\n  \"cost\": 1316.5596752000001,\r\n  \"info\": {\r\n    \"id\": \"T3VY4D-7NL7M-JAEQNW\",\r\n    \"fee\": \"2.10650\",\r\n    \"vol\": \"0.16018100\",\r\n    \"cost\": \"1316.55968\",\r\n    \"misc\": \"\",\r\n    \"pair\": \"XXBTZEUR\",\r\n    \"time\": 1595602217.2371,\r\n    \"type\": \"sell\",\r\n    \"price\": \"8219.20000\",\r\n    \"margin\": \"0.00000\",\r\n    \"postxid\": \"TKH2SE-M7IF5-CFI7LT\",\r\n    \"ordertxid\": \"OYY5YW-NSRYB-VVA2LI\",\r\n    \"ordertype\": \"limit\"\r\n  },\r\n  \"side\": \"sell\",\r\n  \"type\": \"limit\",\r\n  \"order\": \"OYY5YW-NSRYB-VVA2LI\",\r\n  \"price\": 8219.2,\r\n  \"amount\": 0.160181,\r\n  \"symbol\": \"BTC/EUR\",\r\n  \"_source\": \"rest api\",\r\n  \"datetime\": \"2020-07-24T14:50:17.237Z\",\r\n  \"timestamp\": 1595602217237\r\n}\r\n```"
      },
      {
        "user": "kroitor",
        "created_at": "2021-01-03T20:38:40Z",
        "body": "@npomfret that's confusing, indeed. What does `fetchLedger` tell about the same period?"
      },
      {
        "user": "npomfret",
        "created_at": "2021-01-04T21:46:47Z",
        "body": "from the 1st example above (with a balance change of 68.26EUR), there are 2 entries in the ledger:\r\n\r\n```\r\n  {\r\n    \"info\": {\r\n      \"refid\": \"TPPRE4-FQNIZ-2PXN7U\",\r\n      \"time\": 1501407063.1835,\r\n      \"type\": \"trade\",\r\n      \"subtype\": \"\",\r\n      \"aclass\": \"currency\",\r\n      \"asset\": \"XETH\",\r\n      \"amount\": \"-0.4000000000\",\r\n      \"fee\": \"0.0000000000\",\r\n      \"balance\": \"4.2110080200\",\r\n      \"id\": \"LEMB44-P6I2D-AQLWZ5\"\r\n    },\r\n    \"id\": \"LEMB44-P6I2D-AQLWZ5\",\r\n    \"direction\": \"out\",\r\n    \"referenceId\": \"TPPRE4-FQNIZ-2PXN7U\",\r\n    \"type\": \"trade\",\r\n    \"currency\": \"ETH\",\r\n    \"amount\": 0.4,\r\n    \"after\": 4.21100802,\r\n    \"status\": \"ok\",\r\n    \"timestamp\": 1501407063183,\r\n    \"datetime\": \"2017-07-30T09:31:03.183Z\",\r\n    \"fee\": {\r\n      \"cost\": 0,\r\n      \"currency\": \"ETH\"\r\n    },\r\n    \"_source\": \"rest api\"\r\n  },\r\n  {\r\n    \"info\": {\r\n      \"refid\": \"TPPRE4-FQNIZ-2PXN7U\",\r\n      \"time\": 1501407063.1846,\r\n      \"type\": \"trade\",\r\n      \"subtype\": \"\",\r\n      \"aclass\": \"currency\",\r\n      \"asset\": \"ZEUR\",\r\n      \"amount\": \"68.4269\",\r\n      \"fee\": \"0.1642\",\r\n      \"balance\": \"68.2627\",\r\n      \"id\": \"LVGTYH-WSCAN-COQGQL\"\r\n    },\r\n    \"id\": \"LVGTYH-WSCAN-COQGQL\",\r\n    \"direction\": \"in\",\r\n    \"referenceId\": \"TPPRE4-FQNIZ-2PXN7U\",\r\n    \"type\": \"trade\",\r\n    \"currency\": \"EUR\",\r\n    \"amount\": 68.4269,\r\n    \"after\": 68.2627,\r\n    \"status\": \"ok\",\r\n    \"timestamp\": 1501407063184,\r\n    \"datetime\": \"2017-07-30T09:31:03.184Z\",\r\n    \"fee\": {\r\n      \"cost\": 0.1642,\r\n      \"currency\": \"EUR\"\r\n    },\r\n    \"_source\": \"rest api\"\r\n  },\r\n```\r\n\r\nthe last example (with a balance change of 1316.5597 EUR) has 3 entries:\r\n\r\n```\r\n  {\r\n    \"info\": {\r\n      \"refid\": \"T3VY4D-7NL7M-JAEQNW\",\r\n      \"time\": 1595602217.2518,\r\n      \"type\": \"trade\",\r\n      \"subtype\": \"\",\r\n      \"aclass\": \"currency\",\r\n      \"asset\": \"XXBT\",\r\n      \"amount\": \"-0.1601810000\",\r\n      \"fee\": \"0.0000000000\",\r\n      \"balance\": \"0.2677575450\",\r\n      \"id\": \"LT2PKW-HOQ62-F34OQJ\"\r\n    },\r\n    \"id\": \"LT2PKW-HOQ62-F34OQJ\",\r\n    \"direction\": \"out\",\r\n    \"referenceId\": \"T3VY4D-7NL7M-JAEQNW\",\r\n    \"type\": \"trade\",\r\n    \"currency\": \"BTC\",\r\n    \"amount\": 0.160181,\r\n    \"after\": 0.267757545,\r\n    \"status\": \"ok\",\r\n    \"timestamp\": 1595602217251,\r\n    \"datetime\": \"2020-07-24T14:50:17.251Z\",\r\n    \"fee\": {\r\n      \"cost\": 0,\r\n      \"currency\": \"BTC\"\r\n    },\r\n    \"_source\": \"rest api\"\r\n  },\r\n  {\r\n    \"info\": {\r\n      \"refid\": \"T3VY4D-7NL7M-JAEQNW\",\r\n      \"time\": 1595602217.2546,\r\n      \"type\": \"trade\",\r\n      \"subtype\": \"\",\r\n      \"aclass\": \"currency\",\r\n      \"asset\": \"KFEE\",\r\n      \"amount\": \"0.00\",\r\n      \"fee\": \"225.40\",\r\n      \"balance\": \"2926.75\",\r\n      \"id\": \"LXFCDW-HA3FZ-65XQBV\"\r\n    },\r\n    \"id\": \"LXFCDW-HA3FZ-65XQBV\",\r\n    \"direction\": \"in\",\r\n    \"referenceId\": \"T3VY4D-7NL7M-JAEQNW\",\r\n    \"type\": \"trade\",\r\n    \"currency\": \"FEE\",\r\n    \"amount\": 0,\r\n    \"after\": 2926.75,\r\n    \"status\": \"ok\",\r\n    \"timestamp\": 1595602217254,\r\n    \"datetime\": \"2020-07-24T14:50:17.254Z\",\r\n    \"fee\": {\r\n      \"cost\": 225.4,\r\n      \"currency\": \"FEE\"\r\n    },\r\n    \"_source\": \"rest api\"\r\n  },\r\n  {\r\n    \"info\": {\r\n      \"refid\": \"T3VY4D-7NL7M-JAEQNW\",\r\n      \"time\": 1595602217.2541,\r\n      \"type\": \"trade\",\r\n      \"subtype\": \"\",\r\n      \"aclass\": \"currency\",\r\n      \"asset\": \"ZEUR\",\r\n      \"amount\": \"1316.5597\",\r\n      \"fee\": \"0.0000\",\r\n      \"balance\": \"1330.0865\",\r\n      \"id\": \"LIG7WG-GS2F4-R3PCXE\"\r\n    },\r\n    \"id\": \"LIG7WG-GS2F4-R3PCXE\",\r\n    \"direction\": \"in\",\r\n    \"referenceId\": \"T3VY4D-7NL7M-JAEQNW\",\r\n    \"type\": \"trade\",\r\n    \"currency\": \"EUR\",\r\n    \"amount\": 1316.5597,\r\n    \"after\": 1330.0865,\r\n    \"status\": \"ok\",\r\n    \"timestamp\": 1595602217254,\r\n    \"datetime\": \"2020-07-24T14:50:17.254Z\",\r\n    \"fee\": {\r\n      \"cost\": 0,\r\n      \"currency\": \"EUR\"\r\n    },\r\n    \"_source\": \"rest api\"\r\n  },\r\n```\r\n\r\nAh, maybe this has something to do with KFEE (the  kraken fee token) that I think was introduced May 2019"
      },
      {
        "user": "kroitor",
        "created_at": "2021-01-04T21:54:39Z",
        "body": "> Ah, maybe this has something to do with KFEE (the kraken fee token) that I think was introduced May 2019\r\n\r\nLooks like it. You've paid some fees in another currency (kraken fee-points specifically), which explains the discrepancy with separate assets on your balance."
      },
      {
        "user": "npomfret",
        "created_at": "2021-01-04T22:10:21Z",
        "body": "right, so I *should* see my kfee balance reduce with each of these trades...\r\n\r\n... of course it doesn't \r\n\r\nbut i think we figured it out - thanks"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how Kraken's fee structure affects balance calculations differently than other exchanges",
      "Clear accounting for the role of KFEE token in fee payments",
      "Demonstration of accurate balance change calculations considering multiple currency adjustments",
      "Clarification of when fees are deducted from trade proceeds vs. separate balances"
    ]
  },
  {
    "number": 7996,
    "title": "[Binance] get X-MBX-USED-WEIGHT and X-MBX-ORDER-COUNT from http response headers",
    "created_at": "2020-11-19T14:53:21Z",
    "closed_at": "2020-11-19T15:02:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/7996",
    "body": "Hi,\r\n\r\nMay I know if ccxt supports getting http header from the response?\r\nI want to fetch some info from that header (as title).\r\n\r\nThanks,\r\nHien",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/7996/comments",
    "author": "nvhien1992",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2020-11-19T15:02:56Z",
        "body": "@nvhien1992 hi!\r\n\r\n> May I know if ccxt supports getting http header from the response?\r\n\r\nYes, the last received headers are stored in the `exchange.last_response_headers` property on the exchange instance:\r\n\r\n```\r\nconst response = await exchange.fetchTicker ('ETH/BTC')\r\nconsole.log (exchange.last_response_headers)\r\n```\r\n\r\nLet us know if that does not answer your question."
      }
    ],
    "satisfaction_conditions": [
      "Demonstrate how to access HTTP response headers in ccxt",
      "Show a method to retrieve specific header values after API calls",
      "Solution must work with Binance API integration",
      "Approach should be compatible with various API methods"
    ]
  },
  {
    "number": 7979,
    "title": "Limit order always executes at maximum set limit price",
    "created_at": "2020-11-15T20:45:38Z",
    "closed_at": "2020-11-15T22:15:07Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/7979",
    "body": "There is smth I don't understand about limit orders and how they are executed on binance. I am led to believe that a limit order will execute at the limit set **_or better_**. But based on numerous tests, I see it always executes at the limit set, no matter how high it is set. Here is an example for a buy order, where I set the limit at 10% higher (which is ridiculously high just to make the point) than the ask price. \r\n\r\n```\r\nprice:\r\n{'ask': 0.003907, 'bid': 0.003904}\r\n\r\norders:\r\n[{'info': {'symbol': 'LTCBTC', 'orderId': 437641845, 'orderListId': -1, 'clientOrderId': 'some-id', 'transactTime': 1605473031619, 'price': '0.00429700', 'origQty': '0.65000000', 'executedQty': '0.65000000', 'cummulativeQuoteQty': '0.00253912', 'status': 'FILLED', 'timeInForce': 'GTC', 'type': 'LIMIT', 'side': 'BUY'}, 'id': '437641845', 'clientOrderId': 'fjkfdjfdjk', 'timestamp': 1605473031619, 'datetime': '2020-11-15T20:43:51.619Z', 'lastTradeTimestamp': None, 'symbol': 'LTC/BTC', 'type': 'limit', 'side': 'buy', 'price': 0.004297, 'amount': 0.65, 'cost': 0.00253912, 'average': 0.003906338461538462, 'filled': 0.65, 'remaining': 0.0, 'status': 'closed', 'fee': None, 'trades': None}]\r\n```\r\nask price: 0.003907\r\nexecuted price: 0.004297 -> 10% increase \r\n\r\nIs there smth I don't understand? ",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/7979/comments",
    "author": "mklosi",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2020-11-15T21:01:48Z",
        "body": "> Is there smth I don't understand?\r\n\r\nSee the `average` field, it contains the actual average executed price (0.003906338461538462). The `price` field will contain the ordered price value (0.004297). The `cost` field as reported by Binance (`cummulativeQuoteQty`) is supposedly lying, you might want to check that by verifying the prices and summing the costs of trades for this order (`fetchMyTrades`).\r\n\r\nDo you use the Binance testnet for the tests or do you test on the actual production server?\r\nDo you use the futures with leverage?"
      },
      {
        "user": "mklosi",
        "created_at": "2020-11-15T21:37:14Z",
        "body": "So here is another order and the corresponding trade. I see the price between the order and trade also differ by 10%: \r\n\r\norder: \r\n```\r\n[\r\n  {\r\n    \"info\": {\r\n      \"symbol\": \"XRPBTC\",\r\n      \"orderId\": 429308436,\r\n      \"orderListId\": -1,\r\n      \"clientOrderId\": \"...........\",\r\n      \"transactTime\": 1605475762844,\r\n      \"price\": \"0.00001850\",\r\n      \"origQty\": \"15.00000000\",\r\n      \"executedQty\": \"15.00000000\",\r\n      \"cummulativeQuoteQty\": \"0.00025230\",\r\n      \"status\": \"FILLED\",\r\n      \"timeInForce\": \"GTC\",\r\n      \"type\": \"LIMIT\",\r\n      \"side\": \"BUY\"\r\n    },\r\n    \"id\": \"429308436\",\r\n    \"clientOrderId\": \".................\",\r\n    \"timestamp\": 1605475762844,\r\n    \"datetime\": \"2020-11-15T21:29:22.844Z\",\r\n    \"lastTradeTimestamp\": \"None\",\r\n    \"symbol\": \"XRP/BTC\",\r\n    \"type\": \"limit\",\r\n    \"side\": \"buy\",\r\n    \"price\": 0.0000185,\r\n    \"amount\": 15.0,\r\n    \"cost\": 0.0002523,\r\n    \"average\": 0.00001682,\r\n    \"filled\": 15.0,\r\n    \"remaining\": 0.0,\r\n    \"status\": \"closed\",\r\n    \"fee\": \"None\",\r\n    \"trades\": \"None\"\r\n  }\r\n]\r\n```\r\n\r\ntrade: \r\n```\r\n[\r\n  {\r\n    \"info\": {\r\n      \"symbol\": \"XRPBTC\",\r\n      \"id\": 78434404,\r\n      \"orderId\": 429308436,\r\n      \"orderListId\": -1,\r\n      \"price\": \"0.00001682\",\r\n      \"qty\": \"15.00000000\",\r\n      \"quoteQty\": \"0.00025230\",\r\n      \"commission\": \"0.00010924\",\r\n      \"commissionAsset\": \"BNB\",\r\n      \"time\": 1605475762844,\r\n      \"isBuyer\": \"True\",\r\n      \"isMaker\": \"False\",\r\n      \"isBestMatch\": \"True\"\r\n    },\r\n    \"timestamp\": 1605475762844,\r\n    \"datetime\": \"2020-11-15T21:29:22.844Z\",\r\n    \"symbol\": \"XRP/BTC\",\r\n    \"id\": \"78434404\",\r\n    \"order\": \"429308436\",\r\n    \"type\": \"None\",\r\n    \"side\": \"buy\",\r\n    \"takerOrMaker\": \"taker\",\r\n    \"price\": 0.00001682,\r\n    \"amount\": 15.0,\r\n    \"cost\": 0.0002523,\r\n    \"fee\": {\r\n      \"cost\": 0.00010924,\r\n      \"currency\": \"BNB\"\r\n    }\r\n  }\r\n]\r\n```\r\n\r\n> Do you use the Binance testnet for the tests or do you test on the actual production server?\r\n\r\nI'm using the live server \r\n\r\n> Do you use the futures with leverage?\r\n\r\nI'm not currently using futures. \r\n"
      },
      {
        "user": "kroitor",
        "created_at": "2020-11-15T21:42:39Z",
        "body": "@mklosi on the XRP/BTC trade \u2013\u00a0I don't see a problem with this one, looks correct to me, what's wrong with it?"
      },
      {
        "user": "mklosi",
        "created_at": "2020-11-15T22:03:34Z",
        "body": "well, I'm wondering why the \"price\" reported by the \"order\" is 10% higher than the \"price\" reported by the \"trade\". 10% so happens to be what I've put as the price for the limit order -> ask price in the moment of trade + 10%. I am sure if I put a limit order at a price = ask_price + 50%, the order will report that high price. I don't want to test 50% though, since I already lost a bunch of money testing this :)      \r\n\r\nShouldn't the price reported by the \"order\" match that of the \"trade\"?\r\n\r\n"
      },
      {
        "user": "kroitor",
        "created_at": "2020-11-15T22:06:32Z",
        "body": "> Shouldn't the price reported by the \"order\" match that of the \"trade\"?\r\n\r\nNo, the price reported by the order\u00a0\u2013 is the price reported by the exchange, in this case, it's the price of your order upon placing it (the price you've ordered). The `average` price should match the average across trades. And the cost should match the sum of costs of trades. That is, because one order may be filled with more than one trade, depending on the orderbook depth."
      },
      {
        "user": "mklosi",
        "created_at": "2020-11-15T22:11:44Z",
        "body": "ok so in this case, since the order was filled all-in-once, the actual price that the order was filled at, is the \"average\" field. The \"price\" field is just an echo to the limit price I set when I placed the order, not the actual price that the order was executed at, correct? "
      },
      {
        "user": "kroitor",
        "created_at": "2020-11-15T22:15:07Z",
        "body": "> ok so in this case, since the order was filled all-in-once, the actual price that the order was filled at, is the \"average\" field. The \"price\" field is just an echo to the limit price I set when I placed the order, not the actual price that the order was executed at, correct?\r\n\r\nYes, that is correct, but only if the order was filled with a single trade at once. If it was filled with more than one trade, then the actual true filling price is the price of each trade. \r\n\r\nLet me know if that does not answer your question. Feel free to reopen this issue or just ask further questions, if any."
      },
      {
        "user": "mklosi",
        "created_at": "2020-11-15T22:16:37Z",
        "body": "now it makes sense, and it's pretty basic actually. thank you. that was very helpful. I didn't think about the fact that the limit price I set is echoed back to me. "
      }
    ],
    "satisfaction_conditions": [
      "Clarify the distinction between the 'price' field and actual execution price in Binance API responses",
      "Explain how Binance's order execution logic works for limit orders",
      "Demonstrate how to verify actual execution prices through trade data",
      "Address the relationship between order parameters and reported execution metrics"
    ]
  },
  {
    "number": 7961,
    "title": "FTX conditional order price update",
    "created_at": "2020-11-12T08:31:38Z",
    "closed_at": "2020-11-12T15:35:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/7961",
    "body": "Programming Language version: Python 3.7 ( 64bit)\r\nCCXT version: 1.37.59\r\nFTX market\r\n\r\nHi\r\nHow can i update the price of conditional trigger orders without delete it ?\r\nI am using the Stop limit order and try to update the price.\r\n\r\nThis is my place trigger method\r\n`                    side = input1\r\n                    stopPrice = input2\r\n                    quantity = input3\r\n                    orderid=0\r\n                    limitPrice=None\r\n                   `\r\n\r\n\r\n` orderid = self.exchange.createOrder(self.symbol, \"stop\", side, quantity, limitPrice, { \"triggerPrice\": stopPrice })[\"info\"][\"id\"]`",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/7961/comments",
    "author": "mlshin",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2020-11-12T15:35:24Z",
        "body": "1. update to CCXT 1.37.63+\r\n2. use `editOrder` like so:\r\n\r\n```Python\r\nfrom pprint import pprint\r\n\r\norder = self.exchange.create_order(self.symbol, \"stop\", side, quantity, limitPrice, { \"triggerPrice\": stopPrice })\r\n\r\nedited_order = self.exchange.edit_order(order['id'], order['symbol'], order['type'], order['side'], order['amount'], None, {\r\n    'triggerPrice': 12345.67,  # your new price here\r\n})\r\n\r\npprint(edited_order)\r\n```\r\n\r\nLet us know if that helps or not.\r\nThx!"
      },
      {
        "user": "mlshin",
        "created_at": "2020-11-12T15:55:54Z",
        "body": "> 1. update to CCXT 1.37.63+\r\n> 2. use `editOrder` like so:\r\n> \r\n> ```python\r\n> from pprint import pprint\r\n> \r\n> order = self.exchange.create_order(self.symbol, \"stop\", side, quantity, limitPrice, { \"triggerPrice\": stopPrice })\r\n> \r\n> edited_order = self.exchange.edit_order(order['id'], order['symbol'], order['type'], order['side'], order['amount'], None, {\r\n>     'triggerPrice': 12345.67,  # your new price here\r\n> })\r\n> \r\n> pprint(edited_order)\r\n> ```\r\n> \r\n> Let us know if that helps or not.\r\n> Thx!\r\n\r\nThank you for your support .\r\nCode is working without any error . The point is ID is changing after editing. I think this is happening on the server .\r\nin any way I can use this code .\r\nThanks."
      },
      {
        "user": "kroitor",
        "created_at": "2020-11-12T15:56:36Z",
        "body": "> I think this is happening on the server .\r\n\r\nYes, FTX will do cancel+create on the server, as documented in FTX's API docs."
      }
    ],
    "satisfaction_conditions": [
      "Demonstrates how to modify trigger price of existing conditional orders without manual deletion",
      "Works with FTX's API behavior for order modifications",
      "Uses CCXT library's native functionality for order editing",
      "Preserves original order parameters while changing trigger price"
    ]
  },
  {
    "number": 7830,
    "title": "[binance] Is it possible to access coin-margined (delivery) futures?",
    "created_at": "2020-10-19T13:38:26Z",
    "closed_at": "2020-10-19T13:43:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/7830",
    "body": "I can access binance USDT futures with {'defaultType': 'future'}\r\nBut is it possible to access binance COIN futures ? (ex. BTCUSD Quarterly 1225)\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/7830/comments",
    "author": "takei0723",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2020-10-19T13:43:08Z",
        "body": "Yes:\r\n\r\n```Python\r\nimport ccxt\r\nfrom pprint import pprint\r\nprint('CCXT Version:', ccxt.__version__)\r\nexchange = ccxt.binance({\r\n    'enableRateLimit': True,\r\n    'options': {\r\n        'defaultType': 'delivery',\r\n    },\r\n})\r\nmarkets = exchange.load_markets()\r\npprint(exchange.symbols)\r\n```"
      },
      {
        "user": "takei0723",
        "created_at": "2020-10-19T13:48:43Z",
        "body": "Thank you very much !!"
      }
    ],
    "satisfaction_conditions": [
      "Identification of the correct CCXT configuration parameter to access coin-margined/delivery futures markets",
      "Confirmation that Binance delivery futures are supported via CCXT",
      "Clear differentiation between future types (USDT-margined vs coin-margined) in CCXT implementation"
    ]
  },
  {
    "number": 7507,
    "title": "Do the recent metainfo update PRs suggest incoming deprecation?",
    "created_at": "2020-08-24T10:27:20Z",
    "closed_at": "2020-08-24T11:14:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/7507",
    "body": "I noticed that @An-Net has updated many `has` dicts of different exchanges, sometimes e.g. adding `'fetchTicker': true` despite it already being defaulted in the Exchange base class. Does this mean there is a plan to default all to `False`? (I'm asking because in that case I'll have to make some changes in my own repos).",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/7507/comments",
    "author": "binares",
    "comments": [
      {
        "user": "frosty00",
        "created_at": "2020-08-24T11:00:38Z",
        "body": "Not necessarily, I would just say it is more complete to have all the `has` properties in the derived (subclass) exchange files."
      },
      {
        "user": "binares",
        "created_at": "2020-08-24T11:14:01Z",
        "body": "Ah, that explains it, thanks."
      }
    ],
    "satisfaction_conditions": [
      "Clarification of the intent behind explicit 'has' property declarations in derived exchange classes",
      "Confirmation about potential deprecation of implicit defaults from the base Exchange class"
    ]
  },
  {
    "number": 7500,
    "title": " python No module named 'ccxt'\uff0cwhat should I do?",
    "created_at": "2020-08-22T16:48:44Z",
    "closed_at": "2020-08-22T17:26:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/7500",
    "body": "\r\nwhat should I do?\r\nIm win10 python 3.7.3,allredy install cctx1.0.0,but still No module named 'ccxt',help me!!\r\n\r\n- OS:win10\r\n- Programming Language version:python\r\n- CCXT version:1.0.0\r\n\r\nNo module named 'ccxt'\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/7500/comments",
    "author": "keyvin-wei",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2020-08-22T17:26:31Z",
        "body": "Which command do you use to install it? \r\n\r\nMake sure you do not confuse `cctx` (this is a wrong name, just a stub) with `ccxt` (this is the actual package name). \n\n---\n\n@keyvin-wei let us know if the above answer does not help resolve it. Feel free to reopen this issue or just ask further questions if any."
      },
      {
        "user": "keyvin-wei",
        "created_at": "2020-08-23T05:22:12Z",
        "body": "ok\uff0ci type a wrong letter\uff0cis \u201cccxt\u201d not the \u201ccctx\u201d\r\n@kroitor thanks"
      }
    ],
    "satisfaction_conditions": [
      "Identifies the root cause as a package name typo in installation commands"
    ]
  },
  {
    "number": 7469,
    "title": "phemex decimal issue watch_order_book",
    "created_at": "2020-08-15T18:21:21Z",
    "closed_at": "2020-08-21T06:11:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/7469",
    "body": "- OS: macOS 10.13.6\r\n- Programming Language version: 3.6.0\r\n- CCXT version: ccxt 1.33.15 | ccxtpro 0.3.43\r\n\r\n```\r\nclient = ccxtpro.phemex()\r\nwhile True:\r\n    ccxt_orderbook = await client.watch_order_book(\r\n        \"ETH/USD\",\r\n        params={}\r\n    )\r\n```\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"execution.py\", line 1669, in subscribe_book\r\n    params={}\r\n  File \"python3.6/site-packages/ccxtpro/phemex.py\", line 280, in watch_order_book\r\n    await self.load_markets()\r\n  File \"python3.6/site-packages/ccxt/async_support/base/exchange.py\", line 180, in load_markets\r\n    raise e\r\n  File \"python3.6/site-packages/ccxt/async_support/base/exchange.py\", line 176, in load_markets\r\n    result = await self.markets_loading\r\n  File \"python3.6/site-packages/ccxt/async_support/base/exchange.py\", line 165, in load_markets_helper\r\n    currencies = await self.fetch_currencies()\r\n  File \"python3.6/site-packages/ccxt/async_support/phemex.py\", line 692, in fetch_currencies\r\n    maxAmount = float(self.decimal_to_precision(maxValueEv * precision, ROUND, 0.00000001, self.precisionMode))\r\n  File \"python3.6/site-packages/ccxt/base/decimal_to_precision.py\", line 74, in decimal_to_precision\r\n    missing = abs(dec) % precision_dec\r\ndecimal.InvalidOperation: [<class 'decimal.DivisionImpossible'>]\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/7469/comments",
    "author": "jaseisen105",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2020-08-15T22:07:15Z",
        "body": "@jaseisen105 does this work on your side?\r\n\r\n```Python\r\nimport ccxt\r\n\r\nprint('CCXT Version:', ccxt.__version__)\r\n\r\nexchange = ccxt.phemex({\r\n    'enableRateLimit': True,\r\n})\r\n\r\nexchange.verbose = True\r\n\r\nexchange.load_markets()\r\n```"
      },
      {
        "user": "jaseisen105",
        "created_at": "2020-08-16T16:21:58Z",
        "body": "@kroitor - unfortunately no, getting the same error"
      },
      {
        "user": "kroitor",
        "created_at": "2020-08-17T01:47:35Z",
        "body": "I don't have this issue in Python 3.6.9 and Python 3.7.2.\r\n\r\n```\r\nubuntu@ccxt:~/$ python3\r\nPython 3.6.9 (default, Jul 17 2020, 12:50:27)\r\n[GCC 8.4.0] on linux\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>> import ccxt\r\n>>> exchange = ccxt.phemex({'enableRateLimit': True})\r\n>>> exchange.load_markets()\r\n{'BTC/USD': {'percentage': True, 'tierBased': False, 'taker': 0.0075, 'maker': -0...\r\n>>> ccxt.__version__\r\n'1.33.17'\r\n```\r\n\r\nI think it may be related to your Python version (3.6.0).\r\nDo you have the same issue if you upgrade to a newer Python version? Let us know if you can upgrade it to rule out version conflicts. In the meantime I will try to reproduce it on my side with 3.6.0."
      },
      {
        "user": "jaseisen105",
        "created_at": "2020-08-21T06:11:15Z",
        "body": "@kroitor that worked, thanks!"
      }
    ],
    "satisfaction_conditions": [
      "Resolves decimal.InvalidOperation error during market data loading",
      "Maintains compatibility with Phemex API through CCXT/CCXT Pro",
      "Avoids precision calculation errors in currency processing"
    ]
  },
  {
    "number": 7116,
    "title": "Kucoin fetchBalance method returning empty data",
    "created_at": "2020-06-14T01:34:20Z",
    "closed_at": "2020-06-14T01:40:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/7116",
    "body": "Hello,\r\nI have 2 accounts at Kucoin, when trying to call the fetchBalance method in one of them, the API returns the balance to me normally, but when calling this same method in another account, it returns me a json with empty data, why does this happen? I checked the Key / Secret / Phrase API and it is correct, because I am getting the status 200000\r\n\r\n- OS: CentOS 7\r\n- Programming Language version: JavaScript\r\n- CCXT version: 1.28.95\r\n\r\n```\r\nasync getBalance() {\r\n        let balance = []\r\n        try {\r\n            balance = await this.kucoin.fetchBalance()\r\n        } catch (e) {\r\n            let error = {\r\n                error: this.extractErrorMessage(e.message)\r\n            }\r\n            return error\r\n        }\r\n        return balance\r\n    }\r\n```\r\n\r\n```\r\n{ info: { code: '200000', data: [] },\r\n  free: {},\r\n  used: {},\r\n  total: {} }\r\n```\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/7116/comments",
    "author": "viniciussvl",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2020-06-14T01:35:30Z",
        "body": "Hi! Have you deposited to the \"empty\" account?"
      },
      {
        "user": "viniciussvl",
        "created_at": "2020-06-14T01:39:48Z",
        "body": "Wonderful, that was it! What a silly mistake, I apologize. You can close this issue, if someone \"gets it wrong\" like me, you will find this topic haha"
      }
    ],
    "satisfaction_conditions": [
      "Identifies that empty balance data can occur even with valid API credentials",
      "Addresses account-specific factors rather than code implementation",
      "Explains non-technical causes for empty balance responses"
    ]
  },
  {
    "number": 7110,
    "title": "How to use test api?",
    "created_at": "2020-06-13T06:25:05Z",
    "closed_at": "2020-06-13T10:05:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/7110",
    "body": "Hi, I notice that many exchanges have test accounts or apis such as Bitmex, thus their ccxt exchange instance have test url too. So is there a way for ccxt to use the test api automatically, instead of any error of bad Apikey or something else?",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/7110/comments",
    "author": "monk-after-90s",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2020-06-13T10:05:52Z",
        "body": "```Python\r\nimport ccxt\r\nexchange = ccxt.bitmex({\r\n    'enableRateLimit': True,\r\n})\r\nexchange.set_sandbox_mode(True)\r\n```\r\n\r\nLet us know if that does not answer your question."
      },
      {
        "user": "monk-after-90s",
        "created_at": "2020-06-14T01:39:15Z",
        "body": "Thank you @kroitor "
      }
    ],
    "satisfaction_conditions": [
      "Demonstrates how to activate test/sandbox mode for an exchange in CCXT",
      "Ensures test API usage avoids authentication errors with production credentials",
      "Uses native CCXT functionality rather than manual URL overrides"
    ]
  },
  {
    "number": 7033,
    "title": "How to get Huobi bid/ask price with watchTicker?",
    "created_at": "2020-05-28T13:16:00Z",
    "closed_at": "2020-05-28T13:34:22Z",
    "labels": [
      "question",
      "ws"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/7033",
    "body": "Language: Python\r\n\r\nHi @kroitor \r\nI have decided to purchase ccxpro!\r\n\r\nTwo things that I have noticed initially:\r\n-The repository cannot be installed using Poetry (pip works fine), it has an exit code 1.\r\n-Huobi `watch_ticker` is not returning the \"ask\" or \"bid\", which is a bummer since I bought CCXTPRO for that reason \ud83e\udd23 .\r\nI can use `watch_order_book`, but it will take me a lot of refactoring to do..\r\n\r\nIs it possible to add `\"ask\"/\"bid\"` to Huobipro? \r\n\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/7033/comments",
    "author": "Corfucinas",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2020-05-28T13:24:26Z",
        "body": "Hi @Corfucinas !\r\n\r\n> -The repository cannot be installed using Poetry (pip works fine), it has an exit code 1.\r\n\r\nWe haven't tested it with 3rd-party package managers, but will do our best to get there.\r\n\r\n> -Huobi watch_ticker is not returning the \"ask\" or \"bid\", which is a bummer since I bought CCXTPRO for that reason \ud83e\udd23 .\r\n> Is it possible to add \"ask\"/\"bid\" to Huobipro?\r\n\r\nUnfortunately, not, because Huobi Pro does not provide that information via the WS ticker, here's how a ticker update from Huobi looks like:\r\n\r\n```\r\n2020-05-28T13:19:20.960Z onMessage {\r\n  ch: 'market.btcusdt.detail',\r\n  ts: 1590671960809,\r\n  tick: {\r\n    id: 215837272868,\r\n    low: 9053.9,\r\n    high: 9450.01,\r\n    open: 9160.36,\r\n    close: 9399.88,\r\n    vol: 373216777.90379894,\r\n    amount: 40485.241497971125,\r\n    version: 215837272868,\r\n    count: 457796\r\n  }\r\n}\r\n```\r\n\r\n\u2191\u00a0No bid/ask there to derive that data from. So, the only way to track current market prices is to use the orderbook feed. Or fallback to `fetchTicker` over REST.\r\n\r\nIn general, not all exchanges will consider bid/ask a part of the ticker, most often the ticker is limited to the 24 OHLCV + last public trade price. The ticker itself is just a second-order statistical 24-hour calculation (derived data) from the first-order realtime data based on the orderbook+trades. You can derive the ticker info from the source data on the user side.\r\n\r\nLet me know if the above does not answer your questions."
      },
      {
        "user": "Corfucinas",
        "created_at": "2020-05-28T13:33:16Z",
        "body": "Thanks for the prompt reply. I'll continue exploring the library. (I'll work around Huobi, you have some, they take some...one day a single websocket will provide us everything we need for quant!)\r\nyou may close the issue"
      },
      {
        "user": "kroitor",
        "created_at": "2020-05-28T13:34:22Z",
        "body": "@Corfucinas thanks! Feel free to reopen it if needed, or just ask further questions if any. Thank you for using CCXT Pro."
      }
    ],
    "satisfaction_conditions": [
      "Confirmation that Huobi's WebSocket ticker feed does not include bid/ask data",
      "Identification of alternative methods to obtain bid/ask prices for Huobi",
      "Explanation of why bid/ask data isn't part of Huobi's ticker structure"
    ]
  },
  {
    "number": 6993,
    "title": "How to use this.hmac for signature generation?",
    "created_at": "2020-05-22T16:08:56Z",
    "closed_at": "2020-05-22T17:24:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/6993",
    "body": "Hi,\r\n\r\nI'm trying to write the sign method to an exchange, yet without success.\r\nThe problem happens in the signature generation.\r\n\r\nIn javascript: \r\n\r\nfunction generateSignature(key, secret, nonce) {\r\n   var message = nonce + key; \r\n   var hash = CryptoJS.HmacSHA256(message, secret);\r\n   var hashInBase64 = CryptoJS.enc.Base64.stringify(hash);\r\n   return hashInBase64;\r\n}\r\n\r\nit works, but I'm in doubt how to write it with ccxt syntax. \r\nBased on the signature of other exchanges(I read binance, kraken, etc), I'm trying hash and hmac:\r\n\r\n         } else {\r\n             this.checkRequiredCredentials ();\r\n             const nonce = this.nonce ().toString ();\r\n             url += path;\r\n             const message = nonce + this.apiKey;\r\n             const hash = this.hash (this.encode (message), 'sha256', 'base64');\r\n             const signature = this.hmac (hash, this.encode (this.secret), 'sha256', 'base64');\r\n             headers = {\r\n                 'Content-Type': 'application/x-www-form-urlencoded',\r\n                 'key': this.apiKey,\r\n                 'nonce': nonce,\r\n                 'signature': signature,\r\n             };\r\n\r\nI'm getting: ccxt.base.errors.ExchangeNotAvailable: POST ...... 400 Bad Request {\"error\":true,\"data\":{\"message\":\"Invalid signature. Verify key and signature.\"}}\r\n\r\nCan anyone help me to translate the above generateSignature to the ccxt syntax?\r\n\r\nThank you.\r\n\r\nErico.",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/6993/comments",
    "author": "ericoacguedes",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2020-05-22T17:24:03Z",
        "body": "Non-CCXT:\r\n\r\n```JavaScript\r\nfunction generateSignature(key, secret, nonce) {\r\n   var message = nonce + key; \r\n   var hash = CryptoJS.HmacSHA256(message, secret);\r\n   var hashInBase64 = CryptoJS.enc.Base64.stringify(hash);\r\n   return hashInBase64;\r\n}\r\n```\r\n\r\n\u2193\r\n\r\nCCXT:\r\n\r\n```JavaScript\r\n    const message = nonce + this.apiKey;\r\n    const signature = this.hmac (this.encode (message), this.encode (this.secret), 'sha256', 'base64');\r\n    headers = {\r\n        'Content-Type': 'application/x-www-form-urlencoded',\r\n        'key': this.apiKey,\r\n        'nonce': nonce,\r\n        'signature': signature,\r\n    };\r\n```\r\n\r\nLet me know if that does not help.\n\n---\n\n@ericoacguedes in other words, you don't need to `hash()` it in CCXT, just do `hmac()`. It would be great if you report back whether it solves the issue for you or not.\n\n---\n\nI hope the above helped. Closing this for now, feel free to reopen it or just ask further questions if any."
      },
      {
        "user": "ericoacguedes",
        "created_at": "2020-05-22T17:30:16Z",
        "body": "Yes. It works. Thank you."
      }
    ],
    "satisfaction_conditions": [
      "Demonstrates correct HMAC usage in CCXT without redundant hashing",
      "Proper message composition with nonce and API key concatenation",
      "Correct parameter order and encoding for CCXT's hmac method",
      "Verification against exchange's signature validation requirements"
    ]
  },
  {
    "number": 6983,
    "title": "[dsx] fetch orders broken",
    "created_at": "2020-05-20T09:52:37Z",
    "closed_at": "2020-05-20T10:16:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/6983",
    "body": "I'm getting `dsx fetchOrders not supported`, but it is.",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/6983/comments",
    "author": "npomfret",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2020-05-20T10:08:10Z",
        "body": "> but it is.\r\n\r\nNope, I don't think it is. If you look into the actual response \u2013 both DSX and HitBTC will return closed orders from the \"active\" orders endpoint for some while. And then those orders will be moved to inactive orders (the status does not change). So it does not have a true fetchOrders endpoint for closed/canceled orders. It will also return partially filled orders from their historical endpoint. In other words, their \"active\" exchange-specific state has nothing to do with the \"open/closed\" unified status, really. That \"active\" state is time-based. \r\n\r\nIn other words, there's no strict one-to-one correspondence like:\r\n- active != open\r\n- inactive != closed\r\n\r\n\u2191 This API design differs from all other exchanges in that regard.\r\n\r\nBoth exchanges have `fetchOpenOrders` and `fetchClosedOrders`. But neither of them has `fetchOrders` for all orders, regardless of the \"active\" state and regardless of the \"open/closed\" status. Does that answer your question? Let me know, if I'm missing something."
      },
      {
        "user": "npomfret",
        "created_at": "2020-05-20T10:16:41Z",
        "body": "I see, thanks."
      },
      {
        "user": "kroitor",
        "created_at": "2020-05-20T10:16:56Z",
        "body": "Also, because of that \"active/inactive\" design both exchanges have fetchOrder (for \"historical\" orders which may be open/closed/canceled) and fetchOpenOrder (for querying an \"active\" order, which can also be open/closed/canceled). We think of renaming fetchOrder \u2192 fetchClosedOrder to match the API a little bit closer."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why the exchange's API design makes fetchOrders unavailable despite user expectations",
      "Clarification of the relationship between exchange-specific order states and unified CCXT statuses",
      "Identification of alternative methods to retrieve historical orders",
      "Acknowledgement of API design inconsistencies compared to other exchanges"
    ]
  },
  {
    "number": 6982,
    "title": "[hitbtc] trade fee missing currency",
    "created_at": "2020-05-20T09:50:17Z",
    "closed_at": "2020-05-20T10:14:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/6982",
    "body": "        {\r\n            \"info\": {\"id\": 849899156, \"clientOrderId\": \"c6349c2ef7734447a106cd3ac982c23b\", \"orderId\": 245637799183, \"symbol\": \"IOSTBTC\", \"side\": \"sell\", \"quantity\": \"6920\", \"price\": \"0.0000003764\", \"fee\": \"0.000001823282\", \"timestamp\": \"2020-05-20T02:21:55.024Z\"},\r\n            \"id\": \"849899156\",\r\n            \"order\": \"c6349c2ef7734447a106cd3ac982c23b\",\r\n            \"timestamp\": 1589941315024,\r\n            \"datetime\": \"2020-05-20T02:21:55.024Z\",\r\n            \"symbol\": \"IOST/BTC\",\r\n            \"side\": \"sell\",\r\n            \"price\": 3.764e-7,\r\n            \"amount\": 6920,\r\n            \"cost\": 0.002604688,\r\n            \"fee\": {\"cost\": 0.000001823282}\r\n        }",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/6982/comments",
    "author": "npomfret",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2020-05-20T10:03:03Z",
        "body": "Do you have CCXT updated? Because I'm seeing this from parseTrade (i've added the edits to HitBTC for the feeCurrency specified in markets upon merging your PR).\r\n\r\nWith your trade posted above:\r\n\r\n```\r\nmbp:ccxt igorkroitor$ node examples/js/cli hitbtc fetchMyTrades --details\r\nhitbtc.fetchMyTrades ()\r\n-------------------------------------------\r\n{         info: {            id:  849899156,\r\n                  clientOrderId: \"c6349c2ef7734447a106cd3ac982c23b\",\r\n                        orderId:  245637799183,\r\n                         symbol: \"IOSTBTC\",\r\n                           side: \"sell\",\r\n                       quantity: \"6920\",\r\n                          price: \"0.0000003764\",\r\n                            fee: \"0.000001823282\",\r\n                      timestamp: \"2020-05-20T02:21:55.024Z\"          },\r\n            id:   \"849899156\",\r\n         order:   \"c6349c2ef7734447a106cd3ac982c23b\",\r\n     timestamp:    1589941315024,\r\n      datetime:   \"2020-05-20T02:21:55.024Z\",\r\n        symbol:   \"IOST/BTC\",\r\n          type:    undefined,\r\n          side:   \"sell\",\r\n  takerOrMaker:    undefined,\r\n         price:    3.764e-7,\r\n        amount:    6920,\r\n          cost:    0.002604688,\r\n           fee: { cost: 0.000001823282, currency: \"BTC\" }               }\r\n```\r\n\r\n\u2191 The fee currency is there in the most recent version of CCXT. You may have an outdated HitBTC file."
      },
      {
        "user": "npomfret",
        "created_at": "2020-05-20T10:14:13Z",
        "body": "Maybe thanks."
      }
    ],
    "satisfaction_conditions": [
      "Fee currency information must be present in trade data",
      "Solution must work with the latest API/exchange integration version",
      "Fee data structure must match expected API response format"
    ]
  },
  {
    "number": 6961,
    "title": "Position Open Date",
    "created_at": "2020-05-17T13:59:44Z",
    "closed_at": "2020-05-17T17:08:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/6961",
    "body": "Hi guys, \r\nOn deribit, I would like to know the date (timestamp) a position has been opened at. \r\nI am aware I can get timestamp for trades, but is there any way to do the same for a position ?\r\nThanks in advance for any insight!\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/6961/comments",
    "author": "Thjdid",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2020-05-17T17:08:42Z",
        "body": "Hi!\r\n\r\n> I am aware I can get timestamp for trades, but is there any way to do the same for a position ?\r\n\r\nYour position is a cumulative result all your buy/sell orders. The position exists at zero if you haven't placed any orders. When you place an order your position grows from zero up, when you place an opposite order your position shrinks down to zero. It exists regardless of the size of the position (a zero position is also called a neutral position). Therefore a position is not supposed to have a timestamp, really. So, the opening timestamp of your position is the timestamp of your first order that changed your position.\r\n\r\nLet us know if that does not answer your question."
      },
      {
        "user": "Thjdid",
        "created_at": "2020-05-18T01:07:34Z",
        "body": "Hi Kroitor, \r\nThanks for the explanation, it totally makes sense. That's what I thought but I am always happy to get you point of view for confirmation :). \r\n\r\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how to derive a position's opening timestamp using existing trade data",
      "Clarification that positions don't have inherent timestamps but are defined by order execution times",
      "Method to identify the initial trade that established the position"
    ]
  },
  {
    "number": 6903,
    "title": "{ ExchangeError: binanceus {\"code\":-1102,\"msg\":\"Mandatory parameter 'quantity' was not sent, was empty/null, or malformed.\"}",
    "created_at": "2020-05-07T13:25:29Z",
    "closed_at": "2020-05-07T14:20:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/6903",
    "body": "- OS: Windows 10\r\n- Programming Language version: Node Js\r\n- CCXT version: 6.14.4\r\n\r\nHello Igor,\r\n\r\ni am trying to edit an order initially placed as limit order to change it from limit to market order. I am receiving the error below:\r\n{ ExchangeError: binanceus {\"code\":-1102,\"msg\":\"Mandatory parameter 'quantity' was not sent, was empty/null, or malformed.\"}\r\n\r\nhere's my code snippet below:\r\n\r\ntry { myOrder = await exchange.editOrder(orderId, tradingPair, type, side, amount, price, {}); }\r\n\tcatch(err) {...}\r\n\r\nThanks in advance.\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/6903/comments",
    "author": "crossx4real",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2020-05-07T13:45:49Z",
        "body": "Hi!\r\n\r\nTry removing the `price` argument from there, as follows:\r\n\r\n```JavaScript\r\n// if it doesn't work uncomment the next line and paste your verbose request+response\r\n// exchange.verbose = true \r\ntry { myOrder = await exchange.editOrder(orderId, tradingPair, 'market', side, amount); }\r\ncatch(err) {...}\r\n```"
      },
      {
        "user": "crossx4real",
        "created_at": "2020-05-15T01:49:31Z",
        "body": "ok thank will do that. I hope you are enjoying the big swings on BTC this bull season.\r\n\n\n---\n\nworked like a charm. sent you 100 BAT. just saying.... you got 90 days to claim it i think."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of required parameters for editing orders between limit and market types",
      "Clarification of parameter differences between market and limit orders in CCXT",
      "Guidance on mandatory fields for BinanceUS order modifications"
    ]
  },
  {
    "number": 6765,
    "title": "Closing position on Bybit?",
    "created_at": "2020-04-09T20:38:45Z",
    "closed_at": "2020-04-09T20:50:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/6765",
    "body": "Hello, how to close open position using ccxt in bybit",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/6765/comments",
    "author": "antebw",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2020-04-09T20:50:16Z",
        "body": "Hi! To close an open position you should simply place an opposite basic order or a conditional order that will trigger your stop condition. So, if you have opened a position by buying some number of contracts \u2013\u00a0then your should sell the same number of contracts which will effectively reduce your open position to zero (thus closing it). Let us know if that does not answer the question."
      },
      {
        "user": "antebw",
        "created_at": "2020-04-09T22:38:58Z",
        "body": "Thank you for fast response, yes this is working for me. Thx one more time."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how to create an opposite order to neutralize an existing position",
      "Clarification that position closure requires matching direction/quantity with original trade"
    ]
  },
  {
    "number": 6674,
    "title": "Unable to resolve module './js/btcchina.js'",
    "created_at": "2020-03-25T11:36:28Z",
    "closed_at": "2020-03-25T11:51:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/6674",
    "body": "- OS: Debian 10 android apk 29\r\n- Programming Language version: react-native 0.61.5\r\n- CCXT version: 1.24.96\r\n\r\n```\r\nSimply put var ccxt = require('ccxt'); into any module\r\n```\r\n\r\n```\r\n[Wed Mar 25 2020 11:31:13.196]  BUNDLE  ./index.js \r\n\r\nerror: Error: Unable to resolve module `./js/btcchina.js` from `node_modules/ccxt/ccxt.js`: \r\n\r\nNone of these files exist:\r\n  * node_modules/ccxt/js/btcchina.js(.native|.android.js|.native.js|.js|.android.json|.native.json|.json|.android.ts|.native.ts|.ts|.android.tsx|.native.tsx|.tsx)\r\n  * node_modules/ccxt/js/btcchina.js/index(.native|.android.js|.native.js|.js|.android.json|.native.json|.json|.android.ts|.native.ts|.ts|.android.tsx|.native.tsx|.tsx)\r\n    at ModuleResolver.resolveDependency (/home/marcel/ReactNative/FusionCommerce/node_modules/@react-native-community/cli/node_modules/metro/src/node-haste/DependencyGraph/ModuleResolution.js:163:15)\r\n    at ResolutionRequest.resolveDependency (/home/marcel/ReactNative/FusionCommerce/node_modules/@react-native-community/cli/node_modules/metro/src/node-haste/DependencyGraph/ResolutionRequest.js:52:18)\r\n    at DependencyGraph.resolveDependency (/home/marcel/ReactNative/FusionCommerce/node_modules/@react-native-community/cli/node_modules/metro/src/node-haste/DependencyGraph.js:287:16)\r\n    at Object.resolve (/home/marcel/ReactNative/FusionCommerce/node_modules/@react-native-community/cli/node_modules/metro/src/lib/transformHelpers.js:267:42)\r\n    at dependencies.map.result (/home/marcel/ReactNative/FusionCommerce/node_modules/@react-native-community/cli/node_modules/metro/src/DeltaBundler/traverseDependencies.js:434:31)\r\n    at Array.map (<anonymous>)\r\n    at resolveDependencies (/home/marcel/ReactNative/FusionCommerce/node_modules/@react-native-community/cli/node_modules/metro/src/DeltaBundler/traverseDependencies.js:431:18)\r\n    at /home/marcel/ReactNative/FusionCommerce/node_modules/@react-native-community/cli/node_modules/metro/src/DeltaBundler/traverseDependencies.js:275:33\r\n    at Generator.next (<anonymous>)\r\n    at asyncGeneratorStep (/home/marcel/ReactNative/FusionCommerce/node_modules/@react-native-community/cli/node_modules/metro/src/DeltaBundler/traverseDependencies.js:87:24)\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/6674/comments",
    "author": "marcelcure",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2020-03-25T11:52:41Z",
        "body": "@marcelcure Let me know if you still have the same issue with version 1.24.97, it will arrive in 15 minutes. It will be great if you report back whether it helped or not. Also, you might want to rebuild your framework bundles to make sure that your version is up to date. Looking forward to hearing back from you! Thanks!"
      },
      {
        "user": "marcelcure",
        "created_at": "2020-03-25T13:37:08Z",
        "body": "I updated to 1.24.97 and to begin with I had the exact same error, so I deleted node_modules and rebuilt and now it is working perfectly. Thank you. Good job - very fast."
      },
      {
        "user": "kroitor",
        "created_at": "2020-03-25T13:41:20Z",
        "body": "@marcelcure thanks for your feedback! Appreciate it!"
      }
    ],
    "satisfaction_conditions": [
      "Resolves missing module errors when importing CCXT in React Native",
      "Ensures proper version compatibility between CCXT and React Native environment"
    ]
  },
  {
    "number": 6550,
    "title": "I got \"amount is invalid\" error when i try to withdraw",
    "created_at": "2020-03-02T15:36:00Z",
    "closed_at": "2020-03-02T22:14:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/6550",
    "body": "- OS: Mac OS Catalina\r\n- Programming Language version: Node.js\r\n- CCXT version: 1.23.1\r\n- Exchange: Bitmex\r\n- Method: withdraw\r\n\r\nThis is my route:\r\n\r\n```\r\nrouter.post('/withdraw', async (req, res, next) => {\r\n  const {code, address, amount, otpToken, currency } = req.body;\r\n\r\n  const exchange = await new ccxt.bitmex();\r\n  exchange.apiKey = \"MY - KEY\";\r\n  exchange.secret = \"MY - SECRET\";\r\n\r\n  await exchange.withdraw (code, amount, address, tag = undefined, params = {}, otpToken)\r\n  .then((response) => console.log(res))\r\n  .catch(ex => console.log(ex))\r\n\r\n});\r\n```\r\n\r\nAnd this is what i am trying to post:\r\n\r\n{\r\n    \"address\": \"THE ADRESS\",\r\n    \"amount\": 0.0022,\r\n    \"code\": \"BTC\",\r\n    \"otpToken\": \"MY TOKEN\"\r\n}\r\n\r\nWhen i execute this route, i get this error:\r\nBadRequest: bitmex {\"error\":{\"message\":\"amount is invalid\",\"name\":\"HTTPError\"}}\r\n\r\nThe key and the secret are OK. The otpToken too. I can fetch everything.\r\nI\u00b4m new on this, and i can\u00b4t figure it out where is the error on my code.\r\n\r\nThank you!!\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/6550/comments",
    "author": "Nicour",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2020-03-02T22:14:18Z",
        "body": "Hi! \r\n\r\nI think BitMEX requires the amount in satoshis (an integer, not a floating point decimal). So, instead of `\"amount\": 0.0022` it should be `\"amount\": 220000`.\r\n\r\nLet me know if that does not help.\n\n---\n\nClosing this for now, feel free to reopen it or just ask further questions if any. We will be happy if you report back whether the issue is resolved on your side or not. Thx!"
      },
      {
        "user": "Nicour",
        "created_at": "2020-03-03T08:24:53Z",
        "body": "Hello.\r\nThank you very much for your help. \r\nI've just try with the amount in satoshis an it works.\r\n\r\nThank you again!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of exchange-specific amount formatting requirements",
      "Clarification of parameter validation rules for the target exchange",
      "Guidance on converting between currency units and exchange base units"
    ]
  },
  {
    "number": 6546,
    "title": "Limited L2 orderbook does not produce consistent amount of results - CCXT PRO",
    "created_at": "2020-03-01T14:39:07Z",
    "closed_at": "2020-03-01T14:59:12Z",
    "labels": [
      "question",
      "ws"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/6546",
    "body": "- OS: Win10\r\n- Programming Language version: Python 3.8\r\n- CCXT version: 0.0.47\r\n- Exchange: Binance, WS\r\n\r\n```\r\nimport ccxtpro\r\nimport asyncio\r\n\r\nasync def main():\r\n    exchange = ccxtpro.binance({'enableRateLimit': True})\r\n    while True:\r\n        orderbook = await exchange.watch_order_book('ETH/BTC', 10) #INCONSISTENT, see below\r\n        print(len(orderbook['asks']), len(orderbook['bids']))\r\n\r\nasyncio.get_event_loop().run_until_complete(main())\r\n\r\n```\r\n\r\nResults:\r\n\r\n```\r\n10 10\r\n10 10\r\n10 9\r\n9 10\r\n10 10\r\n10 10\r\n10 10\r\n10 9\r\n10 10\r\n```\r\n\r\nand:\r\n```\r\n        orderbook = await exchange.watch_order_book('ETH/BTC', 1)\r\n        print(orderbook['asks'][0]), (orderbook['bids'][0])\r\n```\r\nProduces (after some correct results):\r\n```\r\n    print(orderbook['asks'][0]), (orderbook['bids'][0])\r\nIndexError: list index out of range\r\n```",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/6546/comments",
    "author": "1key",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2020-03-01T14:49:38Z",
        "body": "Technically, this is not fully a bug. What happens is that when you limit the orders in real-time mode by supplying the `limit` argument CCXT will only store up to `limit` orders. In some cases an order may be deleted from the book (when matched), so the exchange sends a zero delta and it is removed from the orderbook leaving just the 9 orders of 10 (until another one fills the gap). The responsibility of CCXT Pro in this case is to return immediately after receiving a \"delete\" command from the exchange (or any of \"delete\", \"update\", \"insert\" deltas).\r\n\r\nSo, from here, you have two options:\r\n\r\n- either expect the number of bids/asks to be less than or equal to `limit` in the result \r\n- or don't send `limit` (CCXT will keep the entire orderbook in memory) and just use python's array slicing like `[0:5]`\r\n\r\nAlso, Binance does support limited WS feeds for 5, 10 or 20 bidasks, however, when `limit` is sent to the exchange \u2013 it will rate-limit the feed by 100ms or 1000ms which is not good for real-time apps, therefore the `limit` is not sent to Binance in particular at this time, and all the limiting is done on the client-side in memory.\r\n\r\nWe will add this to the documentation shortly to avoid confusion.\r\n\r\nLet me know if that does not answer the question."
      },
      {
        "user": "1key",
        "created_at": "2020-03-01T14:56:23Z",
        "body": "Clear and fast answer!\r\nWill work around it then."
      },
      {
        "user": "kroitor",
        "created_at": "2020-03-01T14:59:12Z",
        "body": "@1key we will look into adding an option that would still store the entire orderbook and would always serve a number of bidasks as close as possible to `limit` , but in the general case an exchange orderbook may have less than any number of bid/asks (just like with fetchOrderBook over REST). So if the exchange is inactive, there may be very few or even zero orders on either side of the book. \r\n\r\nFeel free to reopen this if anything or just ask further questions if you have more. Thanks for the feedback!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why orderbook limits may return fewer entries than specified",
      "Strategy to handle variable orderbook entry counts",
      "Clarification of exchange vs client-side limitations",
      "Documentation of orderbook update behavior"
    ]
  },
  {
    "number": 6499,
    "title": "how to make a stoploss in binance?",
    "created_at": "2020-02-18T05:31:28Z",
    "closed_at": "2020-02-21T11:09:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/6499",
    "body": "how can i make a stoplimit order in both futures and spot?\r\nfirst i fetch orderId and call \r\nbinance.fapiPrivate_post_order({type:\"STOP_MARKET/TAKE_PROFIT_MARKET\" }) \r\nis it right?? but don't i need orderId to match quantity for the exact order?\r\nand what about the spot trade stoplimit?\r\n\r\nthanks",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/6499/comments",
    "author": "doongzzi",
    "comments": [
      {
        "user": "lookis",
        "created_at": "2020-02-18T20:21:13Z",
        "body": "there is no stop market order in spot, only in futures.\r\nand stop order doesn't stop some particular order, so you don't need any orderid to \"stop\"\r\njust build the parameters with stop price and quantity in \"params\" manually, stop order isn't an unified order type in ccxt"
      },
      {
        "user": "doongzzi",
        "created_at": "2020-02-19T02:15:32Z",
        "body": "thanks..stupid me"
      },
      {
        "user": "kroitor",
        "created_at": "2020-02-21T11:09:05Z",
        "body": "@doongzzi we will look into unifying this aspect soon, let us know if you have further difficulties. Feel free to reopen this issue or just ask questions if any. Closing this for now, if you don't mind,"
      }
    ],
    "satisfaction_conditions": [
      "Clarify the availability of stop-limit orders in Binance spot vs. futures markets",
      "Explain relationship between stop orders and original orders (orderId dependency)",
      "Define required parameters for creating stop orders in both markets"
    ]
  },
  {
    "number": 6252,
    "title": "[bitstamp] why is fetchOrder 'emulated'",
    "created_at": "2019-12-11T19:21:35Z",
    "closed_at": "2019-12-11T19:25:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/6252",
    "body": "`fetchOrder` in bitstamp It looks like a proper implementation, why is it market as 'emulated'?",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/6252/comments",
    "author": "npomfret",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2019-12-11T19:23:00Z",
        "body": "I think this is a leftover from an earlier version."
      },
      {
        "user": "npomfret",
        "created_at": "2019-12-11T19:25:52Z",
        "body": "Or perhaps the order isn't fully formed?  Does that count as 'emulated'?"
      },
      {
        "user": "kroitor",
        "created_at": "2019-12-11T19:26:52Z",
        "body": "> Does that count as 'emulated'?\r\n\r\nNope."
      },
      {
        "user": "npomfret",
        "created_at": "2019-12-11T19:27:10Z",
        "body": "ok, will do a PR now, thanks."
      },
      {
        "user": "kroitor",
        "created_at": "2019-12-11T19:28:10Z",
        "body": "> ok, will do a PR now, thanks.\r\n\r\nNo worries, I've already uploaded a fix ) The `'emulated'` value is only used in cases where a call is emulated via another endpoint for another call, if the endpoint in question is missing."
      },
      {
        "user": "npomfret",
        "created_at": "2019-12-11T19:29:18Z",
        "body": "Thanks!\r\n\r\nAny objection to adding:\r\n\r\n```\r\n    async fetchOrderTrades (id, symbol = undefined, since = undefined, limit = undefined, params = {}) {\r\n        const order = await this.fetchOrder (id, symbol, params);\r\n        return order['trades'];\r\n    }\r\n```\r\n\r\n?"
      },
      {
        "user": "kroitor",
        "created_at": "2019-12-11T19:30:36Z",
        "body": "@npomfret thx to you for pointing it out!\r\n\r\nNo objections whatsoever ) We already have a `fetchOrderStatus` wrapper in the base class anyway."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why the 'emulated' flag is applied to fetchOrder despite appearing complete",
      "Clarification of what constitutes an 'emulated' method in the library's context",
      "Consistency with the library's design philosophy for handling missing API endpoints"
    ]
  },
  {
    "number": 6148,
    "title": "no name module gdax() in ccxt ",
    "created_at": "2019-11-16T19:27:25Z",
    "closed_at": "2019-11-16T21:02:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/6148",
    "body": "import ccxt  # noqa: E402\r\n\r\nkraken = ccxt.kraken()\r\ngdax = gdax().ccxt\r\n\r\n\r\nI'd like work with this code part. Compiler cannot find function name as gdax(). Also I controlled the file, there is no function in the ccxt  master file. Has the function lost its continuity? How can I continue?",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/6148/comments",
    "author": "BahadirSoybakis",
    "comments": [
      {
        "user": "frosty00",
        "created_at": "2019-11-16T20:04:33Z",
        "body": "`gdax` is depreciated, please use `coinbasepro` instead )\r\n\r\nlet me know if you have any other issues"
      },
      {
        "user": "BahadirSoybakis",
        "created_at": "2019-11-16T20:29:34Z",
        "body": "gdax = ccxt.coinbasepro()\r\nthanks @frosty00  for your support.  "
      }
    ],
    "satisfaction_conditions": [
      "Identifies that the gdax() module name is deprecated",
      "Provides the current valid replacement module name",
      "Explains naming conventions for exchange modules in ccxt",
      "Addresses version compatibility concerns"
    ]
  },
  {
    "number": 6032,
    "title": "Passing keys to cli.py from keys.json",
    "created_at": "2019-10-24T10:09:15Z",
    "closed_at": "2019-10-24T10:14:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/6032",
    "body": "I've hunted for an answer. Using cli.py\r\n\r\nHow to pass keys from keys.json or keys.local.json to cli.py ? My below attempt failed. \r\n\r\n`    \"bitforex\":      { \"skip\": true },\r\n    \"bithumb\":       { \"skip\": true },\r\n    \"bitmex\":       {\"apiKey\": '****', \"secret\": '****'},\r\n    \"bitibu\":        { \"skip\": true },\r\n    \"bitkk\":         { \"skip\": true },\r\n`\r\n\r\n- OS: Ubuntu 18\r\n- Programming Language version: python\r\n- CCXT version: latest\r\n- Exchange: Bitmex\r\n- Method: keys\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/6032/comments",
    "author": "interzonez",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2019-10-24T10:14:54Z",
        "body": "@interzonez your attempt is almost correct, the contents of the file should be:\r\n\r\n```JavaScript\r\n{\r\n    \"bitmex\": {\"apiKey\": \"****\", \"secret\": \"****\"}\r\n}\r\n```\r\n\r\n\u2191 Use double quotes (`\"`) instead of single quotes (`'`) everywhere throughout the JSON file. \r\n\r\nThe two files work like this:\r\n\r\n- if `keys.local.json` is present, then\u00a0`cli.py` will load the keys from there\r\n- if `keys.local.json` is missing, `cli.py` will try to load the keys from `keys.json`, if it's present\r\n\r\nLet us know if that does not answer the question."
      },
      {
        "user": "interzonez",
        "created_at": "2019-10-24T12:38:13Z",
        "body": "Many thanks, works.\r\nWhat's the difference between using `keys.local.json` and `keys.json`  ?"
      },
      {
        "user": "kroitor",
        "created_at": "2019-10-24T13:16:23Z",
        "body": "> What's the difference between using keys.local.json and keys.json ?\r\n\r\n`keys.json` is used for shared keys that may be used on our Travis CI for private testing, so it is a part of the repo, and `keys.local.json` is your local override, that is not a part of the repo. I'd recommend to use `keys.local.json` for your personal keys and private testing."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of JSON syntax requirements for API key configuration files",
      "Clarification of file precedence between keys.json and keys.local.json",
      "Guidance on proper exchange-specific key structure in configuration files",
      "Differentiation between shared vs personal key storage approaches"
    ]
  },
  {
    "number": 5930,
    "title": "Oceanex API has different dynamics. Uses 2048 key.pem to generate key. How to get ccxt to work with oceanex?",
    "created_at": "2019-10-06T21:39:54Z",
    "closed_at": "2019-10-07T07:32:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/5930",
    "body": "Language: Python\r\nCCXT Version: Latest\r\nExchange: ccxt.oceanex()\r\n\r\nGeneral question, Ive successfully created a key on this exchange. Would like some guidance on what to place in the apiKey and secret attributes? Was the 2048 pem key placed as the apiKey attribute? \r\n\r\nThanks.",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/5930/comments",
    "author": "karlandoh",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2019-10-07T07:32:24Z",
        "body": "@karlandoh \r\n\r\n> Would like some guidance on what to place in the apiKey and secret attributes? Was the 2048 pem key placed as the apiKey attribute?\r\n\r\nYes, you should set the `apiKey` and the `secret` should be the full PEM, including the newlines and the RSA private key header/footer, as shown below:\r\n\r\nThis is how we tested this:\r\n\r\n```\r\n        \"apiKey\": \"ID3A7CE21239\",\r\n        \"secret\": \"-----BEGIN RSA PRIVATE KEY-----\\nMIIEpgIBAAKCAQEA3Mc4KehdS8hj1vieiT4P6gstimSARjTasYUw2QhNbHD1lAnh\\ngN92wjLRZvHhXdb6iO62kXJ5V+S5bGnPZTp5FwC/kFVGwHOEmG7Q6BJdLgsPmLF5\\nkBO1v9wIYJ3WuIB1JBaACPbuW/Qa1yTD+K089s0+XvRcbtLjYT/qH/sdHRujD0Kh\\nSJ8rKRy8V1i1lVV9rEHFvz9ZSauZ90mVXrvGCWWyDnsR76rWR/AXSXkKJnD+dESg\\n3X9JD+5C/Bhy1oI2DH12cpOswmWfHrnHwjuVArbJWUbFvF3cIoZO81lG7YUrei9q\\n9+4QTy1WxejALrOrImcpzGfL0lOugf/D9XNmrQIDAQABAoIBAQCRg3DeFjvfpf1A\\nA++h71jX3nQuodz16QI3PN0cPt+g2LbT0sthgGeqyYnA+y2aBwXDHepoKfYWWzdn\\nYDoEs0x6P9EC1WHjmH/NZESmoOvvW/T0pAzGTGdfRCv1WjLaujf7CCVtQyuJSdOi\\n96V+stfapx4zwYVmufKJ93FdkMn4kzQ25+5OP9Uk2gjZtuL12BbGZrVcFcJcNzLP\\nhcD354xO1iaZkrA6xHbx2gTPRLKZlqKs9G0OGX4Sh0ioAmUsBRaOHCdw3lxkb5Mc\\nUzLDve82kkLyKbZ+zuxUQiawHCl79UMwe9vODcvTk5dZvA+XuKTvFvkfWkH7yDlF\\ndyPfyzD1AoGBAPBb6WW8h4DVHHllqacwK5P6Rh80br1rwYc+IY/KeNLLJ1UQUDNN\\no0ISQXwivtRYrqOpRT3IdMIrudVZbtEEjI6j/1737nI/I+mPwguVZSfeJFklP5TU\\nmL1fDUWOibMnFsv3WyL/3bMPbxAwEBK/cLShbywSakkp3lcgT81JuO5vAoGBAOsl\\nHW0Ii2dgh2DPTJZmkWrf7Fl2QrwnuhvhrFkogz2kv2CIXMvuiDlDkwIBhGEpQLnq\\n4dY+uECvRalo0xNpvpehXzj/9zpFW/2RQOkQS/ykEwfl9Xdw2BirgLM7LWLVG2A9\\n1NGY6JpzbsVJ11F/EobZFgy1AnmSgsnbHwa4cMqjAoGBAM0AF1jGK2weV2LS6pfF\\n5eUYGKaUub6lITKQM1/IeLSQwMM0XrLjDNNVbrTJjaje2lSMEppXVf4l/SGSXYm4\\nL4mZJj2BiMW4RJD4I7BtgxE1zhqaQlhV2s/pOhCRObCrLi5YkkqPoC8QgtFzrMHQ\\ntffZmFAmhLBSHWiCDo4wyqHRAoGBAJfkq7No23P5mLmCbvigXMLqzqOjbsxX5TJp\\nfolBUDWbnDvhGgBpnvlOm0GqdTbGDReLkEJy1VaDYb5jBiX+Iq2UAgyx26N6dke/\\ncmyaqFsUKW7qrrtu20hkUIh2a4TyH/L1Pen+mhJbCmzKnBn6uZ79z+55ZpXdfDqk\\nHtCah9F9AoGBAO9x28be0Vum10DdyKzeKgIfLcdoSaP+S/Kmg3x3DnYbjM1DYWSL\\nwULNibKj7lInzMWHrFFX7699QM9U61AXBMeKucTHsa70qZ1xuuYjM5pWMuHNiDjj\\nop2PjLmtGBx0ZZcy2viShsGS1/mzTMH+9p0JNOsk/aUaQIng3R45ok9v\\n-----END RSA PRIVATE KEY-----\"\r\n```\r\n\r\n( \u2191\u00a0This particular key will not work, I've posted it here just to demonstrate the usage, however, it should work with your key).\r\n\r\nLet us know if that does not answer the question."
      }
    ],
    "satisfaction_conditions": [
      "Clarifies which parts of Oceanex credentials map to CCXT's `apiKey` and `secret` parameters",
      "Specifies proper formatting requirements for the PEM key in the `secret` field",
      "Confirms compatibility with CCXT's Oceanex integration"
    ]
  },
  {
    "number": 5359,
    "title": "Format sub-account Binance request",
    "created_at": "2019-06-25T12:58:21Z",
    "closed_at": "2019-06-25T13:39:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/5359",
    "body": "I'm looking into the Implicit API Methods of the manual but can't figure out how to call those sub-account functions for Binance.\r\n\r\nI thought it would be:\r\n\r\n`privateGetSubAccountList()\r\n`\r\n\r\nBut that doesn't work. Tried a few different ones but no luck. Any chance you could steer me in the right direction?\r\n\r\n\r\nLanguage: NodeJs\r\nExchange: Binance",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/5359/comments",
    "author": "charlie-eth",
    "comments": [
      {
        "user": "frosty00",
        "created_at": "2019-06-25T13:34:14Z",
        "body": "Hi there @calbertuk and thank you for using ccxt.\r\n\r\n> I'm looking into the Implicit API Methods of the manual but can't figure out how to call those sub-account functions for Binance.\r\n\r\nImplicit API methods are generated from the `exchange.api` property of an exchange instance. \r\n\r\nLooking at the `.api` of a binance object this is what I see:\r\n\r\n```\r\n  wapi:\r\n   { post: [ 'withdraw', 'sub-account/transfer' ],\r\n     get:\r\n      [ 'depositHistory',\r\n        'withdrawHistory',\r\n        'depositAddress',\r\n        'accountStatus',\r\n        'systemStatus',\r\n        'apiTradingStatus',\r\n        'userAssetDribbletLog',\r\n        'tradeFee',\r\n        'assetDetail',\r\n        'sub-account/list',\r\n        'sub-account/transfer/history',\r\n        'sub-account/assets' ] },\r\n```\r\n\r\nHence to generate the method that you want you need to join the parts of the endpoint you want. In this case I believe you are looking for `wapiGetSubAccountList`.\r\n\r\nNote that here the `-` is removed since it would be an invalid method in javascript otherwise. Let me know if you have any more questions : )"
      },
      {
        "user": "charlie-eth",
        "created_at": "2019-06-25T13:39:38Z",
        "body": "That's all, thanks."
      }
    ],
    "satisfaction_conditions": [
      "Clarifies the correct API endpoint structure for Binance sub-account functions",
      "Identifies the correct API category (wapi vs private) for sub-account endpoints",
      "Explains the method name transformation rules for special characters in endpoints"
    ]
  },
  {
    "number": 5345,
    "title": "[therock] dealing with delisted currency",
    "created_at": "2019-06-23T17:34:27Z",
    "closed_at": "2019-06-23T19:03:00Z",
    "labels": [
      "enhancement",
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/5345",
    "body": "I'm getting this error when requesting withdrawals: `therock does not have currency code USD`.\r\n\r\nThat currency used to be supported.  Is there a recommended way to deal with this?  I'm thinking to just pass the `currency` directly.",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/5345/comments",
    "author": "npomfret",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2019-06-23T18:19:46Z",
        "body": "```Python\r\nexchange.currencies['USD'] = {\r\n    'id': 'USD',\r\n    'code': 'USD',\r\n}\r\nexchange.withdraw ('USD' ...\r\n```\r\n\r\nDoes this help?\n\n---\n\nAlternatively, we could add some switch or option across all exchanges, something like \"useCurrencyCodesAsIds\", that would skip the lookup in `this.currency()` base method. Easy to do, as we don't have to edit all exchanges."
      },
      {
        "user": "npomfret",
        "created_at": "2019-06-23T19:03:00Z",
        "body": "thanks, your first suggestion worked."
      }
    ],
    "satisfaction_conditions": [
      "Provides a way to handle withdrawals for currencies no longer officially supported by the exchange",
      "Offers a method to work with currency identifiers without relying on exchange-provided currency lists",
      "Maintains withdrawal functionality despite currency delisting"
    ]
  },
  {
    "number": 5296,
    "title": "New Exchange: HollaEx",
    "created_at": "2019-06-14T01:19:09Z",
    "closed_at": "2020-03-05T05:22:12Z",
    "labels": [
      "question",
      "new exchange"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/5296",
    "body": "All endpoints added and tested. Failed test for Python, unsure why.\r\n\r\n```\r\n<type 'exceptions.KeyError'> 'hollaex' \r\n\r\n          File \"python/test/test.py\", line 403, in <module>\r\n            main()\r\n\r\n          File \"python/test/test.py\", line 380, in main\r\n            exchange = exchanges[argv.exchange] (explain @ run-tests.js:173)\r\n\r\n\r\nFAIL [\"hollaex\"] (run-tests.js:251)\r\n```\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/5296/comments",
    "author": "swkoyo",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2019-06-14T05:39:01Z",
        "body": "You can run that test with Python to see more details:\r\n\r\n```shell\r\n# in the ccxt folder\r\n$ npm run build\r\n$ python python/test/test.py hollaex --verbose\r\n```"
      },
      {
        "user": "swkoyo",
        "created_at": "2019-06-14T05:47:34Z",
        "body": "Thanks for the reply. Unfortunately, I'm still getting the same error messages...\r\n\r\n```\r\nroot@1b73c2b29588:/ccxt# python python/test/test.py hollaex --verbose\r\n<type 'exceptions.KeyError'> 'hollaex' \r\n\r\n  File \"python/test/test.py\", line 403, in <module>\r\n    main()\r\n\r\n  File \"python/test/test.py\", line 380, in main\r\n    exchange = exchanges[argv.exchange]\r\n\r\n<type 'exceptions.KeyError'> 'hollaex' \r\n\r\n  File \"python/test/test.py\", line 403, in <module>\r\n    main()\r\n\r\n  File \"python/test/test.py\", line 380, in main\r\n    exchange = exchanges[argv.exchange]\r\n```"
      },
      {
        "user": "kroitor",
        "created_at": "2019-06-14T05:48:23Z",
        "body": "@brandonkimmmm do you see that after running `npm run build`?"
      },
      {
        "user": "swkoyo",
        "created_at": "2019-06-14T05:48:26Z",
        "body": "JS and PHP are passing the tests. The only one not passing is Python. "
      },
      {
        "user": "kroitor",
        "created_at": "2019-06-14T05:53:41Z",
        "body": "@brandonkimmmm do you have a ccxt installed with pip globally? It can cause interference with the code of the tested `ccxt` package-folder (same name) going through the local tests. You can simply `pip uninstall` the global `ccxt` if that is the case.\n\n---\n\nIf a global `ccxt` is not installed on your system and you still get the error, but you can't run `npm run build` because you don't have `pandoc` \u2013 you can skip the build phase and just `npm run export-exchanges` \u2013\u00a0that should populate the local ccxt package-folder with hollaex and that should fix the KeyError."
      },
      {
        "user": "swkoyo",
        "created_at": "2019-06-14T05:54:23Z",
        "body": "@kroitor I'm running everything through the docker container and dont have ccxt installed globally"
      },
      {
        "user": "kroitor",
        "created_at": "2019-06-14T05:58:25Z",
        "body": "@brandonkimmmm then this should work:\r\n\r\n```\r\n# in ccxt repo folder\r\nnpm run export-exchanges\r\npython python/test/test.py hollaex --verbose\r\n```\r\n\r\nLet us know if that doesn't help.\n\n---\n\nAlso, before you run the tests, in order to test the private APIs, I suggest you to create a local `keys.local.json` file in the repo folder with your private key for testing the `fetchBalance`, `fetchOrder`, etc:\r\n\r\n`keys.local.json` in the repo root folder:\r\n\r\n```\r\n{\r\n    \"hollaex\": {\r\n        \"apiKey\": \"YOUR_API_KEY\",\r\n        \"secret\": \"YOUR_SECRET\"\r\n    }\r\n}\r\n```\r\n\r\n\u2191\u00a0and then run the tests after adding that file. That will make sure that all tests are fine indeed. No worries, it will not change or alter you balance in any way, all tests are non-intrusive."
      },
      {
        "user": "swkoyo",
        "created_at": "2019-06-14T06:07:22Z",
        "body": "@kroitor Hmmm, I followed the steps but am still getting the same error messages. \r\n\r\n```\r\nroot@1b73c2b29588:/ccxt# python python/test/test.py hollaex --verbose\r\n<type 'exceptions.KeyError'> 'hollaex' \r\n\r\n  File \"python/test/test.py\", line 403, in <module>\r\n    main()\r\n\r\n  File \"python/test/test.py\", line 380, in main\r\n    exchange = exchanges[argv.exchange]\r\n\r\n<type 'exceptions.KeyError'> 'hollaex' \r\n\r\n  File \"python/test/test.py\", line 403, in <module>\r\n    main()\r\n\r\n  File \"python/test/test.py\", line 380, in main\r\n    exchange = exchanges[argv.exchange]\r\n```\r\n\r\nI'm working on a fork of the repo that is `246 commits ahead, 371 commits behind ccxt:master.` Could this be a problem? Also, I had to `pip install tox` while inside the docker container. Not sure if that would affect anything. "
      },
      {
        "user": "kroitor",
        "created_at": "2019-06-14T06:24:19Z",
        "body": "@brandonkimmmm are you sure that:\r\n\r\n1. you did `npm run export-exchanges` before trying the tests?\r\n2. you did `pip list` and there's no `ccxt` there (if it's there, need to `pip uninstall ccxt` before running local tests)"
      },
      {
        "user": "swkoyo",
        "created_at": "2019-06-14T06:34:31Z",
        "body": "@kroitor I found the problem. I didn't have ccxt installed as a local package but it was present in the docker container. I'm getting the proper error messages now."
      },
      {
        "user": "kroitor",
        "created_at": "2019-06-14T06:54:49Z",
        "body": "> I didn't have ccxt installed as a local package but it was present in the docker container.\r\n\r\nYep, that's what I was asking about \u2013\u00a0if it was installed as a local package inside the environment (inside the docker container). Glad you've figured it out! Thx for the feedback!"
      },
      {
        "user": "swkoyo",
        "created_at": "2019-06-14T07:29:49Z",
        "body": "@kroitor Now all the tests are passing except for `--python3` tests. Not really getting any useful info either. \r\n\r\n```\r\nroot@e46c60995e4e:/ccxt# python3 python/test/test.py hollaex --verbose\r\n<class 'KeyError'> 'hollaex' \r\n\r\n  File \"python/test/test.py\", line 403, in <module>\r\n    main()\r\n\r\n  File \"python/test/test.py\", line 380, in main\r\n    exchange = exchanges[argv.exchange]\r\n\r\n<class 'KeyError'> 'hollaex' \r\n\r\n  File \"python/test/test.py\", line 403, in <module>\r\n    main()\r\n\r\n  File \"python/test/test.py\", line 380, in main\r\n    exchange = exchanges[argv.exchange]\r\n```\r\n```\r\nroot@e46c60995e4e:/ccxt# python3 -V\r\nPython 3.6.7\r\n```"
      },
      {
        "user": "kroitor",
        "created_at": "2019-06-14T07:32:23Z",
        "body": "@brandonkimmmm check if you have `pip3 list ccxt` as well, `python` and `python3` may be different as well as `pip` and `pip3`."
      },
      {
        "user": "swkoyo",
        "created_at": "2019-06-14T07:36:25Z",
        "body": "@kroitor Awesome yeah that was the issue. Thanks a lot!"
      },
      {
        "user": "lacksfish",
        "created_at": "2019-07-17T12:42:41Z",
        "body": "@kroitor @brandonkimmmm could you elaborate further what a mortal human has to do inside the docker container to get rid of the KeyError? All I really want to do is run the tests ...\r\n\r\n```\r\nFAILED exchangeName (Python): (explain @ run-tests.js:187)\r\n\r\n        <type 'exceptions.KeyError'> 'exchangeName' \r\n        \r\n          File \"python/test/test.py\", line 409, in <module>\r\n            main()\r\n        \r\n          File \"python/test/test.py\", line 386, in main\r\n            exchange = exchanges[argv.exchange] (explain @ run-tests.js:190)\r\n\r\nFAILED exchangeName (Python 2): (explain @ run-tests.js:187)\r\n\r\n        <type 'exceptions.KeyError'> 'exchangeName' \r\n        \r\n          File \"python/test/test.py\", line 409, in <module>\r\n            main()\r\n        \r\n          File \"python/test/test.py\", line 386, in main\r\n            exchange = exchanges[argv.exchange] (explain @ run-tests.js:190)\r\n\r\nFAILED exchangeName (Python 3): (explain @ run-tests.js:187)\r\n\r\n         (explain @ run-tests.js:190)\r\n\r\nWARN exchangeName (PHP): (explain @ run-tests.js:188)\r\n\r\n        string(11) \"./keys.json\"\r\n        PHP Notice:  Undefined index: exchangeName in /ccxt/php/test/test.php on line 230\r\n        PHP Warning:  A non-numeric value encountered in /ccxt/php/test/test.php on line 243\r\n        PHP Warning:  A non-numeric value encountered in /ccxt/php/test/test.php on line 243\r\n        0 (explain @ run-tests.js:190)\r\nFAIL [\"exchangeName\"] (run-tests.js:268)\r\nAll done, 1 failed (run-tests.js:273)\r\nnpm ERR! code ELIFECYCLE\r\nnpm ERR! errno 1\r\nnpm ERR! ccxt@1.18.941 test: `npm run build && node run-tests \"exchangeName\"`\r\nnpm ERR! Exit status 1\r\nnpm ERR! \r\nnpm ERR! Failed at the ccxt@1.18.941 test script.\r\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\r\n\r\n```\n\n---\n\nFrom what I gathered, the docker is provided for ease of use, but what's the benefit if it does not work out of the box? I had to copy some commands from the travis script, and source the rest of the tricks and fixes from various issue threads... \r\n\r\nSo far I'm doing:\r\n\r\n```\r\nsudo -H pip3 install --upgrade setuptools pip wheel requests pyopenssl six tox twine setuptools web3 aiohttp requests cryptography pyopenssl\r\npip uninstall ccxt\r\n```\r\n\r\nto get the tests to work half-way"
      },
      {
        "user": "kroitor",
        "created_at": "2019-07-18T09:44:24Z",
        "body": "@lacksfish \r\n\r\n> could you elaborate further what a mortal human has to do inside the docker container to get rid of the KeyError?\r\n\r\nYou're running a wrong command. There's no exchange called `exchangeName`. The `exchangeName` is supposed to be substituted for a real exchange id by you, if you want to run the public tests."
      },
      {
        "user": "lacksfish",
        "created_at": "2019-07-18T10:27:45Z",
        "body": "I substituted the exchange I'm working on for \"exchangeName\". It is a placeholder only."
      },
      {
        "user": "kroitor",
        "created_at": "2020-03-05T05:22:12Z",
        "body": "@lacksfish then you need to make sure that the `npm run export-exchanges` stage was properly executed upon `npm run build`. And make sure that there's no globally installed previous version of ccxt with your `pip list`.\n\n---\n\nHollaEx has been listed in CCXT 1.23.61+! Thank you for your help and patience!"
      }
    ],
    "satisfaction_conditions": [
      "Ensure the exchange is properly registered in the test environment",
      "Resolve environment conflicts between local/global package installations",
      "Validate successful execution of build/export steps before testing",
      "Ensure test commands reference valid exchange IDs"
    ]
  },
  {
    "number": 5260,
    "title": "Possible bug in commonCurrencies",
    "created_at": "2019-06-08T00:00:42Z",
    "closed_at": "2019-06-08T00:05:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/5260",
    "body": "- OS: *\r\n- Programming Language version: python\r\n- CCXT version: 1.18.593-643\r\n- Exchange: bitfinex\r\n- Method: commonCurrencies\r\n\r\nHi, I'm using the commonCurrencies in my code for margin trading on bitfinex. It think this has been broken in a recent release. You can see this the following way:\r\n\r\nif I do:\r\n```Python\r\nprint(str(ccxt.bitfinex.commonCurrencies.items()))\r\n```\r\nI get:\r\n```\r\ndict_items([('XBT', 'BTC'), ('BCC', 'BCH'), ('DRK', 'DASH'), ('BCHABC', 'BCH'), ('BCHSV', 'BSV')])\r\n```\r\n\r\nWhile this is not the list found in the bitfinex.py.. My guess is that this is Kraken (?)\r\n\r\nOr am I making a mistake somewhere? ",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/5260/comments",
    "author": "jdieks",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2019-06-08T00:05:45Z",
        "body": "> Or am I making a mistake somewhere?\r\n\r\nYes, the `commonCurrencies` is not a list of currencies for the exchange, it's a list of substitutions for for all the exchanges, which is inherited from the Exchange base class.\r\n\r\nIf you want to get a list of currencies for an exchange, you should check `.currencies` instead of `.commonCurrencies` after calling `load_markets()`:\r\n\r\n```Python\r\nfrom pprint import pprint\r\nimport ccxt\r\nexchange = ccxt.bitfinex({ 'enableRateLimit': True })\r\nexchange.load_markets()\r\npprint(exchange.currencies)\r\n```\r\n\r\nLet us know if that doesn't answer the question )"
      },
      {
        "user": "jdieks",
        "created_at": "2019-06-08T00:18:20Z",
        "body": "Hi Kroitor,\r\n\r\nThanks for the reply. Yes, I see how it works now.\r\nIn an older version I used the ccxt.bitfinex.commonCurrencies.items() list to convert the ccxt commoncurrencies back to the ones that the api of bitfinex wants to see (e.g. BCH:BAB).\r\n\r\nBut I see that I can indeed do exactly the same thing with the currencies command. Thanks for the help.\r\n\r\nHave a good night."
      }
    ],
    "satisfaction_conditions": [
      "Clarification of the distinction between exchange-specific currency data and global common currency substitutions",
      "Method to retrieve exchange-specific currency codes required by Bitfinex API",
      "Clear documentation of proper data access patterns after market loading",
      "Differentiation between base class properties and exchange-specific implementations"
    ]
  },
  {
    "number": 5069,
    "title": "Bitfinex JS symbols.map is not a functiom",
    "created_at": "2019-05-07T04:46:35Z",
    "closed_at": "2019-05-07T05:06:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/5069",
    "body": "- OS: Javascript\r\n- Programming Language version: v11.13.0\r\n- CCXT version: latest\r\n- Exchange: bitfinex\r\n- Method: fetchTickers\r\n\r\nError: TypeError: symbols.map is not a function\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/5069/comments",
    "author": "ahmedbodi",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2019-05-07T04:57:00Z",
        "body": "@ahmedbodi can you please show your code to reproduce it? a full error stack and your verbose request/response? Can't reproduce it with the following code:\r\n\r\n```JavaScript\r\nconst ccxt = require ('ccxt')\r\nconst exchange = new ccxt.bitfinex ({ enableRateLimit: true })\r\n;(async () => {\r\n    const tickers = await exchange.fetchTickers ()\r\n   console.log (tickers)\r\n}) ()\r\n```"
      },
      {
        "user": "ahmedbodi",
        "created_at": "2019-05-07T04:57:55Z",
        "body": "```\r\nconst ccxt = require ('ccxt')\r\n\r\nlet clients = {}\r\n\r\nasync function fetchTickers(client, market)\r\n{\r\n    if (client.has['fetchTickers'])\r\n    {\r\n        try {\r\n            console.log(\"[\" + client.name + \"] Fetch \" + market + \" Tickers\");\r\n            ticker = await client.fetchTickers(market);\r\n        } catch (e) {\r\n            console.log(\"[\" + client.name + \"] Error Fetching \" + market + \" Tickers: \" + e);\r\n        }\r\n    }\r\n}\r\n\r\nasync function fetchOHLCVs(client, market)\r\n{\r\n    if (client.has['fetchOHLCV'])\r\n    {\r\n        try {\r\n            console.log(\"[\" + client.name + \"] Fetch \" + market + \" OHLCV\");\r\n            ohlcv = await client.fetchOHLCV(market);\r\n        } catch (e) {\r\n            console.log(\"[\" + client.name + \"] Error Fetching \" + market + \" OHLCV: \" + e);\r\n        }\r\n    }\r\n}\r\n\r\nasync function fetchOrderBooks(client, market)\r\n{\r\n    if (client.has['fetchOrderBook'])\r\n    {\r\n        try {\r\n            console.log(\"[\" + client.name + \"] Fetch \" + market + \" OrderBook\");\r\n            orderbook = await client.fetchOrderBook(market);\r\n        } catch (e) {\r\n            console.log(\"[\" + client.name + \"] Error Fetching \" + market + \"OrderBooks: \" + e);\r\n        }\r\n    }\r\n}\r\n\r\nasync function main()\r\n{\r\n    for (i in ccxt.exchanges)\r\n    {\r\n        // Create Exchange Client\r\n        exchange = ccxt.exchanges[i];\r\n        clients[exchange] = new ccxt[exchange]({'enableRateLimit': true});\r\n    }\r\n\r\n    // Setup Loops\r\n    while(true)\r\n    {\r\n        for (i in clients)\r\n        {\r\n            client = clients[i];\r\n\r\n            try {\r\n                // Load All Markets and currencies\r\n                markets = await client.loadMarkets();\r\n                currencies = client.currencies;\r\n            } catch (e) {\r\n                console.log(\"[\" + client.name + \"] Error: \" + e)\r\n            }\r\n\r\n            for (market in markets)\r\n            {\r\n                // Fetch Tickers\r\n                //await new Promise(resolve => setTimeout(() => resolve(fetchTickers(client, market)), 60));\r\n\r\n                // Fetch OHLCV\r\n                //await new Promise(resolve => setTimeout(() => resolve(fetchOHLCVs(client, market)), 60));\r\n\r\n                // Fetch OrderBook\r\n                //await new Promise(resolve => setTimeout(() => resolve(fetchOrderBooks(client, market)), 60));\r\n                await Promise.all([fetchTickers(client, market), fetchOHLCVs(client, market), fetchOrderBooks(client, market)]);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nmain()\r\n```"
      },
      {
        "user": "kroitor",
        "created_at": "2019-05-07T04:58:43Z",
        "body": "@ahmedbodi can you remove all the unnecessary parts? (make it the shortest possible snippet to reproduce the issue).\r\n\r\nDoes this work for you\r\n\r\n```JavaScript\r\nconst ccxt = require ('ccxt')\r\nconst exchange = new ccxt.bitfinex ({ enableRateLimit: true })\r\n;(async () => {\r\n    const tickers = await exchange.fetchTickers ()\r\n   console.log (tickers)\r\n}) ()\r\n```\r\n\r\n?"
      },
      {
        "user": "ahmedbodi",
        "created_at": "2019-05-07T04:59:40Z",
        "body": "Strange. that works fine"
      },
      {
        "user": "kroitor",
        "created_at": "2019-05-07T05:03:28Z",
        "body": "@ahmedbodi there's an error in your code, you're passing `market` to `fetchTickers` as the first argument, but it doesn't accept a `market` in the first argument:\r\n\r\n```JavaScript\r\n            ticker = await client.fetchTickers(market); //  \u2190 here\r\n            // should be \r\n            ticker = await client.fetchTickers();\r\n```\r\n\r\nThere are two methods:\r\n\r\n- `fetchTicker (symbol)` (for one symbol)\r\n- `fetchTickers ()` (for all symbols)\r\n\r\n\u2191 You're calling fetchTickers with a `market` argument which is a mistake."
      },
      {
        "user": "ahmedbodi",
        "created_at": "2019-05-07T05:05:07Z",
        "body": "ah good catch. fixed.  testing now"
      },
      {
        "user": "kroitor",
        "created_at": "2019-05-07T05:06:02Z",
        "body": "@ahmedbodi ok, let me know if that doesn't resolve the issue for you. Feel free to reopen this or just ask further questions if any."
      }
    ],
    "satisfaction_conditions": [
      "Clarification of correct method parameters for fetchTickers()",
      "Differentiation between fetchTicker(symbol) and fetchTickers() API methods",
      "Explanation of CCXT method signature requirements",
      "Documentation of proper parameter usage patterns in CCXT"
    ]
  },
  {
    "number": 4828,
    "title": "The \"percentage\" is not returned for all exchanges in loadMarkets()",
    "created_at": "2019-03-13T17:44:19Z",
    "closed_at": "2019-03-13T20:09:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/4828",
    "body": "OS: Windows 10\r\nProgramming Language version: Node.js\r\nCCXT version: #465\r\nExchange: All Exchanges\r\nNode.js 11.9.0 installed\r\nMethod: exchange.loadMarkets()\r\n\r\nHello!\r\n\r\nI have a question about the **\"percentage\"** parameter when requesting:\r\n```javascript\r\nconst markets = await exchange.loadMarkets()\r\n```\r\nI could see that for some exchanges **\"percentage\"** is present in the returnd JSON and other exchanges not. If looking at the below example binance has **\"percentage\"** and coinex doesn't.\r\n\r\nFor coinex, this information is shown. Then I wonder how to think. Is this **\"percentage\"** or not. I am bit confused there?\r\n**\"taker\":0.001,\"maker\":0.001**\r\n\r\n**JSON for binance and coinex:**\r\n**coinex**\r\n\"BBN/BCH\":{\"limits\":{\"amount\":{\"min\":1},\"price\":{\"min\":1e-8}},\"precision\":{\"amount\":8,\"price\":8},\"taker\":0.001,\"maker\":0.001,\"id\":\"BBNBCH\",\"symbol\":\"BBN/BCH\",\"base\":\"BBN\",\"quote\":\"BCH\",\"baseId\":\"BBN\",\"quoteId\":\"BCH\",\"active\":true\r\n\r\n**binance**\r\n\"ETH/BTC\":{\"limits\":{\"amount\":{\"min\":0.001,\"max\":100000},\"price\":{},\"cost\":{\"min\":0.001}},\"precision\":{\"base\":8,\"quote\":8,\"amount\":3,\"price\":6},\"tierBased\":false,\"percentage\":true,\"taker\":0.001,\"maker\":0.001,\"id\":\"ETHBTC\",\"symbol\":\"ETH/BTC\",\"base\":\"ETH\",\"quote\":\"BTC\",\"baseId\":\"ETH\",\"quoteId\":\"BTC\"\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/4828/comments",
    "author": "jackpotcityco",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2019-03-13T20:09:17Z",
        "body": "> Then I wonder how to think. Is this \"percentage\" or not. I am bit confused there?\r\n\r\nIn general, it's always a percentage, unless percentage is defined (not undefined) and has a value of `false`. If you don't see it defined anywhere or it has a value different from `false`, then it's true. \r\n\r\nSo, in this particular case you can assume percentages safely.\r\n\r\nLet us know if that doesn't answer the question. We will unify this aspect with coinex and other exchanges, thx for reporting!"
      },
      {
        "user": "jackpotcityco",
        "created_at": "2019-03-14T01:13:21Z",
        "body": "> In general, it's always a percentage, unless percentage is defined (not undefined) and has a value of false. If you don't see it defined anywhere or it has a value different from false, then it's true.\r\n\r\nThank you for the clarification. I will go with percentages then. \r\nThat is great to find something that can help out for the library!\r\n\r\n"
      }
    ],
    "satisfaction_conditions": [
      "Clarification of default behavior when 'percentage' field is absent",
      "Explanation of how to handle exchange-specific discrepancies in fee representation",
      "Confirmation of future standardization efforts"
    ]
  },
  {
    "number": 4779,
    "title": "Question about: enableRateLimit': true",
    "created_at": "2019-03-03T23:25:59Z",
    "closed_at": "2019-03-04T13:32:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/4779",
    "body": "OS: Windows 10\r\nProgramming Language version: Node.js\r\nCCXT version: #465\r\nExchange: Binance\r\nNode.js 11.9.0 installed\r\nMethod: exchange.fetchOrderBook\r\n\r\nHello!\r\n\r\nI have a working code below to get the orderbooks for 3 symbols in a loop at Binance.\r\n\r\nMy question is about the ratelimit. I know Binance has 1200 requests/minute but I am a bit confused when I see the below ratelimit information.\r\n\r\n**Should I in my code use: 'enableRateLimit': true ?**\r\n\r\nenableRateLimit': true (Takes 3 seconds)\r\n**enableRateLimit': false (Takes 1 second) This is not a good id\u00e9a to do?**\r\n\r\nAssume that I only would run this code once every minute which would be clearly below 1200 requests/minute. Is there Also a limit as the manual says to ONLY do 1 HTTP requests per 2000 milliseconds as this also can get ones IP banned?\r\n\r\n\r\n`**\"rateLimits\": [{\r\n    \"rateLimitType\": \"REQUESTS\",\r\n    \"interval\": \"MINUTE\",\r\n    \"limit\": 1200\r\n  },**\r\n\r\n### _\"rateLimit: A request rate limit in milliseconds. Specifies the required minimal delay between two consequent HTTP requests to the same exchange\"_`\r\n\r\n```javascript\r\n'use strict';\r\nconst ccxt = require('ccxt');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\n\r\nvar i;\r\nconst exchangename = \"binance\";\r\nconst exchange = new ccxt.binance({\r\n    'enableRateLimit': true\r\n});\r\n\r\n(async () => {\r\n    console.log(`start`);\r\n    const start = Date.now();\r\n\r\n\r\n    var orderbookPromises = []\r\n    var symbols = ['ETH/BTC', 'LTC/BTC', 'ZRX/ETH']\r\n    for (i = 0; i < symbols.length; i++) {\r\n\r\n        const symbol = symbols[i]\r\n        \r\n        try {\r\n                let tickerProcessing = new Promise(async (resolve) => {\r\n                    const orderbook = await exchange.fetchOrderBook(symbol, 5);\r\n\r\n                    const exchangename2 = exchangename + '#' + symbol.replace(\"/\", \"\")\r\n                    const dumpFile = path.join(__dirname, 'orderbooks', `${exchangename2}Orderbook.txt`);\r\n                await fs.promises.writeFile(dumpFile, JSON.stringify(orderbook));\r\n                resolve()\r\n            })\r\n            orderbookPromises.push(tickerProcessing)\r\n\r\n        } catch (e) {\r\n            console.error(e);\r\n        }\r\n    }\r\n\r\n    // wait for all of them to execute or fail\r\n    await Promise.all(orderbookPromises)\r\n\r\n\r\n    const end = Date.now();\r\n    console.log(`Done in ${(end - start) / 1000} seconds`);\r\n})();\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/4779/comments",
    "author": "jackpotcityco",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2019-03-04T13:18:34Z",
        "body": "> Should I in my code use: 'enableRateLimit': true ?\r\n\r\nDepends on what your code does, of course. We can't answer what your code should do )\r\n\r\n> enableRateLimit': false (Takes 1 second) This is not a good id\u00e9a to do?\r\n\r\nIt's ok as long as you know what you're doing.\r\n\r\n> Assume that I only would run this code once every minute which would be clearly below 1200 requests/minute. \r\n\r\nIn that case, the above idea is ok.\r\n\r\n> Is there Also a limit as the manual says to ONLY do 1 HTTP requests per 2000 milliseconds as this also can get ones IP banned?\r\n\r\nNo, there is no such specific limit defined in the Manual. The Manual says that there's a default value for the rate limit, but the actual threshold value depends on the exchange in question. Each exchange has its own rate-limits. So, you should treat that value in a flexible way. The Manual also says that the default will be sub-optimal, so the user should tweak those values for the needs of his application.\r\n\r\nLet us know if that doesn't answer the question."
      },
      {
        "user": "jackpotcityco",
        "created_at": "2019-03-04T15:24:58Z",
        "body": "It was the perfect answer. It was a good confirmation to be on the sure side.\r\nSo it is a default value and I should tweak it according the the different exchanges  and usecases then.\r\n\r\nThank you for your help!"
      }
    ],
    "satisfaction_conditions": [
      "Clarify when to enable/disable rate limiting based on request frequency and exchange requirements",
      "Explain how default rate limits relate to exchange-specific requirements",
      "Provide decision criteria for rate limit configuration based on use case",
      "Address relationship between request timing and total request count limits"
    ]
  },
  {
    "number": 4684,
    "title": "Add fetchBalance on trade account Kucoin2",
    "created_at": "2019-02-18T15:29:43Z",
    "closed_at": "2019-02-18T15:52:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/4684",
    "body": "At the moment fetchBalance() on Kucoin2 (newly released platform) returns balance from main account with no option to get balance from the trade account. Could this be added please?",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/4684/comments",
    "author": "charlie-eth",
    "comments": [
      {
        "user": "MarcelBeining",
        "created_at": "2019-02-18T15:45:52Z",
        "body": "+1"
      },
      {
        "user": "kroitor",
        "created_at": "2019-02-18T15:53:57Z",
        "body": "@calbertuk you can choose whatever it is:\r\n\r\n```JavaScript\r\nfetchBalance ({'type': 'trade'}) // this is the default as of version 1.18.248\r\n```\r\n\r\nor\r\n\r\n```JavaScript\r\nfetchBalance ({'type': 'main'}) // this is the default prior to version 1.18.248\r\n```\r\n\r\nLet us know if that does not help."
      },
      {
        "user": "charlie-eth",
        "created_at": "2019-02-18T15:55:10Z",
        "body": "That's perfect, thanks."
      },
      {
        "user": "MarcelBeining",
        "created_at": "2019-02-18T16:31:08Z",
        "body": "Oh, no wonder, on pip, latest version is 1.18.247 ^^"
      }
    ],
    "satisfaction_conditions": [
      "Support for specifying account type (trade/main) when fetching balances",
      "Clear documentation/interface for account type selection",
      "Backward compatibility with previous version behavior"
    ]
  },
  {
    "number": 4601,
    "title": "fetchMinOrderAmounts is used in wrong location",
    "created_at": "2019-02-01T14:18:44Z",
    "closed_at": "2019-02-01T14:38:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/4601",
    "body": "You scrape the minOrderAmounts nicely fro kraken, but they are per currency, not per pair. As such I would expect them to be populated when I do a call to `fetchCurrencies`, and not in `fetchMarkets`.\r\n\r\n- Programming Language version: es6\r\n- CCXT version: 1.18.190\r\n- Exchange: kraken\r\n- Method: fetchMarkets\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/4601/comments",
    "author": "Morriz",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2019-02-01T14:38:22Z",
        "body": "@Morriz min order amount is actually a property of a market (pair), if you think of it, this is more flexible than having min order amount per currency. \r\n\r\nSome exchanges have min order amount that varies for the same currency in different pairs. It is really a per-market property, not a per-currency property, therefore we load it for markets, not for currencies.\r\n\r\nYou can't trade (place orders) with a single currency \u2013 orders are not compatible with single currencies logically. You can trade with a pair of currencies only. In that pair you order one currency for a promise to pay another currency. So min order amount is always related to one currency in a pair of currencies (logically). And putting min order amount into the currency structure would be a structural mistake that would allow to handle Kraken, but no other exchange. \r\n\r\nWe choose to go another way and we have min order amount in the market structure, which covers Kraken as well as the other exchanges, so it's more generic and versatile to have that property in the market structure, not in the currency structure. \r\n\r\nHope this answers your question, let me know if not."
      },
      {
        "user": "Morriz",
        "created_at": "2019-02-01T14:40:55Z",
        "body": "understood...thanks for another swift reply :)"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why min order amount data is structured per-market rather than per-currency",
      "Demonstration of structural consistency across multiple exchanges",
      "Logical alignment with trading mechanics (order placement requiring pairs)"
    ]
  },
  {
    "number": 4361,
    "title": "Kucoin fetchClosedOrders returns order id not fill id",
    "created_at": "2018-12-19T19:45:56Z",
    "closed_at": "2018-12-19T19:51:07Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/4361",
    "body": "```\r\n{ info:\r\n   { coinType: 'KCS',\r\n     amount: 12.4203,\r\n     dealValue: 0.178902,\r\n     fee: 0.0124203,\r\n     dealDirection: 'SELL',\r\n     coinTypePair: 'ETH',\r\n     oid: '5a5475395e39307a6b8e7876',\r\n     dealPrice: 0.014404,\r\n     orderOid: '5a5475105e39307beec73298',\r\n     feeRate: 0.001,\r\n     createdAt: 1515484473000,\r\n     id: 575992,\r\n     direction: 'BUY',\r\n     status: 'closed' },\r\n  id: '5a5475105e39307beec73298',\r\n  timestamp: 1515484473000,\r\n  datetime: '2018-01-09T07:54:33.000Z',\r\n  lastTradeTimestamp: undefined,\r\n  symbol: 'KCS/ETH',\r\n  type: 'limit',\r\n  side: 'buy',\r\n  price: 0.014404,\r\n  amount: 12.4203,\r\n  cost: 0.178902,\r\n  filled: 12.4203,\r\n  remaining: 0,\r\n  status: 'closed',\r\n  fee: { cost: 0.0124203, rate: 0.001, currency: 'KCS' },\r\n  trades: undefined }\r\n {info:\r\n   { coinType: 'KCS',\r\n     amount: 1.3211,\r\n     dealValue: 0.01902912,\r\n     fee: 0.0013211,\r\n     dealDirection: 'BUY',\r\n     coinTypePair: 'ETH',\r\n     oid: '5a5475115e39307a6b8e786f',\r\n     dealPrice: 0.014404,\r\n     orderOid: '5a5475105e39307beec73298',\r\n     feeRate: 0.001,\r\n     createdAt: 1515484433000,\r\n     id: 575985,\r\n     direction: 'BUY',\r\n     status: 'closed' },\r\n  id: '5a5475105e39307beec73298',\r\n  timestamp: 1515484433000,\r\n  datetime: '2018-01-09T07:53:53.000Z',\r\n  lastTradeTimestamp: undefined,\r\n  symbol: 'KCS/ETH',\r\n  type: 'limit',\r\n  side: 'buy',\r\n  price: 0.014404,\r\n  amount: 1.3211,\r\n  cost: 0.01902912,\r\n  filled: 1.3211,\r\n  remaining: 0,\r\n  status: 'closed',\r\n  fee: { cost: 0.0013211, rate: 0.001, currency: 'KCS' },\r\n  trades: undefined }\r\n```\r\n\r\nThis means that the `id` for each trade will be duplicated. We need to use `info.oid`.",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/4361/comments",
    "author": "shortcircuit3",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2018-12-19T19:49:19Z",
        "body": "Are you sure it's `fetchMyTrades`? Looks like an array of orders to me) You probably mean `fetchClosedOrders`?"
      },
      {
        "user": "shortcircuit3",
        "created_at": "2018-12-19T19:51:37Z",
        "body": "@kroitor Youre right. my bad, it is fetchClosedOrders.\r\n\r\nThis is confusing that it returns the fills and were required to aggregate by id. Shouldn't we still use `oid`?"
      },
      {
        "user": "kroitor",
        "created_at": "2018-12-19T19:54:51Z",
        "body": "> This is confusing that it returns the fills and were required to aggregate by id. Shouldn't we still use oid?\r\n\r\nYes, but it is there for historical reasons mostly... It comes from the way the Kucoin API itself is structured.\r\n\r\nAnyways, for the orders `orderOid` should have the priority, and for the trades we have trade id `oid` and `orderOid` in the field order id. So everything was ok apparently, no? )"
      },
      {
        "user": "shortcircuit3",
        "created_at": "2018-12-19T19:57:32Z",
        "body": "Ok, I guess `fetchMyTrades` uses the same endpoint with the correct data. False alarm, just confusing. Thank you!"
      },
      {
        "user": "kroitor",
        "created_at": "2018-12-19T19:58:25Z",
        "body": "No worries, let me know if you notice anything suspicious )"
      }
    ],
    "satisfaction_conditions": [
      "Clarification of identifier hierarchy in Kucoin API responses",
      "Explanation of Kucoin API's trade/order relationship structure",
      "Differentiation between order identifiers and trade identifiers",
      "Guidance on proper API method usage for different data types"
    ]
  },
  {
    "number": 4211,
    "title": "API Keys Setup - Any function to know exactly what parameter to pass",
    "created_at": "2018-11-22T14:05:29Z",
    "closed_at": "2018-11-22T14:10:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/4211",
    "body": "I have read the API Keys Setup wiki and understood there are parameters like apiKey, secret, uid and password, but not all exchange require all the parameter.\r\nIs there any function or method that will tell me exactly which parameter to pass for each exchange.\r\n\r\nSomething like:\r\n```\r\n$quoinex = new \\ccxt\\quoinex ();\r\n$quoinex->getParam(); // ------> This will return apiKey and secret\r\n$1btcxe = new \\ccxt\\1btcxe ();\r\n$1btcxe->getParam(); // -------> This will return only apiKey\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/4211/comments",
    "author": "rohit1290",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2018-11-22T14:10:49Z",
        "body": "See the property named `requiredCredentials` on the exchange instance:\r\n\r\n```PHP\r\n$exchange = new \\ccxt\\quoinex ();\r\nvar_dump ($exchange->requiredCredentials);\r\n```\r\n\r\nLet us know if that does not answer your question."
      },
      {
        "user": "rohit1290",
        "created_at": "2018-11-22T14:38:16Z",
        "body": "Thank you, I can work on $exchange->requiredCredentials and covert it to my required format.\r\nThanks :)"
      }
    ],
    "satisfaction_conditions": [
      "Provides a programmatic way to retrieve required authentication parameters for each exchange",
      "Returns structured authentication requirements in a machine-readable format"
    ]
  },
  {
    "number": 4050,
    "title": "bittrex fetchDeposits returns no timestamp and datetime",
    "created_at": "2018-10-26T07:28:05Z",
    "closed_at": "2018-10-26T07:50:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/4050",
    "body": "- OS: Linux\r\n- Programming Language version: PHP\r\n- CCXT version: 1.17.421\r\n- Exchange: bittrex\r\n- Method: fetchDeposit\r\n\r\nThe only timestamp returned from the exchnage for withdrawals is in the 'LastUpdated' field. This should probably be used for the timestamp and datetime. The 'Opened' field that is used for Withdrawals is not available when fetching deposits",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/4050/comments",
    "author": "WoK-E",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2018-10-26T07:37:26Z",
        "body": "> The only timestamp returned from the exchnage for withdrawals is in the 'LastUpdated' field. This should probably be used for the timestamp and datetime. \r\n\r\nNope, unfortunately, we can't set that timestamp there, because it literally means the last updated timestamp, therefore it is in the transaction structure, in the `updated` field. We don't invent values where the exchange in question does not provide them. You can add that logic to your code in userland on client-side, namely, *\"consider `updated` for Bittrex deposits a `timestamp`\"*. But, unfortunately, this may not play well for all users equally. The other signifcant reason behind it is that the LastUpdated field can change, which should not happen to a unified `timestamp` (it should always be fixed, unchanging, if set).\r\n\r\n> The 'Opened' field that is used for Withdrawals is not available when fetching deposits\r\n\r\nRight, this is by design again, same reasoning basically. Anyways, they don't support any date-based pagination for deposits and withdrawals whatsoever.\r\n\r\nDoes the above answer your question? )\r\n\r\n"
      },
      {
        "user": "WoK-E",
        "created_at": "2018-10-26T07:50:52Z",
        "body": "Yes, it does answer the question, and I understand the reasoning. I will; be closing the issue.\r\n\r\nThe reason I use 'LastUpdated' is because this is when the exchange gets enough confirmations, in order to consider the deposit valid, and stops updating the record. The other (selfish) reason is because I want to minimize the ccxt classes I extend in order to provide such extra logic and functionality :)\r\n\r\nThanks for the prompt response, and thanks for this great library!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why Bittrex deposit timestamps cannot use the 'LastUpdated' field in CCXT's unified response",
      "Guidance on client-side implementation strategies for handling missing timestamps",
      "Acknowledgement of Bittrex's API limitations regarding deposit/withdrawal timestamps"
    ]
  },
  {
    "number": 3840,
    "title": "deployment error in a google / firebase cloud function",
    "created_at": "2018-09-13T12:03:17Z",
    "closed_at": "2018-09-13T12:10:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/3840",
    "body": "I'm unable to use ccxt in a cloud function.  When I start locally the deployment dies if I add the line `const cctx = require('cctx');`.  The same does not happen for other dependencies such as `const uuid = require('uuid');`\r\n\r\nI've added (both) packages to my _package.json_ file, run `npm install` and I can see them both in my _node_modules_ directory.  I've tried cleaning the cache.\r\n\r\n ```\r\n \"dependencies\": {\r\n    \"ccxt\": \"^1.17.283\",\r\n    \"firebase-admin\": \"^6.0.0\",\r\n    \"firebase-functions\": \"^2.0.5\",\r\n    \"uuid\": \"^3.3.2\"\r\n  },\r\n```\r\n\r\nHere's the error:\r\n\r\n```\r\n$ firebase serve  --only functions\r\n\r\n=== Serving from '/Users/crypro/projects/CrypPro-marketdata/firebase'...\r\n\r\ni  functions: Preparing to emulate functions.\r\n\u26a0  functions: Failed to load functions source code. Ensure that you have the latest SDK by running npm i --save firebase-functions inside the functions directory.\r\n\u26a0  functions: Error from emulator. Error parsing triggers: Cannot find module 'cctx'\r\n\r\nTry running \"npm install\" in your functions directory before deploying.\r\n```\r\n\r\nI'm using:\r\n\r\n```\r\n$ node --version\r\nv6.11.5\r\n$ npm --version\r\n6.4.1\r\n$ firebase --version\r\n4.2.1\r\n```\r\n\r\nI'm guessing there's something different between the _uuid_ npm package and the _ccxt_ one, but I've no idea what.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/3840/comments",
    "author": "npomfret",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2018-09-13T12:07:29Z",
        "body": "> functions: Error from emulator. Error parsing triggers: Cannot find module 'cctx'\r\n\r\n\u2193\r\n\r\n```JavaScript\r\nconst cctx = require('cctx');\r\n// \u2191\u2191\u2191\u2191 cctX \u2192 ccXt \u2191\u2191\u2191\u2191 \r\n```"
      },
      {
        "user": "npomfret",
        "created_at": "2018-09-13T12:13:04Z",
        "body": "haha - I'm an idiot.  Been looking at this for an hour.\n\n---\n\n... as s side question, i get another error from firebase which looks like a javascript versioning issue.  Is the following syntax for a very modern version of javascript:\r\n\r\n```\r\nfirebase/functions/node_modules/ccxt/js/base/Exchange.js:438\r\n                    let partial = async params => this[methodName] (path, type, uppercaseMethod, params || {})\r\n                                        ^^^^^^\r\n\r\nSyntaxError: Unexpected identifier\r\n\r\n```"
      },
      {
        "user": "kroitor",
        "created_at": "2018-09-13T12:16:31Z",
        "body": "@npomfret the async syntax won't work with Node version < 7, unfortunately. Version 6 is too old. I suggest updating it, if possible."
      },
      {
        "user": "npomfret",
        "created_at": "2018-09-13T12:17:40Z",
        "body": "Thanks!"
      }
    ],
    "satisfaction_conditions": [
      "Identifies and resolves module import errors in Firebase Cloud Functions",
      "Ensures JavaScript runtime compatibility with dependency requirements",
      "Validates environment configuration matches dependency requirements"
    ]
  },
  {
    "number": 3759,
    "title": "Exmo partial fill is considered as full fill.",
    "created_at": "2018-08-29T06:33:55Z",
    "closed_at": "2018-08-29T11:00:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/3759",
    "body": "When calling fetch order on Exmo on a partially filled order, CCXT seems to be tricked. It thinks the order is fully filled.\r\n\r\nOrder was a limit on 0.5 BTC.\r\n\r\n```\r\n{'id': '1139757129', 'datetime': '2018-08-24T17:13:24.000Z', 'timestamp': 1535130804000, 'lastTradeTimestamp': None, 'status': 'closed', 'symbol': 'BTC/USD', 'type': 'limit', 'side': 'sell', 'price': 6630.999999737207, 'cost': 252.32738738, 'amount': 0.03805269, 'filled': 0.03805269, 'remaining': 0.0, 'trades': [{'id': '67768715', 'info': {'trade_id': 67768715, 'date': 1535130804, 'type': 'sell', 'pair': 'BTC_USD', 'order_id': 1139757129, 'quantity': '0.03805269', 'price': '6630.99999999', 'amount': '252.32738738'}, 'timestamp': 1535130804000, 'datetime': '2018-08-24T17:13:24.000Z', 'symbol': 'BTC/USD', 'order': '1139757129', 'type': None, 'side': 'sell', 'price': 6630.99999999, 'amount': 0.03805269, 'cost': 252.32738738}], 'fee': {'cost': 0.0, 'currency': 'USD'}, 'info': {'type': 'sell', 'in_currency': 'USD', 'in_amount': '252.32738738', 'out_currency': 'BTC', 'out_amount': '0.03805269', 'trades': [{'trade_id': 67768715, 'date': 1535130804, 'type': 'sell', 'pair': 'BTC_USD', 'order_id': 1139757129, 'quantity': '0.03805269', 'price': '6630.99999999', 'amount': '252.32738738'}]}}\r\n```\r\n\r\nResponse for fetch order on exmo seems to be a long list rather than a single order. So it might actually explain why.\r\n\r\n\r\n\r\n- OS: Linux\r\n- CCXT version: 1.17.174 (very recent one given the fact that no code was updated for the past 2 months on EXMO).\r\n- Exchange: exmo\r\n- Method: fetch_order\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/3759/comments",
    "author": "philipperemy",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2018-08-29T10:41:02Z",
        "body": "@philipperemy it looks like an order with one filling trade to me:\r\n\r\n```\r\n{'amount': 0.03805269,   # \u2190------------------------------- ordered amount\r\n 'cost': 252.32738738,\r\n 'datetime': '2018-08-24T17:13:24.000Z',\r\n 'fee': {'cost': 0.0, 'currency': 'USD'},\r\n 'filled': 0.03805269,   # \u2190------------------------------- filled amount\r\n 'id': '1139757129',\r\n 'info': {'in_amount': '252.32738738',\r\n          'in_currency': 'USD',\r\n          'out_amount': '0.03805269',\r\n          'out_currency': 'BTC',\r\n          'trades': [{'amount': '252.32738738',\r\n                      'date': 1535130804,\r\n                      'order_id': 1139757129,\r\n                      'pair': 'BTC_USD',\r\n                      'price': '6630.99999999',\r\n                      'quantity': '0.03805269',\r\n                      'trade_id': 67768715,\r\n                      'type': 'sell'}],\r\n          'type': 'sell'},\r\n 'lastTradeTimestamp': None,\r\n 'price': 6630.999999737207,\r\n 'remaining': 0.0,\r\n 'side': 'sell',\r\n 'status': 'closed',\r\n 'symbol': 'BTC/USD',\r\n 'timestamp': 1535130804000,\r\n 'trades': [{'amount': 0.03805269, # \u2190------------------------------- filled amount\r\n             'cost': 252.32738738,\r\n             'datetime': '2018-08-24T17:13:24.000Z',\r\n             'id': '67768715',\r\n             'info': {'amount': '252.32738738',\r\n                      'date': 1535130804,\r\n                      'order_id': 1139757129,\r\n                      'pair': 'BTC_USD',\r\n                      'price': '6630.99999999',\r\n                      'quantity': '0.03805269',\r\n                      'trade_id': 67768715,\r\n                      'type': 'sell'},\r\n             'order': '1139757129',\r\n             'price': 6630.99999999,\r\n             'side': 'sell',\r\n             'symbol': 'BTC/USD',\r\n             'timestamp': 1535130804000,\r\n             'type': None}],\r\n 'type': 'limit'}\r\n>>>\r\n```\r\n\r\n\u2191 The ordered amount is completely filled with that trade. How do you tell it's still open?"
      },
      {
        "user": "philipperemy",
        "created_at": "2018-08-29T11:00:57Z",
        "body": "@kroitor Hum, ok then it's my mistake. Thanks :)"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how CCXT interprets order fill status from exchange responses",
      "Verification that exchange data matches CCXT's status calculation methodology",
      "Clear mapping between exchange API response fields and CCXT's order status properties"
    ]
  },
  {
    "number": 3637,
    "title": "Bitfinex wallet transfer needs to pass Decimal",
    "created_at": "2018-08-12T23:19:28Z",
    "closed_at": "2018-08-12T23:33:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/3637",
    "body": "- OS: Mac\r\n- Programming Language version: Python 3.6\r\n- CCXT version: 1.13.2\r\n- Exchange: bitfinex\r\n- Method: privatePostTransfer\r\n\r\nWhen i try to transfer from exchange to margin, which is 'trading' wallet, I have to pass in the Json: `client.privatePostTransfer({'amount': '.01','currency': 'btc', 'walletfrom': 'exchange', 'walletto': 'trading'})`\r\n\r\nbut the endpoint only takes Decimal objects, which I can't pass through in the json, for the amount as given by this error:\r\n\r\n\r\n`ccxt.base.errors.InvalidOrder: bitfinex {\"message\":\"Key amount should be a decimal number, e.g. \\\"123.456\\\"\"}`",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/3637/comments",
    "author": "lelly8484",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2018-08-12T23:28:26Z",
        "body": "@lellywang have you tried `'amount': '0.01'` instead of `'.01'` ?"
      },
      {
        "user": "lelly8484",
        "created_at": "2018-08-12T23:33:10Z",
        "body": "Oh that fixed it, thank you, now I'm getting \r\n\r\n`[{'status': 'error', 'message': 'BTC cannot be used for Margin Trading. Transfer to Margin wallet not possible.'}]`\r\n\r\nbut I'm assuming that's some kind of issue on bitfinex end, let me know please if you've seen this before\n\n---\n\nI solved it by using capitalized form 'BTC' instead of 'btc'! if anyone is looking around"
      }
    ],
    "satisfaction_conditions": [
      "Ensure amount values are formatted as valid decimal strings",
      "Use uppercase currency codes matching exchange requirements",
      "Handle exchange-specific API parameter formatting requirements"
    ]
  },
  {
    "number": 3616,
    "title": "Retrieve response headers",
    "created_at": "2018-08-10T10:00:06Z",
    "closed_at": "2018-08-10T16:45:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/3616",
    "body": "Is it possible to retrieve the response headers on both good and false api calls you make for Bitmex?\r\n\r\n```\r\n{\r\n  \"date\": \"Fri, 10 Aug 2018 09:54:59 GMT\",\r\n  \"content-encoding\": \"gzip\",\r\n  \"x-powered-by\": \"Profit\",\r\n  \"etag\": \"W/\\\"2-l9Fw4VUO7kr8CvBlt4zaMCqXZ0w\\\"\",\r\n  \"x-ratelimit-remaining\": \"149\",\r\n  \"content-type\": \"application/json; charset=utf-8\",\r\n  \"status\": \"200\",\r\n  \"x-ratelimit-reset\": \"1533894900\",\r\n  \"x-ratelimit-limit\": \"150\",\r\n  \"strict-transport-security\": \"max-age=31536000; includeSubDomains\"\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/3616/comments",
    "author": "p0ntsNL",
    "comments": [
      {
        "user": "creslinux",
        "created_at": "2018-08-10T14:46:02Z",
        "body": "I think the response headers are available for the last request in your exchange object. \r\n\r\nTake a look in, if named your object exchange object `ccxt`: \r\n`ccxt.last_response_headers._store`"
      },
      {
        "user": "p0ntsNL",
        "created_at": "2018-08-10T16:45:09Z",
        "body": "Thank you Thank you!"
      },
      {
        "user": "kroitor",
        "created_at": "2018-08-10T17:45:14Z",
        "body": "@creslinux thx so much for your help! )"
      }
    ],
    "satisfaction_conditions": [
      "Demonstrates how to access full HTTP response headers from API calls",
      "Works for both successful and unsuccessful API requests",
      "Provides structured access to header values"
    ]
  },
  {
    "number": 3479,
    "title": "`cost_to_precision()` uses `markets[symbol]['precision']['price']`?",
    "created_at": "2018-07-24T16:57:01Z",
    "closed_at": "2018-07-24T17:00:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/3479",
    "body": "Is this a typo on line 903 of `ccxt/python/ccxt/base/exchange.py`?\r\n\r\n```\r\n    def cost_to_precision(self, symbol, cost):\r\n        return ('{:.' + str(self.markets[symbol]['precision']['price']) + 'f}').format(float(cost))\r\n\r\n```\r\nI would have expected it to be:\r\n\r\n```\r\n    def cost_to_precision(self, symbol, cost):\r\n        return ('{:.' + str(self.markets[symbol]['precision']['cost']) + 'f}').format(float(cost))\r\n```\r\n\r\nThis is a genuine question. I could imagine scenarios where it could be intentional.",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/3479/comments",
    "author": "mkoistinen",
    "comments": [
      {
        "user": "mkoistinen",
        "created_at": "2018-07-24T16:57:57Z",
        "body": "```\r\n    costToPrecision (symbol, cost) {\r\n        return parseFloat (cost).toFixed (this.markets[symbol].precision.price)\r\n    }\r\n```\r\nSame in the JS version (not surprisingly)"
      },
      {
        "user": "kroitor",
        "created_at": "2018-07-24T16:58:26Z",
        "body": "No it's not a typo, because exchanges will very rarely provide cost precision. Think logically, cost is `amount * price` that is the same units as price (represented in the same currency, therefore  both `cost` and `price` have that currency's precision)."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why price precision is used instead of cost precision for cost calculations",
      "Clarification about exchange API specifications regarding cost precision availability",
      "Validation that the implementation aligns with exchange data structure conventions"
    ]
  },
  {
    "number": 3455,
    "title": "Bittrex / python fetch_orders() method gone ..?",
    "created_at": "2018-07-21T20:06:26Z",
    "closed_at": "2018-07-21T20:11:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/3455",
    "body": "Language: Python 3.6\r\nCCXT version: 1.12+ (including newest version 1.16.80)\r\nExchange: Bittrex\r\n\r\nThe fetch_orders method for Bittrex seems to have disappeared at some point after v1.11.180 (I tried to upgrade). Seems like a pretty important method for a fairly well-used exchange... ",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/3455/comments",
    "author": "skeebuzz",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2018-07-21T20:11:47Z",
        "body": "@skeebuzz they didn't have it from the very beginning, the old `fetchOrders` was only returning closed orders, so it was removed in favor of `fetchClosedOrders`. Bittrex has `fetchOpenOrders`, `fetchClosedOrders` and the `has` property, according to the Manual. Hope this answers your question."
      },
      {
        "user": "skeebuzz",
        "created_at": "2018-07-21T20:39:26Z",
        "body": "Damn that was fast, and it's Saturday... Thanks very much. You've just earned this project an ETH tip.\r\n\r\nCheers"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why fetch_orders was removed and what replaces its functionality",
      "Identification of alternative methods to retrieve both open and closed orders",
      "Reference to official exchange API capabilities and CCXT's implementation decisions"
    ]
  },
  {
    "number": 3206,
    "title": "Bitrrex wallet status not good fetchCurrencies",
    "created_at": "2018-06-21T09:31:03Z",
    "closed_at": "2018-06-21T10:41:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/3206",
    "body": "\r\n- Ubuntu\r\n- Python: 3.5\r\n- CCXT version: 1.14.189\r\n- Exchange: bittrex\r\n- Method: fetchCurrencies()\r\n\r\nFor example\r\n\r\n```bit.fetchCurrencies()['CANN']``` has de following output: \r\n\r\n``` {'code': 'CANN', 'fee': 0.2, 'status': 'ok', 'precision': 8, 'limits': {'amount': {'max': 100000000.0, 'min': 1e-08}, 'withdraw': {'max': 100000000.0, 'min': 0.2}, 'price': {'max': 100000000.0, 'min': 1e-08}, 'cost': {'max': None, 'min': None}}, 'info': {'MinConfirmation': 300, 'Notice': 'Automated Maintenance.', 'Currency': 'CANN', 'TxFee': 0.2, 'IsActive': False, 'CurrencyLong': 'CannabisCoin', 'BaseAddress': None, 'CoinType': 'BITCOIN'}, 'address': None, 'type': 'BITCOIN', 'active': False, 'name': 'CannabisCoin', 'id': 'CANN'} ```\r\n\r\nAs you can see the wallet is in Automated Maintance and 'IsActive'  is False while the unified status is 'ok'\r\n\r\nI would expect that the status would change to 'disabled' because you cannot withdraw or deposit this coin at the moment\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/3206/comments",
    "author": "fonzmeister",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2018-06-21T10:41:55Z",
        "body": "> I would expect that the status would change to 'disabled' because you cannot withdraw or deposit this coin at the moment\r\n\r\nThe `status` is deprecated there, so you should look into the `active` flag instead:\r\n\r\n```Python\r\n{'active': False,  # \u2190----------------------------- this one\r\n 'address': None,\r\n 'code': 'CANN',\r\n 'fee': 0.2,\r\n 'id': 'CANN',\r\n 'info': {'BaseAddress': None,\r\n          'CoinType': 'BITCOIN',\r\n          'Currency': 'CANN',\r\n          'CurrencyLong': 'CannabisCoin',\r\n          'IsActive': False,\r\n          'MinConfirmation': 300,\r\n          'Notice': 'Automated Maintenance.',\r\n          'TxFee': 0.2},\r\n 'limits': {'amount': {'max': 100000000.0, 'min': 1e-08},\r\n            'cost': {'max': None, 'min': None},\r\n            'price': {'max': 100000000.0, 'min': 1e-08},\r\n            'withdraw': {'max': 100000000.0, 'min': 0.2}},\r\n 'name': 'CannabisCoin',\r\n 'precision': 8,\r\n 'status': 'ok',\r\n 'type': 'BITCOIN'}\r\n```\r\n\r\nLet us know if it does not answer your question. Thx!"
      },
      {
        "user": "fonzmeister",
        "created_at": "2018-06-21T14:06:11Z",
        "body": "Thank you, that works perfectly.\r\nHowever, I don't think it works on poloniex though\r\n\r\nfor example:\r\n```polo.fetchCurrencies()['STEEM']```\r\n\r\ngives as output: \r\n```{'name': 'STEEM', 'active': True, 'fee': 0.01, 'info': {'disabled': 1, 'name': 'STEEM', 'txFee': '0.01000000', 'frozen': 0, 'delisted': 0, 'minConf': 50, 'depositAddress': 'poloniex', 'id': 281}, 'code': 'STEEM', 'id': 'STEEM', 'limits': {'withdraw': {'max': 100000000.0, 'min': '0.01000000'}, 'price': {'max': 100000000.0, 'min': 1e-08}, 'amount': {'max': 100000000.0, 'min': 1e-08}, 'cost': {'max': None, 'min': None}}, 'precision': 8}```\r\n\r\nThe wallet is disabled as is shown in the info part of the dict. however. Active is True"
      },
      {
        "user": "kroitor",
        "created_at": "2018-06-21T14:07:26Z",
        "body": "@fonzmeister thx for pointing that out, will fix Poloniex as well, shortly."
      }
    ],
    "satisfaction_conditions": [
      "Unified status fields must accurately reflect exchange-specific operational states",
      "Consistent status reporting across all exchange integrations",
      "Clear deprecation guidance for legacy fields"
    ]
  },
  {
    "number": 2896,
    "title": "huobipro withdraw return api-signature-not-valid error",
    "created_at": "2018-05-19T18:43:10Z",
    "closed_at": "2018-05-20T04:03:55Z",
    "labels": [
      "duplicate",
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/2896",
    "body": "- OS: Win10\r\n- Programming Language version: Python 3.5.4\r\n- CCXT version: 1.14.25\r\n- Exchange: huobipro\r\n- Method: withdraw\r\n\r\nWhen I tested huobipro withdraw, I got 'signature not valid' response as below:\r\n\r\n> ccxt.base.errors.ExchangeError: huobipro {\"err-msg\":\"Signature not valid: \\u6821\\u9a8c\\u5931\\u8d25\",\"status\":\"error\",\"data\":null,\"err-code\":\"api-signature-not-valid\"}\r\n\r\nMeanwhile, huobipro fetch_balance worked fine. So I think it is not a key pair issue. And I also tested withdraw same target address by other market, it also worked fine. So the address should be good.\r\n\r\nAttach my testing code below, hope it will help:\r\n\r\n    f_m = \"huobipro\"\r\n    t_m = \"okex\" \r\n    currency = \"ZEC\"\r\n\r\n    exchange = getattr(ccxt, f_m)({'apiKey': apiconfig['key'], 'secret': apiconfig['secret'], 'nonce': ccxt.Exchange.milliseconds})\r\n    addresses = get_market_addresses(t_m) #get addresses map\r\n    exchange.load_markets()\r\n    response = exchange.fetch_balance()\r\n    print(response) #fetch balance, worked\r\n    response = exchange.withdraw(currency, 1, addresses[currency]['address'], 'Test withdraw', {})\r\n    print(response) #withdraw, failed\r\n\r\nAttach traceback:\r\n\r\n> Traceback (most recent call last):\r\n  File \"testing2.py\", line 36, in <module>\r\n    withdraw_test()\r\n  File \"testing2.py\", line 33, in withdraw_test\r\n    response = exchange.withdraw(currency, 1, addresses[currency]['address'], 'Test withdraw', {})\r\n  File \"C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python35\\lib\\site-packages\\ccxt\\huobipro.py\", line 661, in withdraw\r\n    response = self.privatePostDwWithdrawApiCreate(self.extend(request, params))\r\n  File \"C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python35\\lib\\site-packages\\ccxt\\base\\exchange.py\", line 306, in request\r\n    return self.fetch2(path, api, method, params, headers, body)\r\n  File \"C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python35\\lib\\site-packages\\ccxt\\base\\exchange.py\", line 303, in fetch2\r\n    return self.fetch(request['url'], request['method'], request['headers'], request['body'])\r\n  File \"C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python35\\lib\\site-packages\\ccxt\\base\\exchange.py\", line 383, in fetch\r\n    self.handle_errors(response.status_code, response.reason, url, method, None, self.last_http_response)\r\n  File \"C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python35\\lib\\site-packages\\ccxt\\huobipro.py\", line 727, in handle_errors\r\n    raise ExchangeError(feedback)\r\nccxt.base.errors.ExchangeError: huobipro {\"err-msg\":\"Signature not valid: \\u6821\\u9a8c\\u5931\\u8d25\",\"data\":null,\"err-code\":\"api-signature-not-valid\",\"status\":\"error\"}\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/2896/comments",
    "author": "radarxc",
    "comments": [
      {
        "user": "radarxc",
        "created_at": "2018-05-20T01:48:11Z",
        "body": "I find when I change withdraw's 'tag' parameter as None, this issue is fixed. I am not sure what happen, but it works fine on other market with tag parameter."
      },
      {
        "user": "kroitor",
        "created_at": "2018-05-20T04:03:55Z",
        "body": "@radarxc you're not using the withdraw method properly. The `tag` is not an arbitrary user string, it is a wallet identifier which should only be set if you're withdrawing a currency that requires the tag for addressing. Let us know if it does not answer your question."
      },
      {
        "user": "radarxc",
        "created_at": "2018-05-20T04:09:40Z",
        "body": "@kroitor \r\ngot you. Thank you very much. I should read document more carefully."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why the 'tag' parameter causes a signature error in HuobiPro withdrawals",
      "Clarification of exchange-specific requirements for withdrawal parameters",
      "Guidance on determining when to include/exclude parameters in API requests",
      "Documentation reference for currency-specific withdrawal requirements"
    ]
  },
  {
    "number": 2762,
    "title": "How can I store price series data into MongoDB ?",
    "created_at": "2018-05-05T18:35:53Z",
    "closed_at": "2018-05-06T01:09:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/2762",
    "body": "Hello,\r\n\r\nI would like to save price series of crypto from multiple exchanges into a MongoDB database but I can't find any example. This is the list of the exchanges I would like to download and store the data: \r\n\r\n```\r\nex =    [\"binance\",\r\n        \"bitfinex\",\r\n        \"bittrex\",\r\n        \"hitbtc\",\r\n        \"kraken\",\r\n        \"kucoin\",\r\n        \"poloniex\",\r\n        \"gateio\"]\r\n```\r\nThese exchanges have +900 symbols with BTC as a quote currency. I can use `fetch_ohlcv (symbol, '1d')` to retrieve the data but it gives me lists inside list, like this :\r\n\r\n```\r\n[[1478131200000, 950.0, 1099.98, 179.0, 240.03, 244.57775612],\r\n [1478736000000, 240.03, 265.89, 89.24, 93.55, 155.50246024],\r\n [1479340800000, 93.57, 99.72, 55.0, 77.53, 624.65850454]]\r\n```\r\n\r\nThe problem is that Mongodb wants an instance of dict, so how could I transform this nested lists into a proper dictionary ? Another question is how to design the database to store data from multiple exchanges ?\r\n\r\nAny help would be greatly appreciate,\r\n\r\nThanks!\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/2762/comments",
    "author": "Kinzowa",
    "comments": [
      {
        "user": "mkutny",
        "created_at": "2018-05-05T20:17:46Z",
        "body": "> Another question is how to design the database to store data from multiple exchanges ?\r\n\r\nThe database table structure for this particular case is pretty straightforward. What you'll eventually end up with is:\r\n- exchange\r\n- symbol\r\n- timestamp\r\n- O\r\n- H\r\n- L\r\n- C\r\n- V\r\n\r\n> The problem is that Mongodb wants an instance of dict, so how could I transform this nested lists into a proper dictionary ? \r\n\r\nIt should be something like:\r\n```javascript\r\nconst exchangeId = 'binance';\r\nconst symbol = 'ETH/BTC';\r\nconst exchange = new ccxt['binance'] ();\r\nconst ohlcvs = await exchange.fetchOHLCV(symbol);\r\n\r\nfor (let i = 0; i < ohlcvs.length; i++) {\r\n    const ohlcv = ohlcvs[i];\r\n    db.insert(exchange.id, symbol, ohlcv[0], ohlcv[1], ohlcv[2], ...);\r\n}\r\n```\r\n\r\nPay attention that on some of the exchanges `fetchOHLCV` is emulated, on them you'll probably get just a fraction of a day candle. Exchanges with native OHLCV implementation also impose some limits on how far back into history you can go and on number of returned candles.\r\n\r\nSo I'm afraid that you'll need to fetch raw trades and build OHLCVs by yourself. Hopefully, it's pretty easy to do with ccxt, just prepare to spend few days on that. More on it here: #2596, #2321."
      },
      {
        "user": "kroitor",
        "created_at": "2018-05-06T01:09:13Z",
        "body": "@HornKild closing this for now, if you don't mind. Let us know if @mkutny's answer does not satisfy your question. Thx!"
      },
      {
        "user": "Kinzowa",
        "created_at": "2018-05-06T06:25:43Z",
        "body": "Thank you @mkutny this is very helpful."
      },
      {
        "user": "mkutny",
        "created_at": "2018-05-06T07:22:10Z",
        "body": "@HornKild , thanks for the feedback!"
      }
    ],
    "satisfaction_conditions": [
      "Conversion of nested OHLCV lists into MongoDB-compatible dictionaries with named fields",
      "Database schema design supporting multiple exchanges and symbols",
      "Handling of exchange-specific OHLCV data inconsistencies"
    ]
  },
  {
    "number": 2644,
    "title": "prompt working in file not working",
    "created_at": "2018-04-22T19:10:18Z",
    "closed_at": "2018-04-22T21:44:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/2644",
    "body": "\r\n- OS: Ubuntu 16.04.4 LTS\r\n- Programming Language version: Python 3.5.2\r\n- CCXT version: 1.13.32\r\n- Exchange: All\r\n- Method: ccxt.exchanges\r\n\r\nI installed it like this:\r\npip install ccxt\r\n\r\nimport ccxt\r\nprint(ccxt.exchanges)\r\n\r\nIt's working in a prompt. But not in a Python file.\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/2644/comments",
    "author": "joosthoeks",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2018-04-22T19:22:29Z",
        "body": "What's your:\r\n- `python --version`\r\n- `pip --version`\r\n\r\nDo you have `python3 --version` in your system ?\r\n\r\n> But not in a Python file.\r\n\r\nMost likely you should have installed it with `sudo pip install ccxt`.\r\n\r\nLet us know if this does not help."
      },
      {
        "user": "joosthoeks",
        "created_at": "2018-04-22T19:40:37Z",
        "body": "My python --version\r\nPython 2.7.12\r\nMy python3 --version\r\nPython 3.5.2\r\nMy pip --version\r\npip 10.0.1 from /usr/local/lib/python3.5/dist-packages/pip (python 3.5)\r\nMy pip3 --version\r\npip 10.0.1 from /usr/local/lib/python3.5/dist-packages/pip (python 3.5)\r\n\r\nIf I install it with sudo pip install ccxt it makes no difference. I tried both Python versions."
      },
      {
        "user": "kroitor",
        "created_at": "2018-04-22T19:54:01Z",
        "body": "Ok, when you say it's not working in a file \u2013\u00a0what output do you see?"
      },
      {
        "user": "joosthoeks",
        "created_at": "2018-04-22T20:00:23Z",
        "body": "Output:\r\nTraceback (most recent call last):\r\n  File \"ccxt.py\", line 1, in <module>\r\n    import ccxt\r\n  File \"/home/joost/ccxt.py\", line 2, in <module>\r\n    print(ccxt.exchanges)\r\nAttributeError: module 'ccxt' has no attribute 'exchanges'\r\n"
      },
      {
        "user": "kroitor",
        "created_at": "2018-04-22T20:13:41Z",
        "body": "Have you tried renaming ccxt.py to any other filename (and deleting the ccxt.pyc)?"
      },
      {
        "user": "joosthoeks",
        "created_at": "2018-04-22T20:24:53Z",
        "body": "I have removed ccxt.pyc and now it's working! Thanks!"
      }
    ],
    "satisfaction_conditions": [
      "Identifies and resolves filename conflicts with imported modules",
      "Addresses cached bytecode interference"
    ]
  },
  {
    "number": 2630,
    "title": "Bittex fetchOrders not supported yet. ",
    "created_at": "2018-04-20T11:16:32Z",
    "closed_at": "2018-04-20T11:25:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/2630",
    "body": "Hi @kroitor,\r\n\r\nWith updated version i get this error: \r\n`Bittex fetchOrders not supported yet. `\r\n\r\nSome versions ago it was working fine.\r\nAny info?\r\n\r\n- OS: \r\n- Programming Language version: JS\r\n- CCXT version: 1.13.10\r\n- Exchange: Bittrex\r\n- Method: fetchOrders\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/2630/comments",
    "author": "morzyns",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2018-04-20T11:25:29Z",
        "body": "@morzyns Hi! Yes, it was emulated earlier, but it used a call to `fetchClosedOrders` or `fetchOpenOrders` internally, so you should use one of the two latter methods. Because it was removed, the version of ccxt was updated to 1.13+. Unfortunately, Bittrex does not have an endpoint to fetch them all in one go, so the earlier implementation of fetchOrders was not working properly and returned just the closed orders instead.\r\n\r\nLet us know if this does not answer your question."
      },
      {
        "user": "morzyns",
        "created_at": "2018-04-20T14:17:46Z",
        "body": "@kroitor,\r\nThanks for extensive answer. So far so good!\r\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why the `fetchOrders` method is no longer supported for Bittrex",
      "Guidance on alternative methods to retrieve order data (e.g., open/closed orders)"
    ]
  },
  {
    "number": 2619,
    "title": "Gdax Sandbox Authentication Error",
    "created_at": "2018-04-19T08:08:52Z",
    "closed_at": "2018-04-19T14:13:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/2619",
    "body": "Hi, \r\nI'm trying to use the api with the Gdax Sandbox, but I get an \"Invalid API Key\" error.\r\n\r\nTo use the sandbox I have changed this line in the code (line 478 in gdax.py):\r\n\r\nFrom: \r\n`url = self.urls['api'] + request `\r\nto:\r\n`url = self.urls['test'] + request `\r\n\r\nIt's weird because I get the error using the sandbox credentials, but if I put the real credentials I get no error. It is like if my change int he code has no effect at all.\r\n\r\nProbably it is just a newbie mistake from me, but I'm stucked with this. \r\n\r\nI'm using python on Ubuntu.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/2619/comments",
    "author": "jebesen",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2018-04-19T14:13:38Z",
        "body": "Hi!\r\n\r\n> Probably it is just a newbie mistake from me, but I'm stucked with this.\r\n\r\n1. For using your live credentials with the live exchange, you don't need to do anything (use it as you would use any other exchange):\r\n\r\n```Python\r\ngdax = ccxt.gdax({\r\n    'apiKey': 'YOUR_LIVE_KEY',\r\n    'secret': 'YOUR_LIVE_SECRET',\r\n})\r\n\r\n# your code goes here...\r\n```\r\n\r\n2. For using your sandbox credentials with the exchange sandbox, do the following:\r\n\r\n```Python\r\ngdax = ccxt.gdax({\r\n    'apiKey': 'YOUR_SANDBOX_KEY',\r\n    'secret': 'YOUR_SANDBOX_SECRET',\r\n})\r\ngdax.urls['api'] = gdax.urls['test']  # \u2190 add just this line to your code (don't edit `gdax.py`)\r\n\r\n# your code goes here...\r\n```\r\n\r\nGDAX uses different accounting databases for sandbox accounts vs regular accounts, therefore you can't use a sandbox account with a live exchange and vice versa.\r\n\r\nLet us know if this does not answer your question. Thx!"
      },
      {
        "user": "jebesen",
        "created_at": "2018-04-19T14:52:12Z",
        "body": "Thank you very much.  Problem solved!"
      },
      {
        "user": "kroitor",
        "created_at": "2018-04-19T14:56:26Z",
        "body": "@jebesen thx for reporting back! )"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how to properly configure the GDAX sandbox environment without modifying library source code",
      "Clarification about credential separation between sandbox and live environments",
      "Demonstration of environment switching that persists across API calls"
    ]
  },
  {
    "number": 2589,
    "title": "fetch_ohlcv returns incomplete data",
    "created_at": "2018-04-16T17:31:21Z",
    "closed_at": "2018-06-26T13:01:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/2589",
    "body": "- OS: ubuntu 16.04\r\n- Programming Language version: python3\r\n- CCXT version: last\r\n- Exchange: bittrex\r\n- Method: fetch_ohlcv\r\n\r\nUsing:\r\n```\r\nimport ccxt, numpy, pandas\r\nb=ccxt.bittrex()\r\ndata = b.fetch_ohlcv(\"XMR/BTC\", \"1m\", limit=10)\r\ndata = numpy.array(data)\r\ndata = data.transpose()\r\ndata = {\"time\": data[0], \"open\":data[1], \"high\":data[2], \"low\":data[3], \"close\":data[4], \"volume\":data[5]}\r\ndata = pandas.DataFrame(data)\r\ndata[\"time\"] = data[\"time\"].apply(lambda x: datetime.fromtimestamp(x/1000.0))\r\ndata = data.set_index(\"time\")\r\nprint(data)\r\n\r\n```\r\n\r\nlogs:\r\n```\r\n2018-04-06 15:01:00  0.024973  0.024973  0.024973  0.024973   0.058050\r\n2018-04-06 15:03:00  0.024973  0.024973  0.024973  0.024973   0.072460\r\n2018-04-06 15:04:00  0.024973  0.024973  0.024973  0.024973   0.400431\r\n2018-04-06 15:08:00  0.024974  0.024974  0.024973  0.024973   3.199803\r\n2018-04-06 15:10:00  0.024823  0.024823  0.024823  0.024823   0.393238\r\n2018-04-06 15:14:00  0.024921  0.024921  0.024921  0.024921   0.691595\r\n2018-04-06 15:25:00  0.024974  0.024974  0.024974  0.024974   2.519503\r\n2018-04-06 15:26:00  0.024974  0.024974  0.024974  0.024974   0.091726\r\n2018-04-06 15:31:00  0.024974  0.024974  0.024974  0.024974   1.105637\r\n2018-04-06 15:33:00  0.024974  0.024974  0.024974  0.024974   4.091391\r\n```\r\nwhich is an incomplete data (missing data on 15:32, for example)\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/2589/comments",
    "author": "fedecaccia",
    "comments": [
      {
        "user": "fedecaccia",
        "created_at": "2018-04-16T17:35:32Z",
        "body": "It also happens using another exchanges, like bitfinex. Further, using bitfinex I get 2016 values."
      },
      {
        "user": "Calambuuur",
        "created_at": "2018-04-27T09:55:34Z",
        "body": "OS Win32\r\nThis code returns an error:\r\nPython 3.6.4 (v3.6.4:d48eceb, Dec 19 2017, 06:04:45) [MSC v.1900 32 bit (Intel)] on win32\r\nType \"copyright\", \"credits\" or \"license()\" for more information.\r\n>>> \r\n======= RESTART: C:/Users/XXX/CCXT/fetch_ohlcv.py =======\r\nTraceback (most recent call last):\r\n  File \"C:/Users/XXX/CCXT/fetch_ohlcv.py\", line 8, in <module>\r\n    data[\"time\"] = data[\"time\"].apply(lambda x: datetime.fromtimestamp(x/1000.0))\r\n  File \"C:\\Users\\Ivanitskii\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages\\pandas\\core\\series.py\", line 2551, in apply\r\n    mapped = lib.map_infer(values, f, convert=convert_dtype)\r\n  File \"pandas/_libs/src\\inference.pyx\", line 1521, in pandas._libs.lib.map_infer\r\n  File \"C:/Users/XXX/CCXT/fetch_ohlcv.py\", line 8, in <lambda>\r\n    data[\"time\"] = data[\"time\"].apply(lambda x: datetime.fromtimestamp(x/1000.0))\r\nNameError: name 'datetime' is not defined\r\n>>> \r\nWhat's  - datetime.fromtimestamp(x/1000.0)?\n\n---\n\nAdd:\r\nfrom datetime import datetime"
      },
      {
        "user": "kroitor",
        "created_at": "2018-04-27T16:46:11Z",
        "body": "@Calambuuur UPD, sorry, never mind my deleted comment."
      },
      {
        "user": "fedecaccia",
        "created_at": "2018-04-27T19:35:51Z",
        "body": "@kroitor any idea on what is happening with the ohlcv requested data?"
      },
      {
        "user": "kroitor",
        "created_at": "2018-04-27T20:42:59Z",
        "body": "@fedecaccia yeah, this is called a *sparse array*, some exchanges may return the OHLCV with candles missing (it means \"no changes for that period since the previous candle\"). I'll add this to the docs and will add a couple of methods to pack/unpack sparse arrays."
      },
      {
        "user": "fedecaccia",
        "created_at": "2018-04-28T14:09:06Z",
        "body": "@kroitor that's great, an sparse array is more efficient to manage resources, I thought it was an incomplete data."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why OHLCV data might have missing intervals",
      "Clarification on exchange-specific OHLCV data formatting",
      "Guidance on handling sparse OHLCV arrays programmatically",
      "Differentiation between API limitations and expected exchange behavior"
    ]
  },
  {
    "number": 2579,
    "title": "Is there any way to set the price to 'ask' using bittrex exchange?",
    "created_at": "2018-04-16T00:17:53Z",
    "closed_at": "2018-04-16T04:02:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/2579",
    "body": "- OS: ubuntu\r\n- Programming Language version: python\r\n- CCXT version: last\r\n- Exchange: bittrex\r\n- Method: execute_order\r\n\r\nSince bittrex only has limit order types there is not way to set a market order. \r\nBut, if I want to be sure that the order is executed, is there any way to set the price to the 'ask' amount in the order_book, without requesting the full order_book previously?\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/2579/comments",
    "author": "fedecaccia",
    "comments": [
      {
        "user": "arielorvits",
        "created_at": "2018-04-16T00:22:59Z",
        "body": "U can request only part of order book.\r\nU can use ticker instead of order book.\r\nnote that sometimes ticker isn't updated enough.\r\nnote that u can't be sure order executed without verifying, since until u send the order - maybe the first 'ask' already sold"
      },
      {
        "user": "kroitor",
        "created_at": "2018-04-16T04:02:51Z",
        "body": "@fedecaccia if I get you correctly, you actually want a market order (*\"Ask\"* means buy for best available price, that is market price and up). \r\n\r\nDespite that Bittrex does not support market orders directly, there's still a way to simulate them, you just need to place the order at a price close to zero or at a very high price, depending on the direction of your order. \r\n\r\nThink what would the exchange do, if you sell 1 BTC for a price of $1. A normal exchange will not sell your bitcoin for a dollar, because there exist bidders in the orderbook that are willing to pay you more ($8000 or more) for your bitcoin. \r\n\r\nSo, a normal exchange will start closing your order for best price for you from the top of the opposite orderbook stack, if you are doing it far worse than current market price. \r\n\r\nIf you wanted the opposite, to buy 1 BTC for a market price, you would then put your bid at a price of $1million for one bitcoin, and a normal exchange will then sell a bitcoin to you from a seller that is willing to take less than $1million from you  and will sell for the market price at around $8000. So, if you are selling, sell for a very low price, if you are buying, then buy for a very high price \u2013\u00a0in both cases you will get the actual market price from a normal exchange.\r\n\r\n**WARNING: Whenever I say \"normal exchange\" I'd suggest you to test if the exchange in question is \"normal\" with a very small amount than is not significant to lose, to make sure. Not all exchanges work normally, but most of the major ones are ok. Anyway, use this method at your own risk and do the testing!**\r\n\r\nHope this answers your question.\r\n\r\n"
      },
      {
        "user": "fedecaccia",
        "created_at": "2018-04-16T13:39:42Z",
        "body": "Thanks kroitor!"
      }
    ],
    "satisfaction_conditions": [
      "Demonstrates a method to simulate market orders using Bittrex's limit order system",
      "Avoids requiring full order book requests to determine pricing",
      "Ensures order execution at best available price",
      "Addresses price validity concerns during order submission latency",
      "Works within Bittrex's API constraints for order types"
    ]
  },
  {
    "number": 2368,
    "title": "Couldn't get timestamp in `fetch_order_book` method",
    "created_at": "2018-03-28T06:34:36Z",
    "closed_at": "2018-03-28T06:42:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/2368",
    "body": "- OS: mac os\r\n- Programming Language version: python\r\n- CCXT version: 1.12.17 \r\n- Exchange: all exchange\r\n- Method: fetch_order_book\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/2368/comments",
    "author": "taish",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2018-03-28T06:42:09Z",
        "body": "We don't set it if a corresponding value is not provided by the exchange in question. You can get the last date from headers in the following way:\r\n```Python\r\nimport ccxt\r\nexchange = ccxt.kraken()\r\nexchange.fetch_order_book('ETH/BTC')\r\nprint(exchange.last_response_headers['Date'])\r\n```\r\nHope it answers your question. Thx!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how to retrieve timestamp data from exchange responses",
      "Clarification about exchange-specific data availability",
      "Method to access low-level API response details"
    ]
  },
  {
    "number": 2365,
    "title": "How to check whether new candle formed?",
    "created_at": "2018-03-27T07:33:41Z",
    "closed_at": "2018-03-27T14:47:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/2365",
    "body": "- OS: Windows 10\r\n- Programming Language version: Node JS 9.0\r\n- CCXT version: \r\n- Exchange: binance\r\n- Method: fetchOHLCV\r\n\r\non init of my script I going to fetch some quantity of candles,\r\nlater i will call another method periodically\r\n\r\nhow can I check - is new candle now forming, so I need to do something with already formed data. how to check it ?\r\nFor instance, I will use 1-hour timeframe, execute function every minute, how han I check that new candle starts?\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/2365/comments",
    "author": "aav80",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2018-03-27T14:44:40Z",
        "body": "> For instance, I will use 1-hour timeframe, execute function every minute, how han I check that new candle starts?\r\n\r\nA new hourly candle starts when a new UTC hour starts...\r\n\r\n```\r\n15:00-16:00 candle 123\r\n16:00-17:00 candle 124\r\n17:00-18:00 candle 125..\r\n...\r\n```\r\n\r\nSo, each new hourly candle starts on the edge of two consecutive clock hours. The new hourly candle is formed everytime a new hour starts.\r\n\r\nAll timestamps in ccxt are **UTC epoch in milliseconds**. \r\n\r\nHope it answers your question, let us know if not. Feel free to reopen it if needed or just ask further questions, if any. Thx!"
      },
      {
        "user": "aav80",
        "created_at": "2018-03-27T16:52:50Z",
        "body": "Yes, you answered completely.\r\n\r\nI have another candle-related question, is there any method which is called when new candle is formed, which I can inherite, or some way to run function only 1 time and right the moment, when candle starts?"
      },
      {
        "user": "kroitor",
        "created_at": "2018-03-27T17:10:35Z",
        "body": "> I have another candle-related question, is there any method which is called when new candle is formed, which I can inherite, or some way to run function only 1 time and right the moment, when candle starts?\r\n\r\nThere's no such method in the library, because it isn't related to the library itself, but mostly related to setting up proper timing for events in your program. This is usually done in userland. \r\n\r\nThink differently: no two events in the world are simultaneous. When you set a timer for 16:00, and it is triggered, it does not necessarily mean that the actual time is 16:00. May be +/- microsecond offset there... And if you request a candle then, the server may have it's own clock which is not in sync with yours, so the server clock may show 15:59 at that moment. \r\n\r\nI guess, Einstein and Heisenberg in their theories claim that no two events can be measured precisely in time-space... So, you should not rely on the clocks, you should instead think of a solution that would work either way. \r\n\r\nThus, instead of waiting an hour for the next candle to arrive and then checking, you check every **half an hour** (or as frequently as you need) if the new candle has arrived or not and base all your further behaviour on that."
      }
    ],
    "satisfaction_conditions": [
      "A method to determine UTC hour boundaries as candle start times",
      "A mechanism to trigger actions exactly once per candle formation",
      "Handling of potential clock synchronization discrepancies",
      "Periodic checking strategy rather than real-time event listening"
    ]
  },
  {
    "number": 2254,
    "title": "Bitmex: fetch_ohlcv optional parameters",
    "created_at": "2018-03-14T03:10:31Z",
    "closed_at": "2018-03-14T03:22:22Z",
    "labels": [
      "duplicate",
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/2254",
    "body": "- OS: Windows\r\n- Programming Language version: Python 3.6\r\n- CCXT version: 1.11.77\r\n- Exchange: Bitmex\r\n- Method: fetch_ohlcv()\r\n\r\nHi! \r\n  The Bitmex API supports returning only completed candles. However the CCXT library hard codes the request to return partial candles. I guess this is for unification of the method between exchanges?!?\r\n\r\nIs it possible to support specifying the `partial` parameter during the method call? This would be very useful. Perhaps it can be sent in the `params` dict and a check be made to see if `partial` exists? If not, use your default which is `True`?\r\n\r\nHere is the bitmex snippet below. \r\n\r\n```\r\ndef fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=100, params={}):\r\n        self.load_markets()\r\n        # send JSON key/value pairs, such as {\"key\": \"value\"}\r\n        # filter by individual fields and do advanced queries on timestamps\r\n        # filter = {'key': 'value'}\r\n        # send a bare series(e.g. XBU) to nearest expiring contract in that series\r\n        # you can also send a timeframe, e.g. XBU:monthly\r\n        # timeframes: daily, weekly, monthly, quarterly, and biquarterly\r\n        market = self.market(symbol)\r\n        request = {\r\n            'symbol': market['id'],\r\n            'binSize': self.timeframes[timeframe],\r\n            'partial': True,     # True == include yet-incomplete current bins\r\n            'count': limit,      # default 100, max 500\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/2254/comments",
    "author": "Dave-Vallance",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2018-03-14T03:22:22Z",
        "body": "Hi!\r\n\r\n```Python\r\n# create the exchange\r\nimport ccxt \r\nbitmex = ccxt.bitmex()\r\n\r\n# params:\r\nsymbol = 'BTC/USD'\r\ntimeframe = '1m'\r\nsince = None\r\nlimit = 100\r\nparams = {'partial': False}  # \u2190-------------  here you go\r\n\r\n# the call:\r\ncandles = bitmex.fetch_ohlcv(symbol, timeframe, since, limit, params)\r\nprint(bitmex.iso8601(candles[len(candles)-1][0]))\r\n```\r\n\r\nLet us know if it does not help."
      },
      {
        "user": "Dave-Vallance",
        "created_at": "2018-03-14T06:56:24Z",
        "body": "Thank you - I will check it out!\n\n---\n\nHi @kroitor \r\n\r\nI took a look at the example. Unfortunately for me, the parameter does not seem to override the bitmex `partial` parameter.\r\n\r\nI extended your example code a little to test.\r\n\r\n```\r\nimport ccxt\r\nimport time\r\nbitmex = ccxt.bitmex()\r\n\r\n\r\n# params:\r\nsymbol = 'BTC/USD'\r\ntimeframe = '1m'\r\nsince = None\r\nlimit = 100\r\nparams = {'partial': False, 'reverse':True}  # \u2190-------------  here you go\r\n\r\n\r\n\r\nwhile True:\r\n    # the call:\r\n    candles = bitmex.fetch_ohlcv(symbol, timeframe, since, limit, params)\r\n    print('{}: O: {} H: {} L:{} C:{}'.format(\r\n        bitmex.iso8601(candles[0][0]),\r\n        candles[0][1],\r\n        candles[0][2],\r\n        candles[0][3],\r\n        candles[0][4]))\r\n    time.sleep(3)\r\n```\r\n\r\nThis is the output: \r\n```\r\n2018-03-14T06:50:00.000Z: O: 9105 H: 9105 L:9104.5 C:9105\r\n2018-03-14T06:50:00.000Z: O: 9105 H: 9105 L:9104.5 C:9105\r\n2018-03-14T06:50:00.000Z: O: 9105 H: 9105 L:9104.5 C:9105\r\n2018-03-14T06:50:00.000Z: O: 9105 H: 9105 L:9104.5 C:9105\r\n2018-03-14T06:50:00.000Z: O: 9105 H: 9105 L:9104.5 C:9105\r\n2018-03-14T06:50:00.000Z: O: 9105 H: 9105 L:9104.5 C:9105\r\n2018-03-14T06:50:00.000Z: O: 9105 H: 9105 L:9104.5 C:9105\r\n2018-03-14T06:50:00.000Z: O: 9105 H: 9105 L:9104.5 C:9104.5\r\n2018-03-14T06:50:00.000Z: O: 9105 H: 9105 L:9104 C:9104\r\n2018-03-14T06:50:00.000Z: O: 9105 H: 9105 L:9100.5 C:9100.5\r\n2018-03-14T06:50:00.000Z: O: 9105 H: 9105 L:9100.5 C:9103\r\n2018-03-14T06:50:00.000Z: O: 9105 H: 9105 L:9100.5 C:9103\r\n```\r\n\r\nHere we can see that partial candle data is being delivered. The low and close starts to change towards the end even though the timestamp is the same. \r\n\r\nPerhaps I am missing something obvious? Apologies if that is the case. \r\n\r\nI appreciate your feedback!"
      },
      {
        "user": "kroitor",
        "created_at": "2018-03-14T07:09:01Z",
        "body": "```Python\r\n# -*- coding: utf-8 -*-\r\n\r\nimport ccxt\r\nimport time\r\nbitmex = ccxt.bitmex()\r\n\r\n\r\n# params:\r\nsymbol = 'BTC/USD'\r\ntimeframe = '1m'\r\nlimit = 100\r\nparams = {'partial': False}  # \u2190--------  no reversal\r\n\r\nwhile True:\r\n\r\n    # pay attention to since with respect to limit if you're doing it in a loop\r\n    since = bitmex.milliseconds () - limit * 60 * 1000 \r\n\r\n    candles = bitmex.fetch_ohlcv(symbol, timeframe, since, limit, params)\r\n    num_candles = len(candles)\r\n    print('{}: O: {} H: {} L:{} C:{}'.format(\r\n        bitmex.iso8601(candles[num_candles - 1][0]),\r\n        candles[num_candles - 1][1],\r\n        candles[num_candles - 1][2],\r\n        candles[num_candles - 1][3],\r\n        candles[num_candles - 1][4]))\r\n    time.sleep(5)\r\n```\r\n\r\n```\r\nmbp:python igorkroitor$ python bitmex-fetch-ohlcv-with-extra-params.py\r\n2018-03-14T07:05:00.000Z: O: 9151 H: 9151.5 L:9139.5 C:9139.5\r\n2018-03-14T07:05:00.000Z: O: 9151 H: 9151.5 L:9139.5 C:9139.5\r\n2018-03-14T07:05:00.000Z: O: 9151 H: 9151.5 L:9139.5 C:9139.5\r\n2018-03-14T07:05:00.000Z: O: 9151 H: 9151.5 L:9139.5 C:9139.5\r\n2018-03-14T07:05:00.000Z: O: 9151 H: 9151.5 L:9139.5 C:9139.5\r\n2018-03-14T07:05:00.000Z: O: 9151 H: 9151.5 L:9139.5 C:9139.5\r\n2018-03-14T07:05:00.000Z: O: 9151 H: 9151.5 L:9139.5 C:9139.5\r\n2018-03-14T07:05:00.000Z: O: 9151 H: 9151.5 L:9139.5 C:9139.5\r\n2018-03-14T07:05:00.000Z: O: 9151 H: 9151.5 L:9139.5 C:9139.5\r\n2018-03-14T07:05:00.000Z: O: 9151 H: 9151.5 L:9139.5 C:9139.5\r\n2018-03-14T07:05:00.000Z: O: 9151 H: 9151.5 L:9139.5 C:9139.5\r\n2018-03-14T07:05:00.000Z: O: 9151 H: 9151.5 L:9139.5 C:9139.5\r\n2018-03-14T07:06:00.000Z: O: 9139.5 H: 9146 L:9139.5 C:9146\r\n2018-03-14T07:06:00.000Z: O: 9139.5 H: 9146 L:9139.5 C:9146\r\n2018-03-14T07:06:00.000Z: O: 9139.5 H: 9146 L:9139.5 C:9146\r\n2018-03-14T07:06:00.000Z: O: 9139.5 H: 9146 L:9139.5 C:9146\r\n2018-03-14T07:06:00.000Z: O: 9139.5 H: 9146 L:9139.5 C:9146\r\n2018-03-14T07:06:00.000Z: O: 9139.5 H: 9146 L:9139.5 C:9146\r\n2018-03-14T07:06:00.000Z: O: 9139.5 H: 9146 L:9139.5 C:9146\r\n2018-03-14T07:06:00.000Z: O: 9139.5 H: 9146 L:9139.5 C:9146\r\n2018-03-14T07:06:00.000Z: O: 9139.5 H: 9146 L:9139.5 C:9146\r\n2018-03-14T07:06:00.000Z: O: 9139.5 H: 9146 L:9139.5 C:9146\r\n2018-03-14T07:06:00.000Z: O: 9139.5 H: 9146 L:9139.5 C:9146\r\n2018-03-14T07:07:00.000Z: O: 9146 H: 9146 L:9140 C:9141\r\n2018-03-14T07:07:00.000Z: O: 9146 H: 9146 L:9140 C:9141\r\n2018-03-14T07:07:00.000Z: O: 9146 H: 9146 L:9140 C:9141\r\n2018-03-14T07:07:00.000Z: O: 9146 H: 9146 L:9140 C:9141\r\n2018-03-14T07:07:00.000Z: O: 9146 H: 9146 L:9140 C:9141\r\n2018-03-14T07:07:00.000Z: O: 9146 H: 9146 L:9140 C:9141\r\n2018-03-14T07:07:00.000Z: O: 9146 H: 9146 L:9140 C:9141\r\n...\r\n```\r\n\r\nDoes this solve your issue?"
      },
      {
        "user": "Dave-Vallance",
        "created_at": "2018-03-14T08:47:55Z",
        "body": "Hi @kroitor \r\n\r\nThanks, you are awesome! That does work. Great solution. \r\n\r\nIf I am reading it correctly, you are just taking the second to last timestamp in the list right? So does that mean the `partial` parameter is not affecting the results? (since partial results are still obtained).    "
      },
      {
        "user": "kroitor",
        "created_at": "2018-03-14T08:52:55Z",
        "body": "> If I am reading it correctly, you are just taking the second to last timestamp in the list right? \r\n\r\nNo, you're not reading it correctly, i'm taking the last candle, because all indexes in an array are zero based. Thus:\r\n\r\n- candles[0] = first element\r\n- candles[1] = second element\r\n- candles[num_candles-1] = last element\r\n\r\nThis is the very basics of any programming course.\r\n\r\n> So does that mean the partial parameter is not affecting the results? (since partial results are still obtained).\r\n\r\nNope, the code above demonstrates exactly the opposite: the partial results are **not obtained** due to `{'partial': False}`, as the **last candle is not changing** over time.\r\n\r\n"
      },
      {
        "user": "Dave-Vallance",
        "created_at": "2018-03-14T09:08:31Z",
        "body": "Apologies... must be getting tired here. Thanks again."
      },
      {
        "user": "goorooau",
        "created_at": "2018-06-01T08:15:14Z",
        "body": "I found I had to use `{'partial': 0}` rather than using the boolean False. It then did not show the current incomplete candle data... not sure if it's an issue on my machine or not.\r\nPython 2.7, Win10 64bit Pro, latest ccxt ver. Bitmex."
      },
      {
        "user": "kroitor",
        "created_at": "2018-06-01T13:19:47Z",
        "body": "@goorooau thx for the feedback!"
      },
      {
        "user": "xmatthias",
        "created_at": "2018-08-13T11:10:01Z",
        "body": "does `'partial': False` or `'partial': 0` work reliably against all exchanges or is this bitmex specific?\r\n\r\nif it's working against all exchanges ... i think it's missing from the documentation ..."
      },
      {
        "user": "kroitor",
        "created_at": "2018-08-13T15:21:02Z",
        "body": "> does 'partial': False or 'partial': 0 work reliably against all exchanges or is this bitmex specific?\r\n\r\nIt is BitMEX-specific."
      }
    ],
    "satisfaction_conditions": [
      "Ability to override the default 'partial' parameter in fetch_ohlcv() for Bitmex",
      "Clear documentation/implementation of exchange-specific parameters in CCXT",
      "Consistent candle data retrieval without partial updates",
      "Proper handling of timestamp alignment in historical data requests",
      "Transparent parameter passing mechanism through CCXT's params dictionary"
    ]
  },
  {
    "number": 2134,
    "title": "inconsistent timeframes format ",
    "created_at": "2018-03-06T07:20:37Z",
    "closed_at": "2018-03-06T08:13:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/2134",
    "body": "The issue is that the format of the exchange property timeframes is NOT consistent. \r\n```\r\nexchange_ids = ['binance', 'bitfinex', 'hitbtc', 'kucoin', 'kraken', 'poloniex', 'gdax', 'gemini', 'huobipro', 'okex']\r\nexchanges = [getattr(ccxt, str.lower())() for str in exchange_ids]\r\n[print(ex.timeframes) for ex in exchanges if hasattr(ex, 'timeframes')]\r\n```\r\n\r\nThe above code prints out some examples in the following:\r\n```\r\n{'1m': '1m', '3m': '3m', '5m': '5m', '15m': '15m', '30m': '30m', '1h': '1h', '2h': '2h', '4h': '4h', '6h': '6h', '8h': '8h', '12h': '12h', '1d': '1d', '3d': '3d', '1w': '1w', '1M': '1M'}\r\n{'1m': '1m', '5m': '5m', '15m': '15m', '30m': '30m', '1h': '1h', '3h': '3h', '6h': '6h', '12h': '12h', '1d': '1D', '1w': '7D', '2w': '14D', '1M': '1M'}\r\n{'1m': '1', '5m': '5', '15m': '15', '30m': '30', '1h': '60', '8h': '480', '1d': 'D', '1w': 'W'}\r\n{'1m': '1', '5m': '5', '15m': '15', '30m': '30', '1h': '60', '4h': '240', '1d': '1440', '1w': '10080', '2w': '21600'}\r\n{'5m': 300, '15m': 900, '30m': 1800, '2h': 7200, '4h': 14400, '1d': 86400}\r\n{'1m': 60, '5m': 300, '15m': 900, '30m': 1800, '1h': 3600, '2h': 7200, '4h': 14400, '12h': 43200, '1d': 86400, '1w': 604800, '1M': 2592000, '1y': 31536000}\r\n{'1m': '1min', '5m': '5min', '15m': '15min', '30m': '30min', '1h': '60min', '1d': '1day', '1w': '1week', '1M': '1mon', '1y': '1year'}\r\n{'1m': '1min', '3m': '3min', '5m': '5min', '15m': '15min', '30m': '30min', '1h': '1hour', '2h': '2hour', '4h': '4hour', '6h': '6hour', '12h': '12hour', '1d': '1day', '3d': '3day', '1w': '1week'}\r\n```\r\n\r\n\r\n`timeframes` is a hash and the values of it do not follow a format across exchanges. For example, some are like '1m' or '5m' that are no different from the keys. Some others are the actual duration in seconds which arguably is the desired format. Some others are just more descriptive keys such as '1min', '1day' and etc. \r\n\r\n\r\n- OS: \r\nOSX 10.13.3\r\n\r\n- Programming Language version: \r\nPython 3.6.4\r\n\r\n- CCXT version:\r\n1.10.760\r\n\r\n- Exchange:\r\nbinance\r\nbitfinex\r\nhitbtc\r\nkucoin\r\nkraken\r\npoloniex\r\ngdax\r\ngemini\r\nhuobipro\r\nokex\r\n\r\n- Method:\r\nthe property timeframes\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/2134/comments",
    "author": "ws2367",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2018-03-06T08:13:43Z",
        "body": "`timeframes` is a hash, where keys are unified and values are exchange-specific, so, I don't see any inconsistencies. You should not rely on the values under the keys and their formats, as they are exchange-specific. The keys are exchange-agnostic and unified and can be safely used across exchanges, namely, the \"1m\", \"5m\", \"15m\", \"1h\", and so on \u2013 those are standardized. So, there isn't an issue here, it's a matter of interpretation. If you need to get the duration in seconds, use the parseTimeframe/parse_timeframe method. Hope it helps. Let us know if it does not answer your question. Thx!"
      },
      {
        "user": "ws2367",
        "created_at": "2018-03-09T16:36:12Z",
        "body": "makes sense. Thanks!"
      }
    ],
    "satisfaction_conditions": [
      "Clarify the distinction between timeframe keys (unified) and values (exchange-specific)",
      "Provide a method to obtain consistent duration values (e.g., in seconds)",
      "Explain how to safely use timeframes across different exchanges",
      "Reference official CCXT utilities for timeframe handling"
    ]
  },
  {
    "number": 2044,
    "title": "Binance receiving error code -2015 while using API keys",
    "created_at": "2018-02-25T09:09:25Z",
    "closed_at": "2018-02-25T13:36:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/2044",
    "body": "Hi,\r\n \r\nI have created a new Binance account and set its API keys (read info, enable trading, IP access unrestricted).\r\nWhile trying to connect to my account programmaticly using CCXT, I get the following authorization error: `ccxt.base.errors.ExchangeError: binance: unknown error code: {\"code\":-2015,\"msg\":\"Invalid API-key, IP, or permissions for action.\"}`\r\nOS: Ubuntu 16 (happens on windows as well)\r\nProgramming language: Python 3.5 \r\nCCXT version: 1.10.1178\r\n\r\nWhen using `python-binance` library, I successfully connect to my account.\r\n\r\nThe code I use:\r\n```\r\nfrom binance.client import Client\r\nimport json\r\nimport ccxt\r\n\r\ndata = json.load(open('binance_auth.json'))\r\n\r\nclient = Client(\r\n    data['secret'],\r\n    data['key'])\r\n\r\napi = {\r\n                'apiKey': data['key'],\r\n                'secret': data['secret'],\r\n                'password': None,\r\n      }\r\nccxtBinance = ccxt.binance(api)\r\n\r\nprint(\"python-binance=\", client.get_account()) # succeeds\r\nprint (\"ccxt=\",ccxtBinance.fetchBalance())     # fails\r\n```\r\n\r\nThanks,\r\nLena",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/2044/comments",
    "author": "lenak25",
    "comments": [
      {
        "user": "mkutny",
        "created_at": "2018-02-25T09:58:51Z",
        "body": "Try the following:\r\n\r\n```javascript\r\napi = {\r\n                'apiKey': data['secret'],\r\n                'secret': data['key'],\r\n      }\r\n```\r\n"
      },
      {
        "user": "lenak25",
        "created_at": "2018-02-25T11:22:44Z",
        "body": "Thanks @mkutny, it works for this account.\r\nI have another Binance account (which was opened a while ago) and I had no problems to connect to it with my original code. Any reason why for some accounts the API key and secret should be swapped, while for others not? Will there be a common solution for all?\r\nThanks,\r\nLena  "
      },
      {
        "user": "mkutny",
        "created_at": "2018-02-25T12:56:06Z",
        "body": "> Any reason why for some accounts the API key and secret should be swapped, while for others not?\r\n\r\nThey should NEVER be swapped. You just happened to mix them in your `binance_auth.json`.\r\n\r\n> I have another Binance account (which was opened a while ago) and I had no problems to connect to it with my original code.\r\n\r\nYour `python-binance` won't work with that pair."
      },
      {
        "user": "lenak25",
        "created_at": "2018-02-25T13:36:59Z",
        "body": "You are correct, my mistake.\r\nThanks, closing this."
      }
    ],
    "satisfaction_conditions": [
      "Identifies root cause of API key/secret mismatch between CCXT and python-binance implementations",
      "Ensures API credentials are validated as correctly assigned (key vs secret)",
      "Provides solution that works consistently across multiple Binance accounts",
      "Explains error code -2015 in context of CCXT's implementation specifics"
    ]
  },
  {
    "number": 2043,
    "title": "futures with different contracts",
    "created_at": "2018-02-25T08:30:31Z",
    "closed_at": "2018-02-25T15:54:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/2043",
    "body": "When fetching the ticker or order book of BTC/USD (exchange: okex), I can only get the weekly futures contract. How can I get biweekly and quarterly contract? Or it is currently impossible in ccxt api?\r\n\r\nThx. \r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/2043/comments",
    "author": "ABO3",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2018-02-25T15:54:52Z",
        "body": "> Or it is currently impossible in ccxt api?\r\n\r\nIt is possible:\r\n\r\n```JavaScript\r\n\r\nconst limit = undefined\r\n\r\n// this week\r\nokex.fetchTicker('BTC/USD', {'contract_type': 'this_week'})\r\nokex.fetchOrderBookr('BTC/USD', limit, {'contract_type': 'this_week'})\r\n\r\n// next week\r\nokex.fetchTicker('BTC/USD', {'contract_type': 'next_week'})\r\nokex.fetchOrderBookr('BTC/USD', limit, {'contract_type': 'next_week'})\r\n\r\n// quarter\r\nokex.fetchTicker('BTC/USD', {'contract_type': 'quarter'})\r\nokex.fetchOrderBookr('BTC/USD', limit, {'contract_type': 'quarter'})\r\n```\r\n\r\nUse the `contract_type` extra parameter. Let us know if it does not help.\r\n\r\n*UPD: edited fetchOrderBook call signatures"
      },
      {
        "user": "ABO3",
        "created_at": "2018-02-25T15:57:51Z",
        "body": "thx, that's helpful"
      },
      {
        "user": "kroitor",
        "created_at": "2018-02-25T15:59:57Z",
        "body": "@ABO3 sorry, there was a typo in my previous answer, I've corrected it. With fetchOrderBook, the extra params dictionary is the third argument, whereas the second argument is the order book depth limit (can be set to None/undefined if not needed). But the answer itself isn't changed significantly, you should still use extra params for exchange-specific things."
      }
    ],
    "satisfaction_conditions": [
      "Confirmation that the CCXT API supports accessing biweekly and quarterly futures contracts",
      "Explanation of how to specify different contract types through API parameters",
      "Clarification on handling exchange-specific parameters in CCXT"
    ]
  },
  {
    "number": 1795,
    "title": "Please help ",
    "created_at": "2018-02-06T18:34:34Z",
    "closed_at": "2018-02-06T19:14:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/1795",
    "body": "Hi everyone, im a newbie in js and i need your help.So this is my code and the main problem is that it doesnt return me eth and btc balances, just says promise pending and after gives me al info about balance on every currency \r\n\r\n```\r\nlet finalamountbinance\r\nlet getbalancebinance = async() => {\r\n    let count=0;\r\n    let balance\r\n    try{\r\n        balance = await binance.fetchBalance()\r\n        console.log(balance)\r\n    }\r\n    catch(BaseError){\r\n        getbalancebinance()\r\n    }\r\n    if(count==0){\r\n        finalamountbinance = balance.BTC.free\r\n        count++\r\n        final=0\r\n    }\r\n    if(count==1){\r\n        finalamountbinance = balance.ETH.free\r\n        count--\r\n        final=0\r\n    }\r\n}\r\nlet getbalanceyobit = async() => {\r\n    let balance\r\n    try{\r\n        balance = await yobit.fetchBalance()\r\n        console.log(yobit)\r\n    }\r\n    catch(BaseError){\r\n        getbalanceyobit()\r\n    }\r\n    return balance\r\n}\r\n\r\nfunction bot(){\r\n    getbalancebinance()\r\n    console.log(finalamountbinance)\r\n    getbalancebinance()\r\n    console.log(finalamountbinance)\r\n}\r\n\r\nbot()\r\n```",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/1795/comments",
    "author": "artbred",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2018-02-06T19:14:15Z",
        "body": "A straightforward answer to your question:\r\n\r\n```JavaScript\r\nlet finalamountbinance\r\nlet getbalancebinance = async() => {\r\n    let count=0;\r\n    let balance\r\n    try{\r\n        balance = await binance.fetchBalance()\r\n        console.log(balance)\r\n    }\r\n    catch(BaseError){\r\n        getbalancebinance()\r\n    }\r\n    if(count==0){\r\n        finalamountbinance = balance.BTC.free\r\n        count++\r\n        final=0\r\n    }\r\n    if(count==1){\r\n        finalamountbinance = balance.ETH.free\r\n        count--\r\n        final=0\r\n    }\r\n}\r\nlet getbalanceyobit = async() => {\r\n    let balance\r\n    try{\r\n        balance = await yobit.fetchBalance()\r\n        console.log(yobit)\r\n    }\r\n    catch(BaseError){\r\n        getbalanceyobit()\r\n    }\r\n    return balance\r\n}\r\n\r\n;(async function bot(){\r\n    await getbalancebinance()\r\n    console.log(finalamountbinance)\r\n    await getbalancebinance()\r\n    console.log(finalamountbinance)\r\n}) ()\r\n```\r\n\r\nHowever, I'm not responsible for the code quality, you need to practice more with general JS and JS promises."
      },
      {
        "user": "artbred",
        "created_at": "2018-02-06T19:20:15Z",
        "body": "Thank you very much"
      }
    ],
    "satisfaction_conditions": [
      "Proper handling of asynchronous operations to ensure balances are resolved before access",
      "Clear demonstration of accessing nested balance data from exchange API responses"
    ]
  },
  {
    "number": 1738,
    "title": "Hitbtc2 empty AVH market, payinEnabled, payoutEnabled, crypto and other fields missing",
    "created_at": "2018-02-02T20:03:20Z",
    "closed_at": "2018-02-02T20:09:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/1738",
    "body": "I found this error with Hitbtc2 (but not Hitbtc):\r\n\r\nFile \"/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/ccxt/base/exchange.py\", line 844, in load_markets\r\n    currencies = self.fetch_currencies()\r\n  File \"/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/ccxt/hitbtc2.py\", line 616, in fetch_currencies\r\n    payin = currency['payinEnabled']",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/1738/comments",
    "author": "alexlacey",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2018-02-02T20:09:15Z",
        "body": "Yep, for some reason their API started reporting this empty currency: `{\"id\":\"AVH\",\"fullName\":\"Animation Vision Cash\"}` but ccxt version 1.10.978 that is capable of handling it has already arrived, please update and retry once again. Let us know if this does not solve the issue for you. Thx!\r\n"
      },
      {
        "user": "alexlacey",
        "created_at": "2018-02-02T20:13:47Z",
        "body": "Wow, that was so fast. Thank you!"
      }
    ],
    "satisfaction_conditions": [
      "Handles missing API fields gracefully without errors",
      "Provides forward compatibility with API changes",
      "Maintains currency fetching functionality despite incomplete data"
    ]
  },
  {
    "number": 1733,
    "title": "[Bug] Bittrex OHLCV not realtime?",
    "created_at": "2018-02-02T14:56:43Z",
    "closed_at": "2018-02-02T15:02:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/1733",
    "body": "Here's how I'm doing the OHLCV requests:\r\n```\r\n  new ccxt[exchange]().fetchOHLCV(\r\n    'ETH/BTC\", \r\n    '1m',\r\n    undefined\r\n  )\r\n\r\n```\r\n\r\nAnd, here's the output for 3 exchange (binance, bittrex, okex):\r\n```\r\nokex:\r\nFri Feb 02 2018 21:52:00 GMT+0700 (+07) (printCurrent @ index.mjs:32)\r\n\r\nbinance\r\n Fri Feb 02 2018 21:52:00 GMT+0700 (+07) (printCurrent @ index.mjs:32)\r\n\r\nbittrex\r\nFri Feb 02 2018 21:49:00 GMT+0700 (+07) (printCurrent @ index.mjs:32)\r\n```\r\n\r\nNotice how bittrex is lagging? I kept on running the script for a while, and bittrex OHLCV was consistently 3-4 min lagging behind.\r\nIs this a bug in my code, or a bug in the library?",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/1733/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2018-02-02T15:02:15Z",
        "body": "> Is this a bug in my code, or a bug in the library?\r\n\r\nThis is neither a bug in your code, nor a bug in the library. It's just how Bittrex works, and you can enable verbose mode (pass the `{'verbose': True}` to the constructor params), and check their URLs and reported values yourself. Bittrex does not have an official OHLCV API endpoint at all, and we use their undocumented v2.0 endpoint for that. Hope it answers your question. Thx!"
      },
      {
        "user": "ghost",
        "created_at": "2018-02-02T17:54:43Z",
        "body": "Wow! I checked their own website, and I get the same 'delay' on their own charts. That's really not a good thing at all, but that's beyoud the scope of this library.\r\nYour answer makes total sense. Thx a lot!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of whether the observed delay originates from the user's code, the library, or the exchange's API limitations",
      "Confirmation that the observed behavior matches the exchange's native API output",
      "Guidance for independent verification of raw exchange data"
    ]
  },
  {
    "number": 1522,
    "title": "hasFetchOHLCV result different from exchange.has for multiple exchanges",
    "created_at": "2018-01-27T00:01:17Z",
    "closed_at": "2018-01-27T00:04:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/1522",
    "body": "- OS: Windows 10\r\n- Programming Language version: Python 3.6.4\r\n- CCXT version: 1.10.854\r\n- Exchange: bittrex, gdax, maybe others\r\n- Method: hasFetchOHLCV\r\n```\r\nPython 3.6.4 (v3.6.4:d48eceb, Dec 19 2017, 06:54:40) [MSC v.1900 64 bit (AMD64)] on win32\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>> import ccxt\r\n>>> bittrex = getattr(ccxt, 'bittrex')({'verbose': True})\r\n>>> bittrex.hasFetchOHLCV\r\nFalse\r\n>>> bittrex.has.get('fetchOHLCV')\r\nTrue\r\n>>> gdax = getattr(ccxt, 'gdax')({'verbose': True})\r\n>>> gdax.hasFetchOHLCV\r\nFalse\r\n>>> gdax.has.get('fetchOHLCV')\r\nTrue```",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/1522/comments",
    "author": "justinxjx",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2018-01-27T00:04:43Z",
        "body": "The `hasFetchOHLCV` is now deprecated (as well as other properties alike). The new metainfo interface is contained within `.has = { }` dictionary. We are removing the outdated properties for more order. Let us know if you find some exchanges with incorrect values in their `.has = { }` property. We will update them appropriately. Hope it answers your question."
      },
      {
        "user": "justinxjx",
        "created_at": "2018-01-27T02:59:57Z",
        "body": "Yes. That answers the question. I apologize if I missed seeing that deprecation somewhere."
      }
    ],
    "satisfaction_conditions": [
      "Clarify the relationship between deprecated properties (like hasFetchOHLCV) and the new .has interface",
      "Confirm the authoritative source for checking API method availability"
    ]
  },
  {
    "number": 1368,
    "title": "Quoinex exchange id wrong in manual",
    "created_at": "2018-01-19T15:14:32Z",
    "closed_at": "2018-01-19T15:24:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/1368",
    "body": "Hi, \r\n\r\nper the manual, the id of Quoinex is \"quoinex\"\r\n\r\nHowever, using this code\r\n`let Quoinex = new ccxt.quoinex ({apiKey: API.Quoinex.Key, secret: API.Quoinex.Secret})`\r\n\r\nresults in this error: \r\n\r\n> TypeError: ccxt.quoinex is not a constructor\r\n>     at c:\\Trader\\Logic\\Test.js:68:22\r\n>     at FSReqWrap.readFileAfterClose [as oncomplete] (fs.js:511:3)\r\n\r\nIf I use \"new ccxt.quoine\", it does work.\r\n\r\nSo manual is wrong, (but I would actually prefer the naming to be per the manual, \"quoinex\")\r\n\r\nSo, do I change my code, or do you change yours?",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/1368/comments",
    "author": "wannesdemaeght",
    "comments": [
      {
        "user": "Deathamns",
        "created_at": "2018-01-19T15:20:20Z",
        "body": "It was renamed recently #1311. `quoinex` is the correct one, just make sure you're using a newer version of the library."
      },
      {
        "user": "wannesdemaeght",
        "created_at": "2018-01-19T15:24:36Z",
        "body": "Aha, great.\r\nThanks!"
      }
    ],
    "satisfaction_conditions": [
      "Clarification of the correct exchange ID naming convention in relation to library versions",
      "Guidance on maintaining compatibility between code and library versions",
      "Resolution of documentation inaccuracies regarding exchange identifiers",
      "Explanation of version-specific behavior in the library"
    ]
  },
  {
    "number": 1345,
    "title": "Question for selling an altcoin for bitcoin",
    "created_at": "2018-01-17T18:44:46Z",
    "closed_at": "2018-01-17T19:13:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/1345",
    "body": "OS:Linux\r\nProgramming Language version:Python\r\nCCXT version:1.10.586\r\nExchange:bleutrade\r\nMethod:create_limit_buy_order\r\n\r\nI want to sell an alt coin for bitcoin but calling create_limit_sell_order or create_limit_buy_order raise the exception of insufficient funds\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/1345/comments",
    "author": "chatzich",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2018-01-17T18:47:42Z",
        "body": "Do you have sufficient funds to place the order? The exception states it clearly, you need to have `amount * price + fee` on your balance to place the order."
      },
      {
        "user": "chatzich",
        "created_at": "2018-01-17T18:51:18Z",
        "body": "(amountOfBtc I want to buy)*priceOfAltcoinInBtc + fee right?"
      },
      {
        "user": "kroitor",
        "created_at": "2018-01-17T18:53:09Z",
        "body": "Which symbol (market, pair) are you trading?"
      },
      {
        "user": "chatzich",
        "created_at": "2018-01-17T18:55:14Z",
        "body": "I want to convert VRC to BTC\r\n"
      },
      {
        "user": "kroitor",
        "created_at": "2018-01-17T19:03:21Z",
        "body": "Ok, the symbol is `VRC/BTC`, and the amount is always on the left (before the slash), the price is on the right (after the slash).\r\n\r\nTherefore, the amount is in VRC. And the price is in BTC.\r\n\r\nSo,\r\n\r\n> (amountOfBtc I want to buy)*priceOfAltcoinInBtc + fee right?\r\n\r\nWrong )\r\n\r\nThe correct version is:\r\n\r\n```amount of VRC you want to buy * price of 1 VRC in BTC + fee```\r\n\r\nDoes this answer your question?"
      },
      {
        "user": "chatzich",
        "created_at": "2018-01-17T19:07:44Z",
        "body": "I want to buy BTC with the amount of VRC "
      },
      {
        "user": "kroitor",
        "created_at": "2018-01-17T19:09:35Z",
        "body": "@ironexmaiden as far as I know, their API does not allow that. You can only buy and sell VRC for BTC, not vice versa. But, hey, when you buy BTC for VRC and you know the amount of VRC, it means, you're just selling VRC for BTC, right? )"
      },
      {
        "user": "chatzich",
        "created_at": "2018-01-17T19:11:12Z",
        "body": "ok thank you"
      },
      {
        "user": "kroitor",
        "created_at": "2018-01-17T19:13:09Z",
        "body": "@ironexmaiden \r\n\r\nYou can't do this:\r\n\r\n- *I want to buy BTC with the amount of VRC*\r\n\r\nBut you can do this:\r\n\r\n- *I want to sell the amount VRC for BTC*\r\n\r\nAnd it's the same thing, you just need to be exact in sides and terms."
      },
      {
        "user": "chatzich",
        "created_at": "2018-01-17T19:16:27Z",
        "body": "How can I achieve this @kroitor ? with create_limit_sell_order? I have thought that this function is selling BTC for the altcoin in  the trade symbol i.e VRC/BTC sells BTC for VRC"
      },
      {
        "user": "kroitor",
        "created_at": "2018-01-17T19:20:20Z",
        "body": "@ironexmaiden \r\n\r\n> with create_limit_sell_order?\r\n\r\nYes\r\n\r\n> I have thought that this function is selling BTC for the altcoin in the trade symbol i.e VRC/BTC sells BTC for VRC\r\n\r\nIt's vice-versa: sells VRC for BTC.\r\n\r\n```\r\n base \u2192 VRC/BTC \u2190 quote\r\n```\r\n\r\n- create_limit_buy_order = you buy the base currency (VRC) and give (pay) quote currency (BTC)\r\n- create_limit_sell_order = you sell the base currency (VRC) and receive the quote currency (BTC)\r\n- amount is always in base currency (VRC)\r\n- price is always in quote currency (BTC)\r\n"
      }
    ],
    "satisfaction_conditions": [
      "Clarification of base/quote currency interpretation in CCXT trading pairs",
      "Explanation of create_limit_sell_order parameters in context of currency pairs",
      "Guidance on calculating required balance including fees",
      "Differentiation between buying base currency vs selling base currency",
      "Verification of exchange API capabilities for desired trade direction"
    ]
  },
  {
    "number": 1229,
    "title": "Clarifying Understanding of `baseVolume` and `quoteVolume`",
    "created_at": "2018-01-13T03:38:36Z",
    "closed_at": "2018-01-13T04:06:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/1229",
    "body": "I've been reading through the manual and just wanted to check that my understanding of base/quote volumes is correct!\r\n\r\nIn a given market FOO/BAR, `baseVolume` indicates the total amount of FOO that has been bought and sold in this market in the past 24hrs, while `quoteVolume` is the total amount of BAR that has been bought and sold in this market in the past 24hrs. Is this correct?\r\n\r\nIf so, I have a follow-up question: Is it possible to get the volumes for the two different directions for a single market using ccxt? E.g. is it possible to distinguish between the amount of FOO that was bought  and  the amount of FOO that has been sold (rather than just the sum total of both)?\r\n\r\nThanks for your time and awesome work!",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/1229/comments",
    "author": "mitchmindtree",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2018-01-13T03:53:55Z",
        "body": "> In a given market FOO/BAR, baseVolume indicates the total amount of FOO that has been bought and sold in this market in the past 24hrs, while quoteVolume is the total amount of BAR that has been bought and sold in this market in the past 24hrs. Is this correct?\r\n\r\nExactly!\r\n\r\n> If so, I have a follow-up question: Is it possible to get the volumes for the two different directions for a single market using ccxt? E.g. is it possible to distinguish between the amount of FOO that was bought and the amount of FOO that has been sold (rather than just the sum total of both)?\r\n\r\nNo, unfortunately, most of exchanges will not return that info segregated. And you cannot deduce exact values of one from another. Most often exchanges will return just the baseVolume or just the quoteVolume.\r\n\r\nOne more note: when you buy FOO on the FOO/BAR market, you are buying it for BAR, right?  So, when you buy FOO for BAR, that means, you are actually selling BAR for FOO.\r\n\r\n- buy FOO/BAR == sell BAR/FOO\r\n- sell FOO/BAR == buy BAR/FOO\r\n\r\nThere's also a volume-weighed average price (vwap, present with some exchanges) \u2013\u00a0that is the average price for those baseVolume and quoteVolume. And, from there:\r\n\r\n- cost = amount * price\r\n- equivalently, quoteVolume (total 24h traded quote cost) ~= baseVolume * vwap (total 24h base cost * average price over last 24h)\r\n\r\nLet me know if this answers your question."
      },
      {
        "user": "mitchmindtree",
        "created_at": "2018-01-13T04:06:59Z",
        "body": "Perfect, thank you for such a quick and detailed response!"
      }
    ],
    "satisfaction_conditions": [
      "Confirmation of correct understanding of baseVolume/quoteVolume definitions",
      "Clarification about availability of directional volume segmentation in CCXT",
      "Explanation of buy/sell relationship dynamics in market pairs",
      "Context about exchange data limitations regarding volume granularity"
    ]
  },
  {
    "number": 1097,
    "title": "How to determine if bittrex's specific wallet is offline or under maintainance",
    "created_at": "2018-01-06T21:01:00Z",
    "closed_at": "2018-01-06T21:07:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/1097",
    "body": "Hello,\r\nIs there a way to check if a wallet on bittrex is offline or under maintainance etc?\r\n\r\nI used cctx.bittrex.load_markets() for ['FCT/BTC'] and returns \"active\":true even though the wallet is currently offline",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/1097/comments",
    "author": "chatzich",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2018-01-06T21:07:37Z",
        "body": "Hi!\r\n\r\n```Python\r\nimport ccxt\r\nimport pprint\r\nexchange = ccxt.bittrex ()\r\nexchange.load_markets()\r\npprint(exchange.currencies['FCT'])\r\npprint(exchange.currencies['FCT']['active'])\r\n```"
      },
      {
        "user": "chatzich",
        "created_at": "2018-01-06T21:10:52Z",
        "body": "Thank you ! But why ['FCT/BTC'] active returns true?"
      },
      {
        "user": "kroitor",
        "created_at": "2018-01-06T21:11:18Z",
        "body": "@ironexmaiden because it is allowed for trading (you can't fund it, but you can trade it).\r\n  "
      },
      {
        "user": "chatzich",
        "created_at": "2018-01-06T21:13:29Z",
        "body": "ok my fault! sorry for the inconvience"
      },
      {
        "user": "kroitor",
        "created_at": "2018-01-06T21:17:11Z",
        "body": "no worries)"
      }
    ],
    "satisfaction_conditions": [
      "Clarify the distinction between trading activity status and wallet funding status",
      "Identify the correct API endpoint/data structure for wallet status checks",
      "Explain how operational statuses map to API responses"
    ]
  },
  {
    "number": 1056,
    "title": "What does edit order do",
    "created_at": "2018-01-03T21:29:06Z",
    "closed_at": "2018-01-03T22:00:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/1056",
    "body": "Can someone please explain what does edit order do? And how does it work (an example)?\r\n\r\nI did not find any information about it in the manual. \r\n\r\nThank you so much for this awesome tool!\r\n  ",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/1056/comments",
    "author": "hunsnowboarder",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2018-01-03T21:37:43Z",
        "body": "Some exchanges support *canceling+placing a new order* in one call (poloniex). For other exchanges that don't support that, the editOrder call will emulate it in two separate calls (cancel, then place new), effectively replacing or *editing* the old order. Let me know if this answers your question.\r\n  "
      },
      {
        "user": "hunsnowboarder",
        "created_at": "2018-01-03T21:42:21Z",
        "body": "Wow, this is megacool! \r\nCould you please just give an example because I am having hard time to understand what args*  mean? I am not sure about the order of the arguments, and also about the exact name of the arguments? (i mean something like \"new_price\" and \"new_volume\" or just \"price\" and \"volume\"?)\r\nThank you in advance. "
      },
      {
        "user": "kroitor",
        "created_at": "2018-01-03T21:46:39Z",
        "body": "This is the default implementation:\r\n\r\n```Python\r\n    def edit_order(self, id, symbol, *args):\r\n        if not self.enableRateLimit:\r\n            raise ExchangeError(self.id + ' edit_order() requires enableRateLimit = true')\r\n        self.cancel_order(id, symbol)\r\n        return self.create_order(symbol, *args)\r\n```\r\n\r\nAs you can see, it accepts the id + all params from `create_order()`: \r\n```\r\ndef create_order(self, symbol, type, side, amount, price=None, params={}):\r\n```\r\n\r\nSo the full ordered set of **positional** arguments for `edit_order()` is:\r\n- id\r\n- symbol\r\n- type\r\n- side\r\n- amount\r\n- price\r\n- params\r\n\r\nDoes this help?\r\n  "
      },
      {
        "user": "hunsnowboarder",
        "created_at": "2018-01-03T21:55:45Z",
        "body": "Thank you so much! Of course it does. :)\r\nJust a question out of curiosity. Why is the symbol a required parameter? The order id should definitely identify the order. I suppose this is an expectation from the exchange just for double checking the command.\r\nAnyway thank you so much for you help! You can close this thread now!\r\n "
      },
      {
        "user": "kroitor",
        "created_at": "2018-01-03T21:58:24Z",
        "body": "> Just a question out of curiosity. Why is the symbol a required parameter? \r\n\r\nBecause they have separate databases with unsynchronized ids between the databases, so you can't mix one id with the other database, if you don't know the symbol.\r\n\r\n> The order id should definitely identify the order. \r\n\r\nOnly if all your orders in the engine use the same linear id space. But this is often **not the case**. \r\n\r\n> I suppose this is an expectation from the exchange just for double checking the command.\r\n\r\nIf you think in terms of scalability and load-balancing, this can make sense. Separate clusters for separate pairs and for unrelated orders = no accidental interference = a more reliable exchange.\r\n  "
      },
      {
        "user": "hunsnowboarder",
        "created_at": "2018-01-03T22:01:02Z",
        "body": "Thank you so much! Of course it does. :)\r\nJust a question out of curiosity. Why is the symbol a required parameter? The order id should definitely identify the order. I suppose this is an expectation from the exchange just for double checking the command.\r\nAnyway thank you so much for you help! You can close this thread now!\r\n \n\n---\n\nYes it does make sense! Thank you so much! Proud to become one of your backers!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of edit_order's core functionality and purpose",
      "Clear parameter specification including argument order and naming conventions",
      "Rationale for required parameters like 'symbol' in edit_order",
      "Differentiation between native exchange support and emulated behavior"
    ]
  },
  {
    "number": 893,
    "title": "bitstamp createOrder type limit throws \"under 5$ Order\" exception",
    "created_at": "2017-12-18T21:39:45Z",
    "closed_at": "2017-12-18T22:09:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/893",
    "body": "createLimitBuyOrder is also broken on bitstamp.\r\n\r\n- exchange.createOrder ('BTC/USD', 'limit', 'buy', '0.001', '20.00') -> doesn't work\r\n- exchange.createOrder ('BTC/USD', 'market', 'buy', '0.001') -> works fine\r\n\r\ni don't know how to fix it myself, sorry.",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/893/comments",
    "author": "jom1337",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2017-12-18T21:50:30Z",
        "body": "Let's see... you're buying BTC 0.001 for a price of $20 per BTC, that is:\r\n\r\n`$20 * 0.001 = $0.020` \r\n\r\nwhich is obviously less that $5. Pure arithmetics...\r\n\r\nYour BTC/USD order should be worth more than $5 in total. \r\n\r\n> i don't know how to fix it myself, sorry.\r\n\r\nOne solution I would propose is to not submit orders that are too small, because most exchanges will forbid *dust trade* (orders of very tiny amounts)."
      },
      {
        "user": "jom1337",
        "created_at": "2017-12-18T22:09:03Z",
        "body": "oh, i totally misunderstood this function.\r\nthanks a lot."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of exchange-specific minimum order value requirements",
      "Clarification of how order parameters affect total order value calculation",
      "Guidance on avoiding dust trade restrictions"
    ]
  },
  {
    "number": 772,
    "title": "XMR (Monero) Withdrawal and Payment ID example",
    "created_at": "2017-12-07T00:27:11Z",
    "closed_at": "2017-12-07T00:36:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/772",
    "body": "Hello!\r\n\r\nMany (all?) exchanges require both wallet + payment ID to deposit XMR (Monero).\r\nTherefore, once withdrawing you should specify both wallet address and payment id. I failed to find a code example for payment id param:\r\n`exchange.withdraw (currency, amount, address, params = {})`\r\n\r\nCould you please help it?\r\n\r\nThank you in advance,\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/772/comments",
    "author": "Fcl69",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2017-12-07T00:29:12Z",
        "body": "@Fcl69 it is exchange-specific currently, we don't have this particular aspect of XMR unified yet. However, we have started a major rework of currencies, so we hope to support for that soon. In the meantime, you will have to look up the name of that param in exchanges' docs. We will notify you on progress. Let me know if the above does not answer your question. Thx!"
      },
      {
        "user": "Fcl69",
        "created_at": "2017-12-07T00:33:07Z",
        "body": "Ok, got it. So... just to confirm. Here's what binance API says, for example:\r\n> addressTag | STRING | NO | Secondary address identifier for coins like XRP,XMR etc.\r\n\r\nDoes it mean my code should look like that:\r\n`exchange.withdraw ('XMR', 1, 'address', params = {addressTag='payment_id'})`\r\n?"
      },
      {
        "user": "kroitor",
        "created_at": "2017-12-07T00:35:33Z",
        "body": "@Fcl69 \r\n\r\n> Does it mean my code should look like that:\r\n> exchange.withdraw ('XMR', 1, 'address', params = {addressTag='payment_id'})\r\n\r\nAlmost, the exact meaning is:\r\n\r\n```Python\r\nexchange.withdraw ('XMR', 1, 'address', {'addressTag': 'payment_id'})\r\n```"
      },
      {
        "user": "Fcl69",
        "created_at": "2017-12-07T00:36:33Z",
        "body": "gotcha! Thank you so much as always!"
      }
    ],
    "satisfaction_conditions": [
      "Clarification of how to include the payment ID parameter in the withdrawal method",
      "Exchange-specific parameter handling guidance",
      "Validation of parameter syntax for the withdraw() method",
      "Alignment with exchange API documentation requirements"
    ]
  },
  {
    "number": 746,
    "title": "pip install on Mac: Permission denied",
    "created_at": "2017-12-04T16:32:43Z",
    "closed_at": "2017-12-04T16:37:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/746",
    "body": "When I install ccxd on command line of Mac, I got a message like a following.\r\nHow can I install ccxt? \r\n\r\npip install ccxt\r\n\r\n\r\nCollecting ccxt\r\n\r\n  Using cached ccxt-1.10.282-py2.py3-none-any.whl\r\nRequirement already satisfied: setuptools in /System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python (from ccxt)\r\nInstalling collected packages: ccxt\r\nException:\r\nTraceback (most recent call last):\r\n  File \"/Library/Python/2.7/site-packages/pip-9.0.1-py2.7.egg/pip/basecommand.py\", line 215, in main\r\n    status = self.run(options, args)\r\n  File \"/Library/Python/2.7/site-packages/pip-9.0.1-py2.7.egg/pip/commands/install.py\", line 342, in run\r\n    prefix=options.prefix_path,\r\n  File \"/Library/Python/2.7/site-packages/pip-9.0.1-py2.7.egg/pip/req/req_set.py\", line 784, in install\r\n    **kwargs\r\n  File \"/Library/Python/2.7/site-packages/pip-9.0.1-py2.7.egg/pip/req/req_install.py\", line 851, in install\r\n    self.move_wheel_files(self.source_dir, root=root, prefix=prefix)\r\n  File \"/Library/Python/2.7/site-packages/pip-9.0.1-py2.7.egg/pip/req/req_install.py\", line 1064, in move_wheel_files\r\n    isolated=self.isolated,\r\n  File \"/Library/Python/2.7/site-packages/pip-9.0.1-py2.7.egg/pip/wheel.py\", line 345, in move_wheel_files\r\n    clobber(source, lib_dir, True)\r\n  File \"/Library/Python/2.7/site-packages/pip-9.0.1-py2.7.egg/pip/wheel.py\", line 316, in clobber\r\n    ensure_dir(destdir)\r\n  File \"/Library/Python/2.7/site-packages/pip-9.0.1-py2.7.egg/pip/utils/__init__.py\", line 83, in ensure_dir\r\n    os.makedirs(path)\r\n  File \"/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/os.py\", line 157, in makedirs\r\n    mkdir(name, mode)\r\nOSError: [Errno 13] Permission denied: '/Library/Python/2.7/site-packages/ccxt'",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/746/comments",
    "author": "kangilrhee",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2017-12-04T16:34:22Z",
        "body": "Have you tried `sudo pip install ccxt` ?"
      },
      {
        "user": "kangilrhee",
        "created_at": "2017-12-04T16:36:10Z",
        "body": "@kroitor Thanks.! I installed \ud83d\udc4d  :)"
      }
    ],
    "satisfaction_conditions": [
      "Resolves permission issues preventing package installation to system directories",
      "Provides a working method to install ccxt successfully",
      "Applies to macOS system Python environments"
    ]
  },
  {
    "number": 625,
    "title": "'master' has been diverged",
    "created_at": "2017-11-18T06:09:06Z",
    "closed_at": "2017-11-18T11:28:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/625",
    "body": "Hi, git noticed that we diverged after 1.10.148 and I'm unable to merge.\r\n\r\n30+ commits are missing from upstream.\r\n\r\nIs it known and I should just reset or it's something unexpected?",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/625/comments",
    "author": "mkutny",
    "comments": [
      {
        "user": "xpl",
        "created_at": "2017-11-18T10:43:39Z",
        "body": "We had to revert some commits yesterday, while trying to figure out a mysterious issue with GitHub showing a wrong username under commits made by our Travis CI deploy script.\r\n\r\nIt turned out it was not related to our recent changes at all, and was a GitHub issue actually (someone managed to link travis@travis-ci.org email with their GitHub account, so every commit made with this email in the `Author` field was erroneously shown as if it was made by that user). Since then, it has been resolved successfully."
      },
      {
        "user": "mkutny",
        "created_at": "2017-11-18T11:28:35Z",
        "body": "> We had to revert some commits yesterday, while trying to figure out a mysterious issue with GitHub showing a wrong username under commits made by our Travis CI deploy script.\r\n\r\nI noticed that too. Actually, I thought that you've got a new team member )\r\n\r\nOk, clear now, will reset."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why the divergence occurred",
      "Confirmation of whether the situation was resolved upstream",
      "Guidance on appropriate branch management action"
    ]
  },
  {
    "number": 566,
    "title": "About cancellation of orders",
    "created_at": "2017-11-14T09:34:02Z",
    "closed_at": "2017-11-14T10:55:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/566",
    "body": "How to find the hang order? How else to cancel the order?",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/566/comments",
    "author": "gavin369",
    "comments": [
      {
        "user": "gavin369",
        "created_at": "2017-11-14T09:37:47Z",
        "body": "How to write code?  \n\n---\n\nawait huobipro.******\uff1f  Can you give me an example? Thanks\uff01"
      },
      {
        "user": "kroitor",
        "created_at": "2017-11-14T10:39:55Z",
        "body": "@gavin369 can you put your question in a few more words, please? \r\n\r\n> How to find the hang order?\r\n\r\nIf your order request failed with unknown order status, you can check your open / closed orders (where implemented) like so:\r\n\r\n```\r\nawait exchange.fetchOrders (symbol, params)\r\n// or\r\nawait exchange.fetchClosedOrders (symbol, params)\r\nawait exchange.fetchOpenOrders (symbol, params)\r\n```\r\n\r\nBut for now, the above method is not implemented for HuobiPro (it will be soon, see more about it here: #71). In the meantime you can use their custom API for fetching orders:\r\n\r\n```\r\nawait exchange.loadMarkets ()\r\nawait exchange.privateGetOrderOrders ({\r\n    'symbol': exchange.markets['ETH/BTC'].id\r\n    'states': [\r\n        'pre-submitted',\r\n        'submitted',\r\n        'partial-filled',\r\n        'partial-canceled',\r\n        'filled',\r\n        'canceled',\r\n    ].join (',')\r\n})\r\n```\r\n\r\n> How else to cancel the order?\r\n\r\n```\r\nawait exchange.cancelOrder (orderId)\r\n```\r\n\r\n> How to write code?\r\n\r\nUhm... Sorry?"
      },
      {
        "user": "gavin369",
        "created_at": "2017-11-14T10:41:40Z",
        "body": "Okay\uff0ci know"
      },
      {
        "user": "kroitor",
        "created_at": "2017-11-14T10:55:06Z",
        "body": "Okay ) I would close this for now if you don't mind."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of methods to check order status (including handling 'hang' orders)",
      "Clear demonstration of order cancellation techniques",
      "Code examples using the exchange's API for order management",
      "Handling of exchange-specific API limitations"
    ]
  },
  {
    "number": 486,
    "title": "Binance: publicGetMarketIdHours",
    "created_at": "2017-11-07T12:35:42Z",
    "closed_at": "2017-11-07T14:03:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/486",
    "body": "````\r\nhours = 8  # \u2190 your timeframe\r\ntopia.load_markets()\r\n\r\nfor symbol in btccoins:\r\n    market = topia.market(symbol)\r\n    response = topia.publicGetMarketIdHours(topia.extend({\r\n        'id': market['id'],\r\n        'hours': hours,\r\n    }))\r\n    time.sleep(delay)\r\n    ticker = topia.parse_ticker(response['Data'], market)  # How to be sure it returns the 8h past hour market?\r\n    # do whatever you need with the ticker...\r\n    datetime = ticker['datetime']\r\n    timestamp = ticker['timestamp']\r\n    open = ticker['open']\r\n    close = ticker['close']\r\n    print(close, datetime, timestamp)\r\n````\r\nthat's the result: -> timestamp is not 8h ago so how can I know it actually represents the 8h past hours timeframe?\r\n\r\n1.814e-05 2017-11-07T12:32:59.000Z 1510057979383\r\n1.209e-05 2017-11-07T12:33:01.000Z 1510057981017\r\n4.15e-05 2017-11-07T12:33:02.000Z 1510057982474\r\n1.07e-06 2017-11-07T12:33:04.000Z 1510057983791\r\n0.00105061 2017-11-07T12:33:05.000Z 1510057985092\r\n\r\nI'm sorry if I did something wrong in advance. I'm really trying to get this sorted out. thanks\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/486/comments",
    "author": "saianwork",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2017-11-07T13:00:31Z",
        "body": "If you look at timestamps you are getting, you will immediately see that those represent current datetime in UTC. When the ticker is returned, the timestamp shows the time when it was generated, not the start of your timeframe. So it will always show approximately current time. Your ticker was generated now, and its values show last 8 hours of history. The beginning of your timeframe isn't indicated anywhere.\r\n\r\n> so how can I know it actually represents the 8h past hours timeframe?\r\n\r\nAsk Binance if they really report true data for the last 8 hours or not? We don't change it on the fly. You get it as is. I hope it answers your question."
      }
    ],
    "satisfaction_conditions": [
      "Clarification of how Binance API reports timeframe boundaries",
      "Verification method for timeframe alignment",
      "Explanation of timestamp meaning in API response",
      "Understanding of historical aggregation window calculation"
    ]
  },
  {
    "number": 414,
    "title": "problem with exchange.parse8601()",
    "created_at": "2017-10-28T15:24:37Z",
    "closed_at": "2017-10-29T15:24:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/414",
    "body": "Hi, this problem happens randomly so I'm not sure if it has something to do with ccxt itself or if it may be a race condition in my threaded program. From time to time, not always, when I call exchange.parse8601(), it shows the following exception:\r\n\r\n```\r\nException in thread Thread-24:\r\nTraceback (most recent call last):\r\n  File \"/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/threading.py\", line 810, in __bootstrap_inner\r\n    self.run()\r\n  File \"/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/threading.py\", line 763, in run\r\n    self.__target(*self.__args, **self.__kwargs)\r\n  File \"nemesis2.py\", line 437, in stream_ohlcv\r\n    from___ = exchange.parse8601(from__) \r\n  File \"/Library/Python/2.7/site-packages/ccxt/exchange.py\", line 589, in parse8601\r\n    dt = datetime.datetime.strptime(string, \"%Y%m%d%H%M%S.%fZ\")\r\nAttributeError: 'module' object has no attribute '_strptime'\r\n```\r\n\r\nMy code is as follows (I'm using relativedelta to extract the last 100 candles since the last time):\r\n\r\n```\r\nnow = datetime.datetime.now()\r\nfrom_ = now - relativedelta (minutes=100)\r\nfrom__='{:%Y-%m-%d %H:%M:%S}'.format(from_)\r\nfrom___ = exchange.parse8601(from__)\r\ndata = exchange.fetch_ohlcv(\"ETH/USD\", \"5m\", from___)\r\n```",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/414/comments",
    "author": "werewere",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2017-10-28T17:14:38Z",
        "body": "Hi, @werewere !\r\n\r\nWhy do you use parse8601 there at all? You don't need to convert a number (a time value) to a string just to parse it back to a number. Try this:\r\n\r\n```Python\r\n_5m_candle = 5 * 60 * 1000  # 5 minutes * 60 seconds * 1000 ms\r\ndata = exchange.fetch_ohlcv(\"ETH/USD\", \"5m\", exchange.milliseconds () - _5m_candle * 100)\r\n```\n\n---\n\nCan you paste the shortest possible snippet that is short enough for posting, but works (can be launched) and reproduces/demonstrates the problematic case or the error?"
      },
      {
        "user": "werewere",
        "created_at": "2017-10-28T17:51:55Z",
        "body": "Yep, you're right. I was doing it more complicated than needed! Your solution is much more elegant.\r\n\r\nRegarding the shortest snippet, here goes it (well, its not the shortest-shortest, but I wanted to keep some info). I'm keeping my (bad) number->string->number design to keep it real. It fails about 1/10 times (anyway I just removed the parse8601 method thanks to your solution, so I'm putting it here just for debugging purposes in case it may be some bug in ccxt):\r\n\r\n```\r\nimport ccxt\r\nimport time\r\nimport threading\r\nimport datetime\r\nfrom dateutil.relativedelta import *\r\n\r\nexchange   = ccxt.poloniex({\r\n    'apiKey': 'KEY',\r\n    'secret': 'SECRET',\r\n})\r\nclass Feed (object):\r\n\r\n    def __init__(self, instruments=[\"ETH/BTC\", \"XRP/BTC\", \"BCH/BTC\"]):\r\n        self.candles=[\"5m\", \"15m\", \"1d\"]\r\n        self.candle_dict = {}\r\n        self.lock = threading.Lock()\r\n\r\n        for instrument in instruments: #1 thread per pair\r\n            thread = threading.Thread(target=self.stream_ohlcv, args=(instrument,))\r\n            thread.daemon = True\r\n            thread.start()\r\n\r\n    def stream_ohlcv(self, instrument=\"ETH/BTC\"):\r\n        while 1:\r\n                try:\r\n                        for candle in self.candles:\r\n                            now = datetime.datetime.utcnow()\r\n\r\n                            if candle == \"1m\":\r\n                                from_ = now - relativedelta (minutes=100)\r\n                            elif candle==\"5m\":\r\n                                from_ = now - relativedelta (minutes=500)\r\n                            elif candle==\"1h\":\r\n                                from_ = now - relativedelta (hours=100)\r\n                            elif candle==\"1d\":\r\n                                from_ = now - relativedelta (days=100)\r\n\r\n                            from__='{:%Y-%m-%d %H:%M:%S}'.format(from_)\r\n\r\n                            from___ = exchange.parse8601(from__) \r\n\r\n                            data = exchange.fetch_ohlcv(instrument, candle, from___)\r\n                            #do things with data\r\n\r\n                except ccxt.RequestTimeout as e: \r\n                    print(type(e).__name__, e.args, 'Request Timeout (ignoring)')\r\n                except ccxt.ExchangeNotAvailable as e:\r\n                    print(type(e).__name__, e.args, 'Exchange Not Available due to downtime or maintenance (ignoring)')\r\n                except ccxt.AuthenticationError as e:\r\n                    print(type(e).__name__, e.args, 'Authentication Error (missing API keys, ignoring)')\r\n\r\n                time.sleep(5)\r\n\r\nfeed = Feed([\"ETH/BTC\", \"XRP/BTC\", \"BCH/BTC\"])\r\ntime.sleep(10000)\r\n```"
      },
      {
        "user": "kroitor",
        "created_at": "2017-10-29T15:24:43Z",
        "body": "@werewere no matter what I do, I can't get an error from this:\r\n\r\n```Python\r\nimport ccxt\r\nimport time\r\nimport threading\r\nimport datetime\r\n\r\ndurations = {\r\n    '5m':       5 * 60 * 1000,\r\n    '15m':     15 * 60 * 1000,\r\n    '1d': 24 * 60 * 60 * 1000,\r\n}\r\n\r\nclass Feed (object):\r\n\r\n    def __init__(self, instruments=[\"ETH/BTC\", \"XRP/BTC\", \"BCH/BTC\"]):\r\n        self.candles=[\"5m\", \"15m\", \"1d\"]\r\n\r\n        for instrument in instruments: #1 thread per pair\r\n            thread = threading.Thread(target=self.stream_ohlcv, args=(instrument,))\r\n            thread.daemon = True\r\n            thread.start()\r\n\r\n    def stream_ohlcv(self, instrument=\"ETH/BTC\"):\r\n\r\n        exchange = ccxt.poloniex({'enableRateLimit': True})\r\n\r\n        while 1:\r\n                try:\r\n                    for candle in self.candles:\r\n                        from_ = durations[candle] * 100\r\n                        data = exchange.fetch_ohlcv(instrument, candle, exchange.milliseconds() - from_)\r\n                        print (exchange.iso8601 (from_), candle, instrument)\r\n                        #do things with data\r\n\r\n                except ccxt.RequestTimeout as e:\r\n                    print(type(e).__name__, e.args, 'Request Timeout (ignoring)')\r\n                except ccxt.ExchangeNotAvailable as e:\r\n                    print(type(e).__name__, e.args, 'Exchange Not Available due to downtime or maintenance (ignoring)')\r\n\r\nfeed = Feed([\"ETH/BTC\", \"XRP/BTC\", \"BCH/BTC\"])\r\ntime.sleep(10000)\r\n```\r\n\r\nThis is the same snippet as yours, but there are a few differences:\r\n\r\n1. In your original example you loop through candles= [ '5m', '15m', '1d' ] (\u2190 no 1m interval here), whereas in your if/else you check for 1m, 5m, 1h, 1d (\u2190 no 15m interval here)...\r\n\r\n2. time.sleep was 5 seconds, which is an overkill, you don't need to sleep that much. In fact, you don't need to sleep at all, if you enableRateLimit in Python 2.7. To avoid conflicts we instantiate the non-authenticated exchange in each thread (no need to authenticate for OHLCVs).\r\n\r\n3. I removed the dateutil from there to make it shorter.\r\n\r\n4. This isn't a good design to poll for many symbols from one exchange. Because your poll requests can interfere with each other, ruining the rate limiter schedule. Most of the time you don't want to launch many threads per exchange, and you need only one thread per exchange. I'd suggest to rethink it. Consider this: your exchange allows 1 request per limited time. And you are launching many threads each doing 1 request per limited time. That is definitely more than 1 request per limit. Therefore this design fails because of a threading conflict.\r\n\r\n5. What's even more strange to me is that you are continuously polling for the SAME candles, you shift by a few seconds (1 candle forward) and then fetch a hundred candles in the past. So 99 of your 100 candles are always repeating. You don't need to do it that way, moreover, you don't need to fetch history every second, because you can fetch it once per hour.\r\n\r\nAnyway, with your snippet or with this one, I was not able to reproduce your error, not even once in 40 launches. Are you sure, this is really the place that is causing trouble and not some other place in your code?\n\n---\n\nIf you don't mind, I am closing this issue for now as being somewhat beyond the scope of the library. Feel free to reopen it if needed or just continue posting here, we will try to help as much as we can."
      },
      {
        "user": "werewere",
        "created_at": "2017-10-29T15:56:13Z",
        "body": "Yep, I tested the problem only with the code I pasted. I'm not sure why it happen though.. Well, I can workaround it with your first solution, so everything is fine :)"
      }
    ],
    "satisfaction_conditions": [
      "Eliminates the need for datetime-to-string-to-timestamp conversion in threaded environments",
      "Provides thread-safe timestamp generation for OHLCV data fetching",
      "Avoids reliance on external datetime parsing libraries in time-sensitive operations",
      "Ensures compatibility with Python 2.7's datetime module limitations"
    ]
  },
  {
    "number": 379,
    "title": "fetch_ohlcv since problem",
    "created_at": "2017-10-23T20:25:01Z",
    "closed_at": "2017-10-23T20:34:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ccxt/ccxt/issues/379",
    "body": "Hi, I'm not sure if this is a bug or a feature; the following code won't work:\r\n\r\n```\r\nsince=int(datetime.datetime.strptime('2017-10-23 00:00:00', '%Y-%m-%d %H:%M:%S').strftime(\"%s\"))\r\nohlc=polo.fetch_ohlcv(\"ETH/BTC\", '5m', since)\r\n```\r\nIt is needed to do the following: \r\n```\r\nsince=int(datetime.datetime.strptime('2017-10-23 00:00:00', '%Y-%m-%d %H:%M:%S').strftime(\"%s\"))\r\nsince *=1000\r\nohlc=polo.fetch_ohlcv(\"ETH/BTC\", '5m', since)\r\n```\r\nI found this because checking the ccxt source code, I saw that (in Poloniex at least) the start time was calculated doing:\r\n\r\n`'start': int(since / 1000),`\r\n\r\nMay be this is due to an old problem in Poloniex (I'm just guessing) and then Poloniex fixed the problem but the ccxt code still has the old workaround?. Anyway, this is not a problem, I can just multiply, but I'm not sure if I'm missing something.",
    "comments_url": "https://api.github.com/repos/ccxt/ccxt/issues/379/comments",
    "author": "werewere",
    "comments": [
      {
        "user": "kroitor",
        "created_at": "2017-10-23T20:30:11Z",
        "body": "Hi, @werewere ! \r\n\r\nNope, it's not a bug, the library works with all timestamps as milliseconds, everywhere. So, yes, you can just do `ohlc=polo.fetch_ohlcv(\"ETH/BTC\", '5m', since * 1000)`. \r\n\r\nMilliseconds are chosen for portability and cross-exchange compatibility, don't forget that Poloniex is not the only exchange that implements the since param and fetch_ohlcv. There are other exchanges as well, and most of the time a common subset of milliseconds-range covers all needs for all exchanges, whereas seconds-based ranges are sometimes not sufficiently precise.\r\n\r\nI hope this reply answers your question, I'd close this issue for now.\r\n\r\nThx!"
      },
      {
        "user": "werewere",
        "created_at": "2017-10-23T21:19:59Z",
        "body": "Yeah, I use also Bitfinex but as it is not fully supported yet for OHLCV, I was doing tests with Poloniex.\r\n\r\nAnyway, understood, thanks! :)"
      },
      {
        "user": "kroitor",
        "created_at": "2017-10-23T21:21:03Z",
        "body": "@werewere bitfinex v2 already supports OHLCV btw ;) And, hopefully, both of Bitfinex v1 and v2 will support it soon ;)"
      },
      {
        "user": "werewere",
        "created_at": "2017-10-23T21:41:34Z",
        "body": "Oh, it is true! I didn't realized that I should use bitfinex2, indeed it has OHLCV!  You made my day :)"
      },
      {
        "user": "kroitor",
        "created_at": "2017-10-23T22:17:35Z",
        "body": "@werewere as of version 1.9.237 you can use Bitfinex v1 to fetch_ohlcv() as well ;) Cheers!"
      },
      {
        "user": "xgdgsc",
        "created_at": "2017-11-19T06:36:23Z",
        "body": "Has the since API changed? `bar_list=bitmex.fetch_ohlcv('XBTZ17', '1m', since='2017-11-08 00:01:44')` works in version `'1.9.39'` but not in version `'1.10.171'`."
      },
      {
        "user": "kroitor",
        "created_at": "2017-11-19T06:43:51Z",
        "body": "@xgdgsc it accepts an integer number of milliseconds for consistency across the majority of exchanges, so you can call it like so:\r\n\r\n```Python\r\nbar_list=bitmex.fetch_ohlcv('XBTZ17', '1m', since=bitmex.parse8601('2017-11-08 00:01:44'))\r\n```"
      },
      {
        "user": "xgdgsc",
        "created_at": "2017-11-19T07:05:20Z",
        "body": "OK. Thanks."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why timestamps must be in milliseconds format",
      "Clarification that the millisecond requirement is a deliberate design choice for cross-exchange compatibility",
      "Confirmation that the approach works consistently across multiple exchanges",
      "Documentation of timestamp handling requirements for fetch_ohlcv method"
    ]
  }
]