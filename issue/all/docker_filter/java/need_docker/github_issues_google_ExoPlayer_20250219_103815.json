[
  {
    "number": 10128,
    "title": "Ffmpeg extension quesion",
    "created_at": "2022-03-30T05:25:24Z",
    "closed_at": "2022-03-30T14:19:17Z",
    "labels": [
      "question",
      "needs triage"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/10128",
    "body": "I'm able to build the ffmpeg extension and use it in the demo app and my own app. But I want to just have the armeabi-v7a and arm64-v8a libraries generated only to reduce the apk size. When I build the demo project, it seems  x86 and x64_64 libraries needs to be in  the ANDROID-LIBS folder. I build the ffmpeg extension in  the Linux machine and  copy the ffmpeg directory to Windows 10  where Android Studio is resided. What needs to be done to achieve this? Thanks.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/10128/comments",
    "author": "tpuserhp",
    "comments": [
      {
        "user": "vovan888",
        "created_at": "2022-03-30T10:58:23Z",
        "body": "app/build.gradle:\r\n\r\n```\r\nandroid {\r\n        ndk {\r\n            abiFilters \"armeabi-v7a\", \"arm64-v8a\"\r\n        }\r\n}\r\n\r\n```"
      },
      {
        "user": "tpuserhp",
        "created_at": "2022-03-30T14:19:16Z",
        "body": "Yes, the suggested changes resulted in a smaller size of the apk  generated. Thank you very much  for your help. This issue can be closed now."
      }
    ],
    "satisfaction_conditions": [
      "Provides a way to exclude x86 and x86_64 architectures from the final APK",
      "Works with Android Studio's build system when using prebuilt libraries",
      "Maintains functionality of the FFmpeg extension after architecture filtering",
      "Doesn't require maintaining multiple library sets for different architectures"
    ],
    "_classification": {
      "category": "Can be dockerized without any issue",
      "timestamp": "2025-04-05 00:48:29"
    }
  },
  {
    "number": 10023,
    "title": "Custom controller layout not recognizing play and pause buttons.",
    "created_at": "2022-03-03T14:33:23Z",
    "closed_at": "2022-03-04T08:39:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/10023",
    "body": "Hi, I think there is a bug with the custom controller layout.\r\n\r\nI tried to add a custom controller layout to StyledPlayerView on the demo app and it is loaded, but when I override the exo_play and exo_pause buttons they don't work. \r\nWeird thing is that exo_ffwd and exo_rew work as expected (I didn't try others).\r\n\r\nPlayer Activity contains StyledPlayerView\r\n\r\n```\r\n    <com.google.android.exoplayer2.ui.StyledPlayerView\r\n          android:id=\"@+id/player_view\"\r\n          android:layout_width=\"match_parent\"\r\n          android:layout_height=\"match_parent\"\r\n          app:controller_layout_id=\"@layout/exo_player_layout\"/>\r\n```\r\n\r\n\r\nAnd this is exo_player_layout\r\n\r\n\r\n```\r\n     <LinearLayout\r\n            android:id=\"@+id/play_controls\"\r\n            android:layout_width=\"wrap_content\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:gravity=\"center\">\r\n\r\n            <ImageButton\r\n                android:id=\"@id/exo_play\"\r\n                android:layout_width=\"wrap_content\"\r\n                android:layout_height=\"wrap_content\"\r\n                app:srcCompat=\"@drawable/ic_exo_play\" />\r\n\r\n            <ImageButton\r\n                android:id=\"@id/exo_pause\"\r\n                android:layout_width=\"wrap_content\"\r\n                android:layout_height=\"wrap_content\"\r\n                app:srcCompat=\"@drawable/ic_exo_pause\"/>\r\n\r\n        </LinearLayout>\r\n\r\n```\r\n\r\nDoes anyone have any ideas?",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/10023/comments",
    "author": "mdurokov",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2022-03-03T15:00:21Z",
        "body": "I think the `StyledPlayerView` is using `@id/exo_play_pause` rather than `@id/exo_play` and `@id/exo_pause`.\r\n\r\nIf you want to provide your custom layout you should use a single button with `@+id/exo_play_pause`. The styled control view does not hide/show one or the other of these buttons, but instead change the drawable of the icon. If you want to change these icons you can do so by adding a `drawables.xml` in the `values` folder of the app module to override the drawables used by default:\r\n\r\n```\r\n<resources>\r\n  <drawable name=\"exo_styled_controls_play\">@drawable/custom_controls_play</drawable>\r\n  <drawable name=\"exo_styled_controls_pause\">@drawable/custom_controls_pause</drawable>\r\n</resources>\r\n``` \r\n\r\nPlease see #10008 also which is about a similar issue.\r\n\r\nThere were quite some changes in the ui components, so if the above does not help, please let us know the exact ExoPlayer version you are depending to with your app."
      },
      {
        "user": "mdurokov",
        "created_at": "2022-03-04T08:39:18Z",
        "body": "That does the trick, thank you! \r\nI didn't see it documented anywhere.\r\nAs a matter of fact, I did use PlayerView before and it worked with exo_play and exo_pause. "
      },
      {
        "user": "draganstojanov",
        "created_at": "2022-03-10T12:10:51Z",
        "body": "It works. But, i have two sets of icons, one for vertical oriented video and other for horizontal oriented. Is there any way to programmatically override drawables?"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of the required UI component IDs for play/pause functionality in StyledPlayerView",
      "Clarification on how to properly customize play/pause button icons",
      "Differentiation between StyledPlayerView and legacy PlayerView component handling",
      "Identification of version-specific requirements"
    ],
    "_classification": {
      "category": "Can be dockerized without any issue",
      "timestamp": "2025-04-05 00:48:44"
    }
  },
  {
    "number": 9008,
    "title": "Issue with wrap_content in ExoPlayerView. ExoPlayerView height remain 0 at run-time if it set to wrap_content",
    "created_at": "2021-06-02T11:46:32Z",
    "closed_at": "2021-06-02T17:14:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/9008",
    "body": "[Condition]\r\n - video url only available\r\n\r\nThe title of this issue was on Stack Overflow but there was no answer.\r\n\r\nI was trying to set exoplayers to recyclerview with multiple media source.\r\n\r\nAutomatic video playback takes up space appropriately. Also, if the height value is given as an absolute value, thumbnail can be seen through the \"use_artwork\" option even if no replay is made('But it's not fit to the given layout).\r\n\r\nSo I brought a thumbnail separately through Glide, but it was too slow.\r\n\r\nIs there a way to automatically set the height value without playing the EXO player automatically or setting an absolute value?\r\n\r\n```\r\n<com.google.android.exoplayer2.ui.PlayerView\r\n                android:layout_width=\"match_parent\"\r\n                android:layout_height=\"wrap_content\"\r\n                app:use_artwork=\"true\"\r\n                app:resize_mode=\"fit\"\r\n                app:show_buffering=\"when_playing\"\r\n                />\r\n```",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/9008/comments",
    "author": "JiyongYang",
    "comments": [
      {
        "user": "andrewlewis",
        "created_at": "2021-06-02T14:12:57Z",
        "body": "If you are trying to set the height of the player view such that it matches the shape of the video but without actually loading the video I don't think there is a way to do that. You can `pause()` the player before preparing it if you want to load the media (and acquire resources for buffering and decoders) but not actually start playback. I'm not sure I follow the question though, so perhaps you could rephrase?"
      },
      {
        "user": "JiyongYang",
        "created_at": "2021-06-02T17:14:09Z",
        "body": "Thank you. It really helped. I think calling `pause()` is way more effective than using other lib."
      }
    ],
    "satisfaction_conditions": [
      "Mechanism to determine video dimensions without full playback",
      "Avoid absolute height values while maintaining layout integrity",
      "Efficient media metadata loading",
      "Integration with ExoPlayer's native capabilities"
    ],
    "_classification": {
      "category": "Can be dockerized without any issue",
      "timestamp": "2025-04-05 00:50:40"
    }
  },
  {
    "number": 8950,
    "title": "Exoplayer download service unable to download different HLS videos with different cookie value for authentication ",
    "created_at": "2021-05-17T12:02:05Z",
    "closed_at": "2021-06-09T13:31:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/8950",
    "body": "I have implemented a download service and it is working fine with normal HLS URL's....but when i try download a HLS URL which usses some cookie value for authentication...my download fails because download manager initializes only once in download service of exoplayer. Is there any way to restart the service every time or change the instance of download manager every time for each video or to stop the download service if one video has been completed and start service again for another video as that would solve my issue. ",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/8950/comments",
    "author": "anandsingh2903",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2021-05-27T14:57:31Z",
        "body": "When you subclass the `DownloadService` you need to implement the `getDownloadManager` method. So you can construct the `DownloadManager` yourself.  So your app can determine what `DataSource.Factory` is passed to the constructor of `DownloadManager`. If you pass a `ResolvingDataSource.Factory` you can change the request at the moment when the request is issued. This seems to be a flexible way to change your request.\r\n\r\n>  restart the service every time or change the instance of download manager every time\r\n\r\nWould the apporach above help for this? Instead of creating a new service or download manager you would be able to change the request you are doing with the `ResolvingDataSource` that modifies the `DataSpec` passed to the upstream data source by consulting the `ResolvingDataSource.Resolver` that you implement.\r\n\r\nPlease let me know if this helps.\r\n\r\nIf not, can you clarify a bit how the request to the server needs to be changed for successfully downloading with authentication?\r\n\r\n"
      },
      {
        "user": "anandsingh2903",
        "created_at": "2021-06-09T13:31:44Z",
        "body": "Alright will try your suggested implementation and will get back to you.\n\n---\n\nThis is working great....thanks"
      }
    ],
    "satisfaction_conditions": [
      "Supports dynamic cookie-based authentication per download request",
      "Enables request modification at download execution time",
      "Avoids service/dependency manager restarts for new downloads"
    ],
    "_classification": {
      "category": "Can be dockerized without any issue",
      "timestamp": "2025-04-05 00:50:57"
    }
  },
  {
    "number": 7343,
    "title": "vp8 decode error",
    "created_at": "2020-05-07T09:36:56Z",
    "closed_at": "2020-05-07T10:02:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/7343",
    "body": "Hello, may I ask if I added the adaptation of vp8 in the vp9 extension, added vp8 decoding in generate_libvpx_android_configs.sh, the compilation shows that it passed, and the vp8 module has been integrated, but when running, the vp8 decoding error Decode error: Bitstream not supported by this decoder\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/7343/comments",
    "author": "kuailedeadai",
    "comments": [
      {
        "user": "andrewlewis",
        "created_at": "2020-05-07T10:02:57Z",
        "body": "It's difficult to know the cause based on the information you've provided, but one thing to note is that in `vpx_jni.cc` in the VP9 extension you will need to initialize the right codec in the call to `vpx_codec_dec_init` (you can use `get_vpx_decoder_by_name` to get the right codec interface to pass into that method). Caveat: last time I did this was in 2016 so the APIs may have changed!\r\n\r\nAs this is not something we support at the moment, and it seems unlikely we would add support given it hasn't been requested and the codec has been superseded, I will close this for now."
      },
      {
        "user": "kuailedeadai",
        "created_at": "2020-05-07T11:45:13Z",
        "body": "Thanks, your suggestion has solved my problem"
      }
    ],
    "satisfaction_conditions": [
      "Identifies the correct codec initialization method for VP8 decoding integration",
      "Addresses decoder configuration mismatch between integration and runtime execution",
      "Provides guidance for decoder interface selection in the codebase architecture"
    ],
    "_classification": {
      "category": "Can be dockerized without any issue",
      "timestamp": "2025-04-05 00:55:48"
    }
  },
  {
    "number": 6710,
    "title": "Exoplayer releases itself when in background",
    "created_at": "2019-11-29T09:55:01Z",
    "closed_at": "2019-11-30T15:26:17Z",
    "labels": [
      "question",
      "need more info"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/6710",
    "body": "#6386 # [REQUIRED] Searched documentation and issues\r\n\r\nTried searching on Google but didn't find anything relevant.\r\n\r\n### [REQUIRED] Question\r\nI have an app that can play videos. I use a single instance of exoplayer that i initialize in a service so that the user can listen and control the video in background. The problem is that when a video is playing, the user goes into background and then pauses the player for 1-2 minutes exoplayer releases itself. So when the app comes back to the foreground all i have is a black screen playerView with no video in it.\r\n\r\n### A full bug report captured from the device\r\n```\r\n2019-11-29 10:26:51.715 23697-26444/app  D/FA: Application backgrounded\r\n2019-11-29 10:26:51.738 23697-26444/app  D/FA: Logging event (FE): app_background(_ab), Bundle[{ga_event_origin(_o)=auto}]\r\n2019-11-29 10:28:13.053 23697-23697/app  I/ExoPlayerImpl: Release 192e8c2 [ExoPlayerLib/2.10.4] [HWSTK-HF, STK-LX1, HUAWEI, 28] [goog.exo.core, goog.exo.ui, goog.exo.hls]\r\n2019-11-29 10:28:13.080 23697-26655/app  D/android.media.AudioTrack: [HSM] AudioTrace stop() uid: 10308, pid: 23697\r\n2019-11-29 10:28:13.084 23697-25116/app W/ACodec: forcing OMX state to Idle when received shutdown in ExecutingState\r\n2019-11-29 10:28:13.136 23697-25115/app  D/SurfaceUtils: disconnecting from surface 0x723f653010, reason disconnectFromSurface\r\n2019-11-29 10:28:13.167 23697-25127/app  W/ACodec: forcing OMX state to Idle when received shutdown in ExecutingState\r\n```\r\n\r\nAs you can see i backgrounded the video and then pause it. After 1.5 minutes without touching the phone  exoplayer released itself. \r\nI can see how this could be done on purpose to free some resources but is there any way to override this?\r\n\r\nThis is what happens when i bring the app to the foreground:\r\n```\r\n2019-11-29 10:58:47.192 23697-23697/app D/ZrHung.AppEyeUiProbe: notify runnable to start.\r\n2019-11-29 10:58:47.192 23697-23750/app D/ZrHung.AppEyeUiProbe: restart watching\r\n2019-11-29 10:58:47.220 23697-27978/app D/FA: Setting user property (FE): _sid, 1575021527\r\n2019-11-29 10:58:47.278 23697-23768/app D/mali_winsys: EGLint new_window_surface(egl_winsys_display *, void *, EGLSurface, EGLConfig, egl_winsys_surface **, EGLBoolean) returns 0x3000\r\n2019-11-29 10:58:47.289 23697-23697/app I/ExoPlayerImpl: Init aaeb70c [ExoPlayerLib/2.10.4] [HWSTK-HF, STK-LX1, HUAWEI, 28]\r\n2019-11-29 10:58:47.296 23697-27978/app D/FA: Logging event (FE): session_start(_s), Bundle[{ga_event_origin(_o)=auto, ga_session_id(_sid)=1575021527}]\r\n2019-11-29 10:58:47.330 23697-27978/app D/FA: Logging event (FE): app_start, Bundle[{method=app_start, ga_event_origin(_o)=app, ga_screen_class(_sc)=MainActivity, ga_screen_id(_si)=5911828178843061323}]\r\n2019-11-29 10:58:47.454 23697-23697/app I/ViewRootImpl: jank_removeInvalidNode all the node in jank list is out of time\r\n2019-11-29 10:58:47.465 23697-23697/app W/InputMethodManager: startInputReason = 1\r\n2019-11-29 10:58:47.500 23697-27978/app D/FA: Connected to remote service\r\n```\r\n\r\nI'm pretty new at this so i don't really understand what all this means or if it's useful at all.\r\nThanks in advance for your time!\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/6710/comments",
    "author": "Cosminnv",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2019-11-30T15:10:16Z",
        "body": "I don't think ExoPlayer does release itself automatically after a given time. But probably the service does release the player when it is destroyed, which would be the correct behaviour of the service.\r\n\r\nWith the available information that sounds like you may call stopForeground(boolean) when the user pauses the player. With this the service is not running in the foreground anymore and the system may remove/destroy the service after a given amount of time (the 2 minutes you are reporting seems reasonable). \r\n\r\nIf this is the case then the service is behaving correctly and according to what the recommendation is for having the player in a foreground service. If you want to override this, then you should not call stopForeground(boolean) for your service.\r\n\r\nMy recommendation would be to remove the service from the foreground as you do, but then. When the app comes to foreground again you have to restart the service and then resume playback from where it was paused.\r\n\r\nAside: is there a specific reason why you have the player in a service for playing a video? Usually this is required for audio, when playback should continue when the player is in background. In case of video you could have the player living in the activity instead."
      },
      {
        "user": "Cosminnv",
        "created_at": "2019-11-30T15:26:17Z",
        "body": "Hi, thanks for the reply.\r\n\r\nYou're right, i do call stopForeground when the player is paused ,but i only do that because i want the user to be able to swipe the notification away without killing the video ( kinda like spotify does). I'll try to do it like you recommended.\r\n\r\nAlso, i kinda need the player to be in a service because i have video of a guy talking. So you can watch him while he is speaking but you can also only listen to him.\r\n\r\nI think i got everything i needed, thank you very much!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how to prevent ExoPlayer from releasing itself when the app is backgrounded",
      "Guidance on maintaining service lifecycle for persistent video playback control",
      "Strategy for handling system cleanup of background services without losing playback state",
      "Mechanism to restore player state when returning to foreground"
    ],
    "_classification": {
      "category": "Can be dockerized without any issue",
      "timestamp": "2025-04-05 00:57:26"
    }
  },
  {
    "number": 5652,
    "title": "VTT caption file download",
    "created_at": "2019-03-19T13:14:25Z",
    "closed_at": "2019-03-20T13:06:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/5652",
    "body": "### [REQUIRED] Searched documentation and issues\r\nI been looking every where but not success finding appropriated solution\r\n\r\n### [REQUIRED] Question\r\nexoplayer r2.4.  In a hls stream with multiple vtt captions files why exoplayer loads the same file after seek back to the beginning of the stream. ie content start playback from 0 position and plays for 3 minutes and 3 .vtt files download for that period, then a user interaction set the content back to 0 and content resume and plays for the same 3 minutes and download the same files again. Is there a way to make exoplayer cache the already  downloaded vtt files?\r\n\r\n<!-- DO NOT DELETE\r\nvalidate_template=true\r\ntemplate_path=.github/ISSUE_TEMPLATE/question.md\r\n-->\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/5652/comments",
    "author": "andresdiez",
    "comments": [
      {
        "user": "tonihei",
        "created_at": "2019-03-20T12:50:39Z",
        "body": "That's possible using a `new CacheDataSourceFactory(new SimpleCache(fileDir, evictor), normalDataSource)` as the data source factory for your `MediaSource`. Please also have a look at similar questions on this issue tracker and other websites."
      },
      {
        "user": "andresdiez",
        "created_at": "2019-03-20T13:06:33Z",
        "body": "That work, thank you."
      }
    ],
    "satisfaction_conditions": [
      "Demonstrates a caching mechanism for VTT subtitle files in ExoPlayer",
      "Integrates with ExoPlayer's existing data source architecture",
      "Applies to multiple subtitle tracks in HLS streams"
    ],
    "_classification": {
      "category": "Can be dockerized without any issue",
      "timestamp": "2025-04-05 00:58:48"
    }
  },
  {
    "number": 4613,
    "title": "Order of execution of listeners",
    "created_at": "2018-08-02T23:43:17Z",
    "closed_at": "2018-08-16T20:57:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/4613",
    "body": "Hi,\r\n\r\nI am using ExoPlayer 2.8.2 release and trying to implement a feature where I want to use the bandwidth measurement from the latest video segment download to influence the quality of the next segment. This is for Dash videos.\r\nI have extended trackSelection to `CustomTrackSelection` object. But, the problem on several occasions, by the time the `DefaultDashChunkSource` calls `updateSelectedTrack` function, the previous download end event hasn't been processed by my `listener` and I haven't had a chance to register the latest throughput sample. \r\nI guess what's happening is that the `onLoadCompleted` event is processed by `ChunkSampleStream` and it proceeds with the next download start _before_ my listener is invoked.\r\nIs there any way to get around this? Is there any way I can \"wait\" before downloading the next segment if my listener hasn't registered the download end event?\r\n\r\nThanks for your attention and help! I appreciate any pointers.",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/4613/comments",
    "author": "kanthicn1",
    "comments": [
      {
        "user": "erdemguven",
        "created_at": "2018-08-07T08:52:12Z",
        "body": "Why don't you use AdaptiveTrackSelection? It already selects tracks according to bandwidth measurement. "
      },
      {
        "user": "kanthicn1",
        "created_at": "2018-08-09T18:58:46Z",
        "body": "Fair enough @erdemguven . Sorry for not writing the complete problem. I don't want to use `AdaptiveTrackSelection` because I want to use my own track selection logic which doesn't quite agree with what `AdaptiveTrackSelection` is doing. Also, the `DefaultBandwidthMeter`, which is used by `AdaptiveTrackSelection`,  gives a  \"SlidingPercentile\" estimate of bandwidth while I want the last instantaneous value of the bandwidth measurement. \r\nOne approach that might actually work for my case is to use a different bandwidth meter instead of relying on throughput measurements from listeners.\r\n\r\n(a) implement `CustomBandwidthMeter` and pass that to the `buildDataSourceFactory` and `customTrackSelection`. -- this is so that my `CustomBandwidthMeter` can expose the last instantaneous measurement of bandwidth sample.\r\n(b) Query the `CustomBandwidthMeter` for the latest throughput sample from `CustomTrackSelection` and use it in my track selection logic.\r\n\r\nMy question is: in the above logic, is there a chance that I might not get the latest throughput sample due to race conditions in event processing? i.e., Is the `DataSourceFactory` guaranteed to update the bandwidth sample before `CustomTrackSelection` is called for picking the quality for the next segment to be loaded?"
      },
      {
        "user": "erdemguven",
        "created_at": "2018-08-16T20:49:57Z",
        "body": "@ojw28 could you look at this?"
      },
      {
        "user": "ojw28",
        "created_at": "2018-08-16T20:57:30Z",
        "body": "> My question is: in the above logic, is there a chance that I might not get the latest throughput sample due to race conditions in event processing? i.e., Is the DataSourceFactory guaranteed to update the bandwidth sample before CustomTrackSelection is called for picking the quality for the next segment to be loaded?\r\n\r\nThere is a guarantee, which is that the `TransferListener.onTransferEnd` call corresponding to a chunk will always be called before `TrackSelection.updateSelectedTrack` is called to pick the quality for the next chunk. Note that `DefaultBandwidthMeter` updates its bitrate estimate in `onTransferEnd`, and `AdaptiveTrackSelection` gets the bitrate estimate in `TrackSelection.updateSelectedTrack`. Hence it's guaranteed that the updated bitrate estimate is used.\r\n\r\nSo in short, as long as you follow the same model in your custom components (albeit changing the actual logic for estimating the bitrate and/or choosing the track), then you'll get the same guarantee, which I think is what you want."
      },
      {
        "user": "kanthicn1",
        "created_at": "2018-08-16T21:03:35Z",
        "body": "Perfect. Thanks @ojw28 and @erdemguven. "
      }
    ],
    "satisfaction_conditions": [
      "Guarantees bandwidth measurement updates occur before next track selection",
      "Provides synchronization mechanism for event processing order",
      "Supports custom track selection using latest instantaneous bandwidth values",
      "Maintains ExoPlayer's internal execution guarantees for custom components"
    ],
    "_classification": {
      "category": "Can be dockerized without any issue",
      "timestamp": "2025-04-05 01:01:45"
    }
  },
  {
    "number": 4547,
    "title": "getWindowIndex() sometime is delay",
    "created_at": "2018-07-22T15:50:48Z",
    "closed_at": "2018-07-23T09:44:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/4547",
    "body": "//Version\r\n2.7.3\r\n\r\n//Description\r\nI'm using ClippingMediaSource and DynamicConcatenatingMediaSource to play multiple video clips, and i need to know the current index of window when onVideoSizeChanged callback, but i found sometime the index is not correct because onPositionDiscontinuity->DISCONTINUITY_REASON_PERIOD_TRANSITION is later than  onVideoSizeChanged.\r\nso i getWindowIndex() is an un correct index.\r\n\r\nMy question is how to get exact window index when onVideoSizeChanged?\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/4547/comments",
    "author": "RuijiePan",
    "comments": [
      {
        "user": "tonihei",
        "created_at": "2018-07-23T08:28:45Z",
        "body": "What you describe is basically working as intended. The reason is that these two event (onVideoSizeChanged and onPositionDiscontinuity) belong to different listeners and our listeners are not synchronized to each other for various reasons.\r\n\r\nHowever, we recently added the `AnalyticsListener` class which combines all listeners we have in one place and gives additional information for each event (including which window they belong to). This new listener has been added in 2.8.0. The easiest way to use it is with `SimpleExoPlayer.addAnalyticsListener`. "
      }
    ],
    "satisfaction_conditions": [
      "Synchronization between video size changes and window index tracking",
      "Event context preservation for media source transitions",
      "Listener integration that maintains window association"
    ],
    "_classification": {
      "category": "Can be dockerized without any issue",
      "timestamp": "2025-04-05 01:01:55"
    }
  },
  {
    "number": 4490,
    "title": "IllegalStateException: Assertions.checkState When using same instance of SimpleCache",
    "created_at": "2018-07-10T07:59:00Z",
    "closed_at": "2018-07-10T09:06:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/4490",
    "body": "Hi,\r\nI am getting the exception\r\n```\r\njava.lang.IllegalStateException\r\nat com.google.android.exoplayer2.util.Assertions.checkState(Assertions.java:81)\r\nat com.google.android.exoplayer2.upstream.cache.SimpleCache.getContentMetadata(SimpleCache.java:348)\r\nat com.google.android.exoplayer2.upstream.cache.SimpleCache.getContentLength(SimpleCache.java:335)\r\nat com.google.android.exoplayer2.upstream.cache.CacheUtil.getCached(CacheUtil.java:88)\r\n```\r\n when I'm trying to use the singleton instance of SimpleCache.\r\n```\r\ncompanion object DownloadCache {\r\n        private var downloadCache: Cache? = null\r\n        private var downloadDirectory: File? = null\r\n\r\n        @Synchronized\r\n        internal fun getDownloadCache(context: Context): Cache {\r\n            if (downloadCache == null) {\r\n                val downloadContentDirectory = File(getDownloadDirectory(context), \"cache\")\r\n                downloadCache = SimpleCache(downloadContentDirectory, NoOpCacheEvictor())\r\n            }\r\n            return downloadCache!!\r\n        }\r\n\r\n        private fun getDownloadDirectory(context: Context): File {\r\n            if (downloadDirectory == null) {\r\n                downloadDirectory = File(LogTrackUtil().getDir(context))\r\n                if (downloadDirectory == null) {\r\n                    downloadDirectory = context.filesDir\r\n                }\r\n            }\r\n            return downloadDirectory!!\r\n        }\r\n    }\r\n```\r\n\r\nI am checking the cached data for a particular URL.\r\nThe below code works perfectly for the first time but following calls to this code throws the exception.\r\n```\r\ndownloadCache = VideoPlayerUtil.getDownloadCache(mContext!!) as SimpleCache\r\nval uri = Uri.parse(mExercise?.fileUrl)\r\nval counters = CacheUtil.CachingCounters()\r\nCacheUtil.getCached(DataSpec(uri), downloadCache, counters)\r\n```\r\n\r\nWhat am I doing wrong?? Please help.",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/4490/comments",
    "author": "joecizac",
    "comments": [
      {
        "user": "erdemguven",
        "created_at": "2018-07-10T09:06:39Z",
        "body": "Probably, you're releasing your singleton instance of SimpleCache (using SimpleCache.release() method) at some point and then try to reuse it. That's why it's throwing that exception.\r\n\r\nAs you use a singleton, I think you can just remove the call to release(). Otherwise you need to recreate another SimpleCache instance after release() call."
      }
    ],
    "satisfaction_conditions": [
      "Identify why the SimpleCache instance becomes invalid after initial use",
      "Explain proper lifecycle management for SimpleCache singleton",
      "Address potential premature release of cache resources",
      "Prevent IllegalStateException when reusing cache instance"
    ],
    "_classification": {
      "category": "Can be dockerized without any issue",
      "timestamp": "2025-04-05 01:02:37"
    }
  },
  {
    "number": 4107,
    "title": "Grabbing synchronized audio samples",
    "created_at": "2018-04-10T17:20:05Z",
    "closed_at": "2018-04-22T21:57:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/4107",
    "body": "Is it possible to grab _synchronized_ audio samples from a running ExoPlayer instance, without having to modify the source code?\r\n\r\nCurrently I'm getting the decoded audio samples inside of `processOutputBuffer` in `MediaCodecAudioRenderer`, but these don't seem to be in sync with the video.  Also this has required me to essentially write my own renderer (and subsequently my own `AudioSink`, since `DefaultAudioSink` is a `final` class). I tried grabbing them from `handleBuffer` in `DefaultAudioSink` instead, but again it seems like the samples I get there (just before the `writeNonBlockingV21` call) are kind of decoupled from the sync logic.",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/4107/comments",
    "author": "kunaljathal",
    "comments": [
      {
        "user": "andrewlewis",
        "created_at": "2018-04-11T08:16:27Z",
        "body": "During normal playback we synchronize video to the audio playout position, so I think the request here is to get a stream of PCM audio data that's synchronized with playout position of the underlying `AudioTrack` (but please correct me if I've misunderstood).\r\n\r\nThe platform `AudioTrack` keeps a buffer of data internally, which introduces latency, so it's not sufficient to output data at the moment it's written to the track. Instead, I think you'll need to keep a buffer of audio that's been written to the track, then output data from your own buffer based on the current playout position.\r\n\r\nI'm afraid we don't have a built-in way to do this at the moment so some level of customization is necessary. There are lots of ways this could be done, but if you want to minimize the number of customized components I think it should be possible with only a custom `AudioProcessor` as follows.\r\n\r\n- Instantiate a `DefaultAudioSink`, passing in a custom `AudioProcessor`, and set up the player with a `MediaCodecAudioRenderer` outputting to this sink.\r\n- Each time the custom audio processor receives input, it should copy it to an output buffer, but also copy the bytes into an additional internal buffer. We are using it as a way to intercept the audio.\r\n- At the same time as populating its internal buffer, we can also check the current playout position via `AudioSink.getCurrentPositionUs`, as we have a reference to the sink. The position can be converted into a frame count, which in turns maps onto a byte offset in the internal buffer, which is the position up to which audio has been played out. You can handle this portion of the internal buffer however you want, then compact the buffer.\r\n- Note: all audio processor methods run on ExoPlayer's internal playback thread, so you may want to pass the data that's been output to an application thread."
      },
      {
        "user": "kunaljathal",
        "created_at": "2018-04-11T19:48:23Z",
        "body": "Okay, gotcha. A couple of preliminary clarifications:\r\n\r\n> Instantiate a `DefaultAudioSink`, passing in a custom `AudioProcessor`, and set up the player with a `MediaCodecAudioRenderer` outputting to this sink.\r\n\r\nI'm creating an instance of `SimpleExoPlayer` via `ExoPlayerFactory.newSimpleInstance`, so I'm assuming I can do what you're describing by simply overriding `DefaultRenderersFactory.buildAudioProcessors` (in the renderers factory that I pass to the constructor of `ExoPlayerFactory.newSimpleInstance`) with my custom `AudioProcessor`, right? Because this `AudioProcessor` then internally gets passed to the underlying `MediaCodecAudioRenderer`, which will then further pass it to it's `DefaultAudioSink`. Does this make sense?\r\n\r\n> At the same time as populating its internal buffer, we can also check the current playout position via `AudioSink.getCurrentPositionUs`, as we have a reference to the sink.\r\n\r\nI'm a bit confused here -- where's the reference? i.e. where in my custom `AudioProcessor` am I able to access the sink?"
      },
      {
        "user": "andrewlewis",
        "created_at": "2018-04-11T19:53:47Z",
        "body": "You need to instantiate the `DefaultAudioSink` yourself so that you can provide a reference to it to your custom audio processor. This means you need to instantiate the `MediaCodecAudioRenderer` yourself, passing in the sink. Overriding `buildAudioRenderers` from `DefaultRenderersFactory` is a good way to do that."
      },
      {
        "user": "kunaljathal",
        "created_at": "2018-04-14T00:46:58Z",
        "body": "Okay, gotcha. I think my final clarification is the following:\r\n\r\n>At the same time as populating its internal buffer, we can also check the current playout position via `AudioSink.getCurrentPositionUs`, as we have a reference to the sink. The position can be converted into a frame count, which in turns maps onto a byte offset in the internal buffer, which is the position up to which audio has been played out. You can handle this portion of the internal buffer however you want, then compact the buffer.\r\n\r\nDoes this imply that the buffer of data I'm getting in the `queueInput` call contains audio data, _a portion of which has already been played out_? Because, if I'm understanding correctly, what you're saying is that I can discard this portion, and collect the samples after it, which are representative of the samples that are about to be played out next (presumably soon after the `getOutputBuffer` call), and hence in sync with the video frames about to be played out next."
      },
      {
        "user": "andrewlewis",
        "created_at": "2018-04-16T11:02:10Z",
        "body": "The audio data just passed to `queueInput` has not been played out yet, as the `AudioTrack` is 'downstream' from the chain of audio processors. The audio data you've already buffered on previous invocations of `queueInput` may have been played out, though. The idea is to use `getCurrentPositionUs` to determine how many bytes of the input have been played out so far, which corresponds to a position in your internal buffer.\r\n\r\nAs the internal buffer can't grow indefinitely, when you determine that some of its audio has been played (based on the current position), you'll need to discard data up to there from your internal buffer, and update a stored offset for the start of the internal buffer. This offset should be reset on each call to `flush`.\r\n\r\nOne other caveat, which may not be relevant to your use case: speed/pitch/trim silence are applied after any custom `AudioProcessor`s at the moment, so the player position will reflect any offset/scaling applied for those."
      },
      {
        "user": "kunaljathal",
        "created_at": "2018-04-16T17:36:39Z",
        "body": "OK, I see. In the case of speed/pitch/trim etc applied _after_ the custom `AudioProcessor` -- is this factored into the position returned by `getCurrentPositionUs` ? To be clear, I'll be using ExoPlayer for streaming video most of the time i.e. the use case that's most relevant to me is interruptions in streaming -- in the case of network issues etc., if the video ends up momentarily lagging / pausing and resuming (i.e. buffering) for any reason, I would want to stop/re-play the audio at the correct positions, keeping it in sync with the video at all times. So if `getCurrentPositionUs` is going to incorporate all that, then that's enough for me."
      },
      {
        "user": "andrewlewis",
        "created_at": "2018-04-17T08:14:07Z",
        "body": "The position returned by `getCurrentPositionUs` will take into account playback parameters, buffering, pausing etc.. If you're not overriding the default playback speed it should work fine."
      },
      {
        "user": "kunaljathal",
        "created_at": "2018-06-11T13:30:39Z",
        "body": "Thanks, this worked. "
      }
    ],
    "satisfaction_conditions": [
      "Provides synchronized audio samples aligned with video playback timing",
      "Works with ExoPlayer's internal synchronization mechanisms",
      "Requires minimal customization of ExoPlayer components",
      "Handles AudioTrack buffer latency automatically",
      "Maintains synchronization during playback interruptions"
    ],
    "_classification": {
      "category": "Can be dockerized without any issue",
      "timestamp": "2025-04-05 01:03:24"
    }
  },
  {
    "number": 2053,
    "title": "Playlist refresh UI",
    "created_at": "2016-11-09T20:16:37Z",
    "closed_at": "2016-11-09T23:10:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/2053",
    "body": "onPlayerStateChanged it's not called when a playlist change from one song to another\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/2053/comments",
    "author": "irenecs",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2016-11-09T20:29:05Z",
        "body": "Why would you expect it to change? One of the key selling points of playlist support in V2 is that we can perform transitions seamlessly, which means there wont be any changes to player state across the transition ;). You should probably be looking at `onPositionDiscontinuity` instead, which is invoked on seeks and also when transitioning from one song to the next.\n"
      },
      {
        "user": "irenecs",
        "created_at": "2016-11-09T20:35:18Z",
        "body": " i would like to refresh  my UI when the song on the playlist change \n"
      },
      {
        "user": "ojw28",
        "created_at": "2016-11-09T20:43:53Z",
        "body": "Yes. So use `onPositionDiscontinuity`. From there, you can use `ExoPlayer.getCurrentWindowIndex` to see the index of the track being played. If it's changed then you can refresh the UI accordingly.\n"
      }
    ],
    "satisfaction_conditions": [
      "Mechanism to detect playlist track changes without relying on player state transitions",
      "Clear way to identify when playback moves to a new track in a playlist",
      "Integration with ExoPlayer's playlist position tracking system",
      "Event-driven approach for UI updates during seamless transitions"
    ],
    "_classification": {
      "category": "Can be dockerized without any issue",
      "timestamp": "2025-04-05 01:08:58"
    }
  },
  {
    "number": 1449,
    "title": "Rendering processed output buffer data as a waveform is always ahead of played audio",
    "created_at": "2016-04-16T21:54:12Z",
    "closed_at": "2016-04-17T15:47:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/1449",
    "body": "I have extended the MediaCodecAudioTrackRenderer to get access to the output buffer to render the PCM data as a waveform.  The problem I am having is that the waveform seems to render faster than the audio being played. I assumed that once the output buffer was processed and discarded any rendering would be matched with the audio playback.  BTW: the player is using a uri datasource.  Code used is below:\n\n```\n@Override\nprotected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, MediaCodec codec, ByteBuffer buffer, BufferInfo bufferInfo, int bufferIndex, boolean shouldSkip) throws ExoPlaybackException {\n    boolean processed = false;\n\n   //  Clone buffer \n    ByteBuffer bb = deepCopy(buffer);\n\n    processed = super.processOutputBuffer(positionUs,elapsedRealtimeUs,codec,buffer,bufferInfo, bufferIndex, shouldSkip);\n    if (processed & !shouldSkip)\n    {\n        // send data to be converted to shorts and then propogate a callback to render float data\n        transform(bb);\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/1449/comments",
    "author": "m1c999",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2016-04-17T15:47:30Z",
        "body": "`MediaCodecAudioTrackRenderer.processOutputBuffer` feeds each output buffer into an `AudioTrack`, but note that an `AudioTrack` has its own audio buffer (at the platform level). So if that buffer is being kept full there will be a delay between an output buffer being processed and the corresponding audio actually being output from the device.\n\nTo do what you're wanting to do you would probably need to generate the data that you need for your visualization from each output buffer, then add that data to the back of a queue with the associated timestamp `bufferInfo.presentationTimeUs`. You could then pull items off the front of the queue and render them as `MediaCodecAudioTrackRenderer.getPositionUs()` reaches the associated timestamps.\n"
      }
    ],
    "satisfaction_conditions": [
      "Synchronize waveform rendering with actual audio playback timing",
      "Utilize audio presentation timestamps for visualization alignment"
    ],
    "_classification": {
      "category": "Can be dockerized without any issue",
      "timestamp": "2025-04-05 01:09:28"
    }
  },
  {
    "number": 1406,
    "title": "how to delay chunk download in exoplayer-DASH",
    "created_at": "2016-03-31T09:34:22Z",
    "closed_at": "2016-04-04T14:16:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/1406",
    "body": "I am working on DASH streaming in ExoPlayer. \nI want to delay(time varies) the download of next chunk , because i have enough buffer to play for next few seconds.\nHow can i achieve this? \n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/1406/comments",
    "author": "RamkumarVooda",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2016-03-31T09:47:11Z",
        "body": "Why don't you trust the player to buffer chunks in a sensible way? Or to put it another way, why do you actually want to do this? Having enough buffer to play the next few seconds isn't a good reason in itself, and artificially keeping the buffer small significantly increases the probability of re-buffers or playback failures.\n"
      },
      {
        "user": "RamkumarVooda",
        "created_at": "2016-03-31T12:37:39Z",
        "body": "I am implementing an adaptive streaming algorithm in FormatEvaluator Class. So according to the algorithm i need to delay the download for some time only if the buffer is exceeding certain threshold.\n"
      },
      {
        "user": "ojw28",
        "created_at": "2016-04-04T10:46:37Z",
        "body": "`LoadControl` (and `DefaultLoadControl`) implements this functionality currently, so you should start there.\n"
      },
      {
        "user": "RamkumarVooda",
        "created_at": "2016-04-04T14:16:52Z",
        "body": "yes got it.\nThank you\n"
      }
    ],
    "satisfaction_conditions": [
      "Mechanism to conditionally delay chunk downloads based on buffer thresholds",
      "Integration with ExoPlayer's buffer management system",
      "Support for variable delay durations",
      "No degradation of adaptive streaming logic"
    ],
    "_classification": {
      "category": "Can be dockerized without any issue",
      "timestamp": "2025-04-05 01:09:47"
    }
  },
  {
    "number": 1186,
    "title": "HLS - Handling low buffer and seek with no network connection",
    "created_at": "2016-01-25T22:22:33Z",
    "closed_at": "2016-01-26T00:21:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/1186",
    "body": "I'm using ExoPlayer for audio only, HLS streams. As such, we can buffer quite a bit of audio which we want to continue playing even if the network drops or the device is put into airplane mode. In general that works fine, but there are a couple of no-network scenarios I'm trying to handle:\n1. Play through buffer \n2. Attempt to seek\n\nMy approach so far has been to register listeners with DefaultLoadControl and HlsSampleSource and to move my player into something similar to a buffering state when a load error is encountered. This solves the specific use cases I mentioned, but it doesn't give me very granular understanding of why loading failed. \n\nI realize that to some extent these are business / presentation layer concerns, but I'm wondering if there are recommended ways to address them in the context of ExoPlayer? For example, are there any ways to pause and resume loading? Is there a way to get a 'low buffer' warning before the loader kicks in? \n\nAny insights are greatly appreciated.\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/1186/comments",
    "author": "jedhoffmann",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2016-01-25T22:56:29Z",
        "body": "I'm a little confused. Are you basically saying that you don't want playback to fail, ever, even if there's no network? Specifically, you'd rather the player enter an indefinite buffering state until network is restored?\n"
      },
      {
        "user": "jedhoffmann",
        "created_at": "2016-01-25T23:15:26Z",
        "body": "That is essentially how I have it coded right now, but it's clearly not ideal. Focusing just on the scenario of playing out the buffer with no network: is there a way you would recommend monitoring the buffers so that we can stop playback if they drop below a critical level and we don't have a network to load more?\n"
      },
      {
        "user": "ojw28",
        "created_at": "2016-01-25T23:26:07Z",
        "body": "You could probably stop the player from failing by passing a large value as minLoadableRetryCount to the HlsChunkSource constructor. You don't need to do anything special to have the player enter a buffering state when the buffer runs out; it'll do this automatically. So I think passing a large minLoadableRetryCount is all you'd need to do to achieve what you want.\n"
      },
      {
        "user": "jedhoffmann",
        "created_at": "2016-01-26T00:20:59Z",
        "body": "Thanks for the suggestion. It looks like that is doing the right thing for me. \n"
      }
    ],
    "satisfaction_conditions": [
      "Mechanism to prevent playback failure during network loss",
      "Buffer monitoring capability",
      "Controlled retry behavior for loading attempts",
      "Integration with ExoPlayer's native buffering state"
    ],
    "_classification": {
      "category": "Can be dockerized without any issue",
      "timestamp": "2025-04-05 01:10:28"
    }
  },
  {
    "number": 967,
    "title": "Switching between encrypted streams",
    "created_at": "2015-11-18T12:49:19Z",
    "closed_at": "2015-11-26T12:15:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/967",
    "body": "Hello,\nI have encountered a problem while switching between encrypted HLS streams after upgrading to ExoPlayer 1.5.2 from 1.4.1, I am switching between streams as advised in question #931\nSwitching between non-encrypted streams is fine, also between encrypted and non-encrypted. But when switching between encrypted streams i get this exception\n\n``` java\n11-18 13:32:27.926 13748-13847/? E/LoadTask: Unexpected exception loading stream\n11-18 13:32:27.926 13748-13847/? E/LoadTask: java.lang.IllegalArgumentException\n11-18 13:32:27.926 13748-13847/? E/LoadTask:     at com.google.android.exoplayer.util.Assertions.checkArgument(Assertions.java:39)\n11-18 13:32:27.926 13748-13847/? E/LoadTask:     at com.google.android.exoplayer.util.ParsableByteArray.setPosition(ParsableByteArray.java:133)\n11-18 13:32:27.926 13748-13847/? E/LoadTask:     at com.google.android.exoplayer.util.ParsableByteArray.skipBytes(ParsableByteArray.java:145)\n11-18 13:32:27.926 13748-13847/? E/LoadTask:     at com.google.android.exoplayer.extractor.ts.TsExtractor.read(TsExtractor.java:141)\n11-18 13:32:27.926 13748-13847/? E/LoadTask:     at com.google.android.exoplayer.hls.HlsExtractorWrapper.read(HlsExtractorWrapper.java:240)\n11-18 13:32:27.926 13748-13847/? E/LoadTask:     at com.google.android.exoplayer.hls.TsChunk.load(TsChunk.java:108)\n11-18 13:32:27.926 13748-13847/? E/LoadTask:     at com.google.android.exoplayer.upstream.Loader$LoadTask.run(Loader.java:209)\n11-18 13:32:27.926 13748-13847/? E/LoadTask:     at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:390)\n11-18 13:32:27.926 13748-13847/? E/LoadTask:     at java.util.concurrent.FutureTask.run(FutureTask.java:234)\n11-18 13:32:27.926 13748-13847/? E/LoadTask:     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1080)\n11-18 13:32:27.926 13748-13847/? E/LoadTask:     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:573)\n11-18 13:32:27.926 13748-13847/? E/LoadTask:     at java.lang.Thread.run(Thread.java:841)\n```\n\nI have tried to track down the issue and found out that TS Extractor is trying to skip adaptation field longer than the size of tsPacket Buffer:\n\n``` java\n11-18 13:32:27.625 13748-13773/? E/null\u00a0check: position: 5, bytes: 7, limit: 188\n11-18 13:32:27.625 13748-13773/? E/null\u00a0check: position: 6, bytes: 1, limit: 9\n11-18 13:32:27.625 13748-13773/? E/null\u00a0check: position: 9, bytes: 0, limit: 9\n11-18 13:32:27.625 13748-13748/? E/Status: preparing\n11-18 13:32:27.896 13748-13847/? E/null\u00a0check: position: 5, bytes: 10, limit: 188\n11-18 13:32:27.926 13748-13847/? E/null\u00a0check: position: 5, bytes: 185, limit: 188\n```\n\nwhere preparing is status of player after switching and bytes is the number if bytes extractor is trying to skip. This never happened while i was using version 1.4.1. Encryption is standard AES so it should be replicable with any encrypted HLS streams.\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/967/comments",
    "author": "SnowcatSVK",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2015-11-18T17:21:43Z",
        "body": "You're probably not fully rebuilding the renderers when you switch. You shouldn't re-use any objects that you used to build one set of renderers when building the next set, particularly things like DataSource instances. Is it possible that you are re-using them? If so, try not doing so.\n"
      },
      {
        "user": "SnowcatSVK",
        "created_at": "2015-11-19T08:05:25Z",
        "body": "Well, i am using DemoPlayer and HLSRendererBuilder from demo directory in project, these are the methods i am using for switching:\n\n``` java\nprivate HlsRendererBuilder createRenderer() {\n        String userAgent = Util.getUserAgent(this, \"ExoplayerTest\");\n        return new HlsRendererBuilder(this, userAgent, contentUri.toString());\n    }\n\n    private void preparePlayer() {\n        if (player == null) {\n            player = new DemoPlayer(createRenderer());\n            player.addListener(this);\n            player.setCaptionListener(this);\n            player.setMetadataListener(this);\n            playerNeedsPrepare = true;\n\n        }\n        if (playerNeedsPrepare) {\n            player.prepare();\n            playerNeedsPrepare = false;\n        }\n        player.setSurface(surfaceView.getHolder().getSurface());\n        player.setPlayWhenReady(true);\n    }\n\n    private void releasePlayer() {\n        if (player != null) {\n            //playerPosition = player.getCurrentPosition();\n            player.release();\n            player = null;\n\n        }\n    }\n```\n\nand this is the way i am using those methods: \n\n``` javascript\n    releasePlayer();\n    preparePlayer();\n```\n\nonly thing i am reusing is surfaceView, unless there is something in DemoPlayer and HLSRendererBuilder that i have missed, but that shouldn't be the case since it never happened with nonencrypted streams\n"
      },
      {
        "user": "ojw28",
        "created_at": "2015-11-19T16:53:35Z",
        "body": "If that's the case then the two playbacks should be completely independent to one another. It's pretty much equivalent to backing out of playback in the demo activity and selecting another sample. In which case I don't understand how one playback could affect the next (at a theoretical level)?\n\nCan you modify the demo app in some way to reproduce the issue? And if so, can you upload it to GitHub so that we can reproduce ourselves?\n"
      },
      {
        "user": "SnowcatSVK",
        "created_at": "2015-11-20T10:25:01Z",
        "body": "I have my whole project in private repository on GitHub, i can privately send you link to that repository so you can test it yourself\n"
      },
      {
        "user": "ojw28",
        "created_at": "2015-11-26T12:15:28Z",
        "body": "The issue is related to the way that you've made `HlsChunkSource.encryptionKeyUri`static in your branch. The breaks the assumption that the second playback is independent of the first, because state is being left lying around from the first playback in the static variable. If I null it out where the player is released, then the second playback works fine.\n\nSo the conclude - It looks like an issue with your local modifications. As a general style point, it's worth exploring solutions that don't require statics except in the specific case of singletons (which definitely isn't the case for this particular variable). I also noticed some interesting code in User.java where initSingletons re-initializes singletons potentially multiple times, which looks wrong to me.\n"
      },
      {
        "user": "SnowcatSVK",
        "created_at": "2015-11-27T08:44:44Z",
        "body": "Thank you very much for help, I must have left it there from the time when I was trying different solutions and forgot about it, shame I couldn't find it myself, as for User.java, this is a recycled class from an older project written by different developer, I have recycled it as it was working well with our API and I needed to get going fast with testing, this project was just for testing purposes, so I am completely rewriting it since all of the issues are resolved now.\n"
      }
    ],
    "satisfaction_conditions": [
      "Ensure encryption state is fully reset between encrypted stream switches",
      "Guarantee complete independence between playback sessions",
      "Avoid static variables for non-singleton components",
      "Maintain proper resource lifecycle management"
    ],
    "_classification": {
      "category": "Can be dockerized without any issue",
      "timestamp": "2025-04-05 01:11:27"
    }
  }
]