[
  {
    "number": 4295,
    "title": "Changing exif data question",
    "created_at": "2024-12-13T19:31:47Z",
    "closed_at": "2024-12-14T08:06:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/4295",
    "body": "Hi, could you please explain how to change ExifImageWidth and ExifImageHeight? I use withMetadata() and Ideally I want to copy all metadata except ExifImageWidth, ExifImageHeight. ImageHeight and ImageWidth copied too and it's not correct when I change orientation. Please help.",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/4295/comments",
    "author": "ihopciklumer",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2024-12-13T20:42:51Z",
        "body": "Please try something like the following:\r\n```js\r\n.withExif({\r\n  IFD0: {\r\n    PixelXDimension: \"123\",\r\n    PixelYDimension: \"456\"\r\n  }\r\n})\r\n```"
      },
      {
        "user": "ihopciklumer",
        "created_at": "2024-12-14T08:06:41Z",
        "body": "Thanks! It helped!"
      }
    ],
    "satisfaction_conditions": [
      "Ability to modify EXIF dimensions (width/height) independently of other metadata",
      "Preservation of non-targeted EXIF metadata during modification"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-04 23:53:52"
    }
  },
  {
    "number": 3729,
    "title": "How to resize images when composite",
    "created_at": "2023-07-19T04:51:07Z",
    "closed_at": "2023-07-22T12:18:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/3729",
    "body": "I am trying to merge images using 'sharp'.\r\nThere are 6 images, size is 1536x1536px.\r\n\r\nThe size of the combined image will be 1536x9216.\r\nI would like to know how to write a merged image to be reduced to 256x1536.\r\n\r\nindex.ts\r\n```typescript\r\nimport sharp from \"sharp\";\r\n\r\nasync function main() {\r\n\r\n  const imagePaths = [\"images/1.jpeg\", \"images/2.jpeg\", \"images/3.jpeg\",\"images/4.jpeg\", \"images/5.jpeg\", \"images/6.jpeg\"];\r\n  const outputImgWidth = 1536;\r\n  const outputImgHeight = 9216;\r\n \r\n    let totalHeight = 0;\r\n    const compositeParams = imagePaths.map(image => {\r\n      const top = totalHeight;\r\n      totalHeight += outputImgWidth;\r\n      \r\n      return {\r\n        input: image,\r\n        gravity: \"northwest\",\r\n        left: 0,\r\n        top: top\r\n      };\r\n    });\r\n  \r\n    await sharp({\r\n      create: {\r\n        width: outputImgWidth,\r\n        height: outputImgHeight,\r\n        channels: 4,\r\n        background: { r: 255, g: 255, b: 255, alpha: 0 }\r\n      }\r\n    })\r\n      .composite(compositeParams);\r\n      .toFile(`preview.jpg`,(err, info)=>{\r\n          if(err){ throw err }\r\n          console.log(info)\r\n        });\r\n}\r\n\r\nmain().then();\r\n``` \r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/3729/comments",
    "author": "HarunoOi",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2023-07-19T09:15:39Z",
        "body": "Hi, in this example, because all the dimensions are known up-front, I'd suggest images are resized before composition:\r\n```diff\r\n-        input: image,\r\n+        input: await image.resize({ width: 256, height: 256 }).toBuffer(),\r\n```\r\n"
      },
      {
        "user": "HarunoOi",
        "created_at": "2023-07-21T05:01:32Z",
        "body": "I changed it to this writing style.\r\n`input: await sharp(image).resize(256).toBuffer(),`\r\n\r\nThen an error occurred in the following section.\r\n`.composite(compositeParams)`\r\n\r\nerror\r\n```\r\nArgument of type 'Promise<{ input: Buffer; left: number; top: number; }>[]'  is not assignable to parameter of type 'OverlayOptions[]' \r\nProperty  'Promise<{ input: Buffer; left: number; top: number; }>'  is missing in type 'OverlayOptions' \r\n```\r\n"
      },
      {
        "user": "lovell",
        "created_at": "2023-07-21T10:59:48Z",
        "body": "If your map function is `async` then you'll probably need to `await` it approximately here:\r\n```diff\r\n-     const compositeParams = imagePaths.map(async image => {\r\n+     const compositeParams = await Promise.all(imagePaths.map(async image => {\r\n```"
      },
      {
        "user": "HarunoOi",
        "created_at": "2023-07-22T12:16:27Z",
        "body": "We were able to achieve this!\r\n\r\nApart from the module, it took me a long time due to my lack of coding knowledge.\r\nThanks for telling me about it."
      }
    ],
    "satisfaction_conditions": [
      "Resize individual images before composition to achieve final desired dimensions",
      "Handle asynchronous operations correctly when preparing image buffers",
      "Maintain valid composite parameters structure after transformations"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-04 23:54:18"
    }
  },
  {
    "number": 3696,
    "title": "Is it possible to access trim offsets for all sides and not just top and left?",
    "created_at": "2023-06-12T18:44:45Z",
    "closed_at": "2023-06-12T19:20:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/3696",
    "body": "## Question about an existing feature\r\n\r\n### What are you trying to achieve?\r\n\r\nFor my specific use case I need to have access to the size that was trimmed from all sides and not just top and left (trimOffsetTop, trimOffsetLeft) returned by the trim method.\r\n\r\nThe main reason is that I need to save the original position that the actual content had within the transparent background in its original canvas, so that I'm able to \"recreate\" the image if needed for example, by repositioning the content in a different canvas later.\r\n\r\nIn my cases there is no guarantee the top/bottom transparent space are equal, and the same applies to left/right as well.\r\n\r\nIs it possible to achieve this with sharp right now? I could not find any related issues or discussions and I'm yet to read through the source code.\r\n\r\nSomething tells me I should be able to achieve this without sharp, before trimming, but I didn't want to come up with a solution that acts different than the `trim` and end up with inconsistent saved data vs output.\r\n\r\nThanks!\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/3696/comments",
    "author": "gugiserman",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2023-06-12T18:57:18Z",
        "body": "You can calculate this using the input and output dimensions.\r\n```\r\nright offset = input width - output width - left offset\r\nbottom offset = input height - output height - top offset\r\n```"
      },
      {
        "user": "gugiserman",
        "created_at": "2023-06-12T19:20:03Z",
        "body": "> You can calculate this using the input and output dimensions.\r\n> \r\n> ```\r\n> right offset = input width - output width - left offset\r\n> bottom offset = input height - output height - top offset\r\n> ```\r\n\r\nI'm dumb!\r\nThanks!"
      }
    ],
    "satisfaction_conditions": [
      "Provides a method to calculate all four trim offsets (top, left, bottom, right) using available data",
      "Ensures consistency with sharp's trim behavior",
      "Uses input/output dimensions to derive missing offsets",
      "Doesn't require assumptions about symmetry in transparent areas"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-04 23:54:28"
    }
  },
  {
    "number": 3403,
    "title": "How do I output multiple resized images in multiple formats?",
    "created_at": "2022-10-11T01:19:02Z",
    "closed_at": "2022-10-11T16:31:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/3403",
    "body": "So far I have been able to figure out how to take in an image and output multiple sizes, like so:\r\n\r\n```js\r\nconst sharp = require('sharp')\r\n\r\nconst image = `beach`;\r\nconst format = `jpg`;\r\n\r\nconst resize = size => sharp(`${image}.jpg`)\r\n  .resize({ width: size })\r\n  .toFile(__dirname + `/processed/${image}-${size}.${format}`)\r\n;\r\n\r\nPromise\r\n  .all([2160, 1920, 1440, 1080, 720, 480, 320].map(resize))\r\n  .then(() => {\r\n    console.log('Image resizing is complete.');\r\n  });\r\n```\r\n\r\n...and it works just fine.\r\n\r\nNow I want to be able to output multiple formats of each resized image as well (`avif` is the preferred choice, but `jpg` is the fallback kind of thing), but can't figure it out...\r\n\r\nI've tried this so far:\r\n\r\n```js\r\nconst sharp = require('sharp')\r\n\r\nconst image = `beach`;\r\nconst format = [`jpg`, `avif`]\r\n\r\nconst resize = size => sharp(`${image}.jpg`)\r\n  .resize({ width: size })\r\n  .toFile(__dirname + `/processed/${image}-${size}.${format[0]}`)\r\n  .toFile(__dirname + `/processed/${image}-${size}.${format[1]}`)\r\n;\r\n\r\nPromise\r\n  .all([2160, 1920, 1440, 1080, 720, 480, 320].map(resize))\r\n  .then(() => {\r\n    console.log('Image resizing is complete.');\r\n  });\r\n```\r\n\r\n...but it seems that I cannot chain two `toFile`'s together?\r\n\r\nBeen googling around but have not found anything yet...\r\n\r\nAny help is greatly appreciated, thank you XD",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/3403/comments",
    "author": "rchrdnsh",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2022-10-11T07:33:22Z",
        "body": "Perhaps try something like (untested):\r\n```js\r\nconst resize = (width) =>\r\n  Promise.all(\r\n    format.map((f) =>\r\n      sharp(`${image}.jpg`)\r\n        .resize({ width })\r\n        .toFile(__dirname + `/processed/${image}-${width}.${f}`)\r\n    )\r\n  );\r\n```\r\n"
      },
      {
        "user": "rchrdnsh",
        "created_at": "2022-10-11T16:31:03Z",
        "body": "aha! that worked great...i think i understand...for each width do a map of each format... \r\n\r\nI don't know anything about `Promise.all` however, so i will go learn about it now, but thank you :-)"
      }
    ],
    "satisfaction_conditions": [
      "Generate multiple output formats (e.g. AVIF and JPG) for each resized image",
      "Handle asynchronous file writing operations correctly",
      "Process all format conversions for a given size before moving to next size",
      "Maintain parallel processing efficiency for multiple sizes"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-04 23:54:36"
    }
  },
  {
    "number": 3299,
    "title": "How sharpness works with multi-page PDFs?",
    "created_at": "2022-07-20T15:12:38Z",
    "closed_at": "2022-07-21T07:40:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/3299",
    "body": "Hi,\r\nFirst of all, thank you for this library, it's really great!\r\n\r\nI'm wondering how is the sharpness calculated for PDF file?\r\n\r\nFor example, I have a PDF file with a few pages inside, I read it with `sharp` and convert to one large image. \r\nWhen I check it for the sharpness, what will I get: some average value for all the pages, minimal sharpness of the most blurred page or something else?\r\n\r\nSorry if there is an answer somewhere, couldn't find it.\r\nBest regards!",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/3299/comments",
    "author": "4m4rel",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2022-07-21T07:25:15Z",
        "body": "The following will calculate the sharpness of all pages combined (imagine they have been stitched together top to bottom).\r\n```js\r\nconst { sharpness } = await sharp(input, { pages: -1 }).stats();\r\n```\r\nIf you want averages/min/max etc., you'll need to make one call per page and calculate yourself:\r\n```js\r\nconst sharpnessFirstPage = (await sharp(input, { page: 0 }).stats()).sharpness;\r\nconst sharpnessSecondPage = (await sharp(input, { page: 1 }).stats()).sharpness;\r\n...\r\n```"
      },
      {
        "user": "4m4rel",
        "created_at": "2022-07-21T07:40:12Z",
        "body": "Yeah, I did that, but the operation was much slower.\r\n\r\nSo, if we have a PDF where one page is completely blurred and all the others fine, we get sharpness value just a little bit lower, but not the one that says \"You might have a problem with blurred page in this file\"...\r\n\r\nOk, I understood your point. Thanks a lot for the answer!"
      }
    ],
    "satisfaction_conditions": [
      "Clarify how sharpness calculation aggregates values across multiple PDF pages",
      "Explain the relationship between processing method and result interpretation",
      "Identify requirements for detecting per-page quality issues"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-04 23:54:41"
    }
  },
  {
    "number": 2975,
    "title": "pipeline await and toBuffer",
    "created_at": "2021-11-15T18:59:31Z",
    "closed_at": "2021-12-12T20:52:23Z",
    "labels": [
      "question",
      "cookbook"
    ],
    "url": "https://github.com/lovell/sharp/issues/2975",
    "body": "I am trying to pipe an input stream to a sharp pipeline and get a buffer out of it.\r\nTo be able to handle the input stream errors, i thought i could do this:\r\n\r\n```\r\nconst sharp = require('sharp');\r\nconst pipeline = require('util').promisify(require('stream').pipeline);\r\nconst got = require('got');\r\n\r\nasync function getThumbnailBuffer(uri) {\r\n\tconst pil = sharp().resize({\r\n\t\tfit: \"inside\",\r\n\t\theight: 64\r\n\t}).toFormat('webp', {\r\n\t\tquality: 50\r\n\t});\r\n\tconst pipe = await pipeline(got.stream(uri), pil);\r\n\tconst buf = await pil.toBuffer();\r\n\treturn buf; // i know i can return pil.toBuffer(), i do this to show where we wait\r\n};\r\n```\r\n\r\nhowever that doesn't work - `await pipeline` doesn't return when no error is thrown.\r\nOn the other hand, it correctly (meaning `try { await getThumbnailBuffer(url); }` works) throws an error (from got.stream) when there is one.\r\n\r\nI also tried this but toBuffer is not a stream, so it can't work:\r\n```\r\n\treturn await pipeline(got.stream(uri), pil.toBuffer());\r\n```\r\n\r\nInstead i had to do that:\r\n\r\n```\r\nconst sharp = require('sharp');\r\nconst pipeline = require('util').promisify(require('stream').pipeline);\r\nconst got = require('got');\r\n\r\nmodule.exports = async function (uri) {\r\n\tconst pil = sharp().resize({\r\n\t\tfit: \"inside\",\r\n\t\theight: 64\r\n\t}).toFormat('webp', {\r\n\t\tquality: 50\r\n\t});\r\n\tlet toBuff;\r\n\tsetTimeout(async () => {\r\n\t\ttoBuff = pil.toBuffer();\r\n\t});\r\n\tawait pipeline(got.stream(uri), pil);\r\n\tconst buf = await toBuff;\r\n\treturn buf; // i know i can return toBuff, i do this to show where we wait\r\n};\r\n```\r\n\r\nthis works and also catches (in a way compatible with async/await) errors.\r\nHowever it's ugly.\r\nIt's hard to tell if it comes from\r\n- node\r\n- got\r\n- sharp\r\nbut right now i'm inclined to think the need to call \"toBuffer\" to trigger the stream is odd.\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/2975/comments",
    "author": "kapouer",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2021-11-15T19:24:15Z",
        "body": "A `sharp` instance implements a `Duplex` stream so won't emit the `close` event (and therefore resolve the \"promisified\" logic here) until it knows the destination of the output, as this might be another `WritableStream`.\r\n\r\nPerhaps an alternative approach might be to `await` the input and output sides concurrently, something like (untested):\r\n```js\r\nconst [pipe, buf] = await Promise.all([\r\n  pipeline(got.stream(uri), pil),\r\n  pil.toBuffer()\r\n]);\r\n```"
      },
      {
        "user": "kapouer",
        "created_at": "2021-11-15T20:57:11Z",
        "body": "Yes ! that's so much nicer ! Even better, this works too:\r\n```\r\nconst [buf] = await Promise.all([\r\n  pil.toBuffer(),\r\n  pipeline(got.stream(uri), pil)\r\n]);\r\n```\r\nmaybe it would help so much if it was given as an example somewhere in the documentation.\r\nEDIT: i made sure this actually works and also actually throws correctly in case of input stream error."
      },
      {
        "user": "lovell",
        "created_at": "2021-12-12T20:52:23Z",
        "body": "Glad you got it working. I've tagged this as `cookbook` for inclusion in future possible document relating to problem-oriented solutions (as opposed to API-level reference)."
      }
    ],
    "satisfaction_conditions": [
      "Ensures pipeline completion before buffer conversion",
      "Proper error propagation from input stream",
      "Synchronization between stream processing and buffer collection",
      "Avoidance of implementation-specific hacks",
      "Compatibility with async/await patterns"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-04 23:54:51"
    }
  },
  {
    "number": 2718,
    "title": " VipsJpeg: Corrupt JPEG data: premature end of data segment",
    "created_at": "2021-05-16T18:24:59Z",
    "closed_at": "2021-05-16T18:44:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/2718",
    "body": "I am trying to resize an array of images here is my code:\r\nconst Sharp = require('sharp');\r\nconst fs = require('fs');\r\n\r\nconst transformer = Sharp().resize(300);\r\n\r\n\r\nconst addFoto = async (request, h) => {\r\n  const fotos = [].concat(request.payload.fotoFile);\r\n  const smallerFotos = Promise.all(fotos.map(async (foto) => {\r\n    const writeStream = fs.createWriteStream(foto.hapi.filename);\r\n    return foto.pipe(transformer).pipe(writeStream);\r\n  }));\r\nthe code works when the array length is one\r\nbut fails when more than file is in the array \r\nfiles are jpeg\r\nthanks\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/2718/comments",
    "author": "mibuen",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2021-05-16T18:33:20Z",
        "body": "You'll need to create a new sharp instance per input.\r\n```diff\r\n- const transformer = Sharp().resize(300);\r\n+ const transformer = () => Sharp().resize(300);\r\n\r\n  const addFoto = async (request, h) => {\r\n  const fotos = [].concat(request.payload.fotoFile);\r\n  const smallerFotos = Promise.all(fotos.map(async (foto) => {\r\n  const writeStream = fs.createWriteStream(foto.hapi.filename);\r\n- return foto.pipe(transformer).pipe(writeStream);\r\n+ return foto.pipe(transformer()).pipe(writeStream);\r\n  }));\r\n```"
      }
    ],
    "satisfaction_conditions": [
      "Ensure separate Sharp instances are used for concurrent image processing operations",
      "Maintain proper stream isolation for each image processing pipeline",
      "Support concurrent JPEG processing without data corruption",
      "Preserve core resizing functionality across multiple files"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-04 23:55:05"
    }
  },
  {
    "number": 2638,
    "title": "Metadata before and after Resize",
    "created_at": "2021-03-25T08:32:38Z",
    "closed_at": "2021-03-25T14:05:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/2638",
    "body": "Hello, \r\n\r\nIs possible to get both metada from image resized in a single step ?\r\nIn other words, two metadata for same image, before and after resize, in a single step.\r\n\r\nTo get metadata after resize I use :\r\n\r\n```\r\n    sharp(imageBuffer)                              \r\n    \t.resize(800, 900, {                                           \r\n    \t\tfit: 'inside',                                              \r\n    \t\twithoutEnlargement: true                                    \r\n    \t})\r\n        .jpeg({ quality: 80 })\r\n    \t.toBuffer({ resolveWithObject: true })\r\n    \t.then(data => {\r\n               console.log(data);\r\n \t    })\r\n    \t.catch(err => {if (err) \r\n    \t{\r\n    \t    console.log(err);\r\n    \t    throw err;\r\n    \t}\r\n    });\r\n```\r\n\r\nTo get metada before resize I use `.metadata()`.\r\n\r\nBut how to get both metadata in a single step ?",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/2638/comments",
    "author": "softy2k",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2021-03-25T12:25:21Z",
        "body": "Perhaps try something like the following (untested):\r\n```js\r\nconst [ before, after ] = await Promise.all([\r\n  sharp(imageBuffer).metadata(),\r\n  sharp(imageBuffer).resize({ ... }).toBuffer({ resolveWithObject: true })\r\n]);\r\n```"
      },
      {
        "user": "softy2k",
        "created_at": "2021-03-25T13:24:05Z",
        "body": "Thanks **lovell**, work like a charm"
      }
    ],
    "satisfaction_conditions": [
      "Retrieve both original and resized image metadata without requiring separate processing steps",
      "Avoid redundant image buffer processing",
      "Provide access to pre-resize and post-resize metadata simultaneously"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-04 23:55:22"
    }
  },
  {
    "number": 2442,
    "title": "Webp vs. JPEG sizes?",
    "created_at": "2020-11-15T21:45:42Z",
    "closed_at": "2020-11-27T14:00:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/2442",
    "body": "I am a newbie for image processing.  To my understanding, webp is supposed to have smaller size than jpeg.  However, from my experiment, this is not the case after converting to both format using Sharp.\r\n\r\nI am actually getting smaller sizes when converting to JPEG.  \r\nHere is my configurations:\r\n```\r\nsharp().resize({ width: 300 }).jpeg({ quality: 100 })\r\nsharp().resize({ width: 300 }).webp({ lossless: true })\r\n```\r\nOriginal PNG size is 937 KB.\r\nConverted JPEG is 408.7 KB\r\nConverted WEBP is 584.9 KB\r\n\r\nFor resized smaller images are the same result.  \r\nAm I missing something or this is expected?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/2442/comments",
    "author": "RoosterH",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2020-11-16T11:59:58Z",
        "body": "Hi, JPEG is always lossy, even at a \"quality\" of 100.\r\n\r\nA fairer comparison might be:\r\n```diff\r\n  sharp().resize({ width: 300 }).jpeg({ quality: 100 })\r\n- sharp().resize({ width: 300 }).webp({ lossless: true })\r\n+ sharp().resize({ width: 300 }).webp({ quality: 100 })\r\n```"
      },
      {
        "user": "RoosterH",
        "created_at": "2020-11-16T17:27:45Z",
        "body": "lovell,\r\n\r\nThanks a lot.  After trying \r\n```\r\n sharp().resize({ width: 300 }).webp({ quality: 100 })\r\n```\r\nThe size was reduced to 217.3 KB.  This indeed is a great reduction!"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of when WebP achieves smaller file sizes compared to JPEG",
      "Comparison of lossless vs lossy compression tradeoffs",
      "Guidance on fair format comparison methodology",
      "Clarification of quality parameter implications"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-04 23:55:28"
    }
  },
  {
    "number": 2392,
    "title": "await does not work?",
    "created_at": "2020-10-02T00:45:11Z",
    "closed_at": "2020-10-02T16:02:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/2392",
    "body": "My code:\r\n\r\n```\r\nconst fs = require('fs');\r\nconst sharp = require('sharp');\r\n\r\nconst src = '/tmp/input.jpg';\r\nconst dst = '/tmp/output.jpg';\r\n\r\n(async () => {\r\n    await sharp(src).resize(100, 100).toFile(dst);\r\n    await fs.chmod(dst, 0o666);\r\n})();\r\n\r\n```\r\nI have got an error:\r\n`exception: Error: ENOENT: no such file or directory, chmod '/tmp/output.jpg'`\r\n\r\nIt looks like chmod runs before the sharp has been done its job.\r\n\r\nAny ideas?",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/2392/comments",
    "author": "m00nk",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2020-10-02T08:47:42Z",
        "body": "Hi, `fs.chmod` does not return a Promise, so this might be the cause. Perhaps add a try/catch block around each use of `await`?"
      },
      {
        "user": "m00nk",
        "created_at": "2020-10-02T11:26:10Z",
        "body": "I have tried this:\r\n\r\n```\r\n(async () => {\r\n    await sharp(src).resize(100, 100).toFile(dst);\r\n    await fs.promises.chmod(dst, 0o666);\r\n})();\r\n```\r\n\r\nand had the same result - chmod runs before the output file has been created."
      },
      {
        "user": "lovell",
        "created_at": "2020-10-02T11:42:58Z",
        "body": "Please can you provide complete information about the versions, platform, OS etc. involved."
      },
      {
        "user": "m00nk",
        "created_at": "2020-10-02T12:39:44Z",
        "body": "Linux Mint (Ubuntu), Node 12.18, sharp 0.26.0"
      },
      {
        "user": "lovell",
        "created_at": "2020-10-02T12:59:06Z",
        "body": "Thanks, I cannot reproduce this. Is there anything unusual about the /tmp filesystem on this machine? Does using a non-tmp path work? What happened when you added the separate try/catch blocks around each use of await?"
      },
      {
        "user": "m00nk",
        "created_at": "2020-10-02T14:03:02Z",
        "body": "I have found very strange behavior. The code:\r\n\r\n```js\r\nconsole.log('START');\r\n\r\nconst proc = sharp(srcImg);\r\n// some other code is here\r\nproc\r\n\t.toFile(dstImg)\r\n\t.then(info => { console.log('INFO', info);})\r\n\t.catch(err => { console.log('ERR', err);});\r\n\r\ntry{\r\n\tawait proc;\r\n\tconsole.log('DONE PROC');\r\n}\r\ncatch(e){ console.log('EXCEPTION', e); }\r\n\r\nconsole.log('FINISHED');\r\n```\r\n\r\nI have got:\r\n```\r\nSTART\r\nDONE PROC\r\nFINISHED\r\nINFO {\r\n   format: 'jpeg',\r\n   width: 250,\r\n   height: 90,\r\n   channels: 3,\r\n   premultiplied: false,\r\n   size: 8098\r\n }\r\n```\r\n\r\nSo last console.log runs before the image has been created. But if I use \"the chain\" like:\r\n\r\n```js\r\nconst proc = sharp(srcImg)\r\n\t.toFile(dstImg)\r\n\t.then(info => {\tconsole.log('INFO', info);\t})\r\n\t.catch(err => {\tconsole.log('ERR', err);\t});\r\n```\r\ninstead of\r\n```js\r\nconst proc = sharp(srcImg);\r\nproc.toFile(dstImg)\r\n\t.then(info => { console.log('INFO', info);})\r\n\t.catch(err => { console.log('ERR', err);});\r\n```\r\nI have got:\r\n\r\n```\r\nSTART\r\nINFO {\r\n   format: 'jpeg',\r\n   width: 250,\r\n   height: 90,\r\n   channels: 3,\r\n   premultiplied: false,\r\n   size: 8098\r\n}\r\nDONE PROC\r\nFINISHED\r\n```\r\n\r\nIn this way all works right - last console.log runs AFTER the image has been created.\r\n\r\nCan you explain this behaviour? I am not very good in JS, so maybe I do something wrong, but in my opinion that behoviour is very odd. \r\n\r\nThank you.\r\n\r\nPS.\r\nAll code above placed inside async function. "
      },
      {
        "user": "lovell",
        "created_at": "2020-10-02T14:12:50Z",
        "body": "Your code is mixing up Promise chains and await/try/catch notation.\r\n\r\nThe call to `toFile()` returns a Promise, so that's what you must `await`, e.g. `await proc.toFile(dstImg)`\r\n\r\nYou can't await a sharp instance itself, so e.g. `await proc` is incorrect (it resolves straight away)."
      },
      {
        "user": "m00nk",
        "created_at": "2020-10-02T15:40:20Z",
        "body": "Ah, yes. Thank you ))"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why awaiting a sharp instance directly doesn't wait for file operations",
      "Clarification that only specific Sharp methods return Promises to await",
      "Guidance on proper async workflow sequencing with Sharp operations",
      "Explanation of Promise chain vs async/await interaction",
      "Verification that file system timing isn't the root cause"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-04 23:55:36"
    }
  },
  {
    "number": 2278,
    "title": "base64\u7f16\u7801\u5b57\u7b26\u4e32\u4e0d\u6b63\u786e\u7684\u65f6\u5019\uff0ctry/catch\u6ca1\u6709\u6355\u83b7\u5230error",
    "created_at": "2020-07-03T08:55:37Z",
    "closed_at": "2020-07-04T11:00:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/2278",
    "body": "\u5ba2\u6237\u7aef\r\nlet buff = fs.readFileSync(fileName)\r\nlet base64Str = buff.toString('base64')\r\nbase64Str = base64Str.substring(0, base64Str.length - 100) \uff08base64Str.length > 100)\r\n\r\n\u670d\u52a1\u7aef\r\ntry {\r\n  let buffer = Buffer.from(base64Str, 'base64')\r\n  let img = sharp(buffer)\r\n  await img.metadata()\r\n  sharp(buffer).resize(width, height)\r\n} catch (error) {\r\n  \r\n}\r\n\r\n\u6709\u8f93\u51fa\r\nUncaught Error: VipsJpeg: Premature end of JPEG file\r\nVipsJpeg: out of order read at line 1008\r\n\r\n\u4f46\u662f\u6211\u6ca1\u6709\u5728catch\u91cc\u9762\u6355\u83b7\u5230error\uff0c\u8bf7\u95ee\u4e0b\u662f\u4ec0\u4e48\u539f\u56e0\uff1f",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/2278/comments",
    "author": "tangna",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2020-07-03T13:05:41Z",
        "body": "Does the following change, to `await` a call to `toBuffer`, ensure the error is caught?\r\n```diff\r\n- sharp(buffer).resize(width, height)\r\n+ await sharp(buffer).resize(width, height).toBuffer()\r\n```\r\nIf not, please provide a complete, standalone code sample and image that allows someone else to reproduce this problem."
      },
      {
        "user": "tangna",
        "created_at": "2020-07-03T15:42:46Z",
        "body": "\u8c22\u8c22\uff0c\u8fd9\u6837\u662f\u53ef\u4ee5\u7684\u3002\r\n\u4e4b\u524d\uff0c\u6211\u662f\u60f3\u7528sharp(buffer).resize(width, height)\u8fd4\u56destream\uff0c\u7136\u540e\u4e0a\u4f20\u5230Aliyun OSS\uff0c\u800c\u4e0d\u7528\u8f6c\u6210buffer\uff1b\r\n\u8fd9\u6837\u6709\u529e\u6cd5\u5417\uff1f\r\n\r\n"
      },
      {
        "user": "lovell",
        "created_at": "2020-07-03T20:42:35Z",
        "body": "The use of Stream-based output means you can no longer \"catch\" errors, instead you'll need to listen for the error event.\r\n```diff\r\n- sharp(buffer).resize(width, height)\r\n+ sharp(buffer).resize(width, height).on('error', err => { ... })\r\n```\r\n\r\n(This is a Node.js concept rather than being specific to sharp.)"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of error handling differences between Promise-based and Stream-based operations in Node.js",
      "Guidance on proper error capture for both synchronous and asynchronous image processing workflows",
      "Clear distinction between error handling in promise chains vs event-driven streams",
      "Solution that maintains functionality while implementing proper error handling"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-04 23:55:46"
    }
  },
  {
    "number": 2184,
    "title": "Can't compress a 24 bit jpg to an 8 bit jpg",
    "created_at": "2020-04-27T07:50:22Z",
    "closed_at": "2020-04-27T21:19:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/2184",
    "body": "What are you trying to achieve?\r\ncompress a 24 bit jpg to an 8 bit jpg\r\n\r\nHave you searched for similar feature requests?\r\nyes, couldn't find anything\r\n\r\nWhat would you expect the API to look like?\r\n\r\nawait sharp(in).depth(8).toFile(out);\r\n\r\nWhat alternatives have you considered?\r\npngquant but it's only for png files\r\n\r\nIs there a sample image that helps explain?\r\nno",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/2184/comments",
    "author": "quinton-ashley",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2020-04-27T09:07:59Z",
        "body": "Hi, JPEG images use 8 bits per channel, so a 24-bit JPEG is three-channel RGB and an 8-bit JPEG is single-channel greyscale.\r\n\r\n(JPEG images can also use 12 bits per channel, but those are very rare and most software does not support them.)"
      },
      {
        "user": "quinton-ashley",
        "created_at": "2020-04-27T21:19:35Z",
        "body": "Oh my bad, thanks for the explanation and for sharp! It's really good :)"
      }
    ],
    "satisfaction_conditions": [
      "Clarification of JPEG bit depth vs color channel terminology",
      "Identification of grayscale conversion as the required operation",
      "Validation of JPEG format capabilities"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-04 23:55:52"
    }
  },
  {
    "number": 2053,
    "title": "toFile does not save all files.",
    "created_at": "2020-01-24T09:32:33Z",
    "closed_at": "2020-01-27T09:20:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/2053",
    "body": "Using sharp for reading the image from the buffer. Resizing it then saving with toFile function, but when I check the directory, there are only 4 or 6, or 7 or the exact 8 of the 8 sent images saved.\r\n\r\nawait sharp(file.buffer)\r\n          .resize(dimensions.width, dimensions.height + 1)     \r\n          .resize(dimensions.width, dimensions.height)\r\n          .toFormat(dimensions.type)                       \r\n          .toFile(dir + `/${filename}` + fileFormat);",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/2053/comments",
    "author": "AlexandrHovsepyan",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2020-01-24T10:59:28Z",
        "body": "Please can you provide a complete, standalone code sample that allows someone else to reproduce this problem."
      },
      {
        "user": "AlexandrHovsepyan",
        "created_at": "2020-01-24T11:23:24Z",
        "body": "`const multer = require('multer');\r\nconst sharp = require('sharp');\r\nconst imageSize = require('image-size');\r\n\r\nconst storage = multer.memoryStorage();\r\n\r\nexports.mediaResizeFiles = async (req, res, next) => {\r\nawait Promise.all(\r\nreq.files.map(async file => {\r\nlet userId = req.user._id;\r\nlet data = req.user._id + '-' + Date.now();\r\nlet filename = crypto.createHash('md5').update(data).digest(\"hex\");\r\nlet fileFormat = path.extname(file.originalname);\r\nlet directory = '';\r\n\r\n            if (file.mimetype.startsWith('image')) {\r\n                \r\n                directory = 'image';\r\n                 let dir = createMediaDir(userId, directory);\r\n\r\n                let dimensions = imageSize(file.buffer);\r\n            \r\n                await sharp(file.buffer)\r\n                        .resize(dimensions.width, dimensions.height + 1)\r\n                        .resize(dimensions.width, dimensions.height) \r\n                        .toFormat(dimensions.type)                      \r\n                        .toFile(dir + `/${filename}` + fileFormat);\r\n              }\r\n      })\r\n}`\r\n\r\nThis is the main part of the code related to the issue."
      },
      {
        "user": "lovell",
        "created_at": "2020-01-24T13:12:10Z",
        "body": "This bit of code, unrelated to sharp, will not generate unique filenames:\r\n```\r\nlet data = req.user._id + '-' + Date.now();\r\nlet filename = crypto.createHash('md5').update(data).digest(\"hex\");\r\n```"
      },
      {
        "user": "AlexandrHovsepyan",
        "created_at": "2020-01-24T14:51:55Z",
        "body": "I am sorry, I think there is a misunderstanding. Do you mean that in the 8 files there the cache (md5) is being matched with the each other?"
      },
      {
        "user": "lovell",
        "created_at": "2020-01-24T16:13:29Z",
        "body": "The value of `filename` is an md5 hash of a timestamp so is not guaranteed to be unique."
      },
      {
        "user": "AlexandrHovsepyan",
        "created_at": "2020-01-27T07:39:53Z",
        "body": "After changes, I believe everything is fine now. Thank you for everything. "
      }
    ],
    "satisfaction_conditions": [
      "Ensures unique filenames to prevent overwriting"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-04 23:56:56"
    }
  },
  {
    "number": 1940,
    "title": "Get metadata from resized/modified image.",
    "created_at": "2019-10-28T02:20:55Z",
    "closed_at": "2019-10-29T03:30:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1940",
    "body": "What are you trying to achieve?\r\nI want to get width, height and size in file system from a resized image. I've tried using the `metadata` method, but it gives me information about the original image, not the resized image. I wonder if that is possible without having to re-open the image after storing it.\r\n\r\nHave you searched for similar questions?\r\nYes :)\r\n\r\nAre you able to provide a standalone code sample that demonstrates this question?\r\n```\r\n// Resize the image.\r\nvar transform = await sharp().resize(resizeOptions).jpeg({ quality: 90 }).toFormat('jpg')\r\nfile.stream.pipe(transform)\r\n\r\n// Save the image on the file system.\r\nawait Drive.disk('spaces').put(path, transform, {\r\n  ACL: 'public-read',\r\n  ContentType: 'image/jpg'\r\n})\r\n\r\n// Get image metadata\r\nconst metadata = await transform.metadata()\r\nconsole.log(metadata) // This gives me the original image metadata\r\n```\r\n\r\nAre you able to provide a sample image that helps explain the question?\r\nI don't believe it is necessary.\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1940/comments",
    "author": "maverick504",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2019-10-28T10:33:36Z",
        "body": "Hi, in your sample code, `transform` refers to the input sharp instance rather than the output JPEG data. You'll need to add a call to `toBuffer()` to generate the output image, something like (untested):\r\n\r\n```diff\r\n  // Resize the image.\r\n- var transform = await sharp().resize(resizeOptions).jpeg({ quality: 90 }).toFormat('jpg')\r\n+ const transform = sharp().resize(resizeOptions).jpeg({ quality: 90 }).toFormat('jpg')\r\n  file.stream.pipe(transform)\r\n+ const output = await transform.toBuffer()\r\n\r\n  // Save the image on the file system.\r\n- await Drive.disk('spaces').put(path, transform, {\r\n+ await Drive.disk('spaces').put(path, output, {\r\n    ACL: 'public-read',\r\n    ContentType: 'image/jpg'\r\n  })\r\n\r\n  // Get image metadata\r\n- const metadata = await transform.metadata()\r\n+ const metadata = await sharp(output).metadata()\r\n```"
      },
      {
        "user": "maverick504",
        "created_at": "2019-10-29T01:05:46Z",
        "body": "It works! Thank you very much!"
      }
    ],
    "satisfaction_conditions": [
      "Retrieve metadata from the processed/resized image data rather than the original input stream",
      "Access final image metadata without requiring filesystem re-reading after storage",
      "Ensure metadata reflects the actual bytes being written to storage"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-04 23:57:04"
    }
  },
  {
    "number": 1902,
    "title": "Extract after extract",
    "created_at": "2019-10-05T13:37:02Z",
    "closed_at": "2019-10-06T20:14:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1902",
    "body": "Is it possible?\r\n\r\nI have one image and want to exctract region one after one.\r\n\r\n````\r\nconst image = () => sharp(data).extract({\r\n          left: paddingLeft,\r\n          top: paddingTop,\r\n           width: W,\r\n          height: H\r\n       });\r\n\r\nimage().toFile(destination);\r\nimage().extract({ \r\nleft: pleft, \r\ntop: pTop,\r\n width: pw, height: ph\r\n            }).toFile(destination2);\r\n````\r\n\r\nbut second instans do not see the first extract(). It crops original image.\r\n\r\n  ",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1902/comments",
    "author": "Alexufo",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2019-10-06T19:56:59Z",
        "body": "Hi, you'll need to use two pipelines for this, something like (untested):\r\n```javascript\r\nconst image1 = await image().toBuffer();\r\nsharp(image1).extract({ ... }).toFile(destination2);\r\n```"
      },
      {
        "user": "Alexufo",
        "created_at": "2019-10-06T20:14:45Z",
        "body": "Yes. Thanks. I did\r\n\r\n```\r\n                const cropped = await sharp(data).extract({\r\n                    left: paddingLeft,\r\n                    top: paddingTop,\r\n                    width: pW,\r\n                    height: pH\r\n                }).toBuffer();\r\n\r\n                const img1 = await sharp(cropped).toFile()\r\n                const Img2 = await sharp(cropped).extract({}).toFile()\r\n```"
      }
    ],
    "satisfaction_conditions": [
      "Ensure sequential image processing where subsequent operations work on the output of previous transformations",
      "Provide a method to preserve intermediate processing results between operations",
      "Maintain operation order and dependency chain in image processing"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-04 23:57:12"
    }
  },
  {
    "number": 1779,
    "title": "code only seems to work if intermediate file is used?",
    "created_at": "2019-07-04T16:41:18Z",
    "closed_at": "2019-07-08T16:40:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1779",
    "body": "I have a chunk of code as follows:\r\n\r\n```\r\n      var img = sharp(path)\r\n  \r\n      // Extract the grayscale channel?\r\n      // and save as 'newGrey.png'\r\n      var grey = img.extractChannel(0)\r\n      await grey.toColorspace(\"b-w\")\r\n(1)        .toFile(\"newGrey-\"+ client.clientID + client.counter +\".png\")\r\n\r\n      // Load new alpha and join\r\n      let filename = 'transparencies/'+client.rasterConfig.transparency+'.png'\r\n      //console.log(filename)\r\n(2)      await sharp('newGrey-'+ client.clientID + client.counter + '.png')\r\n        .toColorspace(\"b-w\")\r\n        .joinChannel(filename)\r\n        .toBuffer((err, data, info) => { \r\n\r\n```\r\n\r\nThis code works.  \r\n\r\nBut as you can see, I'm basically writing the file to a temp image at point (1), then reload that same temp image at point (2).  This seems totally like it should be redundant.  But if I remove the toFile at (1) and the load at (2), I don't get the same resultant image.\r\n\r\nWhat am I misunderstanding here?\r\n\r\nThanks\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1779/comments",
    "author": "avpavp",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2019-07-06T12:47:26Z",
        "body": "Hi, if you're using the channel operations then yes, intermediate images will be required. You could use raw, uncompressed pixel data, something like:\r\n```javascript\r\nconst { width, height } = await sharp(path)\r\n  .metadata();\r\n\r\nconst greyscale = await sharp(path)\r\n  .extractChannel(0)\r\n  .toColorspace(\"b-w\")\r\n  .raw()\r\n  .toBuffer();\r\n\r\nconst result = await sharp(greyscale, { raw: { width, height, channels: 1 })\r\n  .toColorspace(\"b-w\")\r\n  .joinChannel(filename)\r\n  .toBuffer();\r\n```"
      },
      {
        "user": "avpavp",
        "created_at": "2019-07-08T16:40:53Z",
        "body": "Ah - thanks for the tip.  I've managed to get this working - with your help!\r\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why intermediate file operations are required in Sharp's processing pipeline",
      "Demonstration of alternative approach to avoid file I/O while maintaining functionality",
      "Clarification of Sharp's channel operation requirements",
      "Preservation of color space transformations during processing"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-04 23:57:35"
    }
  },
  {
    "number": 1778,
    "title": "Usage with Axios?",
    "created_at": "2019-07-04T14:39:06Z",
    "closed_at": "2019-07-05T06:15:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1778",
    "body": "I'm currently trying to download an image using Axios and then resize the result and save it locally via Node in a GraphQL resolver.\r\n\r\nThis is the block of code I'm working with:\r\n```javascript\r\naxios.get(url)\r\n                .then((response) => {\r\n                    const { set, collector_number } = response.data;\r\n                    const sourceUrl = response.data.image_uris.border_crop;\r\n                    const filename = `${set}/${collector_number}.png`;\r\n                    axios.get(sourceUrl, { responseType: 'arraybuffer' })\r\n                        .then((res) => {\r\n                            console.log(`Resizing Image!`)\r\n                            sharp(res)\r\n                                .resize(226, 321)\r\n                                .toFile(`../cardimg/${filename}`)\r\n                                .then(() => {\r\n                                    console.log(`Image downloaded and resized!`)\r\n                                })\r\n                                .catch((err) => {\r\n                                    console.log(`Couldn't process: ${err}`);\r\n                                })\r\n                        })\r\n                })\r\n```\r\n\r\nWhen I execute the code (via GraphQL Mutation), it throws an error saying that states `Input file is missing`.\r\n\r\nNot sure if it's misuse of Axios, or if I'm doing something wrong with Sharp.\r\n\r\nAny suggestions?   I was originally worried that I needed to mess with the format of the response coming from the HTTP request, but from what I can gather, I'm doing it correctly.  \r\n\r\nThanks in advance!\r\n\r\nI've used `console.log` to ensure that it's definitely grabbing an image and the URL is correct, so that's already been tested, so the `sourceUrl` is indeed grabbing an image, I'm just not sure how to properly do anything -with-  the data that I'm grabbing.",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1778/comments",
    "author": "czbak3r",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2019-07-04T15:06:24Z",
        "body": "I think Axios returns an object on which the `data` property is of interest:\r\n\r\n```diff\r\n-    .then((res) => {\r\n+    .then(({ data }) => {\r\n```"
      },
      {
        "user": "czbak3r",
        "created_at": "2019-07-04T16:25:15Z",
        "body": "You're right!\r\n\r\nI used `.data` on the first Axios request but not the second one.\r\n\r\nOversight.  Oops.\r\n\r\nThank you!\r\n\r\nI'll double check after work.  :)"
      },
      {
        "user": "ChristianRich",
        "created_at": "2022-11-29T07:27:09Z",
        "body": "Doh... I just fell into the exact same trap and ended up here :-)"
      }
    ],
    "satisfaction_conditions": [
      "Correct extraction of binary image data from Axios response",
      "Compatibility between HTTP response data and image processing library requirements"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-04 23:57:45"
    }
  },
  {
    "number": 1717,
    "title": "Error while trying to use composite",
    "created_at": "2019-05-23T18:21:47Z",
    "closed_at": "2019-05-27T10:18:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1717",
    "body": "I'm trying to use composite like this:\r\n\r\n```\r\nconst sharpFile = this.electronService.sharp(null, options);\r\n\r\nconst pagePhotos = page.allPhotos.map(photo => {\r\n  return {\r\n    input: photo.photo.sizes[0].localPath,\r\n    top: Math.round(photo.y),\r\n    left: Math.round(photo.x)\r\n  };\r\n});\r\n\r\nconsole.log(pagePhotos);\r\n\r\nconst pageBuffer = sharpFile.composite(pagePhotos).toBuffer();\r\n\r\n// localPath is something like this\r\n// \"/Users/username/Library/Application Support/projectname/projects/PKTFB45BW/photos/FKYCARH45MQ-1000.jpg\"\r\n```\r\n\r\nI'm getting this error\r\n\r\n```\r\nUnhandled Promise rejection: Input buffer contains unsupported image format ; Zone: <root> ; Task: null ; Value: Error: Input buffer contains unsupported image format Error: Input buffer contains unsupported image format\r\n\r\nError: Input buffer contains unsupported image format\r\n```\r\n\r\nWhat am I doing wrong?",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1717/comments",
    "author": "GunterJameda",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2019-05-23T19:52:17Z",
        "body": "Hi, I might need a more complete code sample. What is `options` set to?"
      },
      {
        "user": "GunterJameda",
        "created_at": "2019-05-24T09:20:38Z",
        "body": "Options is set to this:\r\n\r\n```\r\nconst options: SharpOptions = {\r\n  create:\r\n    {\r\n      width: Math.floor(page.width * page.zoom),\r\n      height: Math.floor(page.height * page.zoom),\r\n      channels: 3,\r\n      background: ColorUtil.hex2rgb(page.backgroundColor)\r\n    }\r\n  };\r\n```"
      },
      {
        "user": "lovell",
        "created_at": "2019-05-24T15:23:41Z",
        "body": "Thanks. Is `photo.photo.sizes[0].localPath` a string? Are you able to provide an image that fails in this manner?"
      },
      {
        "user": "GunterJameda",
        "created_at": "2019-05-24T15:27:50Z",
        "body": "Yes. As I previously said, it is a string like this:\r\n\r\n`/Users/username/Library/Application Support/projectname/projects/PKTFB45BW/photos/FKYCARH45MQ-1000.jpg`\r\n\r\nAll images fail, to be precise. I don't understand why, since the path is absolute."
      },
      {
        "user": "lovell",
        "created_at": "2019-05-24T15:33:02Z",
        "body": "Please can you provide a complete, standalone code sample/repo that exhibits this behaviour."
      },
      {
        "user": "GunterJameda",
        "created_at": "2019-05-24T15:40:10Z",
        "body": "The code I just provided is as complete as it can be, but I'll write it all together and make some adjustments to be a working one.\r\n\r\n```\r\nconst options: SharpOptions = {\r\n  create:\r\n    {\r\n      width: 2000,\r\n      height: 1000,\r\n      channels: 3,\r\n      background: {r:0,g:0,b:0}\r\n    }\r\n  };\r\n\r\nconst photos = [\r\n'/Users/username/Library/Application Support/projectname/projects/PKTFB45BW/photos/A.jpg',\r\n'/Users/username/Library/Application Support/projectname/projects/PKTFB45BW/photos/B.jpg',\r\n'/Users/username/Library/Application Support/projectname/projects/PKTFB45BW/photos/C.jpg'\r\n];\r\n\r\nconst sharpFile = this.electronService.sharp(null, options);\r\n\r\nconst pagePhotos = photos.map((photo, index) => {\r\n  return {\r\n    input: photo,\r\n    top: 100 + 100 * index,\r\n    left: 100 + 100 * index\r\n  };\r\n});\r\n\r\nconst pageBuffer = sharpFile.composite(pagePhotos).toBuffer();\r\n```\r\n\r\nI'm not sure if this will do the trick."
      },
      {
        "user": "lovell",
        "created_at": "2019-05-24T16:57:42Z",
        "body": "I'm unable to reproduce this problem using the provided code snippet.\r\n\r\nThe original report was an \"Unhandled Promise rejection\" so I can only suggest you add some error handling to your code to help narrow down exactly where the problem is occurring.\r\n\r\nPerhaps there's some code not shown here that also uses sharp? What is `pageBuffer` (which is a Promise, not a Buffer) used for? "
      },
      {
        "user": "GunterJameda",
        "created_at": "2019-05-24T17:05:10Z",
        "body": "It was thenned, after that and then the buffer would be injected in sharp again.\r\n\r\nEDIT: below is another possible pain point. It is not the `then` code.\r\n\r\nI was initially trying to change this snippet (which works all fine)\r\n\r\n```\r\nconst pageBuffer: Promise<Buffer> = page.allPhotos.reduce<Promise<Buffer>>((bufferPromise: Promise<Buffer>, framePhoto) =>\r\n      bufferPromise.then((buffer => this.electronService.sharp(framePhoto.photo.sizes[0].localPath)\r\n        .rotate(undefined, {\r\n          background: { r: 0, g: 0, b: 0 }\r\n        })\r\n        .resize(\r\n          Math.round(framePhoto.width - framePhoto.borderThickness * 2),\r\n          Math.round(framePhoto.height - framePhoto.borderThickness * 2))\r\n        .extend({\r\n          top: framePhoto.borderThickness,\r\n          left: framePhoto.borderThickness,\r\n          right: framePhoto.borderThickness,\r\n          bottom: framePhoto.borderThickness\r\n        })\r\n        .toBuffer()\r\n        .then(frameBuffer => this.electronService.sharp(buffer).overlayWith(\r\n          frameBuffer,\r\n          {\r\n            top: Math.round(framePhoto.y),\r\n            left: Math.round(framePhoto.x)\r\n          }).toBuffer())\r\n      ) as any)\r\n      , sharpFile.jpeg().toBuffer() as any as Promise<Buffer>);\r\n```\r\n\r\nto `composite` method, which didn't work at all and threw that error. I tried to catch the error and the message was unclear, anyway. Here it is:\r\n\r\n`Error: Input buffer contains unsupported image format`"
      },
      {
        "user": "lovell",
        "created_at": "2019-05-25T09:15:43Z",
        "body": "Thank you for providing a more complete code sample.\r\n\r\nIf you've used `create` to create a new, blank image but have not specified any output format e.g. via `png()` etc. then the data returned by `toBuffer()` will be raw, uncompressed pixel data.\r\n\r\nIt looks like you might be feeding the resolved value of `pageBuffer` back into a new sharp instance, so you'll need to describe that raw data.\r\n\r\n```javascript\r\nsharp(rawBuffer, { raw: { width, height, channels }})...\r\n```"
      },
      {
        "user": "GunterJameda",
        "created_at": "2019-05-27T10:18:27Z",
        "body": "Thank you for your help!\r\nIt solved the issue! :)"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how to properly handle raw pixel data created via sharp's `create` method",
      "Clarification on required format specifications when reusing buffers between sharp operations",
      "Guidance on maintaining image format compatibility across chained operations"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-04 23:57:58"
    }
  },
  {
    "number": 1642,
    "title": "Detecting whether withoutEnlargement is fired or not",
    "created_at": "2019-04-04T15:35:22Z",
    "closed_at": "2019-04-05T09:02:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1642",
    "body": "## What are you trying to achieve?\r\nI am trying to create a set of sizes under the original size.  \r\n\r\nThe withoutEnlargement option works in that it does not scale up the image, however, ideally there would be a flag or something when doing toFile/toBuffer to say that the image was larger than the original image. \r\n\r\nThe problem I have at the moment is that I'm doing the following;\r\n\r\n```js\r\nsharp(tmpFilePath)\r\n        .resize(width, null, {\r\n          withoutEnlargement: true\r\n        })\r\n        .toFile(thumbPath)\r\n        .then((a) => {\r\n// Upload file to GCS\r\n});\r\n```\r\n\r\nAnd I would like to NOT create the new file in GCS if it is just the same as the original size, that way I don't have a file called '2000-image.jpg' when the width is actually 1500.\r\n\r\nIs there something I'm missing, or an extra callback parameter or something that would allow me to know in the `then` function so I could decide not to upload it. \r\n\r\n## Have you searched for similar questions?\r\nYes\r\n\r\n## Are you able to provide a standalone code sample that demonstrates this question?\r\nNot immediately, but I can if needed.\r\n\r\n## Are you able to provide a sample image that helps explain the question?\r\nAny image under the size you're trying to resize to. \r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1642/comments",
    "author": "Dayjo",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2019-04-04T18:09:50Z",
        "body": "Hello, in your code example the `a` parameter passed to `then()` is an object that includes the post-resize dimensions. Perhaps add a test for `a.width` being less than `width`?"
      },
      {
        "user": "Dayjo",
        "created_at": "2019-04-05T08:17:56Z",
        "body": "@lovell wonderful, that's a perfect solution thank you :) \r\n\r\nWould it be safe to use;\r\n\r\n```js\r\n.toFile(thumbPath)\r\n        .then((img) => {\r\n          if (img.width == width) {\r\n               ....\r\n```"
      }
    ],
    "satisfaction_conditions": [
      "Provides a way to detect if the image was actually resized or remained at original dimensions",
      "Offers a method to compare output dimensions with target resize parameters",
      "Ensures reliable dimension data is available in the processing pipeline"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-04 23:58:05"
    }
  },
  {
    "number": 1635,
    "title": "resize() after composite() cause error",
    "created_at": "2019-03-29T17:33:36Z",
    "closed_at": "2019-04-03T08:36:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1635",
    "body": "Hi,\r\n\r\nThere is a wierd issue when Im trying to `resize()` after `composite()`, the source is:\r\n\r\n```javascript\r\nsharp({\r\n    create: {\r\n        width: 789,\r\n        height: 789,\r\n        channels: 4,\r\n        background: '#bfff00'\r\n    }\r\n}).png().composite([{ input: content }]).resize(192).toBuffer((err, data) => {\r\n    if (err)\r\n        return callback(err);\r\n    this.emitFile(target, data);\r\n    callback(null, '');\r\n});\r\n```\r\n\r\nAnd it halted with *Image to composite must have same dimensions or smaller*.\r\n\r\nIf I deleted `.resize(192)`, it works fine.\r\n\r\nIf I deleted `.png()`, the same error would be occurred again.",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1635/comments",
    "author": "snakevil",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2019-03-30T10:26:55Z",
        "body": "You'll need to break this into two pipelines, something like (untested):\r\n```javascript\r\nsharp({\r\n  create: {\r\n    width: 789,\r\n    height: 789,\r\n    channels: 4,\r\n    background: '#bfff00'\r\n  }\r\n})\r\n  .composite([{\r\n    input: content\r\n  }])\r\n  .png()\r\n  .toBuffer()\r\n  .then(data => sharp(data)\r\n    .resize(192)\r\n    .toBuffer()\r\n  )\r\n  .then( ... );\r\n```"
      },
      {
        "user": "snakevil",
        "created_at": "2019-04-03T08:36:57Z",
        "body": "Yup. I finally solved that with two instances :-p"
      },
      {
        "user": "ZiangYan",
        "created_at": "2019-09-25T07:24:44Z",
        "body": "I've encountered the same problem when performing resizing after composition.\r\n\r\nThanks @lovell , this solution indeed works.\r\n\r\nBut I'm still curious about why a naive combination like\r\n\r\n```\r\nsharp(data).composite(...).resize(...)\r\n```\r\n doesn't work"
      },
      {
        "user": "johannwagner",
        "created_at": "2019-09-28T09:45:35Z",
        "body": "I also ran into this issue.\r\n\r\nI think, the issue is, that the call order is not used in the different transformations. So it is not important, if you do resize and composite or composite and resize."
      },
      {
        "user": "djardine",
        "created_at": "2020-01-08T02:00:08Z",
        "body": "Think @johannwagner is correct above, but regardless of the call order, to me it would seem to make more sense if the resize() is applied to the final composite image, not just the input base image, but not sure how others feel about that....?"
      },
      {
        "user": "slikts",
        "created_at": "2020-05-08T09:48:50Z",
        "body": "This is somewhat non-intuitive; a logical expectation would be that compositing images together would also allow them being processed together."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of why resize() after composite() causes dimension validation errors",
      "Clarification of Sharp's pipeline processing order",
      "Method to apply resize to final composite result",
      "Guidance on separation of transformation stages",
      "Clarification of image dimension inheritance in processing chain"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-04 23:58:15"
    }
  },
  {
    "number": 1584,
    "title": "Resize -> extract -> rotate leads to no rotate",
    "created_at": "2019-02-19T13:28:44Z",
    "closed_at": "2019-02-24T10:08:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1584",
    "body": "We have the following code:\r\n```js\r\nsharp()\r\n  .resize(600, 600)\r\n  .extract({ width: 200, height: 50, left: 0, top: 0 })\r\n  .rotate(90);\r\n```\r\n\r\nResult should be 50x200 however, it is 200x50 (rotate not applied).\r\n\r\nWhen we do `resize` in a different instance, then the result is 50x200 as expected:\r\n```js\r\nconst instance1 = sharp().resize(600, 600);\r\n  \r\nconst instance2 = sharp()\r\n  .extract({ width: 200, height: 50, left: 0, top: 0 })\r\n  .rotate(90);\r\n\r\ninstance1.pipe(instance2);\r\n```\r\n\r\nIs this an expected behaviour? If yes, what's the reason for this?\r\n\r\nSharp version: 0.21.3",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1584/comments",
    "author": "deftomat",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2019-02-19T14:26:37Z",
        "body": "Hello, the ordering of applying both a rotate and extract operation post-resize is currently fixed so the two-pipeline approach you suggest is correct. Please see #241 for discussion about a future possible additional API."
      },
      {
        "user": "deftomat",
        "created_at": "2019-02-21T07:34:27Z",
        "body": "Oh, thats sad. We need to construct pipelines dynamically and using a lot of new instances hit the CPU really badly. In our code it is like 30ms with 1 instance and 550ms with 3 instances \ud83d\ude22 "
      },
      {
        "user": "lovell",
        "created_at": "2019-02-22T22:08:05Z",
        "body": "I suspect much of that time will be spent in the (de)compression round trips. If you've not already done so, it'd be worth experimenting with raw, uncompressed data for the intermediate stages.\r\n\r\n```javascript\r\nconst instance1 = sharp().resize(600, 600).raw();\r\n  \r\nconst instance2 = sharp({ raw: { width: 600, height: 600, channels: 3 }})\r\n  .extract({ width: 200, height: 50, left: 0, top: 0 })\r\n  .rotate(90);\r\n\r\ninstance1.pipe(instance2);\r\n```"
      },
      {
        "user": "deftomat",
        "created_at": "2019-02-24T10:08:11Z",
        "body": "Awesome! Thanks, It helps a lot.\r\n"
      }
    ],
    "satisfaction_conditions": [
      "Explanation of operation order constraints in Sharp pipelines",
      "Confirmation of expected behavior vs potential bug",
      "Performance optimization strategy for multi-stage processing",
      "Guidance on handling intermediate processing stages without compression overhead",
      "Clarification of Sharp's operation sequencing limitations"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-04 23:58:42"
    }
  },
  {
    "number": 1561,
    "title": "Resize jpeg/webp without changing quality",
    "created_at": "2019-01-29T12:34:48Z",
    "closed_at": "2019-01-29T17:15:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1561",
    "body": "First, thanks for developing this great library Lovell. \r\nI was wondring if there is an option to resize an image without changing the quality. \r\n`sharp(buffer).resize(width).toBuffer()`\r\nAdding the jpeg function increases the filesize:\r\n`.jpeg({\r\n    quality: 100\r\n  })`\r\n`.metadata() ` doesnt show the initial quality. Not sure if that is even possible. I just saw that pain.net recognizes the quality.",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1561/comments",
    "author": "midevnull",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2019-01-29T16:14:01Z",
        "body": "Hello, did you see #908?"
      },
      {
        "user": "midevnull",
        "created_at": "2019-01-29T17:10:49Z",
        "body": "@lovell Thank you very much. Found a solution in the linked issue."
      }
    ],
    "satisfaction_conditions": [
      "Resize JPEG/WebP images without altering the original quality",
      "Avoid recompression that increases file size",
      "Work with unknown original quality metadata"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-04 23:58:50"
    }
  },
  {
    "number": 1461,
    "title": "store an image 2 times",
    "created_at": "2018-11-15T15:19:36Z",
    "closed_at": "2018-11-15T21:03:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1461",
    "body": "I have to resize an image 2 times and store it in different files\r\nand most importantly i want them to be Promise based so i can await them\r\n\r\ncurrently i use this method which i doubt to be correct:\r\n\r\n```\r\nawait sharp(my_file)\r\n\t.jpeg({quality: 90, chromaSubsampling: '4:4:4'})\r\n\t.resize(200, 200)\r\n\t.toFile('200x200.jpg', (err, info) => {}); // save\r\n\r\nawait sharp(my_file)\r\n\t.jpeg({quality: 90, chromaSubsampling: '4:4:4'})\r\n\t.resize(40, 40)\r\n\t.toFile('40x40.jpg', (err, info) => {}); // save\r\n```\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1461/comments",
    "author": "Mehdi-Azmoudeh",
    "comments": [
      {
        "user": "Daiz",
        "created_at": "2018-11-15T15:57:14Z",
        "body": "`.toFile` returns a Promise when a callback isn't specified.\r\n\r\nIf you want to encode the two different varieties in parallel, you can just do the following:\r\n\r\n```javascript\r\nasync function encode(my_file) {\r\n  const src = sharp(my_file).jpeg({quality: 90, chromaSubsampling: \"4:4:4\"});\r\n  const i200 = src.resize(200, 200).toFile(\"200x200.jpg\");\r\n  const i40 = src.resize(40, 40).toFile(\"40x40.jpg\");\r\n  return Promise.all([i200, i40]);\r\n}\r\n```\r\n\r\nYou can also `await Promise.all([i200, i40])` in the above example, naturally, if you want it as part of a bigger function or pipeline."
      },
      {
        "user": "Mehdi-Azmoudeh",
        "created_at": "2018-11-15T18:54:19Z",
        "body": "Great! So I can use it like this:\r\n\r\n`await encode(my_file);`\r\n\r\nPerfect! many thanks."
      }
    ],
    "satisfaction_conditions": [
      "Demonstrate proper Promise-based handling of multiple image processing operations",
      "Show how to process multiple resizes from a single source image",
      "Ensure operations can be executed either sequentially or in parallel",
      "Avoid callback-style syntax in favor of Promise chains"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-04 23:58:56"
    }
  },
  {
    "number": 1449,
    "title": "GLib-GObject-WARNING and GLib-GObject-CRITICAL",
    "created_at": "2018-11-06T20:47:20Z",
    "closed_at": "2018-11-10T22:49:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1449",
    "body": "Although my code executes fine and generates the file 100%, I am getting the following error messages:\r\n\r\n```\r\n(sharp:157048): GLib-GObject-WARNING **: 21:49:04.120: invalid uninstantiatable type '(null)' in cast to 'GObject'\r\n\r\n(sharp:157048): GLib-GObject-CRITICAL **: 21:49:04.120: g_object_set_qdata: assertion 'G_IS_OBJECT (object)' failed\r\n```\r\n\r\nMy code is as follow:\r\n\r\n```\r\nvar sharpImg = sharp('file1.png');\r\nsharpImg.metadata().then(function (metadata) {\r\n\tvar origWidth = metadata.width;\r\n\tvar origHeight = metadata.height;\r\n\treturn sharpImg.resize(Math.round(origWidth / 2), Math.round(origHeight / 2));\r\n}).then(function (data) {\r\n\tdata.toFile('file2.png', function (err, info) {\r\n\t\t// Done with err == null (No errors here)\r\n\t});\r\n});\r\n```",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1449/comments",
    "author": "1Map",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2018-11-07T11:47:27Z",
        "body": "Hello, this looks like #1320 - are you using the latest version?"
      },
      {
        "user": "1Map",
        "created_at": "2018-11-07T15:38:22Z",
        "body": "I am using Sharp version ^0.20.8"
      },
      {
        "user": "lovell",
        "created_at": "2018-11-10T22:39:01Z",
        "body": "Are you able to reproduce with the latest v0.21.0 version?"
      },
      {
        "user": "1Map",
        "created_at": "2018-11-10T22:45:52Z",
        "body": "@lovell No, I upgraded to 0.21.0 and I was monitoring fro past day or so.  It seems the problem was fixed in the latest version, so you can go ahead and close this.  Thanks for the help."
      }
    ],
    "satisfaction_conditions": [
      "Identifies the root cause as a known library issue rather than user code error",
      "Confirms resolution requires a specific version of the dependency",
      "Addresses GLib-GObject warnings without requiring code changes when using correct versions"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-04 23:59:26"
    }
  },
  {
    "number": 1397,
    "title": "when I map data with code, both png and jpeg are converted with a white background though I have a condition to only do that when output ext is  jpeg or jpg",
    "created_at": "2018-10-01T16:15:39Z",
    "closed_at": "2018-10-02T19:53:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1397",
    "body": "I'm trying to convert a transparent logo to jpg and png.  As you can see in my code below, I check to see if the file output ext is jpeg or jpg and if it is, it change the background to white and flatten it. \r\n\r\nFor some strange reason, when I map data with function, both png and jpeg are converted with a white background though I have a condition to only do that when output ext is  jpeg or jpg\r\n\r\n\r\n\r\n\r\n```\r\nlet local_file = '/tmp/output/295aadfd-f837-4ffb-b3a0-4a407cca54e0.png'\r\n\r\nlet data = [[700,\r\n    null,\r\n    'width',\r\n    '/tmp/output/295aadfd-f837-4ffb-b3a0-4a407cca54e0_10',\r\n    'png'],\r\n    [700,\r\n        null,\r\n        'width',\r\n        '/tmp/output/295aadfd-f837-4ffb-b3a0-4a407cca54e0_10',\r\n        'jpg'],\r\n    [1000,\r\n        null,\r\n        'width',\r\n        '/tmp/output/295aadfd-f837-4ffb-b3a0-4a407cca54e0_10',\r\n        'png'],\r\n    [1000,\r\n        null,\r\n        'width',\r\n        '/tmp/output/295aadfd-f837-4ffb-b3a0-4a407cca54e0_10',\r\n        'jpg']]\r\n\r\n\r\nPromise.all(data.map(convert_image_sharp(local_file))).then(() => {\r\n                    console.log('image convert done');\r\n                });\r\n\r\n\r\n```\r\n\r\n\r\n```\r\nfunction convert_image_sharp(image_path) {\r\n    let image = sharp(image_path);\r\n    return data => image\r\n        .metadata()\r\n        .then(function (metadata) {\r\n            let inputs = beatify_input(data);\r\n            if (inputs['crop']) {\r\n                image.extract(inputs['crop'][0], inputs['crop'][1], inputs['crop'][2], inputs['crop'][3])\r\n            }\r\n            image.resize(inputs['width'], inputs['height']);\r\n            if (['jpg', 'jpeg'].includes(inputs['ext'])){\r\n                console.log(inputs['ext']);\r\n                image.background('white');\r\n                image.flatten();\r\n            }\r\n            return image.toFile(inputs['write_path']);\r\n        })\r\n\r\n}\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1397/comments",
    "author": "wobeng",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2018-10-01T17:45:24Z",
        "body": "Hello, it's unclear what `data` refers to in the `convert_image_sharp` function. Are you able to provide a standalone, working code sample?"
      },
      {
        "user": "wobeng",
        "created_at": "2018-10-01T17:48:09Z",
        "body": "Hi @lovell I updated what data is"
      },
      {
        "user": "lovell",
        "created_at": "2018-10-01T19:05:24Z",
        "body": "The shared `image` instance is being mutated by each function invocation. You'll need to move the `sharp(image_path)` constructor into the anonymous function returned by `convert_image_sharp` to create a new sharp instance per function invocation.\r\n\r\n```diff\r\nfunction convert_image_sharp(image_path) {\r\n-    let image = sharp(image_path) ;\r\n-    return data => image\r\n+    return data => sharp(image_path)\r\n        .metadata()\r\n```"
      },
      {
        "user": "wobeng",
        "created_at": "2018-10-01T19:23:13Z",
        "body": "If I move the sharp(image_path) constructor into the anonymous function returned by convert_image_sharp, who can I access metadata? can you show me an example with metadata included"
      },
      {
        "user": "lovell",
        "created_at": "2018-10-01T20:22:35Z",
        "body": "The code sample provided doesn't appear to use `metadata` as provided by the call to `metadata()` so I'm not sure I understand what is needed. This might be more of a question for StackOverflow."
      },
      {
        "user": "wobeng",
        "created_at": "2018-10-01T20:26:45Z",
        "body": "Question:\r\n\r\nAfter I do sharp(image_path).metadata(), to get the sharp object back, do I need to use the constructor sharp(image_path) again\r\n"
      },
      {
        "user": "lovell",
        "created_at": "2018-10-02T19:51:51Z",
        "body": "Here's a possible (untested) version of `convert_image_sharp` that should behave in a way that I have understood your `data.map` logic to expect.\r\n```javascript\r\nfunction convert_image_sharp(image_path) {\r\n  return () => {\r\n    const image = sharp(image_path);\r\n    const { crop, ext, width, height, write_path } = beatify_input(data);\r\n    if (crop) {\r\n      image.extract(...crop);\r\n    }\r\n    image.resize(width, height);\r\n    if (['jpg', 'jpeg'].includes(ext)) {\r\n      image.background('white').flatten();\r\n    }\r\n    return image.toFile(write_path);\r\n  };\r\n}\r\n```\r\nThis question is not really specific to sharp and is more of a general JavaScript coding question suited to a site such as StackOverflow."
      },
      {
        "user": "wobeng",
        "created_at": "2018-10-02T19:53:23Z",
        "body": "Got it and thank you :)\r\n\r\n forgive me...I had to learn node js within 48 hours"
      }
    ],
    "satisfaction_conditions": [
      "Ensure image processing operations use isolated instances per conversion",
      "Preserve transparency for PNG outputs while flattening JPG/JPEG",
      "Clarify instance lifecycle in asynchronous processing"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-04 23:59:34"
    }
  },
  {
    "number": 1292,
    "title": "Remove alpha channel from png output",
    "created_at": "2018-07-11T14:35:08Z",
    "closed_at": "2018-07-22T19:49:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1292",
    "body": "Hi I try to compose an `icon.png` (with 4 channels) onto a background.\r\nRight now my solution is like this\r\n```js\r\nconst icon = sharp('icon.png').resize(size)\r\nsharp({ create: { width, height, background, channels: 4 } })\r\n  .overlayWith(await icon.toBuffer())\r\n  .toFile('output.png')\r\n```\r\n\r\nNow I sometimes need to remove the alpha channel from the `output.png`,\r\nI tried using `.flatten()` but the output image still has 4 channels.\r\nIt only worked when I also `.flatten()` the `icon` but then I get problems with the overlay.\r\n\r\nIs there a solution for this or do I have thought error somewhere?\r\nThank you for your help.",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1292/comments",
    "author": "dertieran",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2018-07-11T16:38:30Z",
        "body": "Hello, sharp will flatten before adding the overlay. To flatten after, something like the following should work (untested):\r\n\r\n```javascript\r\nconst rgbaImage = await sharp({ create: { width, height, background, channels: 4 } })\r\n  .overlayWith(await icon.toBuffer())\r\n  .toBuffer();\r\n\r\nsharp(rgbaImage)\r\n  .flatten()\r\n  .toFile('output.png')\r\n```"
      },
      {
        "user": "dertieran",
        "created_at": "2018-07-12T16:00:40Z",
        "body": "Thanks a lot that worked \ud83d\udc4d \r\nI just needed to add `.png()` before converting it to a buffer otherwise I would get the\r\n```\r\nInput buffer contains unsupported image format\r\n```\r\nSo now it looks like this:\r\n```js\r\nconst icon = sharp('icon.png').resize(size)\r\nconst buffer = await sharp({ create: { width, height, background, channels: 4 } })\r\n  .overlayWith(await icon.toBuffer())\r\n  .png()\r\n  .toBuffer()\r\n\r\nsharp(buffer)\r\n  .flatten()\r\n  .toFile('output.png')\r\n```"
      }
    ],
    "satisfaction_conditions": [
      "Ensures alpha channel removal occurs after image composition",
      "Maintains valid image format during intermediate processing",
      "Allows separate processing stages for composition and alpha removal",
      "Preserves overlay functionality without premptively modifying source alpha"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-04 23:59:46"
    }
  },
  {
    "number": 1280,
    "title": "Metadata not updated after rotate()",
    "created_at": "2018-06-28T03:44:35Z",
    "closed_at": "2018-06-28T18:14:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1280",
    "body": "If I have a file of dimensions 1999x1124, exif orientation=8, and I run it through sharp:\r\n```js\r\nsharp(file).rotate().metadata().then(metadata => console.log(metadata))\r\n```\r\nI get the original metadata.  I would have expected to see the new dimensions: (1124x1999)  I tried inserting `sharp.cache(false)` after rotating, but that had no effect.\r\n\r\nI suspect this is because the metadata function works \"without decoding any compressed image data,\" and it would need to read the buffer in order to redetermine it?  This seems broken to me.  Shouldn't the rotate() function update whatever source it's pulling this metadata from?\r\n\r\nPerhaps one non-breaking solution to this could be accepting a second options argument to the rotate method with a \"resolveWithObject\" flag that would work just like toBuffer, resolving an additional data object containing the new size after rotation.  I don't particularly like this idea design-wise, just brainstorming.\r\n\r\nMy use-case is, I need to resize an overlay image down to match the *rotated* image, prior to applying it.  I've had to resort to calling toBuffer twice: once to just fetch the dimensions, and then again after applying the overlay.  It's just really ugly and inefficient.  Here's the simplified version:\r\n```js\r\nfunction applyOverlay(file, overlayFile) {\r\n    return sharp(file)\r\n        .rotate()\r\n        .toBuffer({resolveWithObject: true})\r\n        .then(async ({data, info}) => {\r\n            const newWidth  = info.width;\r\n            const newHeight = info.height;\r\n\r\n            const overlay = await sharp(overlayFile)\r\n                .resize(newWidth, newHeight)\r\n                .max()\r\n                .toBuffer();\r\n\r\n            return sharp(data)\r\n                .overlayWith(overlay)\r\n                .toBuffer();\r\n        });\r\n}\r\n```\r\nIf there's some easier way to do this that I'm missing, by all means let me know where I've gone wrong.  Thanks!",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1280/comments",
    "author": "hackel",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2018-06-28T08:43:03Z",
        "body": "Hello, to perform a calculation based on EXIF Orientation without decoding pixel data, try something like the following (untested):\r\n```javascript\r\nsharp(file)\r\n  .metadata()\r\n  .then(({ width, height, orientation }) => {\r\n    const [newWidth, newHeight] = orientation < 5\r\n      ? [width, height]\r\n      : [height, width];\r\n    ...\r\n  });\r\n```"
      },
      {
        "user": "hackel",
        "created_at": "2018-06-28T18:06:08Z",
        "body": "Ha, well that is ridiculously simple, thanks.  I still think there's a case to be made for retrieving current metadata (or at least dimensions) at an arbitrary point in the pipeline, but this will work for my case."
      },
      {
        "user": "CptMaumau",
        "created_at": "2021-09-23T10:12:40Z",
        "body": "I recommend to do the opposite in case the metadata doesn't contain the orientation flag\r\n```\r\nconst [newWidth, newHeight] = orientation > 5\r\n  ? [metadata.height, metadata.width]\r\n  : [metadata.width, metadata.height];\r\n```"
      },
      {
        "user": "Apidcloud",
        "created_at": "2023-06-15T15:45:45Z",
        "body": "For what it's worth, just noticed the above snippet is not exactly the opposite (and therefore not entirely correct), as it missing the number 5 itself.\r\n\r\nIt should then be:\r\n```\r\nconst [newWidth, newHeight] = orientation >= 5\r\n  ? [metadata.height, metadata.width]\r\n  : [metadata.width, metadata.height];\r\n  ```"
      }
    ],
    "satisfaction_conditions": [
      "Provides a way to determine rotated image dimensions without full image processing",
      "Works with EXIF orientation metadata to calculate dimensions",
      "Avoids redundant image processing steps",
      "Handles edge cases in EXIF orientation values correctly",
      "Doesn't require breaking API changes"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-04 23:59:54"
    }
  },
  {
    "number": 1179,
    "title": "ForceSet deprecation warnings in v8 while building",
    "created_at": "2018-04-04T06:58:10Z",
    "closed_at": "2018-04-04T09:23:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1179",
    "body": "I'm getting many of these in various files with the latest version of node:\r\n```\r\n  CXX(target) Release/obj.target/sharp/src/utilities.o\r\nIn file included from ../../nan/nan.h:192:0,\r\n                 from ../src/utilities.cc:19:\r\n../../nan/nan_maybe_43_inl.h: In function 'Nan::Maybe<bool> Nan::ForceSet(v8::Local<v8::Object>, v8::Local<v8::Value>, v8::Local<v8::Value>, v8::PropertyAttribute)':\r\n../../nan/nan_maybe_43_inl.h:112:73: warning: 'v8::Maybe<bool> v8::Object::ForceSet(v8::Local<v8::Context>, v8::Local<v8::Value>, v8::Local<v8::Value>, v8::PropertyAttribute)' is deprecated: Use CreateDataProperty / DefineOwnProperty [-Wdeprecated-declarations]\r\n   return obj->ForceSet(isolate->GetCurrentContext(), key, value, attribs);\r\n                                                                         ^\r\nIn file included from /root/.node-gyp/9.10.1/include/node/v8.h:26:0,\r\n                 from /root/.node-gyp/9.10.1/include/node/node.h:63,\r\n                 from ../src/utilities.cc:18:\r\n/root/.node-gyp/9.10.1/include/node/v8.h:3165:29: note: declared here\r\n                 Maybe<bool> ForceSet(Local<Context> context, Local<Value> key,\r\n                             ^\r\n/root/.node-gyp/9.10.1/include/node/v8config.h:318:3: note: in definition of macro 'V8_DEPRECATED'\r\n   declarator __attribute__((deprecated(message)))\r\n   ^~~~~~~~~~\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1179/comments",
    "author": "jwater7",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2018-04-04T07:56:49Z",
        "body": "Hello, does the most recent version of sharp, namely v0.20.1, exhibit this behaviour also?"
      },
      {
        "user": "jwater7",
        "created_at": "2018-04-04T09:23:53Z",
        "body": "v0.20.1 does in fact fix the issue, sorry - this was a misunderstanding on my part how the node packages were getting updated and I thought I was getting the latest version.  I'll resolve the issue, thanks for the tip."
      }
    ],
    "satisfaction_conditions": [
      "Identifies that the root cause is an outdated dependency version incompatible with the current Node.js version",
      "Provides a path to update/replace deprecated API usage in dependencies",
      "Confirms compatibility between native modules and the Node.js runtime version"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-05 00:00:36"
    }
  },
  {
    "number": 1057,
    "title": "Using overlayWith before a rotate call throws an error",
    "created_at": "2017-12-09T08:22:44Z",
    "closed_at": "2017-12-12T08:06:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1057",
    "body": "I'm working on a project where I need to extract a piece of an image and then mask the extracted image with a polygon shape and then rotate it. I am using an SVG string buffer as the mask.\r\n\r\nWhen I run this line of code with rotate() I get an error:\r\n\"Overlay image must have same dimensions or smaller\"\r\n\r\n```\r\nsharp(imageData)\r\n    .extract({left: left, top: top, width: width, height: height})\r\n    .overlayWith(mask, {cutout: true})\r\n    .flip(isMirrored)\r\n    .rotate(rotation)\r\n    .png()\r\n    .toFile(filePath);\r\n```\r\n\r\nWhen I run it without the rotate call, it runs without error. I am not sure if this is an actual bug or if I may be doing something wrong. I am assuming that the overlayWith is happening after the rotation and that may be what is causing the error.\r\n\r\nI also want to thank you for creating this library. It is brilliant!",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1057/comments",
    "author": "zachzurn",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2017-12-10T20:03:32Z",
        "body": "Hello, your guess is correct, the overlay is applied at the end. You'll probably need to split this into two pipelines, something like:\r\n```javascript\r\nsharp(imageData)\r\n  .extract({left: left, top: top, width: width, height: height})\r\n  .overlayWith(mask, { cutout: true })\r\n  .raw()\r\n  .toBuffer({ resolveWithObject: true })\r\n  .then(({ data, info }) => sharp(data, { raw: info })\r\n    .flip(isMirrored)\r\n    .rotate(rotation)\r\n    .png()\r\n    .toFile(filePath)\r\n  );\r\n```\r\n"
      },
      {
        "user": "zachzurn",
        "created_at": "2017-12-12T00:11:03Z",
        "body": "Ah thanks! I will do it that way."
      }
    ],
    "satisfaction_conditions": [
      "Ensures overlay operation occurs before any dimension-altering transformations",
      "Maintains correct sequence of image processing steps (extract \u2192 mask \u2192 transform \u2192 output)",
      "Explains why operation order affects image dimensions in the pipeline"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-05 00:00:52"
    }
  },
  {
    "number": 1052,
    "title": "Create folder with `.toFile`?",
    "created_at": "2017-12-04T16:02:11Z",
    "closed_at": "2017-12-04T17:11:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1052",
    "body": "If the folder doesn't exist `sharp` throws me an error\r\nIs there's a way to sharp to create such folder if it doesn't exist?\r\n\r\n```js\r\n.toFile(`./public/uploads/${'resize-' + req.body.file}`)\r\n```\r\n```\r\nError: vips__file_open_write: unable to open file \"./public/uploads/greyscale-67badcb0-8a98-4126-828a-4e9fe152979b.jpeg\" for writing\r\nunix error: No such file or directory\r\n```",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1052/comments",
    "author": "hackuun",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2017-12-04T17:11:48Z",
        "body": "Hello, please see #874."
      },
      {
        "user": "hackuun",
        "created_at": "2017-12-05T15:39:35Z",
        "body": "@lovell got it. So you suggest something like this: first check is directory is exist, if not then create it with `mkdirp` and only after fire up `sharp`? Can I see basic clean example, because right now it looks little messed for me."
      },
      {
        "user": "papandreou",
        "created_at": "2017-12-05T18:44:15Z",
        "body": "```js\r\nconst mkdirp = require('mkdirp-promise');\r\nconst sharp = require('sharp');\r\n(async () => {\r\n  await mkdirp('public/uploads');\r\n\r\n  await sharp()\r\n    // ...\r\n    .toFile(`./public/uploads/${'resize-' + req.body.file}`);\r\n})();\r\n```\r\n"
      },
      {
        "user": "hackuun",
        "created_at": "2017-12-08T23:10:20Z",
        "body": "@papandreou thanks!"
      }
    ],
    "satisfaction_conditions": [
      "Ensure target directory exists before writing file with sharp",
      "Provide clear directory creation pattern that works with async/await",
      "Avoid sharp-specific directory creation implementation"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-05 00:01:00"
    }
  },
  {
    "number": 1049,
    "title": "Multiple operations doesn't work",
    "created_at": "2017-11-30T19:56:54Z",
    "closed_at": "2017-11-30T20:12:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1049",
    "body": "Hello. I am trying to resize and then grayscale image, but console gives me an error\r\n\r\n```js\r\nsharp(req.file.buffer)\r\n    .resize(800)\r\n    .toFile(`./public/uploads/${'resize-' + req.body.file}`)\r\n    .grayscale()\r\n    .toFile(`./public/uploads/${'grayscale-' + req.body.file}`)\r\n```\r\n\r\nIs it possible? Or this savings should be separate operations?",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1049/comments",
    "author": "hackuun",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2017-11-30T20:10:38Z",
        "body": "Hello, `toFile` returns a `Promise` so try something like the following (untested):\r\n\r\n```javascript\r\nPromise.all([\r\n  sharp(req.file.buffer)\r\n    .resize(800)\r\n    .toFile(`./public/uploads/resize-${req.body.file}`),\r\n  sharp(req.file.buffer)\r\n    .resize(800)\r\n    .grayscale()\r\n    .toFile(`./public/uploads/grayscale-${req.body.file}`)\r\n]).then( ... );\r\n```"
      },
      {
        "user": "hackuun",
        "created_at": "2017-11-30T20:12:37Z",
        "body": "@lovell thank you, this will work."
      }
    ],
    "satisfaction_conditions": [
      "Explanation of how to perform multiple distinct image processing operations in sequence",
      "Clarification on handling asynchronous file operations in Sharp",
      "Demonstration of processing the same source image through multiple independent pipelines",
      "Guidance on maintaining image processing state between operations"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-05 00:01:10"
    }
  },
  {
    "number": 1025,
    "title": ".jpeg({quality:100}) results in larger image file size than the original",
    "created_at": "2017-11-14T21:53:53Z",
    "closed_at": "2017-11-15T15:38:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1025",
    "body": "```\r\nsharp('input.jpg')\r\n  .jpeg({quality:100})\r\n  .toFile();\r\n```\r\n\r\nThe input file is 7.4MB (quality 100). The output file is 18.3 MB. Same thing happens with toBuffer(). Why? How can I output a jpeg with same quality as the original (instead of the default 80) without increasing  file size?",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1025/comments",
    "author": "cheadle",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2017-11-15T11:43:42Z",
        "body": "Hello, `quality` is not the only attribute that can affect JPEG file size. Concepts such as chroma subsampling and \"fancy\" downsampling can also have an impact, especially at higher \"quality\" levels.\r\n\r\nAlthough you've not mentioned platform, my best guess would be that you're using OS X. If so, please see #1006 for a recent example and discussion.\r\n\r\n(It's also worth mentioning that the ability for any software to determine the original \"quality\" setting of a JPEG image depends on it making assumptions about the quantisation tables used at compression time, which may not always be correct.)"
      },
      {
        "user": "cheadle",
        "created_at": "2017-11-15T15:38:28Z",
        "body": "Thanks Lovell. Yes, I am on OS X. Looks like sharp v0.19.0 will fix this issue. Great work on this library. It's a pleasure to use. "
      }
    ],
    "satisfaction_conditions": [
      "Explanation of JPEG compression factors beyond quality settings that affect file size",
      "Platform-specific considerations for JPEG processing",
      "Clarification on preserving original JPEG quantization characteristics"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-05 00:01:26"
    }
  },
  {
    "number": 997,
    "title": "how to get metadata width and height after trim",
    "created_at": "2017-10-18T20:59:25Z",
    "closed_at": "2017-10-19T12:42:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/997",
    "body": "Is there a way to get width and height metadata after trim?\r\n\r\n```\r\nlet transform = sharp()\r\n    .trim()\r\n    .metadata()\r\n    .then(function(metadata) {\r\n        console.log(metadata)\r\n    })\r\n\r\nreturn readableStream\r\n            .pipe(transform)\r\n```\r\n\r\nThis doesn't seem to work\r\n\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/997/comments",
    "author": "jaekunchoi",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2017-10-19T10:51:53Z",
        "body": "Hello, `metadata()` operates on the input but it looks like you need to generate the output.\r\n\r\n`toBuffer()` provides the output dimensions via `info`, so try something like (untested):\r\n\r\n```javascript\r\nconst trimmer = sharp()\r\n  .trim()\r\n  .toBuffer((err, data, info) => {\r\n    console.log(info)\r\n  })\r\nreturn readableStream\r\n  .pipe(trimmer)\r\n```"
      },
      {
        "user": "jaekunchoi",
        "created_at": "2017-10-19T11:31:48Z",
        "body": "thanks. How do I then pass the info to the next `pipe`?"
      },
      {
        "user": "lovell",
        "created_at": "2017-10-19T11:54:53Z",
        "body": "When using Stream-based output, the data piped from a sharp instance is the (compressed) image.\r\n\r\nThe instance will emit an `info` event with the data you need, which can be used to update another variable in an outer scope, something like:\r\n\r\n```javascript\r\n// Define this within a scope that writableStream can access\r\nlet trimmedInfo\r\n\r\nconst trimmer = sharp()\r\n  .trim()\r\n  .on('info', info => {\r\n    trimmedInfo = info\r\n  })\r\n\r\nreadableStream\r\n  .pipe(trimmer)\r\n  .pipe(writableStream);\r\n```"
      },
      {
        "user": "jaekunchoi",
        "created_at": "2017-10-19T11:58:41Z",
        "body": "thanks I mean I want to be able to do something like:\r\n\r\n```\r\nlet trimmedInfo = { width: 0, height: 0 }\r\n\r\nconst trimmer = sharp()\r\n  .trim()\r\n  .on('info', info => {\r\n    trimmedInfo = info\r\n  })\r\n  .extend({ top: trimmedInfo.height, bottom: trimmedInfo.height, left: trimmedInfo.width, right: trimmedInfo.width })\r\n  .background(background)\r\n\r\nreadableStream\r\n  .pipe(trimmer)\r\n```\r\n\r\nIt seems width and height is 0 how can I pass them through as they are not updated?"
      },
      {
        "user": "lovell",
        "created_at": "2017-10-19T12:00:20Z",
        "body": "Thanks for the extra context. You'll need to separate this into two operations with two sharp instances, one for the trim, and a second for the extend."
      },
      {
        "user": "jaekunchoi",
        "created_at": "2017-10-19T12:12:46Z",
        "body": "thanks for the tip.\r\n\r\nI have this operation below but it doesn't seem to update the `padding_width` for example into `extend` parameter. It only seems to persist 0\r\n\r\n```\r\n          let padding_width = 0\r\n          let padding_height = 0\r\n\r\n          const transformer2 = sharp()\r\n            .trim()\r\n            .on('info', trimmed_metadata => {\r\n              console.log(height, trimmed_metadata)\r\n              padding_width = parseInt((width - trimmed_metadata.width) / 2)\r\n              padding_height = (height - trimmed_metadata.height) / 2\r\n\r\n              if(trimmed_metadata.width > width) {\r\n                padding_width = 10\r\n              }\r\n\r\n              if(padding_height >= 50) {\r\n                padding_height = parseInt(padding_height)\r\n              } else {\r\n                padding_height = 50\r\n              }\r\n\r\n              console.log('Trimmed Metadata ', trimmed_metadata)\r\n              console.log('Original Metadata ', original_metadata)\r\n              if(trimmed_metadata.height == original_metadata.height) {\r\n                padding_height = 0\r\n              }\r\n\r\n              console.log(padding_height, padding_width)\r\n\r\n            })\r\n\r\n          const transformer3 = sharp()\r\n            .extend({ top: padding_height, bottom: padding_height, left: padding_width, right: padding_width })\r\n            .background(background)\r\n```"
      },
      {
        "user": "lovell",
        "created_at": "2017-10-19T12:29:58Z",
        "body": "Thank you for even more context. In the above example, `padding_width` has a value of `0` when `extend()` is called on `transformer3`.\r\n\r\nYou'll probably want to defer this assignment, something like:\r\n\r\n```javascript\r\nconst transformer3 = sharp()\r\n  .background(background)\r\n\r\nconst transformer2 = sharp()\r\n  .trim()\r\n  .on('info', trimmed_metadata => {\r\n    ...\r\n    transformer3.extend({ ... })\r\n  })\r\n```\r\n"
      },
      {
        "user": "jaekunchoi",
        "created_at": "2017-10-19T12:36:11Z",
        "body": "thank you it works beautifully!"
      }
    ],
    "satisfaction_conditions": [
      "Access to post-trim image dimensions before subsequent processing steps",
      "Synchronization between metadata availability and pipeline configuration",
      "Chaining multiple image processing operations with shared metadata",
      "Event-driven access to processing metadata"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-05 00:01:33"
    }
  },
  {
    "number": 920,
    "title": "doc about install on alpine on docker",
    "created_at": "2017-08-24T10:10:01Z",
    "closed_at": "2017-08-30T13:11:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/920",
    "body": "all package needed while install: (can delete after install)\r\n> vips-dev fftw-dev python make g++ binutils\r\n\r\nextra package required while running:\r\n> vips\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/920/comments",
    "author": "GongT",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2017-08-24T20:53:19Z",
        "body": "Hello, Python and a C++11 compiler (and related tools) are prerequisites for all platforms, not just Alpine Linux.\r\n\r\n`fftw-dev` is included in the \"latest\" docs, which will be promoted to the \"stable\" docs after the next release."
      }
    ],
    "satisfaction_conditions": [
      "Clarify which packages are temporary build dependencies versus permanent runtime dependencies",
      "Confirm alignment with Alpine Linux package documentation"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-05 00:02:19"
    }
  },
  {
    "number": 808,
    "title": "how to get metadata of output image?",
    "created_at": "2017-05-16T15:21:49Z",
    "closed_at": "2017-05-16T16:57:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/808",
    "body": "the current example only get input image metadata, not output, if the input image's size is 1200x1200, we get  `{width: 1200, height: 1200, ...}` not `{width: 400, height: ?, ...}`\r\n\r\n\r\n```js\r\n      const sharpInstance = sharp(buf).resize(400);\r\n      const resizedBuf = await sharpInstance.toBuffer();\r\n      const metadata = await sharpInstance.metadata();\r\n```",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/808/comments",
    "author": "hbakhtiyor",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2017-05-16T16:52:22Z",
        "body": "Hello, I think you're looking for the metadata of the processed image, which would be:\r\n```javascript\r\nconst metadata = await sharp(resizedBuf).metadata();\r\n```\r\n\r\nFrom v0.17.3+, you could also use:\r\n```javascript\r\nconst { data, info } = await sharpInstance.toBuffer({ resolveWithObject: true });\r\n```"
      },
      {
        "user": "hbakhtiyor",
        "created_at": "2017-05-16T16:57:33Z",
        "body": "thanks"
      },
      {
        "user": "ajhool",
        "created_at": "2018-08-02T02:36:49Z",
        "body": "Can this be achieved without calling toBuffer? It seems like a common use-case that somebody would need to know the metadata of the transformed file."
      },
      {
        "user": "lovell",
        "created_at": "2018-08-02T08:17:33Z",
        "body": "@ajhool Please can you provide a code sample demonstrating how you think this might be improved."
      },
      {
        "user": "kghost",
        "created_at": "2018-12-21T14:10:00Z",
        "body": "@lovell\r\nEg, I want to convert an unknown sized image to 200\\*100 with { fit: inside }. after resize call, the size of processed image is unknown, I need to calculate paddings and call extend to extend the image to 200\\*100.\r\n\r\n\r\nI don't know if it is a bug. After\r\n\r\n```\r\nimg.resize(200,100,{fit:sharp.fit.inside})\r\n``` \r\n\r\nI got an 100*100 image when input is square."
      }
    ],
    "satisfaction_conditions": [
      "Provide metadata of the processed/resized image rather than the original input",
      "Avoid requiring buffer conversion to access output metadata",
      "Support retrieving transformation results for subsequent operations",
      "Handle non-trivial resize operations with fit parameters"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-05 00:02:48"
    }
  },
  {
    "number": 688,
    "title": "Error: extract_area: bad extract area",
    "created_at": "2017-01-19T13:00:31Z",
    "closed_at": "2017-01-19T13:54:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/688",
    "body": "Hello, I'm using 512x512 image. First I resize it then extract and expecting readable stream data but it shows me \"Error: extract_area: bad extract area\" error.\r\nHere's the code;\r\n\r\n```\r\ntest2(x, y, zoom) {\r\n        const width = 500;\r\n        const height = 500;\r\n\r\n        return this.image\r\n            .metadata()\r\n            .then((metadata) => {\r\n                var resizedWidth = metadata.width * zoom;\r\n                var resizedHeight = metadata.height * zoom;\r\n                var left = parseInt(resizedWidth * x);\r\n                var top = parseInt(resizedHeight * y);\r\n                return this.image\r\n                    .resize(resizedWidth, resizedHeight)\r\n                    .extract({left: left, top: top, width: width, height: height})\r\n                    .jpeg()\r\n                    .resize(500);\r\n            });\r\n}\r\n```\r\nThanks.",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/688/comments",
    "author": "erhankilic",
    "comments": [
      {
        "user": "erhankilic",
        "created_at": "2017-01-19T13:06:21Z",
        "body": "Ahhh, I must say, resizedWidth = 1024, resizedHeight = 1024 (because i used zoom = 0,5) and left = 204, right = 204 (because i used x = 0,2 and y = 0,2). Extract area is valid."
      },
      {
        "user": "lovell",
        "created_at": "2017-01-19T13:39:45Z",
        "body": "Hello, I think the problem here is that `.resize(500)` will replace the values passed to `.resize(resizedWidth, resizedHeight)`. Whilst you can chain `extract` with `resize` (with `extract`), you can't chain `resize` with itself.\r\n\r\nIf you need the output image to always be 500 pixels wide, you might be able to extract-then-resize via `.extract(...).resize(500, resizedHeight)`, making sure to alter your `resizedHeight` calculation accordingly."
      },
      {
        "user": "erhankilic",
        "created_at": "2017-01-19T13:54:46Z",
        "body": "Ahhh, thanks,\r\n\r\nI fixed it with this codes.\r\n\r\n```\r\nreturn this.image\r\n            .metadata()\r\n            .then((metadata) => {\r\n                var resizedWidth = metadata.width * zoom;\r\n                var resizedHeight = metadata.height * zoom;\r\n                var left = parseInt(resizedWidth * x);\r\n                var top = parseInt(resizedHeight * y);\r\n                return this.image\r\n                    .jpeg()\r\n                    .resize(resizedWidth, resizedHeight)\r\n                    .toBuffer()\r\n                    .then((data) => {\r\n                        return sharp(data)\r\n                            .extract({left: left, top: top, width: width, height: height})\r\n                            .resize(width, height);\r\n                    })\r\n            });\r\n```"
      },
      {
        "user": "imCorfitz",
        "created_at": "2020-10-18T08:10:44Z",
        "body": "I know this may be an old thread - but I experienced this issue recently, and it was due to the orientation of the image on the server, not being equivalent of the interpreted orientation in the browser. Say I took a picture with my iPhone, then safari and the phone knew how to properly orient the photo, but the server no.\r\n\r\nIn order to fix that, I simply initialised the sharp procedure with `.rotate()`, which took care of that. \r\n\r\n`sharp('image data goes here').rotate().extract({left: left, top: top, width: width, height: height}).resize(width, height);`.\r\n\r\nJust as a note for future visitors, as this issue pops up as the first result when searching in Google."
      },
      {
        "user": "hunzaGit",
        "created_at": "2021-06-24T19:15:59Z",
        "body": "Thanks to @imCorfitz 's comment I solved the problem, for some strange reason Sharp (v0.25.4) interprets some rotated images, in particular a vertical image taken from the smartphone's gallery. If the frontend of the app gets the picture (vertical or horizontal) from the camera everything works fine.\r\n\r\nIn my case, simply comparing the Sharp Metadata with the original dimensions of the photo fixed it.\r\n\r\nAs a simple code example for future visitors:\r\n```\r\nif(dimOriginal.width === metadata.height && dimOriginal.height === metadata.width){\r\n    console.log(\"image is rotated\");\r\n    promiseImg = promiseImg.rotate()\r\n}\r\n```"
      },
      {
        "user": "geiszla",
        "created_at": "2022-05-23T11:39:11Z",
        "body": "This is still an issue until this day. Is there an issue tracking this?\r\n\r\nEdit: my bad, didn't realize the `rotate()` auto-rotates the image. Works perfectly now."
      }
    ],
    "satisfaction_conditions": [
      "Handling of image orientation metadata before extraction",
      "Validation of extraction coordinates against actual image dimensions",
      "Correct sequencing of processing operations",
      "Handling of aspect ratio changes during processing"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-05 00:03:19"
    }
  },
  {
    "number": 625,
    "title": "Mysticism: sharp reacalls old type-related buffer from somewhere?",
    "created_at": "2016-11-15T10:15:57Z",
    "closed_at": "2016-11-15T13:11:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/625",
    "body": "My app uploads jpg/png files (type is restricted in app) to server, source image is saved to certain path (it works).\r\nThen I apply following resize routine:\r\n\r\n ```\r\n//Processing logo\r\n              sharp(logoPath + '/logo_upload')\r\n                .resize(640,120)\r\n                .max()\r\n                .toFormat('jpeg')\r\n                .toFile(logoPath + '/logo.jpg', function(err, info) {\r\n                  if (err) {console.error(err); throw (err)}\r\n                  console.log('120 info: ', info)\r\n                });\r\n```\r\n\r\nThe issue is **very** strange:\r\n1) I upload \"1.jpg\", sharp works - 1.jpg image resized/saved, no problem\r\n2) upload \"2.png\", sharp works as well -  image resized/saved (always under the same name - logo.jpg)\r\n3) upload \"3.jpg\", sharp resizes and saves \"1.jpg\" content (WTF?! from where?) \r\nAfter that no matter what I upload (source file logo_upload changes every time - I double-checked) - sharp output stays the same, \"1.jpg\" ((\r\nVersions: sharp - 0.16.2, node - 4.4.5\r\n\r\nGuys, what I'm doing wrong? What to consider to check in approach?\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/625/comments",
    "author": "greenais",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2016-11-15T10:56:19Z",
        "body": "Hello, it looks like the input filename remains the same so you're probably seeing the effects of libvips' operation cache serving the previous contents to the processing pipeline.\r\n\r\nPerhaps try adding the following before any processing:\r\n\r\n``` javascript\r\nsharp.cache({files: 0});\r\n```\r\n"
      },
      {
        "user": "greenais",
        "created_at": "2016-11-15T13:11:20Z",
        "body": "Wow, you are right - that cache plays tricks.\nTried your suggestion, \n`sharp.cache({files: 0});`\ndoesn't work.\n\n`sharp.cache({items: 0});`\ndoes.\n\nProbably it's a good idea to put this in FAQ.\nThank you for your great job and support.\n"
      }
    ],
    "satisfaction_conditions": [
      "Identify and address the root cause of unexpected cached image processing results",
      "Provide a solution to disable or manage libvips' operation cache effectively",
      "Differentiate between different cache configuration options (files vs items)",
      "Explain cache behavior implications for sequential image processing operations"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-05 00:03:32"
    }
  },
  {
    "number": 585,
    "title": "Resizing image with larger dimension and size",
    "created_at": "2016-09-26T19:01:52Z",
    "closed_at": "2016-10-12T18:54:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/585",
    "body": "Like to have some suggestions regarding the issue i'm facing currently.\n\nWe are allowing image upload and user can choose larger dimension images and large in size.\n\nAs of now  we are giving some fixed dimension to resize. is there a way to figure out  preferred  `height` and `width`  which to be resized based on the image we upload.\n\n```\nex  var dim1 = getPrefferedSize(4000,5500)  // 1024, 1400\nex  var dim2 = getPrefferedSize(2040,1500)  // 904, 720\n```\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/585/comments",
    "author": "tomalex0",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2016-09-26T19:33:56Z",
        "body": "Hello, I'm not quite sure I understand the requirement here. Are the numbers in the comments input dimensions or expected output dimensions? A fully worked example would help me :)\n"
      },
      {
        "user": "tomalex0",
        "created_at": "2016-09-26T20:23:53Z",
        "body": "@lovell  sorry for not to be clear\n\nWhen we upload  a larger image (4000 x 5000), can we give some `percentage` instead of `width and height`, so that it will be  resized into lets say `1024 x 1200`.   Its kind of hard to figure out  to which size it should be resized.\n\nI'm looking  for a solution so that user will still upload larger images but in node layer we will take care of resizing, considering users can upload different size of images\n"
      },
      {
        "user": "lovell",
        "created_at": "2016-10-12T18:31:20Z",
        "body": "If the output dimensions are to be a percentage of input dimensions then something like the following (untested) should work:\n\n``` javascript\nconst percentage = 25;\nsharp(input).metadata()\n  .then(info => {\n    const width = Math.round(info.width * percentage / 100);\n    const height = Math.round(info.height * percentage / 100);\n    return sharp(input).resize(width, height).toBuffer();\n  })\n  .then(output => {\n     ...\n  });\n```\n\n\n---\n\n@tomalex0 Does this help answer you question?\n"
      },
      {
        "user": "tomalex0",
        "created_at": "2016-10-12T18:54:46Z",
        "body": "Sorry for not updating, this does helped us.\nThanks a lot\n"
      },
      {
        "user": "jrock2468",
        "created_at": "2019-12-16T02:43:10Z",
        "body": "> If the output dimensions are to be a percentage of input dimensions then something like the following (untested) should work:\r\n> \r\n> ```js\r\n> const percentage = 25;\r\n> sharp(input).metadata()\r\n>   .then(info => {\r\n>     const width = Math.round(info.width * percentage / 100);\r\n>     const height = Math.round(info.height * percentage / 100);\r\n>     return sharp(input).resize(width, height).toBuffer();\r\n>   })\r\n>   .then(output => {\r\n>      ...\r\n>   });\r\n> ```\r\n\r\nThis would be an awesome example to include in the documentation.  I searched for something similar for a long time."
      },
      {
        "user": "lovell",
        "created_at": "2019-12-16T21:20:43Z",
        "body": "@jrock2468 Commit 703d90e adds a similar example to the docs, thanks for the nudge."
      }
    ],
    "satisfaction_conditions": [
      "Dynamic dimension calculation based on original image proportions",
      "Proportional scaling mechanism",
      "Automatic handling of arbitrary input sizes"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-05 00:03:39"
    }
  },
  {
    "number": 563,
    "title": "Get meta info before transforming?",
    "created_at": "2016-09-06T23:52:52Z",
    "closed_at": "2016-09-07T18:52:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/563",
    "body": "Question...\n\nWhat would be the best way to go about determining a streamed input source's dimensions before transforming to a writable stream (i.e. get the meta info without having to pipe data somewhere)?\n\nI can use withoutEnlargement() to prevent enlarging, but I would rather not generate a new image at all in my use-case. I am getting a read stream from S3 and piping it through Sharp to create thumbnails and then streaming those thumbnails back to S3.\n\nI would prefer not to create several duplicate thumbnails, but I'm just not sure what the best approach is to do so.\n\n**For Example:**\n1. User uploads a 100px image\n2. My image processor creates thumbnails that should have widths [250, 500, 750]\n3. Since I'm using withoutEnlargement(), I get three extra duplicate images that are all the same size instead\n4. Only after they are created do I get the 'info' that tells me they are all the same, at which time I need to remove those duplicates and update my models to point to the original instead.\n\nThanks you for your help!\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/563/comments",
    "author": "elliotfleming",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2016-09-07T09:09:51Z",
        "body": "Hi Elliot, did you see #236 and the other issues/questions that reference it?\n"
      },
      {
        "user": "elliotfleming",
        "created_at": "2016-09-07T18:52:40Z",
        "body": "Yes I think that would do the trick.\n"
      }
    ],
    "satisfaction_conditions": [
      "Ability to retrieve image dimensions/metadata before processing thumbnails",
      "Solution must work with streamed input from object storage",
      "Mechanism to skip unnecessary transformations based on source dimensions",
      "Integration with Sharp's processing pipeline"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-05 00:03:47"
    }
  },
  {
    "number": 528,
    "title": "How to prevent crash on unhandled errors when using streams?",
    "created_at": "2016-07-25T21:06:32Z",
    "closed_at": "2016-07-27T18:43:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/528",
    "body": "Hi,\n\nwhat is the recommended way of preventing a crash of the application if I'm using sharp as follows and the buffer data is undefined or has unsupported image data in it?\nThe 'error' event is not being fired in this case. Do I need to incorporate a try/catch block somehow?\n\n``` js\nvar pipeline = sharp()\n.on('error', err => console.log('error'))\n.pipe(fs.createWriteStream('filename.jpg'));\n\nvar readStream = new stream.PassThrough();\nreadStream.end(someBuffer);\n\nreadStream.pipe(pipeline);\n```\n\nWhen `someBuffer` is undefined, I get this error and the app crashes.\n\n```\n     Error: Input file is missing or of an unsupported image format\n        at Error (native)\n```\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/528/comments",
    "author": "dsine-de",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2016-07-27T15:43:55Z",
        "body": "Piping `undefined` into a `sharp` instance will (currently) result in a zero-length Buffer being processed by libvips. This situation can be improved, but I would expect it to still emit the `error` event. I'll need to take a closer look.\n\n\n---\n\nIf you change your example to call `pipe` on the pipeline rather than the return value of the call to `on` it correctly emits the expected error.\n\n``` diff\n- .on('error', err => console.log('error'))\n- .pipe(fs.createWriteStream('filename.jpg'));\n+ .on('error', err => console.log('error'));\n+ pipeline.pipe(fs.createWriteStream('filename.jpg'));\n```\n\nMy best guess would be that this is something to do with to node's `stream.Duplex` object inheriting from `stream.Readable` but not `stream.Writable` (due to the lack of multiple inheritance).\n"
      },
      {
        "user": "dsine-de",
        "created_at": "2016-07-27T18:43:15Z",
        "body": "Thank you - that helped a lot.\n"
      },
      {
        "user": "papandreou",
        "created_at": "2016-07-28T09:10:49Z",
        "body": "`on` is chainable, but `pipe` returns the target (writable) stream, so the original snippet pipes the readable stream directly into the writable stream.\n"
      },
      {
        "user": "afrozl",
        "created_at": "2016-08-08T21:50:13Z",
        "body": "I'm trying to follow this example, but I am clearly missing something as I am unable to trap the error. \nmy pipeline looks like:\n\n```\n var remoteWriteStream = bucket.file('assets/images/lead/' + file).createWriteStream({metadata: { contentType: 'image/jpeg'}});\n var pipeline = sharp('./public/images/tmp/' + file)\n .resize(1280, 800)\n .crop(sharp.gravity.north)\n .quality(85)\n .on('error', err => console.log('error');\n pipeline.pipe(remoteWriteStream)\n\nsharp error: Error: Input file is missing or \nof an unsupported image format\n\n```\n"
      },
      {
        "user": "lovell",
        "created_at": "2016-08-09T08:56:51Z",
        "body": "@afrozl Perhaps try using an absolute path instead of the relative `./public/images/...` (as paths are relative to the working directory, which isn't always the same as the directory containing your script).\n"
      },
      {
        "user": "afrozl",
        "created_at": "2016-08-09T10:55:50Z",
        "body": "Thanks, looks like I was receiving the error but not handling the unpipe correctly\n"
      }
    ],
    "satisfaction_conditions": [
      "Error handling must prevent application crashes when processing invalid/undefined input",
      "Error handling must work with stream pipelines involving sharp",
      "Solution must explain proper error listener attachment for stream components",
      "Must handle both file existence errors and unsupported format errors",
      "Solution should work for both read and write stream configurations"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-05 00:03:55"
    }
  },
  {
    "number": 396,
    "title": "Unable to put an overlay of smaller size than the resized  image",
    "created_at": "2016-04-05T04:28:21Z",
    "closed_at": "2016-04-15T02:44:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/396",
    "body": "Hi I have a functionality to put a default overlay on top of images of different sizes\nand using sharp for generating those images \n\nThe error comes up saying the overlay image should be of same size of resized image\nIs there a way to do the same\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/396/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2016-04-14T21:01:04Z",
        "body": "Hello, please try with the latest version:\r\n\r\n> \"Improvements to overlayWith: differing sizes/formats, gravity, buffer input.\"\r\n\n\n---\n\n@sbsomya Were you able to try with v0.14.0?\r\n"
      },
      {
        "user": "ghost",
        "created_at": "2016-04-15T02:44:20Z",
        "body": "Yess lovell \nThanks\n"
      },
      {
        "user": "srameshr",
        "created_at": "2019-02-15T19:45:23Z",
        "body": "@lovell I am on 0.21.2 and this issue still exists"
      }
    ],
    "satisfaction_conditions": [
      "Support overlaying images of different sizes without requiring exact dimension matching",
      "Provide positioning control for overlay placement",
      "Maintain overlay image proportions/quality"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-05 00:04:25"
    }
  },
  {
    "number": 181,
    "title": "Set image resolution (dpi)",
    "created_at": "2015-03-19T10:23:24Z",
    "closed_at": "2015-03-19T11:01:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/181",
    "body": "I think that my search skills are failing me...\n\nIs it possible to manually set the desired dpi of an image?\n\nI have a set of big TIFFs at 300 dpi and I would like to convert them into 300 dpi and 72 dpi JPEGs, is it possible?\n\nThanks!\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/181/comments",
    "author": "Couto",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2015-03-19T10:53:42Z",
        "body": "As far as I know, and if I understand your question correctly, the concept of DPI doesn't mean anything in the land of JPEG.\n\nYou should be able to achieve the equivalent of a 300DPI to 72DPI conversion by resizing to smaller dimensions, e.g. resize a source 1000x1000 pixel square image to a `1000 * 72 / 300` = 240x240 pixel image.\n"
      },
      {
        "user": "Couto",
        "created_at": "2015-03-19T11:01:26Z",
        "body": "Oh boy... I need to review my concepts of image formats and so on (it's not my area of expertise), as far as I can tell, you're absolutely right! :)\n\nThanks for the explanation! :+1: \n"
      }
    ],
    "satisfaction_conditions": [
      "Explains the relationship between DPI and pixel dimensions in raster image formats",
      "Provides a method to achieve equivalent visual resolution across different output formats"
    ],
    "_classification": {
      "category": "Does not need build environment",
      "timestamp": "2025-04-05 00:04:48"
    }
  }
]