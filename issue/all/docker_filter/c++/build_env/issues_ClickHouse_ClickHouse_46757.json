{
  "number": 46757,
  "title": "Join in materialized view is 60x slower than in select statement.",
  "created_at": "2023-02-23T02:52:11Z",
  "closed_at": "2023-02-23T04:27:49Z",
  "labels": [
    "question",
    "comp-joins",
    "question-answered"
  ],
  "url": "https://github.com/ClickHouse/ClickHouse/issues/46757",
  "body": "**Describe the situation**\r\n\r\nSeems materialized view with join not working with **FillRightFirst** plan, please loot at the script blew.\r\n\r\nThank you for your time. \r\n\r\nSelect statement statistics: \r\n`0 rows in set. Elapsed: 0.021 sec. Processed 262.02 thousand rows, 2.10 MB (12.69 million rows/s., 101.50 MB/s.)`\r\n\r\nMaterialized view statistics(a insert statement to source table):\r\n\r\n`1 row in set. Elapsed: 1.422 sec.`\r\n\r\n**How to reproduce**\r\n1. Create null table t_null;\r\n2. Create mergetree table t_numbers with 100000000 rows;\r\n3. Execute Select Statement 1 as blow code;\r\n4. Create materialized view with the same query;\r\n5. Insert only 1 record into t_null to trigger materialized view;\r\n\r\n\r\n* Which ClickHouse server version to use\r\nClickHouse client version 22.8.13.20 (official build).\r\nConnecting to localhost:9000 as user default.\r\nConnected to ClickHouse server version 22.8.13 revision 54460.\r\n\r\n* Non-default settings, if any\r\nNone\r\n\r\n* `CREATE TABLE` statements for all tables involved\r\n\r\n`CREATE TABLE t_numbers\r\n(\r\n    `A` UInt64,\r\n    `B` String\r\n)\r\nENGINE = MergeTree\r\nORDER BY A;`\r\n\r\n `CREATE TABLE t_null\r\n(\r\n    `A` UInt64,\r\n    `B` String\r\n)\r\nENGINE = Null;`\r\n\r\n`CREATE MATERIALIZED VIEW mv_null\r\nENGINE = MergeTree\r\nORDER BY A AS\r\nSELECT\r\n    null_outer.A,\r\n    concat(null_outer.B, subquery.B)\r\nFROM t_null AS null_outer\r\nLEFT JOIN\r\n(\r\n    SELECT\r\n        num.A,\r\n        'inner' AS B\r\n    FROM t_numbers AS num\r\n    INNER JOIN t_null AS null_inner ON num.A = null_inner.A\r\n) AS subquery ON null_outer.A = subquery.A;`\r\n\r\n* Sample data for all these tables\r\n\r\n`INSERT INTO t_numbers SELECT\r\n    number,\r\n    toString(cityHash64(number))\r\nFROM numbers(100000000)`\r\n\r\n* Queries to run that lead to slow performance\r\n\r\nQuery 1, which runs very fast!\r\n\r\n`SELECT\r\n    null_outer.A,\r\n    concat(null_outer.B, subquery.B)\r\nFROM t_null AS null_outer\r\nLEFT JOIN\r\n(\r\n    SELECT\r\n        num.A,\r\n        'inner' AS B\r\n    FROM t_numbers AS num\r\n    INNER JOIN t_null AS null_inner ON num.A = null_inner.A\r\n) AS subquery ON null_outer.A = subquery.A;\r\n`\r\nQuery 2, which runs very slow!\r\n\r\n`INSERT INTO t_null VALUES(1, 'insert');`\r\n \r\n\r\n**Expected performance**\r\nStatement in materialized view runs as fast as select statement, instead of 67x slow.\r\n\r\n**Additional context**\r\n\r\nIf we check the plan, clickhouse choose FillRightFirst for both inner and outer join, may be materialized view is not using the same plan?\r\n\r\nEXPLAIN\r\nSELECT\r\n    null_outer.A,\r\n    concat(null_outer.B, subquery.B)\r\nFROM t_null AS null_outer\r\nLEFT JOIN\r\n(\r\n    SELECT\r\n        num.A,\r\n        'inner' AS B\r\n    FROM t_numbers AS num\r\n    INNER JOIN t_null AS null_inner ON num.A = null_inner.A\r\n) AS subquery ON null_outer.A = subquery.A\r\n\r\nQuery id: 0e4c95b7-204e-4922-8d01-414f6ad86758\r\n\r\n\u250c\u2500explain\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 Expression ((Projection + Before ORDER BY))                                                      \u2502\r\n\u2502   Join (JOIN **FillRightFirst**)                                                                     \u2502\r\n\u2502     Expression (Before JOIN)                                                                     \u2502\r\n\u2502       ReadFromStorage (Null)                                                                     \u2502\r\n\u2502     Expression ((Joined actions + (Rename joined columns + (Projection + Before ORDER BY))))     \u2502\r\n\u2502       Join (JOIN **FillRightFirst**)                                                                 \u2502\r\n\u2502         Expression (Before JOIN)                                                                 \u2502\r\n\u2502           ReadFromMergeTree (rtd.t_numbers)                                                      \u2502\r\n\u2502         Expression ((Joined actions + (Rename joined columns + (Projection + Before ORDER BY)))) \u2502\r\n\u2502           ReadFromStorage (Null)                                                                 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n",
  "comments_url": "https://api.github.com/repos/ClickHouse/ClickHouse/issues/46757/comments",
  "author": "qiang5714",
  "comments": [
    {
      "user": "den-crane",
      "created_at": "2023-02-23T04:22:34Z",
      "body": "You compare incorrectly.\r\n\r\nt_null has ENGINE = Null, so it's empty in the SELECT and not empty in the MATVIEW!!!\r\n\r\n```sql\r\nCREATE TABLE t_Memory ( A UInt64,B String ) ENGINE = Memory;\r\nINSERT INTO t_Memory VALUES(1, 'insert');\r\n\r\nSELECT null_outer.A, concat(null_outer.B, subquery.B) \r\n  FROM t_Memory AS null_outer LEFT JOIN \r\n ( SELECT num.A, 'inner' AS B FROM t_numbers AS num \r\n   INNER JOIN t_Memory AS null_inner ON num.A = null_inner.A ) AS subquery ON null_outer.A = subquery.A; \r\n\r\n1 row in set. Elapsed: 0.406 sec. Processed 100.00 million rows, 800.00 MB (246.21 million rows/s., 1.97 GB/s.)\r\n```"
    },
    {
      "user": "den-crane",
      "created_at": "2023-02-23T04:27:14Z",
      "body": "You can use this \r\n\r\n```sql\r\nCREATE MATERIALIZED VIEW mv_null ENGINE = MergeTree ORDER BY A \r\nAS SELECT null_outer.A, concat(null_outer.B, subquery.B) \r\n   FROM t_null AS null_outer \r\n   LEFT JOIN ( \r\n               SELECT A, 'inner' AS B FROM t_numbers where A in (select A from t_null)    \r\n             ) AS subquery ON null_outer.A = subquery.A;\r\n\r\nINSERT INTO t_null VALUES(1, 'insert');\r\n\r\n1 row in set. Elapsed: 0.021 sec.\r\n\r\nINSERT INTO t_null VALUES(1, 'insert');\r\n\r\n1 row in set. Elapsed: 0.014 sec.\r\n```"
    },
    {
      "user": "qiang5714",
      "created_at": "2023-02-23T06:37:49Z",
      "body": "@den-crane \r\nThank you for you time. I understand that t_null is not null in materialized view, I did this on purpose because I want to find a way to trigger a materialized view from another table except the left most one in the Join.\r\n\r\nSuppose we have two tables, t_left and t_right, a materialized view will not trigger by t_right if we use \r\n\r\n`t_left join t_right on t_left.id = t_right.id`\r\n\r\nbut, if my program can collect both t_left.id and t_right.id,  and we can insert all id into a t_null to do this, as we change the view to \r\n\r\n`t_null left join (t_left join t_right on t_left.id = t_right.id) as t_inner on t_null.id = t_inner.id `\r\n\r\nand do this:\r\n\r\n`insert into t_null values(t_left.id)(t_right.id);`\r\n\r\nthen all data changed in t_left and t_right will trigger the materialized view\u3002 And, If t_left and t_right is very large, we should use t_null as a filter, put it in the right side, that should make t_left join t_right very fast\uff0c that's what I want.  just like what your advice did:\r\n\r\n`t_null left join (t_left join t_right on t_left.id = t_right.id and **t_right.id in (select trigger.id from t_null trigger)**) as t_inner on t_null.id = t_inner.id `\r\n\r\nMy question is, Why my query is slow than yours, or **why IN operator is faster than join**?\r\n\r\nThank you."
    },
    {
      "user": "den-crane",
      "created_at": "2023-02-23T13:36:24Z",
      "body": "Clickhouse inner join has an optimization to join with empty tables:\r\n\r\n```sql\r\nCREATE TABLE left ( A UInt64,B String ) ENGINE = MergeTree ORDER BY A as \r\nSELECT number, toString(cityHash64(number)) FROM numbers(100000000);\r\n\r\nCREATE TABLE right ( A UInt64, B String ) ENGINE = MergeTree ORDER BY A;\r\n\r\nselect count() from left inner join right using A;\r\n\r\n1 row in set. Elapsed: 0.010 sec. Processed 261.64 thousand rows, 2.09 MB (27.24 million rows/s., 217.93 MB/s.)\r\n\r\n\r\ninsert  into right SELECT number, toString(cityHash64(number)) FROM numbers(1);\r\n\r\nselect count() from left inner join right using A;\r\n1 row in set. Elapsed: 0.367 sec. Processed 100.00 million rows, 800.00 MB (272.51 million rows/s., 2.18 GB/s.)\r\n```\r\nwhat's why SELECT with join with engine Null is fast.\r\n\r\n---------------------\r\nClickhouse `JOIN` does not use indexes, Clickhouse `IN` uses indexes.\r\n\r\n```sql\r\nselect count() from left inner join right using A;\r\n1 row in set. Elapsed: 0.367 sec. Processed 100.00 million rows, 800.00 MB (272.56 million rows/s., 2.18 GB/s.)\r\n\r\nselect count() from left inner join right using B;\r\n1 row in set. Elapsed: 1.030 sec. Processed 100.00 million rows, 2.84 GB (97.12 million rows/s., 2.76 GB/s.)\r\n\r\nselect count() from left where A in (select A from right);\r\n1 row in set. Elapsed: 0.010 sec. Processed 8.19 thousand rows, 65.54 KB (856.87 thousand rows/s., 6.85 MB/s.)\r\n\r\nselect count() from left where B in (select B from right);\r\n1 row in set. Elapsed: 0.932 sec. Processed 100.00 million rows, 2.84 GB (107.29 million rows/s., 3.05 GB/s.)\r\n```\r\n`where A in (` is fast because it uses primary index of the `left`\r\n"
    }
  ],
  "git_commit_info": {
    "sha": "045fd6f55db37059c97c0c276e8914b096e1f6bb",
    "date": "2017-02-07T22:40:08Z",
    "message": "fix build without readline",
    "author": "proller"
  },
  "repository_info": {},
  "llm_calls_before_build": 0,
  "dockerfile_attempt_1": 1,
  "dockerfile_attempt_1_failed": true,
  "dockerfile_build_success": true,
  "llm_calls_total": 10,
  "dockerfile": "FROM ubuntu:20.04\n\n# Avoid interactive prompts during package installation\nENV DEBIAN_FRONTEND=noninteractive\n\n# Install dependencies for ClickHouse\nRUN apt-get update && apt-get install -y \\\n    apt-transport-https \\\n    ca-certificates \\\n    dirmngr \\\n    gnupg \\\n    wget \\\n    sudo \\\n    git \\\n    cmake \\\n    build-essential \\\n    gcc-9 \\\n    g++-9 \\\n    libicu-dev \\\n    libreadline-dev \\\n    libmysqlclient-dev \\\n    unixodbc-dev \\\n    libltdl-dev \\\n    libssl-dev \\\n    libgoogle-perftools-dev \\\n    libbz2-dev \\\n    libzstd-dev \\\n    libboost-dev \\\n    libboost-system-dev \\\n    libboost-filesystem-dev \\\n    libboost-thread-dev \\\n    libboost-program-options-dev \\\n    zlib1g-dev \\\n    liblz4-dev \\\n    libdouble-conversion-dev \\\n    libzookeeper-mt-dev \\\n    libsparsehash-dev \\\n    librdkafka-dev \\\n    libcapnp-dev \\\n    libpoco-dev \\\n    libunwind-dev \\\n    libxml2-dev \\\n    libpcre3-dev \\\n    ninja-build \\\n    python3 \\\n    python3-pip \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Set gcc-9 as default compiler\nRUN update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 90 \\\n    && update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-9 90 \\\n    && update-alternatives --set gcc /usr/bin/gcc-9 \\\n    && update-alternatives --set g++ /usr/bin/g++-9\n\n# Create build directory\nWORKDIR /build\n\n# Clone ClickHouse repository and checkout specific commit\nRUN git clone https://github.com/ClickHouse/ClickHouse.git \\\n    && cd ClickHouse \\\n    && git checkout 045fd6f55db37059c97c0c276e8914b096e1f6bb\n\n# Create build directory\nWORKDIR /build/ClickHouse/build\n\n# Configure cmake for the build\nRUN cmake .. -DCMAKE_BUILD_TYPE=Release\n\n# Build ClickHouse (with retry mechanism to handle potential build failures)\nRUN for i in 1 2 3; do \\\n        cmake --build . -- -j$(nproc) && break || \\\n        echo \"Build attempt $i failed, retrying with less parallelism...\" && \\\n        cmake --build . -- -j2 && break || \\\n        echo \"Build attempt $i failed, retrying with single thread...\" && \\\n        cmake --build . -- -j1 && break || \\\n        echo \"Build attempt $i failed, will retry...\" && \\\n        sleep 5; \\\n    done\n\n# Add the build directory to PATH\nENV PATH=\"/build/ClickHouse/build/programs:${PATH}\"\n\n# Create directories for ClickHouse data and configuration\nRUN mkdir -p /etc/clickhouse-server/config.d \\\n    && mkdir -p /etc/clickhouse-server/users.d \\\n    && mkdir -p /var/lib/clickhouse \\\n    && mkdir -p /var/lib/clickhouse/tmp\n\n# Create a basic configuration file for ClickHouse server\nRUN echo '<clickhouse>\\n\\\n    <logger>\\n\\\n        <level>trace</level>\\n\\\n        <console>true</console>\\n\\\n    </logger>\\n\\\n    <listen_host>0.0.0.0</listen_host>\\n\\\n    <path>/var/lib/clickhouse/</path>\\n\\\n    <tmp_path>/var/lib/clickhouse/tmp/</tmp_path>\\n\\\n</clickhouse>' > /etc/clickhouse-server/config.xml\n\n# Create a users.xml file with default settings\nRUN echo '<clickhouse>\\n\\\n    <users>\\n\\\n        <default>\\n\\\n            <password></password>\\n\\\n            <networks>\\n\\\n                <ip>::/0</ip>\\n\\\n            </networks>\\n\\\n        </default>\\n\\\n    </users>\\n\\\n</clickhouse>' > /etc/clickhouse-server/users.xml\n\n# Create test script to reproduce and validate the issue\nRUN echo '#!/bin/bash\\n\\\necho \"Starting ClickHouse server...\"\\n\\\nclickhouse-server --config=/etc/clickhouse-server/config.xml &\\n\\\nsleep 5\\n\\\n\\n\\\necho \"Creating test tables...\"\\n\\\nclickhouse-client --query=\"CREATE TABLE t_numbers (A UInt64, B String) ENGINE = MergeTree ORDER BY A\"\\n\\\nclickhouse-client --query=\"CREATE TABLE t_null (A UInt64, B String) ENGINE = Null\"\\n\\\n\\n\\\necho \"Inserting data into t_numbers...\"\\n\\\nclickhouse-client --query=\"INSERT INTO t_numbers SELECT number, toString(number) FROM numbers(100000000)\"\\n\\\n\\n\\\necho \"Testing SELECT statement...\"\\n\\\nclickhouse-client --query=\"EXPLAIN SELECT null_outer.A, concat(null_outer.B, subquery.B) FROM t_null AS null_outer LEFT JOIN (SELECT num.A, '\"'\"'inner'\"'\"' AS B FROM t_numbers AS num INNER JOIN t_null AS null_inner ON num.A = null_inner.A) AS subquery ON null_outer.A = subquery.A\"\\n\\\nclickhouse-client --query=\"SELECT null_outer.A, concat(null_outer.B, subquery.B) FROM t_null AS null_outer LEFT JOIN (SELECT num.A, '\"'\"'inner'\"'\"' AS B FROM t_numbers AS num INNER JOIN t_null AS null_inner ON num.A = null_inner.A) AS subquery ON null_outer.A = subquery.A\"\\n\\\n\\n\\\necho \"Creating materialized view...\"\\n\\\nclickhouse-client --query=\"CREATE MATERIALIZED VIEW mv_null ENGINE = MergeTree ORDER BY A AS SELECT null_outer.A, concat(null_outer.B, subquery.B) FROM t_null AS null_outer LEFT JOIN (SELECT num.A, '\"'\"'inner'\"'\"' AS B FROM t_numbers AS num INNER JOIN t_null AS null_inner ON num.A = null_inner.A) AS subquery ON null_outer.A = subquery.A\"\\n\\\n\\n\\\necho \"Testing materialized view performance...\"\\n\\\nclickhouse-client --query=\"INSERT INTO t_null VALUES (1, '\"'\"'test'\"'\"')\"\\n\\\n\\n\\\necho \"Test completed.\"\\n\\\n' > /test-issue-46757.sh\n\n# Make the test script executable\nRUN chmod +x /test-issue-46757.sh\n\n# Set working directory\nWORKDIR /\n\n# Default command\nCMD [\"echo\", \"ClickHouse environment prepared for testing issue #46757. Run /test-issue-46757.sh to test the join performance in materialized views.\"]",
  "successful_candidate_index": 1,
  "successful_candidate_attempt": 1,
  "successful_candidate_improvement_attempt": 0,
  "satisfaction_conditions": [
    "Query performance with empty tables matches expected baseline",
    "Efficient filtering of large joined datasets",
    "Materialized view correctly triggers on relevant table changes"
  ]
}