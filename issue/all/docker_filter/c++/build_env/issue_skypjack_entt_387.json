{
  "number": 387,
  "title": "In which cases would sorting a full-owning group cause an assertion to fail?",
  "created_at": "2020-01-10T17:52:34Z",
  "closed_at": "2020-01-11T00:58:07Z",
  "labels": [
    "question"
  ],
  "url": "https://github.com/skypjack/entt/issues/387",
  "body": "Apologies for so many tickets \ud83d\ude43 \r\n\r\nI have a full-owning group of components called `global_transform_group` that holds a three-component tuple of components. I also have a nested group called `global_render_group` that has the same three components, along with an additional render-related component.\r\n\r\nWith any more than 1 entity belonging to those groups (0 works fine, too), I either get an assertion failure when calling `global_transform_group.sort()` or `false` when calling `global_transform_group.sortable()`.\r\n\r\nThe documentation seems to contradict itself:\r\n\r\n> Sorting owned components is no longer allowed once the group has been created. However, full-owning groups can be sorted by means of their sort member functions. Sorting a full-owning group affects all its instances.\r\n\r\nWhich, at least to me, starts by saying you cannot sort, but then goes on to say that full-owning groups _can_ sort, which leaves me a bit confused \ud83d\ude05 \r\n\r\nSo, in which circumstances can I sort a full-owning group? Should I eliminate the nested group and just use a single full-owning group with all four components?\r\n\r\nIt's worth mentioning I'm using a custom sort function.",
  "comments_url": "https://api.github.com/repos/skypjack/entt/issues/387/comments",
  "author": "Qix-",
  "comments": [
    {
      "user": "skypjack",
      "created_at": "2020-01-10T21:21:32Z",
      "body": "When you use groups, you can sort only the most restrictive ones, that is the one with the higher number of rules.\r\nFrom your example:\r\n```\r\nauto global_transform_group = registry.group<A, B, C>();\r\nauto global_render_group = registry.group<A, B, C, D>();\r\n```\r\nThis is allowed, they are nested groups. In this case, `global_render_group` is more restrictive because it sets more constraints on the entities that want to enter it. Therefore, it will be fully contained within `global_transform_group` by construction.\r\nNow, consider what would happen if you sorted `global_transform_group`. Since it's _larger_ that `global_render_group`, the elements contained by the latter could be moved around and exit it during the sort. This isn't an option of course.\r\nWhat happens if you sort `global_render_group`? Since it's fully contained within `global_transform_group`, it doesn't matter how it's elements are arranged, they cannot exit the _outer_ group in any case.\r\nTherefore, it's allowed to sort `global_render_group` and this is the reason for which `global_render_group.sortable()` returns true while `global_transform_group` isn't sortable.\r\n\r\n---\r\n\r\nIf you want to sort both, you can't make all them full-owning group.\r\nThere doesn't exist an architecture that allows you to sort stuff and reaches the maximum performance at the same time. Long story short, this is because we need to arrange things in a specific way to get the best from the data and you cannot shuffle them for your purposes.\r\nIf sorting is more important than iterating 1M entities in 0.005ms rather 0.006ms (I guess so), you can define the two groups as partially owning ones in such a way that they don't overlap on owned components. In this case, both will be sortable."
    },
    {
      "user": "Qix-",
      "created_at": "2020-01-11T00:58:07Z",
      "body": "Right okay, that makes much more sense :D Thank you~!"
    }
  ],
  "satisfaction_conditions": [
    "Clarify the relationship between group restrictiveness and sorting capability",
    "Define criteria for when a full-owning group can be sorted",
    "Explain trade-offs between group structure and sorting needs"
  ],
  "_classification": {
    "category": "Can be dockerized without any issue",
    "timestamp": "2025-04-04 23:58:03"
  },
  "git_commit_info": {
    "sha": "210eebc0dc967f65d48a75f10ff05e766f20c638",
    "date": "2020-01-09T21:51:35Z",
    "message": "sparse_set/storage: ::reset is now ::clear",
    "author": "Michele Caini"
  },
  "repository_info": {
    "structure_summary": ".\n./.git\n./.git/branches\n./.git/description\n./.git/hooks\n./.git/hooks/applypatch-msg.sample\n./.git/hooks/commit-msg.sample\n./.git/hooks/post-update.sample\n./.git/hooks/pre-applypatch.sample\n./.git/hooks/pre-commit.sample\n./.git/hooks/pre-merge-commit.sample\n./.git/hooks/pre-push.sample\n./.git/hooks/pre-receive.sample\n./.git/hooks/push-to-checkout.sample\n./.git/hooks/update.sample\n./.git/hooks/fsmonitor-watchman.sample\n./.git/hooks/pre-rebase.sample\n./.git/hooks/prepare-commit-msg.sample\n./.git/hooks/sendemail-validate.sample\n./.git/info\n./.git/info/exclude\n./.git/config\n./.git/objects\n./.git/objects/pack\n./.git/objects/pack/pack-0a5d8f43c7a0fc3f6991b53e3b10b7976982b670.pack\n./.git/objects/pack/pack-0a5d8f43c7a0fc3f6991b53e3b10b7976982b670.rev\n./.git/objects/pack/pack-0a5d8f43c7a0fc3f6991b53e3b10b7976982b670.idx\n./.git/objects/info\n./.git/HEAD\n./.git/refs\n./.git/refs/heads\n./.git/refs/heads/master\n./.git/refs/tags\n./.git/refs/remotes\n./.git/refs/remotes/origin\n./.git/refs/remotes/origin/HEAD\n./.git/packed-refs\n./.git/logs\n./.git/logs/refs\n./.git/logs/refs/remotes\n./.git/logs/refs/remotes/origin\n./.git/logs/refs/remotes/origin/HEAD\n./.git/logs/refs/heads\n./.git/logs/refs/heads/master\n./.git/logs/HEAD\n./.git/index\n./.github\n./.github/workflows\n./.github/workflows/build.yml\n./.github/workflows/coverage.yml\n./.github/FUNDING.yml\n./build\n./build/.gitignore\n./cmake\n./cmake/in\n./cmake/in/EnTTBuildConfig.cmake.in\n./cmake/in/EnTTConfig.cmake.in\n./cmake/in/cereal.in\n./cmake/in/cr.in\n./cmake/in/googletest.in\n./cmake/in/version.h.in\n./conan\n./conan/build.py\n./conan/ci\n./conan/ci/build.sh\n./conan/ci/install.sh\n./conan/test_package\n./conan/test_package/CMakeLists.txt\n./conan/test_package/conanfile.py\n./conan/test_package/test_package.cpp\n./conanfile.py\n./docs\n./docs/md\n./docs/md/core.md\n./docs/md/entity.md\n./docs/md/faq.md\n./docs/md/lib.md\n./docs/md/links.md\n./docs/md/locator.md\n./docs/md/meta.md\n./docs/md/process.md\n./docs/md/resource.md\n./docs/md/signal.md\n./docs/CMakeLists.txt\n./docs/dox\n./docs/dox/extra.dox\n./docs/doxy.in\n./scripts\n./scripts/amalgamate.py\n./scripts/config.json\n./scripts/update_homebrew.sh\n./single_include\n./single_include/entt\n./single_include/entt/entt.hpp\n./src\n./src/entt\n./src/entt/config\n./src/entt/config/config.h\n./src/entt/config/version.h\n./src/entt/core\n./src/entt/core/algorithm.hpp\n./src/entt/core/attribute.h\n./src/entt/core/family.hpp\n./src/entt/core/hashed_string.hpp\n./src/entt/core/ident.hpp\n./src/entt/core/monostate.hpp\n./src/entt/core/type_info.hpp\n./src/entt/core/type_traits.hpp\n./src/entt/core/utility.hpp\n./src/entt/entity\n./src/entt/entity/actor.hpp\n./src/entt/entity/entity.hpp\n./src/entt/entity/fwd.hpp\n./src/entt/entity/group.hpp\n./src/entt/entity/helper.hpp\n./src/entt/entity/observer.hpp\n./src/entt/entity/registry.hpp\n./src/entt/entity/runtime_view.hpp\n./src/entt/entity/snapshot.hpp\n./src/entt/entity/sparse_set.hpp\n./src/entt/entity/storage.hpp\n./src/entt/entity/utility.hpp\n./src/entt/entity/view.hpp\n./src/entt/locator\n./src/entt/locator/locator.hpp\n./src/entt/meta\n./src/entt/meta/factory.hpp\n./src/entt/meta/meta.hpp\n./src/entt/meta/policy.hpp\n./src/entt/process\n./src/entt/process/process.hpp\n./src/entt/process/scheduler.hpp\n./src/entt/resource\n./src/entt/resource/cache.hpp\n./src/entt/resource/fwd.hpp\n./src/entt/resource/handle.hpp\n./src/entt/resource/loader.hpp\n./src/entt/signal\n./src/entt/signal/delegate.hpp\n./src/entt/signal/dispatcher.hpp\n./src/entt/signal/emitter.hpp\n./src/entt/signal/fwd.hpp\n./src/entt/signal/sigh.hpp\n./src/entt/entt.hpp\n./src/entt/fwd.hpp\n./test\n./test/benchmark\n./test/benchmark/benchmark.cpp\n./test/entt\n./test/entt/core\n./test/entt/core/algorithm.cpp\n./test/entt/core/family.cpp\n./test/entt/core/hashed_string.cpp\n./test/entt/core/ident.cpp\n./test/entt/core/monostate.cpp\n./test/entt/core/type_info.cpp\n./test/entt/core/type_traits.cpp\n./test/entt/core/utility.cpp\n./test/entt/entity\n./test/entt/entity/actor.cpp\n./test/entt/entity/entity.cpp\n./test/entt/entity/group.cpp\n./test/entt/entity/helper.cpp\n./test/entt/entity/observer.cpp\n./test/entt/entity/registry.cpp\n./test/entt/entity/runtime_view.cpp\n./test/entt/entity/snapshot.cpp\n./test/entt/entity/sparse_set.cpp\n./test/entt/entity/storage.cpp\n./test/entt/entity/view.cpp\n./test/entt/locator\n./test/entt/locator/locator.cpp\n./test/entt/process\n./test/entt/process/process.cpp\n./test/entt/process/scheduler.cpp\n./test/entt/resource\n./test/entt/resource/resource.cpp\n./test/entt/signal\n./test/entt/signal/delegate.cpp\n./test/entt/signal/dispatcher.cpp\n./test/entt/signal/emitter.cpp\n./test/entt/signal/sigh.cpp\n./test/entt/meta\n./test/entt/meta/meta.cpp\n./test/snapshot\n./test/snapshot/snapshot.cpp\n./test/CMakeLists.txt\n./test/lib\n./test/lib/dispatcher\n./test/lib/dispatcher/lib.cpp\n./test/lib/dispatcher/main.cpp\n./test/lib/dispatcher/types.h\n./test/lib/dispatcher_plugin\n./test/lib/dispatcher_plugin/main.cpp\n./test/lib/dispatcher_plugin/plugin.cpp\n./test/lib/dispatcher_plugin/proxy.h\n./test/lib/dispatcher_plugin/types.h\n./test/lib/dispatcher_plugin_std\n./test/lib/dispatcher_plugin_std/main.cpp\n./test/lib/dispatcher_plugin_std/plugin.cpp\n./test/lib/dispatcher_plugin_std/proxy.h\n./test/lib/dispatcher_plugin_std/types.h\n./test/lib/dispatcher_std\n./test/lib/dispatcher_std/lib.cpp\n./test/lib/dispatcher_std/main.cpp\n./test/lib/dispatcher_std/types.h\n./test/lib/emitter\n./test/lib/emitter/lib.cpp\n./test/lib/emitter/main.cpp\n./test/lib/emitter/types.h\n./test/lib/emitter_plugin\n./test/lib/emitter_plugin/main.cpp\n./test/lib/emitter_plugin/plugin.cpp\n./test/lib/emitter_plugin/proxy.h\n./test/lib/emitter_plugin/types.h\n./test/lib/emitter_plugin_std\n./test/lib/emitter_plugin_std/main.cpp\n./test/lib/emitter_plugin_std/plugin.cpp\n./test/lib/emitter_plugin_std/proxy.h\n./test/lib/emitter_plugin_std/types.h\n./test/lib/emitter_std\n./test/lib/emitter_std/lib.cpp\n./test/lib/emitter_std/main.cpp\n./test/lib/emitter_std/types.h\n./test/lib/meta\n./test/lib/meta/lib.cpp\n./test/lib/meta/main.cpp\n./test/lib/meta/types.h\n./test/lib/meta_plugin\n./test/lib/meta_plugin/main.cpp\n./test/lib/meta_plugin/plugin.cpp\n./test/lib/meta_plugin/types.h\n./test/lib/meta_plugin_std\n./test/lib/meta_plugin_std/main.cpp\n./test/lib/meta_plugin_std/plugin.cpp\n./test/lib/meta_plugin_std/types.h\n./test/lib/meta_std\n./test/lib/meta_std/lib.cpp\n./test/lib/meta_std/main.cpp\n./test/lib/meta_std/types.h\n./test/lib/registry\n./test/lib/registry/lib.cpp\n./test/lib/registry/main.cpp\n./test/lib/registry/types.h\n./test/lib/registry_plugin\n./test/lib/registry_plugin/main.cpp\n./test/lib/registry_plugin/plugin.cpp\n./test/lib/registry_plugin/proxy.h\n./test/lib/registry_plugin/types.h\n./test/lib/registry_plugin_std\n./test/lib/registry_plugin_std/main.cpp\n./test/lib/registry_plugin_std/plugin.cpp\n./test/lib/registry_plugin_std/proxy.h\n./test/lib/registry_plugin_std/types.h\n./test/lib/registry_std\n./test/lib/registry_std/lib.cpp\n./test/lib/registry_std/main.cpp\n./test/lib/registry_std/types.h\n./test/odr.cpp\n./.gitignore\n./AUTHORS\n./CMakeLists.txt\n./CONTRIBUTING.md\n./LICENSE\n./README.md\n./TODO\n./deps\n./deps/.gitignore\n",
    "readme": "\n--- ./README.md ---\n![EnTT: Gaming meets modern C++](https://user-images.githubusercontent.com/1812216/42513718-ee6e98d0-8457-11e8-9baf-8d83f61a3097.png)\n\n<!--\n@cond TURN_OFF_DOXYGEN\n-->\n[![GitHub version](https://badge.fury.io/gh/skypjack%2Fentt.svg)](https://github.com/skypjack/entt/releases)\n[![Build Status](https://github.com/skypjack/entt/workflows/build/badge.svg)](https://github.com/skypjack/entt/actions)\n[![Coverage](https://codecov.io/gh/skypjack/entt/branch/master/graph/badge.svg)](https://codecov.io/gh/skypjack/entt)\n[![Try online](https://img.shields.io/badge/try-online-brightgreen)](https://godbolt.org/z/v8txVr)\n[![Gitter chat](https://badges.gitter.im/skypjack/entt.png)](https://gitter.im/skypjack/entt)\n[![Donate](https://img.shields.io/badge/donate-paypal-blue.svg)](https://www.paypal.me/skypjack)\n[![Patreon](https://img.shields.io/badge/become-patron-red.svg)](https://www.patreon.com/bePatron?c=1772573)\n\n`EnTT` is a header-only, tiny and easy to use library for game programming and\nmuch more written in **modern C++**, mainly known for its innovative\n**entity-component-system (ECS)** model.<br/>\n[Among others](https://github.com/skypjack/entt/wiki/EnTT-in-Action), it's used\nin [**Minecraft**](https://minecraft.net/en-us/attribution/) by Mojang and the\n[**ArcGIS Runtime SDKs**](https://developers.arcgis.com/arcgis-runtime/) by\nEsri. Open an issue or submit a PR if you don't see your project in the list!\n\n---\n\nDo you want to **keep up with changes** or do you have a **question** that\ndoesn't require you to open an issue?<br/>\nJoin the [gitter channel](https://gitter.im/skypjack/entt) and meet other users\nlike you. The more we are, the better for everyone.\n\nWondering why your **debug build** is so slow on Windows or how to represent a\n**hierarchy** with components?<br/>\nCheck out the\n[FAQ](https://github.com/skypjack/entt/wiki/Frequently-Asked-Questions) and the\n[wiki](https://github.com/skypjack/entt/wiki) if you have these or other doubts,\nyour answers may already be there.\n\nIf you use `EnTT` and you want to say thanks or support the project, please\n**consider becoming a\n[sponsor](https://github.com/users/skypjack/sponsorship)**.<br/>\nYou can help me make the difference.\n[Many thanks](https://skypjack.github.io/sponsorship/) to those who supported me\nand still support me today.\n\n# Table of Contents\n\n* [Introduction](#introduction)\n  * [Code Example](#code-example)\n  * [Motivation](#motivation)\n  * [Performance](#performance)\n* [Build Instructions](#build-instructions)\n  * [Requirements](#requirements)\n  * [Library](#library)\n  * [Documentation](#documentation)\n  * [Tests](#tests)\n* [Packaging Tools](#packaging-tools)\n* [EnTT in Action](#entt-in-action)\n* [Contributors](#contributors)\n* [License](#license)\n* [Support](#support)\n<!--\n@endcond TURN_OFF_DOXYGEN\n-->\n\n# Introduction\n\nThe entity-component-system (also known as _ECS_) is an architectural pattern\nused mostly in game development. For further details:\n\n* [Entity Systems Wiki](http://entity-systems.wikidot.com/)\n* [Evolve Your Hierarchy](http://cowboyprogramming.com/2007/01/05/evolve-your-heirachy/)\n* [ECS on Wikipedia](https://en.wikipedia.org/wiki/Entity%E2%80%93component%E2%80%93system)\n\nThis project started off as a pure entity-component system. Over time the\ncodebase has grown as more and more classes and functionalities were added.<br/>\nHere is a brief, yet incomplete list of what it offers today:\n\n* Statically generated integer **identifiers** for types (assigned either at\n  compile-time or at runtime).\n* A `constexpr` utility for human readable **resource names**.\n* A minimal **configuration system** built using the monostate pattern.\n* An incredibly fast **entity-component system** based on sparse sets, with its\n  own _pay for what you use_ policy to adjust performance and memory usage\n  according to the users' requirements.\n* Views and groups to iterate entities and components and allow different access\n  patterns, from **perfect SoA** to fully random.\n* A lot of **facilities** built on top of the entity-component system to help\n  the users and avoid reinventing the wheel (dependencies, snapshot, actor\n  class, support for **reactive systems** and so on).\n* The smallest and most basic implementation of a **service locator** ever seen.\n* A built-in, non-intrusive and macro-free runtime **reflection system**.\n* A **cooperative scheduler** for processes of any type.\n* All that is needed for **resource management** (cache, loaders, handles).\n* Delegates, **signal handlers** (with built-in support for collectors) and a\n  tiny event dispatcher for immediate and delayed events to integrate in loops.\n* A general purpose **event emitter** as a CRTP idiom based class template.\n* And **much more**! Check out the\n  [**wiki**](https://github.com/skypjack/entt/wiki).\n\nConsider this list a work in progress as well as the project. The whole API is\nfully documented in-code for those who are brave enough to read it.\n\nCurrently, `EnTT` is tested on Linux, Microsoft Windows and OSX. It has proven\nto work also on both Android and iOS.<br/>\nMost likely it won't be problematic on other systems as well, but it hasn't been\nsufficiently tested so far.\n\n## Code Example\n\n```cpp\n#include <entt/entt.hpp>\n#include <cstdint>\n\nstruct position {\n    float x;\n    float y;\n};\n\nstruct velocity {\n    float dx;\n    float dy;\n};\n\nvoid update(entt::registry &registry) {\n    auto view = registry.view<position, velocity>();\n\n    for(auto entity: view) {\n        // gets only the components that are going to be used ...\n\n        auto &vel = view.get<velocity>(entity);\n\n        vel.dx = 0.;\n        vel.dy = 0.;\n\n        // ...\n    }\n}\n\nvoid update(std::uint64_t dt, entt::registry &registry) {\n    registry.view<position, velocity>().each([dt](auto &pos, auto &vel) {\n        // gets all the components of the view at once ...\n\n        pos.x += vel.dx * dt;\n        pos.y += vel.dy * dt;\n\n        // ...\n    });\n}\n\nint main() {\n    entt::registry registry;\n    std::uint64_t dt = 16;\n\n    for(auto i = 0; i < 10; ++i) {\n        auto entity = registry.create();\n        registry.assign<position>(entity, i * 1.f, i * 1.f);\n        if(i % 2 == 0) { registry.assign<velocity>(entity, i * .1f, i * .1f); }\n    }\n\n    update(dt, registry);\n    update(registry);\n\n    // ...\n}\n```\n\n## Motivation\n\nI started developing `EnTT` for the _wrong_ reason: my goal was to design an\nentity-component system to beat another well known open source solution both in\nterms of performance and possibly memory usage.<br/>\nIn the end, I did it, but it wasn't very satisfying. Actually it wasn't\nsatisfying at all. The fastest and nothing more, fairly little indeed. When I\nrealized it, I tried hard to keep intact the great performance of `EnTT` and to\nadd all the features I wanted to see in *my own library* at the same time.\n\nNowadays, `EnTT` is finally what I was looking for: still faster than its\n_competitors_, lower memory usage in the average case, a really good API and an\namazing set of features. And even more, of course.\n\n## Performance\n\nThe proposed entity-component system is incredibly fast to iterate entities and\ncomponents, this is a fact. Some compilers make a lot of optimizations because\nof how `EnTT` works, some others aren't that good. In general, if we consider\nreal world cases, `EnTT` is somewhere between a bit and much faster than many of\nthe other solutions around, although I couldn't check them all for obvious\nreasons.\n\nIf you are interested, you can compile the `benchmark` test in release mode (to\nenable compiler optimizations, otherwise it would make little sense) by setting\nthe `BUILD_BENCHMARK` option of `CMake` to `ON`, then evaluate yourself whether\nyou're satisfied with the results or not.\n\nHonestly I got tired of updating the README file whenever there is an\nimprovement.<br/>\nThere are already a lot of projects out there that use `EnTT` as a basis for\ncomparison (this should already tell you a lot). Many of these benchmarks are\ncompletely wrong, many others are simply incomplete, good at omitting some\ninformation and using the wrong function to compare a given feature. Certainly\nthere are also good ones but they age quickly if nobody updates them, especially\nwhen the library they are dealing with is actively developed.\n\nThe choice to use `EnTT` should be based on its carefully designed API, its\nset of features and the general performance, **not** because some single\nbenchmark shows it to be the fastest tool available.\n\nIn the future I'll likely try to get even better performance while still adding\nnew features, mainly for fun.<br/>\nIf you want to contribute and/or have suggestions, feel free to make a PR or\nopen an issue to discuss your idea.\n\n# Build Instructions\n\n## Requirements\n\nTo be able to use `EnTT`, users must provide a full-featured compiler that\nsupports at least C++17.<br/>\nThe requirements below are mandatory to compile the tests and to extract the\ndocumentation:\n\n* `CMake` version 3.7 or later.\n* `Doxygen` version 1.8 or later.\n\nIf you are looking for a C++14 version of `EnTT`, check out the git tag `cpp14`.\n\n## Library\n\n`EnTT` is a header-only library. This means that including the `entt.hpp` header\nis enough to include the library as a whole and use it. For those who are\ninterested only in the entity-component system, consider to include the sole\n`entity/registry.hpp` header instead.<br/>\nIt's a matter of adding the following line to the top of a file:\n\n```cpp\n#include <entt/entt.hpp>\n```\n\nUse the line below to include only the entity-component system instead:\n\n```cpp\n#include <entt/entity/registry.hpp>\n```\n\nThen pass the proper `-I` argument to the compiler to add the `src` directory to\nthe include paths.\n\n## Documentation\n\nThe documentation is based on [doxygen](http://www.doxygen.nl/).\nTo build it:\n\n    $ cd build\n    $ cmake .. -DBUILD_DOCS=ON\n    $ make\n\nThe API reference will be created in HTML format within the directory\n`build/docs/html`. To navigate it with your favorite browser:\n\n    $ cd build\n    $ your_favorite_browser docs/html/index.html\n\n<!--\n@cond TURN_OFF_DOXYGEN\n-->\nIt's also available [online](https://skypjack.github.io/entt/) for the latest\nversion, that is the last stable tag.<br/>\nMoreover, there exists a [wiki](https://github.com/skypjack/entt/wiki) dedicated\nto the project where users can find all related documentation pages.\n<!--\n@endcond TURN_OFF_DOXYGEN\n-->\n\n## Tests\n\nTo compile and run the tests, `EnTT` requires *googletest*.<br/>\n`cmake` will download and compile the library before compiling anything else.\nIn order to build the tests, set the CMake option `BUILD_TESTING` to `ON`.\n\nTo build the most basic set of tests:\n\n* `$ cd build`\n* `$ cmake -DBUILD_TESTING=ON ..`\n* `$ make`\n* `$ make test`\n\nNote that benchmarks are not part of this set.\n\n# Packaging Tools\n\n`EnTT` is available for some of the most known packaging tools. In particular:\n\n* [`Conan`](https://github.com/conan-io/conan-center-index), the C/C++ Package\n  Manager for Developers.\n\n* [`vcpkg`](https://github.com/Microsoft/vcpkg), Microsoft VC++ Packaging\n  Tool.<br/>\n  You can download and install `EnTT` in just a few simple steps:\n\n  ```\n  $ git clone https://github.com/Microsoft/vcpkg.git\n  $ cd vcpkg\n  $ ./bootstrap-vcpkg.sh\n  $ ./vcpkg integrate install\n  $ vcpkg install entt\n  ```\n\n  The `EnTT` port in `vcpkg` is kept up to date by Microsoft team members and\n  community contributors.<br/>\n  If the version is out of date, please\n  [create an issue or pull request](https://github.com/Microsoft/vcpkg) on the\n  `vcpkg` repository.\n\n* [`Homebrew`](https://github.com/skypjack/homebrew-entt), the missing package\n  manager for macOS.<br/>\n  Available as a homebrew formula. Just type the following to install it:\n\n  ```\n  brew install skypjack/entt/entt\n  ```\n\nConsider this list a work in progress and help me to make it longer.\n\n<!--\n@cond TURN_OFF_DOXYGEN\n-->\n# EnTT in Action\n\n`EnTT` is widely used in private and commercial applications. I cannot even\nmention most of them because of some signatures I put on some documents time\nago. Fortunately, there are also people who took the time to implement open\nsource projects based on `EnTT` and did not hold back when it came to\ndocumenting them.\n\n[Here](https://github.com/skypjack/entt/wiki/EnTT-in-Action) you can find an\nincomplete list of games, applications and articles that can be used as a\nreference.\n\nIf you know of other resources out there that are about `EnTT`, feel free to\nopen an issue or a PR and I'll be glad to add them to the list.\n\n# Contributors\n\n`EnTT` was written initially as a faster alternative to other well known and\nopen source entity-component systems. Nowadays this library is moving its first\nsteps. Much more will come in the future and hopefully I'm going to work on it\nfor a long time.<br/>\nRequests for features, PR, suggestions ad feedback are highly appreciated.\n\nIf you find you can help me and want to contribute to the project with your\nexperience or you do want to get part of the project for some other reasons,\nfeel free to contact me directly (you can find the mail in the\n[profile](https://github.com/skypjack)).<br/>\nI can't promise that each and every contribution will be accepted, but I can\nassure that I'll do my best to take them all seriously.\n\nIf you decide to participate, please see the guidelines for\n[contributing](CONTRIBUTING.md) before to create issues or pull\nrequests.<br/>\nTake also a look at the\n[contributors list](https://github.com/skypjack/entt/blob/master/AUTHORS) to\nknow who has participated so far.\n<!--\n@endcond TURN_OFF_DOXYGEN\n-->\n\n# License\n\nCode and documentation Copyright (c) 2017-2020 Michele Caini.<br/>\nLogo Copyright (c) 2018-2020 Richard Caseres.\n\nCode released under\n[the MIT license](https://github.com/skypjack/entt/blob/master/LICENSE).\nDocumentation released under\n[CC BY 4.0](https://creativecommons.org/licenses/by/4.0/).<br/>\nLogo released under\n[CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/).\n\n<!--\n@cond TURN_OFF_DOXYGEN\n-->\n# Support\n\nIf you want to support this project, you can\n[offer me](https://github.com/users/skypjack/sponsorship) an espresso.<br/>\nIf you find that it's not enough, feel free to\n[help me](https://www.paypal.me/skypjack) the way you prefer.\n<!--\n@endcond TURN_OFF_DOXYGEN\n-->\n\n\n\n--- ./docs/md/core.md ---\n# Crash Course: core functionalities\n\n<!--\n@cond TURN_OFF_DOXYGEN\n-->\n# Table of Contents\n\n* [Introduction](#introduction)\n* [Compile-time identifiers](#compile-time-identifiers)\n* [Runtime identifiers](#runtime-identifiers)\n* [Hashed strings](#hashed-strings)\n  * [Wide characters](wide-characters)\n  * [Conflicts](#conflicts)\n* [Monostate](#monostate)\n* [Type info](#type-info)\n  * [Almost unique identifiers](#almost-unique-identifiers)\n<!--\n@endcond TURN_OFF_DOXYGEN\n-->\n\n# Introduction\n\n`EnTT` comes with a bunch of core functionalities mostly used by the other parts\nof the library itself.<br/>\nHardly users will include these features in their code, but it's worth\ndescribing what `EnTT` offers so as not to reinvent the wheel in case of need.\n\n# Compile-time identifiers\n\nSometimes it's useful to be able to give unique identifiers to types at\ncompile-time.<br/>\nThere are plenty of different solutions out there and I could have used one of\nthem. However, I decided to spend my time to define a compact and versatile tool\nthat fully embraces what the modern C++ has to offer.\n\nThe _result of my efforts_ is the `identifier` class template:\n\n```cpp\n#include <ident.hpp>\n\n// defines the identifiers for the given types\nusing id = entt::identifier<a_type, another_type>;\n\n// ...\n\nswitch(a_type_identifier) {\ncase id::type<a_type>:\n    // ...\n    break;\ncase id::type<another_type>:\n    // ...\n    break;\ndefault:\n    // ...\n}\n```\n\nThis is all what the class template has to offer: a `type` inline variable that\ncontains a numerical identifier for the given type. It can be used in any\ncontext where constant expressions are required.\n\nAs long as the list remains unchanged, identifiers are also guaranteed to be the\nsame for every run. In case they have been used in a production environment and\na type has to be removed, one can just use a placeholder to left the other\nidentifiers unchanged:\n\n```cpp\ntemplate<typename> struct ignore_type {};\n\nusing id = entt::identifier<\n    a_type_still_valid,\n    ignore_type<a_type_no_longer_valid>,\n    another_type_still_valid\n>;\n```\n\nA bit ugly to see, but it works at least.\n\n# Runtime identifiers\n\nSometimes it's useful to be able to give unique identifiers to types at\nruntime.<br/>\nThere are plenty of different solutions out there and I could have used one of\nthem. In fact, I adapted the most common one to my requirements and used it\nextensively within the entire library.\n\nIt's the `family` class. Here is an example of use directly from the\nentity-component system:\n\n```cpp\nusing component_family = entt::family<struct internal_registry_component_family>;\n\n// ...\n\ntemplate<typename Component>\ncomponent_type component() const noexcept {\n    return component_family::type<Component>;\n}\n```\n\nThis is all what a _family_ has to offer: a `type` inline variable that contains\na numerical identifier for the given type.\n\nPlease, note that identifiers aren't guaranteed to be the same for every run.\nIndeed it mostly depends on the flow of execution.\n\n# Hashed strings\n\nA hashed string is a zero overhead unique identifier. Users can use\nhuman-readable identifiers in the codebase while using their numeric\ncounterparts at runtime, thus without affecting performance.<br/>\nThe class has an implicit `constexpr` constructor that chews a bunch of\ncharacters. Once created, all what one can do with it is getting back the\noriginal string or converting it into a number.<br/>\nThe good part is that a hashed string can be used wherever a constant expression\nis required and no _string-to-number_ conversion will take place at runtime if\nused carefully.\n\nExample of use:\n\n```cpp\nauto load(entt::hashed_string::hash_type resource) {\n    // uses the numeric representation of the resource to load and return it\n}\n\nauto resource = load(entt::hashed_string{\"gui/background\"});\n```\n\nThere is also a _user defined literal_ dedicated to hashed strings to make them\nmore user-friendly:\n\n```cpp\nconstexpr auto str = \"text\"_hs;\n```\n\n## Wide characters\n\nThe hashed string has a design that is close to that of an `std::basic_string`.\nIt means that `hashed_string` is nothing more than an alias for\n`basic_hashed_string<char>`. For those who want to use the C++ type for wide\ncharacter representation, there exists also the alias `hashed_wstring` for\n`basic_hashed_string<wchar_t>`.<br/>\nIn this case, the user defined literal to use to create hashed strings on the\nfly is `_hws`:\n\n```cpp\nconstexpr auto str = \"text\"_hws;\n```\n\nNote that the hash type of the `hashed_wstring` is the same of its counterpart.\n\n## Conflicts\n\nThe hashed string class uses internally FNV-1a to compute the numeric\ncounterpart of a string. Because of the _pigeonhole principle_, conflicts are\npossible. This is a fact.<br/>\nThere is no silver bullet to solve the problem of conflicts when dealing with\nhashing functions. In this case, the best solution seemed to be to give up.\nThat's all.<br/>\nAfter all, human-readable unique identifiers aren't something strictly defined\nand over which users have not the control. Choosing a slightly different\nidentifier is probably the best solution to make the conflict disappear in this\ncase.\n\n# Monostate\n\nThe monostate pattern is often presented as an alternative to a singleton based\nconfiguration system. This is exactly its purpose in `EnTT`. Moreover, this\nimplementation is thread safe by design (hopefully).<br/>\nKeys are represented by hashed strings, values are basic types like `int`s or\n`bool`s. Values of different types can be associated to each key, even more than\none at a time. Because of this, users must pay attention to use the same type\nboth during an assignment and when they try to read back their data. Otherwise,\nthey will probably incur in unexpected results.\n\nExample of use:\n\n```cpp\nentt::monostate<entt::hashed_string{\"mykey\"}>{} = true;\nentt::monostate<\"mykey\"_hs>{} = 42;\n\n// ...\n\nconst bool b = entt::monostate<\"mykey\"_hs>{};\nconst int i = entt::monostate<entt::hashed_string{\"mykey\"}>{};\n```\n\n# Type info\n\nThe `type_info` class template is meant to provide some basic information about\ntypes of all kinds.<br/>\nCurrently, the only information available is the numeric identifier associated\nwith a given type:\n\n```cpp\nauto id = entt::type_info<my_type>::id();\n```\n\nIn general, the `id` function is also `constexpr` but this isn't guaranteed for\nall compilers and platforms (although it's valid with the most well-known and\npopular compilers).<br/>\nThis function **can** use non-standard features of the language for its own\npurposes. This allows it to provide compile-time identifiers that remain stable\nbetween different runs. However, it's possible to force the use of standard\nfeatures only by defining the macro `ENTT_STANDARD_CPP`. In this case, there is\nno guarantee that the identifiers are stable across executions though. Moreover,\nidentifiers are generated at runtime and are no longer a compile-time thing.\n\nAn external type system can also be used if needed. In fact, `type_info` can be\nspecialized by type and is also _sfinae-friendly_ in order to allow more refined\nspecializations such as:\n\n```cpp\ntemplate<typename Type>\nstruct entt::type_info<Type, std::void_d<decltype(Type::custom_id())>> {\n    static constexpr ENTT_ID_TYPE id() ENTT_NOEXCEPT {\n        return Type::custom_id();\n    }\n};\n```\n\nNote that this class template and its specializations are widely used within\n`EnTT`. It also plays a very important role in making `EnTT` work transparently\nacross boundaries.<br/>\nPlease refer to the dedicated section for more details.\n\n## Almost unique identifiers\n\nSince the default non-standard, compile-time implementation makes use of hashed\nstrings, it may happen that two types are assigned the same numeric\nidentifier.<br/>\nIn fact, although this is quite rare, it's not entirely excluded.\n\nAnother case where two types are assigned the same identifier is when classes\nfrom different contexts (for example two or more libraries loaded at runtime)\nhave the same fully qualified name.<br/>\nSince the default model is based on the name of the classes, if the types belong\nto the same namespace then their identifiers _could_ be identical (they won't\nnecessarily be the same though).\n\nFortunately, there are several easy ways to deal with this:\n\n* The most trivial one is to define the `ENTT_STANDARD_CPP` macro. Note that\n  runtime identifiers don't suffer from the sam problem. However, this solution\n  doesn't work well with a plugin system, where the libraries aren't linked.\n\n* Another possibility is to specialize the `type_info` class for one of the\n  conflicting types, in order to assign it a custom identifier. This is probably\n  the easiest solution that also preserves the feature of the tool.\n\n* A fully customized identifier generation policy (based for example on enum\n  classes or preprocessing steps) may represent yet another option.\n\nThese are just some examples of possible approaches to the problem but there are\nmany others. As already mentioned above, since users have full control over\ntheir types, this problem is in any case easy to solve and should not worry too\nmuch.<br/>\nIn all likelihood, it will never happen to run into a conflict anyway.\n\n\n\n--- ./docs/md/entity.md ---\n# Crash Course: entity-component system\n\n<!--\n@cond TURN_OFF_DOXYGEN\n-->\n# Table of Contents\n\n* [Introduction](#introduction)\n* [Design decisions](#design-decisions)\n  * [A bitset-free entity-component system](#a-bitset-free-entity-component-system)\n  * [Pay per use](#pay-per-use)\n  * [All or nothing](#all-or-nothing)\n  * [Stateless systems](#stateless-systems)\n* [Vademecum](#vademecum)\n* [The Registry, the Entity and the Component](#the-registry-the-entity-and-the-component)\n  * [Observe changes](#observe-changes)\n    * [They call me Reactive System](#they-call-me-reactive-system)\n  * [Sorting: is it possible?](#sorting-is-it-possible)\n  * [Helpers](#helpers)\n    * [Null entity](#null-entity)\n    * [Stamp](#stamp)\n    * [Dependencies](#dependencies)\n    * [Tags](#tags)\n    * [Actor](#actor)\n    * [Context variables](#context-variables)\n  * [Snapshot: complete vs continuous](#snapshot-complete-vs-continuous)\n    * [Snapshot loader](#snapshot-loader)\n    * [Continuous loader](#continuous-loader)\n    * [Archives](#archives)\n    * [One example to rule them all](#one-example-to-rule-them-all)\n* [Views and Groups](#views-and-groups)\n  * [Views](#views)\n  * [Runtime views](#runtime-views)\n  * [Groups](#groups)\n    * [Full-owning groups](#full-owning-groups)\n    * [Partial-owning groups](#partial-owning-groups)\n    * [Non-owning groups](#non-owning-groups)\n    * [Nested groups](#nested-groups)\n  * [Types: const, non-const and all in between](#types-const-non-const-and-all-in-between)\n  * [Give me everything](#give-me-everything)\n  * [What is allowed and what is not](#what-is-allowed-and-what-is-not)\n    * [More performance, more constraints](#more-performance-more-constraints)\n* [Empty type optimization](#empty-type-optimization)\n* [Multithreading](#multithreading)\n  * [Iterators](#iterators)\n* [Beyond this document](#beyond-this-document)\n<!--\n@endcond TURN_OFF_DOXYGEN\n-->\n\n# Introduction\n\n`EnTT` is a header-only, tiny and easy to use entity-component system (and much\nmore) written in modern C++.<br/>\nThe entity-component-system (also known as _ECS_) is an architectural pattern\nused mostly in game development.\n\n# Design decisions\n\n## A bitset-free entity-component system\n\n`EnTT` offers a _bitset-free_ entity-component system that doesn't require users\nto specify the set of components neither at compile-time nor at runtime.<br/>\nThis is why users can instantiate the core class simply like:\n\n```cpp\nentt::registry registry;\n```\n\nIn place of its more annoying and error-prone counterpart:\n\n```cpp\nentt::registry<comp_0, comp_1, ..., comp_n> registry;\n```\n\nFurthermore, it isn't necessary to announce the existence of a component type.\nWhen the time comes, just use it and that's all.\n\n## Pay per use\n\n`EnTT` is entirely designed around the principle that users have to pay only for\nwhat they want.\n\nWhen it comes to using an entity-component system, the tradeoff is usually\nbetween performance and memory usage. The faster it is, the more memory it uses.\nEven worse, some approaches tend to heavily affect other functionalities like\nthe construction and destruction of components to favor iterations, even when it\nisn't strictly required. In fact, slightly worse performance along non-critical\npaths are the right price to pay to reduce memory usage and have overall better\nperfomance sometimes and I've always wondered why this kind of tools do not\nleave me the choice.<br/>\n`EnTT` follows a completely different approach. It gets the best out from the\nbasic data structures and gives users the possibility to pay more for higher\nperformance where needed.\n\nSo far, this choice has proven to be a good one and I really hope it can be for\nmany others besides me.\n\n## All or nothing\n\n`EnTT` is such that at every moment a pair `(T *, size)` is available to\ndirectly access all the instances of a given component type `T`.<br/>\nThis was a guideline and a design decision that influenced many choices, for\nbetter and for worse. I cannot say whether it will be useful or not to the\nreader, but it's worth to mention it since it's one of the corner stones of\nthis library.\n\nMany of the tools described below give the possibility to get this information\nand have been designed around this need.<br/>\nThe rest is experimentation and the desire to invent something new, hoping to\nhave succeeded.\n\n## Stateless systems\n\n`EnTT` is designed so that it can work with _stateless systems_. In other words,\nall systems can be free functions and there is no need to define them as classes\n(although nothing prevents users from doing so).<br/>\nThis is possible because the main class with which the users will work provides\nall what is needed to act as the sole _source of truth_ of an application.\n\n# Vademecum\n\nThe registry to store, the views and the groups to iterate. That's all.\n\nAn entity (the _E_ of an _ECS_) is an opaque identifier that users should use\nas-is. Inspecting an identifier isn't recommended since its format can change in\nfuture and a registry has all the functionalities to query them out-of-the-box.\nThe type `entt::entity` implements the concept of _entity identifier_.<br/>\nComponents (the _C_ of an _ECS_) must be both move constructible and move\nassignable. They are list initialized by using the parameters provided to\nconstruct the component itself. No need to register components or their types\nneither with the registry nor with the entity-component system at all.<br/>\nSystems (the _S_ of an _ECS_) can be plain functions, functors, lambdas and so\non. It's not required to announce them in any case and have no requirements.\n\nThe following sections explain in short how to use the entity-component system,\nthe core part of the whole library.<br/>\nThe project is composed of many other classes in addition to those describe\nbelow. For more details, please refer to the inline documentation.\n\n# The Registry, the Entity and the Component\n\nA registry can store and manage entities, as well as create views and groups to\niterate the underlying data structures.<br/>\nThe class template `basic_registry` lets users decide what's the preferred type\nto represent an entity. Because `std::uint32_t` is large enough for almost all\nthe cases, there exists also the type `entt::entity` for it and the alias\n`entt::registry` for `entt::basic_registry<entt::entity>`.\n\nEntities are represented by _entity identifiers_. An entity identifier carries\ninformation about the entity itself and its version.<br/>\nUser defined identifiers can be introduced by means of the `ENTT_OPAQUE_TYPE`\nmacro if needed.\n\nA registry is used both to construct and to destroy entities:\n\n```cpp\n// constructs a naked entity with no components and returns its identifier\nauto entity = registry.create();\n\n// destroys an entity and all its components\nregistry.destroy(entity);\n```\n\nThe `create` member function accepts also a hint and has an overload that gets\ntwo iterators and can be used to generate multiple entities at once efficiently.\nSimilarly, the `destroy` member function works also with a range of entities:\n\n```cpp\n// destroys all the entities in a range\nauto view = registry.view<a_component, another_component>();\nregistry.destroy(view.begin(), view.end());\n```\n\nWhen an entity is destroyed, the registry can freely reuse it internally with a\nslightly different identifier. In particular, the version of an entity is\nincreased after destruction.<br/>\nUsers can probe an identifier to know the information it carries:\n\n```cpp\n// returns true if the entity is still valid, false otherwise\nbool b = registry.valid(entity);\n\n// gets the version contained in the entity identifier\nauto version = registry.version(entity);\n\n// gets the actual version for the given entity\nauto curr = registry.current(entity);\n```\n\nComponents can be assigned to or removed from entities at any time. As for the\nentities, the registry offers a set of functions to use to work with components.\n\nThe `assign` member function template creates, initializes and assigns to an\nentity the given component. It accepts a variable number of arguments to use to\nconstruct the component itself if present:\n\n```cpp\nregistry.assign<position>(entity, 0., 0.);\n\n// ...\n\nauto &velocity = registry.assign<velocity>(entity);\nvel.dx = 0.;\nvel.dy = 0.;\n```\n\nThis function is overloaded and can receive also a couple of iterators to be\nused to assign the same component to multiple entities at once.\n\nIf an entity already has the given component, the `replace` member function\ntemplate can be used to replace it:\n\n```cpp\nregistry.replace<position>(entity, 0., 0.);\n\n// ...\n\nauto &velocity = registry.replace<velocity>(entity);\nvel.dx = 0.;\nvel.dy = 0.;\n```\n\nWhen it's unknown whether an entity already owns an instance of a component,\n`assign_or_replace` is the function to use instead:\n\n```cpp\nregistry.assign_or_replace<position>(entity, 0., 0.);\n\n// ...\n\nauto &velocity = registry.assign_or_replace<velocity>(entity);\nvel.dx = 0.;\nvel.dy = 0.;\n```\n\nThis is a slightly faster alternative for the following snippet:\n\n```cpp\nif(registry.has<comp>(entity)) {\n    registry.replace<comp>(entity, arg1, argN);\n} else {\n    registry.assign<comp>(entity, arg1, argN);\n}\n```\n\nThe `has` member function may also be useful if in doubt about whether or not an\nentity has one or more components:\n\n```cpp\nbool b = registry.has<position, velocity>(entity);\n```\n\nIf the goal is to delete a single component from an entity that owns it, the\n`remove` member function template is the way to go:\n\n```cpp\nregistry.remove<position>(entity);\n```\n\nWhen in doubt whether the entity owns the component or not, use the `reset`\nmember function instead. It behaves similarly to `remove` but it discards the\ncomponent if and only if it exists, otherwise it returns safely to the caller:\n\n```cpp\nregistry.reset<position>(entity);\n```\n\nThere exist also two other _versions_ of the `reset` member function:\n\n* If no entity is passed to it, `reset` will remove the given component from\n  each entity that has it:\n\n  ```cpp\n  registry.reset<position>();\n  ```\n\n* If neither the entity nor the component are specified, all the entities still\n  in use and their components are destroyed:\n\n  ```cpp\n  registry.reset();\n  ```\n\nFinally, references to components can be retrieved simply as:\n\n```cpp\nconst auto &cregistry = registry;\n\n// const and non-const reference\nconst auto &crenderable = cregistry.get<renderable>(entity);\nauto &renderable = registry.get<renderable>(entity);\n\n// const and non-const references\nconst auto [cpos, cvel] = cregistry.get<position, velocity>(entity);\nauto [pos, vel] = registry.get<position, velocity>(entity);\n```\n\nThe `get` member function template gives direct access to the component of an\nentity stored in the underlying data structures of the registry. There exists\nalso an alternative member function named `try_get` that returns a pointer to\nthe component owned by an entity if any, a null pointer otherwise.\n\n## Observe changes\n\nBecause of how the registry works internally, it stores a bunch of signal\nhandlers for each pool in order to notify some of its data structures on the\nconstruction and destruction of components or when an instance of a component is\nexplicitly replaced by the user.<br/>\nThese signal handlers are also exposed and made available to users. These are\nthe basic bricks to build fancy things like dependencies and reactive systems.\n\nTo get a sink to be used to connect and disconnect listeners so as to be\nnotified on the creation of a component, use the `on_construct` member function:\n\n```cpp\n// connects a free function\nregistry.on_construct<position>().connect<&my_free_function>();\n\n// connects a member function\nregistry.on_construct<position>().connect<&my_class::member>(instance);\n\n// disconnects a free function\nregistry.on_construct<position>().disconnect<&my_free_function>();\n\n// disconnects a member function\nregistry.on_construct<position>().disconnect<&my_class::member>(instance);\n```\n\nTo be notified when components are destroyed, use the `on_destroy` member\nfunction instead. Finally, the `on_replace` member function will return a sink\nto which to connect listeners to observe changes.\n\nThe function type of a listener for the construction signal should be equivalent\nto the following:\n\n```cpp\nvoid(entt::entity, entt::registry &, Component &);\n```\n\nWhere `Component` is intuitively the type of component of interest. The listener\nis provided with the registry that triggered the notification, the entity\naffected by the change and the newly created instance.<br/>\nThe sink returned by the `on_replace` member function accepts listeners the\nsignature of which is the same of that of the construction signal. The one of\nthe destruction signal is also similar, except for the `Component` parameter:\n\n```cpp\nvoid(entt::entity, entt::registry &);\n```\n\nThis is mainly due to performance reasons. While the component is made available\nafter the construction, it is not when destroyed. Because of that, there are no\nreasons to get it from the underlying storage unless the user requires so.\n\nNote also that:\n\n* Listeners for the construction signal are invoked **after** components have\n  been assigned to entities.\n\n* Listeners designed to observe changes are invoked **before** components have\n  been replaced and therefore before newly created instances have been assigned\n  to entities.\n\n* Listeners for the destruction signal are invoked **before** components have\n  been removed from entities.\n\nThere are also some limitations on what a listener can and cannot do:\n\n* Connecting and disconnecting other functions from within the body of a\n  listener should be avoided. It can lead to undefined behavior in some cases.\n\n* Assigning and removing components from within the body of a listener that\n  observes the destruction of instances of a given type should be avoided. It\n  can lead to undefined behavior in some cases. This type of listeners is\n  intended to provide users with an easy way to perform cleanup and nothing\n  more.\n\nTo a certain extent, these limitations don't apply. However, it's risky to try\nto force them and users should respect the limitations unless they know exactly\nwhat they are doing.\n\nEvents and therefore listeners must not be used as replacements for systems.\nThey shouldn't contain much logic and interactions with a registry should be\nkept to a minimum. Moreover, the greater the number of listeners, the greater\nthe performance hit when components are created or destroyed.\n\nPlease, refer to the documentation of the signal class to know all the features\nit offers.<br/>\nThere are many useful but less known functionalities that aren't described here,\nsuch as the connection objects or the possibility to attach listeners with a\nlist of parameters that is shorter than that of the signal itself.\n\n### They call me Reactive System\n\nSignals are the basic tools to construct reactive systems, even if they aren't\nenough on their own. `EnTT` tries to take another step in that direction with\nthe `observer` class template.<br/>\nIn order to explain what reactive systems are, this is a slightly revised quote\nfrom the documentation of the library that first introduced this tool,\n[Entitas](https://github.com/sschmid/Entitas-CSharp):\n\n>Imagine you have 100 fighting units on the battlefield but only 10 of them\n>changed their positions. Instead of using a normal system and updating all 100\n>entities depending on the position, you can use a reactive system which will\n>only update the 10 changed units. So efficient.\n\nIn `EnTT`, this means to iterating over a reduced set of entities and components\nwith respect to what would otherwise be returned from a view or a group.<br/>\nOn these words, however, the similarities with the proposal of `Entitas` also\nend. The rules of language and the design of the library obviously impose and\nallow different things.\n\nAn `observer` is initialized with an instance of a registry and a set of rules\nthat describes what are the entities to intercept. As an example:\n\n```cpp\nentt::observer observer{registry, entt::collector.replace<sprite>()};\n```\n\nThe class is default constructible and can be reconfigured at any time by means\nof the `connect` member function. Moreover, instances can be disconnected from\nthe underlying registries through the `disconnect` member function.<br/>\nThe `observer` offers also what is needed to query the internal state and to\nknow if it's empty or how many entities it contains. Moreover, it can return a\nraw pointer to the list of entities it contains.\n\nHowever, the most important features of this class are that:\n\n* It's iterable and therefore users can easily walk through the list of entities\n  by means of a range-for loop or the `each` member function.\n\n* It's clearable and therefore users can consume the entities and literally\n  reset the observer after each iteration.\n\nThese aspects make the observer an incredibly powerful tool to know at any time\nwhat are the entities that matched the given rules since the last time one\nasked:\n\n```cpp\nfor(const auto entity: observer) {\n    // ...\n}\n\nobserver.clear();\n```\n\nThe snippet above is equivalent to the following:\n\n```cpp\nobserver.each([](const auto entity) {\n    // ...\n});\n```\n\nAt least as long as the `observer` isn't const. This means that the non-const\noverload of `each` does also reset the underlying data structure before to\nreturn to the caller, while the const overload does not for obvious reasons.\n\nThe `collector` is an utility aimed to generate a list of `matcher`s (the actual\nrules) to use with an `observer` instead.<br/>\nThere are two types of `matcher`s:\n\n* Observing matcher: an observer will return at least all the living entities\n  for which one or more of the given components have been explicitly replaced\n  and not yet destroyed.\n\n  ```cpp\n  entt::collector.replace<sprite>();\n  ```\n\n* Grouping matcher: an observer will return at least all the living entities\n  that would have entered the given group if it existed and that would have\n  not yet left it.\n\n  ```cpp\n  entt::collector.group<position, velocity>(entt::exclude<destroyed>);\n  ```\n\n  A grouping matcher supports also exclusion lists as well as single components.\n\nRoughly speaking, an observing matcher intercepts the entities for which the\ngiven components are replaced (as in `registry::replace`) while a grouping\nmatcher tracks the entities that have assigned the given components since the\nlast time one asked.<br/>\nIf an entity already has all the components except one and the missing type is\nassigned to it, the entity is intercepted by a grouping matcher.\n\nIn addition, a matcher can be filtered with a `where` clause:\n\n```cpp\nentt::collector.replace<sprite>().where<position>(entt::exclude<velocity>);\n```\n\nThis clause introduces a way to intercept entities if and only if they are\nalready part of a hypothetical group. If they are not, they aren't returned by\nthe observer, no matter if they matched the given rule.<br/>\nIn the example above, whenever the component `sprite` of an entity is replaced,\nthe observer probes the entity itself to verify that it has at least `position`\nand has not `velocity` before to store it aside. If one of the two conditions of\nthe filter isn't respected, the entity is discared, no matter what.\n\nA `where` clause accepts a theoretically unlimited number of types as well as\nmultiple elements in the exclusion list. Moreover, every matcher can have its\nown clause and multiple clauses for the same matcher are combined in a single\none.\n\n## Sorting: is it possible?\n\nSorting entities and components is possible with `EnTT`.<br/>\nThere are two functions that respond to slightly different needs:\n\n* Components can be sorted either directly:\n\n  ```cpp\n  registry.sort<renderable>([](const auto &lhs, const auto &rhs) {\n      return lhs.z < rhs.z;\n  });\n  ```\n\n  Or by accessing their entities:\n\n  ```cpp\n  registry.sort<renderable>([](const entt::entity lhs, const entt::entity rhs) {\n      return entt::registry::entity(lhs) < entt::registry::entity(rhs);\n  });\n  ```\n\n  There exists also the possibility to use a custom sort function object for\n  when the usage pattern is known. As an example, in case of an almost sorted\n  pool, quick sort could be much slower than insertion sort.\n\n* Components can be sorted according to the order imposed by another component:\n\n  ```cpp\n  registry.sort<movement, physics>();\n  ```\n\n  In this case, instances of `movement` are arranged in memory so that cache\n  misses are minimized when the two components are iterated together.\n\nAs a side note, the use of groups limits the possibility of sorting pools of\ncomponents. Refer to the specific documentation for more details.\n\n## Helpers\n\nThe so called _helpers_ are small classes and functions mainly designed to offer\nbuilt-in support for the most basic functionalities.<br/>\nThe list of helpers will grow longer as time passes and new ideas come out.\n\n### Null entity\n\nIn `EnTT`, the `entt::null` variable models the concept of _null entity_.<br/>\nThe library guarantees that the following expression always returns false:\n\n```cpp\nregistry.valid(entt::null);\n```\n\nA registry rejects the null entity in all cases because it isn't considered\nvalid. It also means that the null entity cannot own components.<br/>\nThe type of the null entity is internal and should not be used for any purpose\nother than defining the null entity itself. However, there exist implicit\nconversions from the null entity to identifiers of any allowed type:\n\n```cpp\nentt::entity null = entt::null;\n```\n\nSimilarly, the null entity can be compared to any other identifier:\n\n```cpp\nconst auto entity = registry.create();\nconst bool null = (entity == entt::null);\n```\n\nBe aware that `entt::null` and entity 0 aren't the same thing. Likewise, a zero\ninitialized entity isn't the same as `entt::null`. Therefore, although\n`entt::entity{}` is in some sense an alias for entity 0, none of them can be\nused to create a null entity.\n\n### Stamp\n\nUsing multiple registries at the same time is quite common. Examples are the\nseparation of the UI from the simulation or the loading of different scenes in\nthe background, possibly on a separate thread, without having to keep track of\nwhich entity belongs to which scene.<br/>\nIn fact, with `EnTT` this is even a recommended practice, as the registry is\nnothing more than an opaque container you can swap at any time.\n\nOnce there are multiple registries available, one or more methods are needed to\ntransfer information from one container to another. This results in the `stamp`\nmember functions of the `registry` class.<br/>\nThis function takes one entity from a registry and uses it to _stamp_ one or\nmore entities in another registry (or even the same, making local copies).\n\nIt opens definitely the doors to a lot of interesting features like migrating\nentities between registries, prototypes, shadow registry, prefabs, shared\ncomponents without explicit ownership models and copy-on-write policies among\nthe other things.\n\n### Dependencies\n\nThe `registry` class is designed to create short circuits between its functions.\nThis makes easy to define dependencies between different operations.<br/>\nFor example, the following adds (or replaces) the component `a_type` whenever\n`my_type` is assigned to an entity:\n\n```cpp\nregistry.on_construct<my_type>().connect<&entt::registry::assign_or_replace<a_type>>(registry);\n```\n\nSimilarly, the code shown below removes `a_type` from an entity whenever\n`my_type` is assigned to it:\n\n```cpp\nregistry.on_construct<my_type>().connect<entt::overload<void(entt::entity)>(&entt::registry::reset<a_type>)>(registry);\n```\n\nIn this case, to prevent the _wrong_ overload for `reset` being selected,\n`entt::overload` is used to help the compiler make the right choice.<br/>\nA dependency can also be easily broken as follows:\n\n```cpp\nregistry.on_construct<my_type>().disconnect<&entt::registry::assign_or_replace<a_type>>(registry);\n```\n\nThere are many other types of dependencies. In general, all functions that\naccept an entity as the first argument are good candidates for this purpose.\n\n### Tags\n\nThere's nothing magical about the way tags can be assigned to entities while\navoiding a performance hit at runtime. Nonetheless, the syntax can be annoying\nand that's why a more user-friendly shortcut is provided to do it.<br/>\nThis shortcut is the alias template `entt::tag`.\n\nIf used in combination with hashed strings, it helps to use tags where types\nwould be required otherwise. As an example:\n\n```cpp\nregistry.assign<entt::tag<\"enemy\"_hs>>(entity);\n```\n\n### Actor\n\nThe `actor` class is designed for those who don't feel immediately comfortable\nworking with components or for those who are migrating a project and want to\napproach it one step at a time.\n\nThis class acts as a thin wrapper for an entity and for all its components. It's\nconstructed with a registry and is in charge of the destruction of the entity\nwhen it goes out of the scope.<br/>\nAn actor offers all the functionalities required to work with components, such\nas the `assign` and` remove` member functions, but also `has`,` get`, `try_get`\nand so on.\n\nMy advice isn't to use the `actor` class to hide entities and components behind\na more object-oriented interface. Instead, users should rely on it only where\nstrictly necessary. In all other cases, it's highly advisable to become familiar\nwith the model of `EnTT` and work directly with the registry, the views and the\ngroups, rather than with a tool that could introduce a performance degradation.\n\n### Context variables\n\nIt is often convenient to assign context variables to a registry, so as to make\nit the only _source of truth_ of an application.<br/>\nThis is possible by means of a member function named `set` to use to create a\ncontext variable from a given type. Either `ctx` or `try_ctx` can be used to\nretrieve the newly created instance, while `unset` is meant to literally reset\nthe variable if needed.\n\nExample of use:\n\n```cpp\n// creates a new context variable initialized with the given values\nregistry.set<my_type>(42, 'c');\n\n// gets the context variable\nconst auto &var = registry.ctx<my_type>();\n\n// if in doubts, probe the registry to avoid assertions in case of errors\nif(auto *ptr = registry.try_ctx<my_type>(); ptr) {\n    // uses the context variable associated with the registry, if any\n}\n\n// unsets the context variable\nregistry.unset<my_type>();\n```\n\nThe type of a context variable must be such that it's default constructible and\ncan be moved. The `set` member function either creates a new instance of the\ncontext variable or overwrites an already existing one if any. The `try_ctx`\nmember function returns a pointer to the context variable if it exists,\notherwise it returns a null pointer.\n\n## Snapshot: complete vs continuous\n\nThe `registry` class offers basic support to serialization.<br/>\nIt doesn't convert components to bytes directly, there wasn't the need of\nanother tool for serialization out there. Instead, it accepts an opaque object\nwith a suitable interface (namely an _archive_) to serialize its internal data\nstructures and restore them later. The way types and instances are converted to\na bunch of bytes is completely in charge to the archive and thus to final users.\n\nThe goal of the serialization part is to allow users to make both a dump of the\nentire registry or a narrower snapshot, that is to select only the components in\nwhich they are interested.<br/>\nIntuitively, the use cases are different. As an example, the first approach is\nsuitable for local save/restore functionalities while the latter is suitable for\ncreating client-server applications and for transferring somehow parts of the\nrepresentation side to side.\n\nTo take a snapshot of the registry, use the `snapshot` member function. It\nreturns a temporary object properly initialized to _save_ the whole registry or\nparts of it.\n\nExample of use:\n\n```cpp\noutput_archive output;\n\nregistry.snapshot()\n    .entities(output)\n    .destroyed(output)\n    .component<a_component, another_component>(output);\n```\n\nIt isn't necessary to invoke all these functions each and every time. What\nfunctions to use in which case mostly depends on the goal and there is not a\ngolden rule to do that.\n\nThe `entities` member function asks the registry to serialize all the entities\nthat are still in use along with their versions. On the other side, the\n`destroyed` member function tells to the registry to serialize the entities that\nhave been destroyed and are no longer in use.<br/>\nThese two functions can be used to save and restore the whole set of entities\nwith the versions they had during serialization.\n\nThe `component` member function is a function template the aim of which is to\nstore aside components. The presence of a template parameter list is a\nconsequence of a couple of design choices from the past and in the present:\n\n* First of all, there is no reason to force a user to serialize all the\n  components at once and most of the times it isn't desiderable. As an example,\n  in case the stuff for the HUD in a game is put into the registry for some\n  reasons, its components can be freely discarded during a serialization step\n  because probably the software already knows how to reconstruct the HUD\n  correctly from scratch.\n\n* Furthermore, the registry makes heavy use of _type-erasure_ techniques\n  internally and doesn't know at any time what component types it contains.\n  Therefore being explicit at the call site is mandatory.\n\nThere exists also another version of the `component` member function that\naccepts a range of entities to serialize. This version is a bit slower than the\nother one, mainly because it iterates the range of entities more than once for\ninternal purposes. However, it can be used to filter out those entities that\nshouldn't be serialized for some reasons.<br/>\nAs an example:\n\n```cpp\nconst auto view = registry.view<serialize>();\noutput_archive output;\n\nregistry.snapshot().component<a_component, another_component>(output, view.cbegin(), view.cend());\n```\n\nNote that `component` stores items along with entities. It means that it works\nproperly without a call to the `entities` member function.\n\nOnce a snapshot is created, there exist mainly two _ways_ to load it: as a whole\nand in a kind of _continuous mode_.<br/>\nThe following sections describe both loaders and archives in details.\n\n### Snapshot loader\n\nA snapshot loader requires that the destination registry be empty and loads all\nthe data at once while keeping intact the identifiers that the entities\noriginally had.<br/>\nTo do that, the registry offers a member function named `loader` that returns a\ntemporary object properly initialized to _restore_ a snapshot.\n\nExample of use:\n\n```cpp\ninput_archive input;\n\nregistry.loader()\n    .entities(input)\n    .destroyed(input)\n    .component<a_component, another_component>(input)\n    .orphans();\n```\n\nIt isn't necessary to invoke all these functions each and every time. What\nfunctions to use in which case mostly depends on the goal and there is not a\ngolden rule to do that. For obvious reasons, what is important is that the data\nare restored in exactly the same order in which they were serialized.\n\nThe `entities` and `destroyed` member functions restore the sets of entities and\nthe versions that the entities originally had at the source.\n\nThe `component` member function restores all and only the components specified\nand assigns them to the right entities. Note that the template parameter list\nmust be exactly the same used during the serialization.\n\nThe `orphans` member function literally destroys those entities that have no\ncomponents attached. It's usually useless if the snapshot is a full dump of the\nsource. However, in case all the entities are serialized but only few components\nare saved, it could happen that some of the entities have no components once\nrestored. The best the users can do to deal with them is to destroy those\nentities and thus update their versions.\n\n### Continuous loader\n\nA continuous loader is designed to load data from a source registry to a\n(possibly) non-empty destination. The loader can accommodate in a registry more\nthan one snapshot in a sort of _continuous loading_ that updates the\ndestination one step at a time.<br/>\nIdentifiers that entities originally had are not transferred to the target.\nInstead, the loader maps remote identifiers to local ones while restoring a\nsnapshot. Because of that, this kind of loader offers a way to update\nautomatically identifiers that are part of components (as an example, as data\nmembers or gathered in a container).<br/>\nAnother difference with the snapshot loader is that the continuous loader does\nnot need to work with the private data structures of a registry. Furthermore, it\nhas an internal state that must persist over time. Therefore, there is no reason\nto create it by means of a registry, or to limit its lifetime to that of a\ntemporary object.\n\nExample of use:\n\n```cpp\nentt::continuous_loader<entt::entity> loader{registry};\ninput_archive input;\n\nloader.entities(input)\n    .destroyed(input)\n    .component<a_component, another_component, dirty_component>(input, &dirty_component::parent, &dirty_component::child)\n    .orphans()\n    .shrink();\n```\n\nIt isn't necessary to invoke all these functions each and every time. What\nfunctions to use in which case mostly depends on the goal and there is not a\ngolden rule to do that. For obvious reasons, what is important is that the data\nare restored in exactly the same order in which they were serialized.\n\nThe `entities` and `destroyed` member functions restore groups of entities and\nmap each entity to a local counterpart when required. In other terms, for each\nremote entity identifier not yet registered by the loader, the latter creates a\nlocal identifier so that it can keep the local entity in sync with the remote\none.\n\nThe `component` member function restores all and only the components specified\nand assigns them to the right entities.<br/>\nIn case the component contains entities itself (either as data members of type\n`entt::entity` or as containers of entities), the loader can update them\nautomatically. To do that, it's enough to specify the data members to update as\nshown in the example.\n\nThe `orphans` member function literally destroys those entities that have no\ncomponents after a restore. It has exactly the same purpose described in the\nprevious section and works the same way.\n\nFinally, `shrink` helps to purge local entities that no longer have a remote\nconterpart. Users should invoke this member function after restoring each\nsnapshot, unless they know exactly what they are doing.\n\n### Archives\n\nArchives must publicly expose a predefined set of member functions. The API is\nstraightforward and consists only of a group of function call operators that\nare invoked by the snapshot class and the loaders.\n\nIn particular:\n\n* An output archive, the one used when creating a snapshot, must expose a\n  function call operator with the following signature to store entities:\n\n  ```cpp\n  void operator()(entt::entity);\n  ```\n\n  Where `entt::entity` is the type of the entities used by the registry. Note\n  that all the member functions of the snapshot class make also an initial call\n  to this endpoint to save the _size_ of the set they are going to store.<br/>\n  In addition, an archive must accept a pair of entity and component for each\n  type to be serialized. Therefore, given a type `T`, the archive must contain a\n  function call operator with the following signature:\n\n  ```cpp\n  void operator()(entt::entity, const T &);\n  ```\n\n  The output archive can freely decide how to serialize the data. The register\n  is not affected at all by the decision.\n\n* An input archive, the one used when restoring a snapshot, must expose a\n  function call operator with the following signature to load entities:\n\n  ```cpp\n  void operator()(entt::entity &);\n  ```\n\n  Where `entt::entity` is the type of the entities used by the registry. Each\n  time the function is invoked, the archive must read the next element from the\n  underlying storage and copy it in the given variable. Note that all the member\n  functions of a loader class make also an initial call to this endpoint to read\n  the _size_ of the set they are going to load.<br/>\n  In addition, the archive must accept a pair of entity and component for each\n  type to be restored. Therefore, given a type `T`, the archive must contain a\n  function call operator with the following signature:\n\n  ```cpp\n  void operator()(entt::entity &, T &);\n  ```\n\n  Every time such an operator is invoked, the archive must read the next\n  elements from the underlying storage and copy them in the given variables.\n\n### One example to rule them all\n\n`EnTT` comes with some examples (actually some tests) that show how to integrate\na well known library for serialization as an archive. It uses\n[`Cereal C++`](https://uscilab.github.io/cereal/) under the hood, mainly\nbecause I wanted to learn how it works at the time I was writing the code.\n\nThe code is not production-ready and it isn't neither the only nor (probably)\nthe best way to do it. However, feel free to use it at your own risk.\n\nThe basic idea is to store everything in a group of queues in memory, then bring\neverything back to the registry with different loaders.\n\n# Views and Groups\n\nFirst of all, it's worth answering a question: why views and groups?<br/>\nBriefly, they're a good tool to enforce single responsibility. A system that has\naccess to a registry can create and destroy entities, as well as assign and\nremove components. On the other side, a system that has access to a view or a\ngroup can only iterate, read and update entities and components.<br/>\nIt is a subtle difference that can help designing a better software sometimes.\n\nMore in details:\n\n* Views are a non-intrusive tool to access entities and components without\n  affecting other functionalities or increasing the memory consumption.\n\n* Groups are an intrusive tool that allows to reach higher performance along\n  critical paths but has also a price to pay for that.\n\nThere are mainly two kinds of views: _compile-time_ (also known as `view`) and\nruntime (also known as `runtime_view`).<br/>\nThe former requires a compile-time list of component types and can make several\noptimizations because of that. The latter can be constructed at runtime instead\nusing numerical type identifiers and are a bit slower to iterate.<br/>\nIn both cases, creating and destroying a view isn't expensive at all since they\ndon't have any type of initialization.\n\nGroups come in three different flavors: _full-owning groups_, _partial-owning\ngroups_ and _non-owning groups_. The main difference between them is in terms of\nperformance.<br/>\nGroups can literally _own_ one or more component types. They are allowed to\nrearrange pools so as to speed up iterations. Roughly speaking: the more\ncomponents a group owns, the faster it is to iterate them.<br/>\nA given component can belong to multiple groups only if they are _nested_, so\nusers have to define groups carefully to get the best out of them.\n\n## Views\n\nA view behaves differently if it's constructed for a single component or if it\nhas been created to iterate multiple components. Even the API is slightly\ndifferent in the two cases.\n\nSingle component views are specialized in order to give a boost in terms of\nperformance in all the situations. This kind of views can access the underlying\ndata structures directly and avoid superfluous checks. There is nothing as fast\nas a single component view. In fact, they walk through a packed array of\ncomponents and return them one at a time.<br/>\nSingle component views offer a bunch of functionalities to get the number of\nentities they are going to return and a raw access to the entity list as well as\nto the component list. It's also possible to ask a view if it contains a\ngiven entity.<br/>\nRefer to the inline documentation for all the details.\n\nMulti component views iterate entities that have at least all the given\ncomponents in their bags. During construction, these views look at the number of\nentities available for each component and pick up a reference to the smallest\nset of candidates in order to speed up iterations.<br/>\nThey offer fewer functionalities than single component views. In particular,\na multi component view exposes utility functions to get the estimated number of\nentities it is going to return and to know whether it's empty or not. It's also\npossible to ask a view if it contains a given entity.<br/>\nRefer to the inline documentation for all the details.\n\nThere is no need to store views around for they are extremely cheap to\nconstruct, even though they can be copied without problems and reused freely.\nViews also return newly created and correctly initialized iterators whenever\n`begin` or `end` are invoked.\n\nViews share the way they are created by means of a registry:\n\n```cpp\n// single component view\nauto single = registry.view<position>();\n\n// multi component view\nauto multi = registry.view<position, velocity>();\n```\n\nFiltering entities by components is also supported:\n\n```cpp\nauto view = registry.view<position, velocity>(entt::exclude<renderable>);\n```\n\nTo iterate a view, either use it in a range-for loop:\n\n```cpp\nauto view = registry.view<position, velocity>();\n\nfor(auto entity: view) {\n    // a component at a time ...\n    auto &position = view.get<position>(entity);\n    auto &velocity = view.get<velocity>(entity);\n\n    // ... or multiple components at once\n    auto [pos, vel] = view.get<position, velocity>(entity);\n\n    // ...\n}\n```\n\nOr rely on the `each` member function to iterate both entities and components:\n\n```cpp\nregistry.view<position, velocity>().each([](auto entity, auto &pos, auto &vel) {\n    // ...\n});\n```\n\nThe `each` member function is highly optimized. Unless users want to iterate\nonly entities or get only some of the components, this should be the preferred\napproach. Note that the entity can also be excluded from the parameter list if\nnot required, but this won't improve performance for multi component views.<br/>\nThere exists an alternative version of `each` named `less` that works exactly as\nits counterpart but for the fact that it doesn't return empty components.\n\nAs a side note, in the case of single component views, `get` accepts but doesn't\nstrictly require a template parameter, since the type is implicitly defined:\n\n```cpp\nauto view = registry.view<const renderable>();\n\nfor(auto entity: view) {\n    const auto &renderable = view.get(entity);\n    // ...\n}\n```\n\n**Note**: prefer the `get` member function of a view instead of that of a\nregistry during iterations to get the types iterated by the view itself.\n\n## Runtime views\n\nRuntime views iterate entities that have at least all the given components in\ntheir bags. During construction, these views look at the number of entities\navailable for each component and pick up a reference to the smallest\nset of candidates in order to speed up iterations.<br/>\nThey offer more or less the same functionalities of a multi component view.\nHowever, they don't expose a `get` member function and users should refer to the\nregistry that generated the view to access components. In particular, a runtime\nview exposes utility functions to get the estimated number of entities it is\ngoing to return and to know whether it's empty or not. It's also possible to ask\na runtime view if it contains a given entity.<br/>\nRefer to the inline documentation for all the details.\n\nRuntime view are extremely cheap to construct and should not be stored around in\nany case. They should be used immediately after creation and then they should be\nthrown away. The reasons for this go far beyond the scope of this document.<br/>\nTo iterate a runtime view, either use it in a range-for loop:\n\n```cpp\nentt::component types[] = { entt::type_info<position>::id(), entt::type_info<velocity>::id() };\nauto view = registry.runtime_view(std::cbegin(types), std::cend(types));\n\nfor(auto entity: view) {\n    // a component at a time ...\n    auto &position = registry.get<position>(entity);\n    auto &velocity = registry.get<velocity>(entity);\n\n    // ... or multiple components at once\n    auto [pos, vel] = registry.get<position, velocity>(entity);\n\n    // ...\n}\n```\n\nOr rely on the `each` member function to iterate entities:\n\n```cpp\nentt::component types[] = { entt::type_info<position>::id(), entt::type_info<velocity>::id() };\n\nregistry.runtime_view(std::cbegin(types), std::cend(types)).each([](auto entity) {\n    // ...\n});\n```\n\nPerformance are exactly the same in both cases.\n\n**Note**: runtime views are meant for all those cases where users don't know at\ncompile-time what components to use to iterate entities. This is particularly\nwell suited to plugin systems and mods in general. Where possible, don't use\nruntime views, as their performance are slightly inferior to those of the other\nviews.\n\n## Groups\n\nGroups are meant to iterate multiple components at once and to offer a faster\nalternative to multi component views.<br/>\nGroups overcome the performance of the other tools available but require to get\nthe ownership of components and this sets some constraints on pools. On the\nother side, groups aren't an automatism that increases memory consumption,\naffects functionalities and tries to optimize iterations for all the possible\ncombinations of components. Users can decide when to pay for groups and to what\nextent.<br/>\nThe most interesting aspect of groups is that they fit _usage patterns_. Other\nsolutions around usually try to optimize everything, because it is known that\nsomewhere within the _everything_ there are also our usage patterns. However\nthis has a cost that isn't negligible, both in terms of performance and memory\nusage. Ironically, users pay the price also for things they don't want and this\nisn't something I like much. Even worse, one cannot easily disable such a\nbehavior. Groups work differently instead and are designed to optimize only the\nreal use cases when users find they need to.<br/>\nAnother nice-to-have feature of groups is that they have no impact on memory\nconsumption, put aside full non-owning groups that are pretty rare and should be\navoided as long as possible.\n\nAll groups affect to an extent the creation and destruction of their components.\nThis is due to the fact that they must _observe_ changes in the pools of\ninterest and arrange data _correctly_ when needed for the types they own.<br/>\nThat being said, the way groups operate is beyond the scope of this document.\nHowever, it's unlikely that users will be able to appreciate the impact of\ngroups on the other functionalities of a registry.\n\nGroups offer a bunch of functionalities to get the number of entities they are\ngoing to return and a raw access to the entity list as well as to the component\nlist for owned components. It's also possible to ask a group if it contains a\ngiven entity.<br/>\nRefer to the inline documentation for all the details.\n\nThere is no need to store groups around for they are extremely cheap to\nconstruct, even though they can be copied without problems and reused freely.\nA group performs an initialization step the very first time it's requested and\nthis could be quite costly. To avoid it, consider creating the group when no\ncomponents have been assigned yet. If the registry is empty, preparation is\nextremely fast. Groups also return newly created and correctly initialized\niterators whenever `begin` or `end` are invoked.\n\nTo iterate groups, either use them in a range-for loop:\n\n```cpp\nauto group = registry.group<position>(entt::get<velocity>);\n\nfor(auto entity: group) {\n    // a component at a time ...\n    auto &position = group.get<position>(entity);\n    auto &velocity = group.get<velocity>(entity);\n\n    // ... or multiple components at once\n    auto [pos, vel] = group.get<position, velocity>(entity);\n\n    // ...\n}\n```\n\nOr rely on the `each` member function to iterate both entities and components:\n\n```cpp\nregistry.group<position>(entt::get<velocity>).each([](auto entity, auto &pos, auto &vel) {\n    // ...\n});\n```\n\nThe `each` member function is highly optimized. Unless users want to iterate\nonly entities, this should be the preferred approach. Note that the entity can\nalso be excluded from the parameter list if not required and it can improve even\nfurther the performance during iterations.\n\n**Note**: prefer the `get` member function of a group instead of that of a\nregistry during iterations to get the types iterated by the group itself.\n\n### Full-owning groups\n\nA full-owning group is the fastest tool an user can expect to use to iterate\nmultiple components at once. It iterates all the components directly, no\nindirection required. This type of groups performs more or less as if users are\naccessing sequentially a bunch of packed arrays of components all sorted\nidentically, with no jumps nor branches.\n\nA full-owning group is created as:\n\n```cpp\nauto group = registry.group<position, velocity>();\n```\n\nFiltering entities by components is also supported:\n\n```cpp\nauto group = registry.group<position, velocity>(entt::exclude<renderable>);\n```\n\nOnce created, the group gets the ownership of all the components specified in\nthe template parameter list and arranges their pools as needed.\n\nSorting owned components is no longer allowed once the group has been created.\nHowever, full-owning groups can be sorted by means of their `sort` member\nfunctions. Sorting a full-owning group affects all its instances.\n\n### Partial-owning groups\n\nA partial-owning group works similarly to a full-owning group for the components\nit owns, but relies on indirection to get components owned by other groups. This\nisn't as fast as a full-owning group, but it's already much faster than views\nwhen there are only one or two free components to retrieve (the most common\ncases likely). In the worst case, it's not slower than views anyway.\n\nA partial-owning group is created as:\n\n```cpp\nauto group = registry.group<position>(entt::get<velocity>);\n```\n\nFiltering entities by components is also supported:\n\n```cpp\nauto group = registry.group<position>(entt::get<velocity>, entt::exclude<renderable>);\n```\n\nOnce created, the group gets the ownership of all the components specified in\nthe template parameter list and arranges their pools as needed. The ownership of\nthe types provided via `entt::get` doesn't pass to the group instead.\n\nSorting owned components is no longer allowed once the group has been created.\nHowever, partial-owning groups can be sorted by means of their `sort` member\nfunctions. Sorting a partial-owning group affects all its instances.\n\n### Non-owning groups\n\nNon-owning groups are usually fast enough, for sure faster than views and well\nsuited for most of the cases. However, they require custom data structures to\nwork properly and they increase memory consumption. As a rule of thumb, users\nshould avoid using non-owning groups, if possible.\n\nA non-owning group is created as:\n\n```cpp\nauto group = registry.group<>(entt::get<position, velocity>);\n```\n\nFiltering entities by components is also supported:\n\n```cpp\nauto group = registry.group<>(entt::get<position, velocity>, entt::exclude<renderable>);\n```\n\nThe group doesn't receive the ownership of any type of component in this\ncase. This type of groups is therefore the least performing in general, but also\nthe only one that can be used in any situation to slightly improve performance.\n\nNon-owning groups can be sorted by means of their `sort` member functions.\nSorting a non-owning group affects all its instances.\n\n### Nested groups\n\nA type of component cannot be owned by two or more conflicting groups such as:\n\n* `registry.group<transform, sprite>()`.\n* `registry.group<transform, rotation>()`.\n\nHowever, the same type can be owned by groups belonging to the same _family_,\nalso called _nested groups_, such as:\n\n* `registry.group<sprite, transform>()`.\n* `registry.group<sprite, transform, rotation>()`.\n\nFortunately, these are also very common cases if not the most common ones.<br/>\nIt allows to increase performance on a greater number of component combinations.\n\nTwo nested groups are such that they own at least one componet type and the list\nof component types involved by one of them is contained entirely in that of the\nother. More specifically, this applies independently to all component lists used\nto define a group.<br/>\nTherefore, the rules for defining whether two or more groups are nested can be\nsummarized as:\n\n* One of the groups involves one or more additional component types with respect\n  to the other, whether they are owned, observed or excluded.\n\n* The list of component types owned by the most restrictive group is the same or\n  contains entirely that of the others. This also applies to the list of\n  observed and excluded components.\n\nIt means that nested groups _extend_ their parents by adding more conditions in\nthe form of new components.\n\nAs mentioned, the components don't necessarily have to be all _owned_ so that\ntwo groups can be considered nested. The following definitions are fully valid:\n\n* `registry.group<sprite>(entt::get<renderable>)`.\n* `registry.group<sprite, transform>(entt::get<renderable>)`.\n* `registry.group<sprite, transform>(entt::get<renderable, rotation>)`.\n\nExclusion lists also play their part in this respect. When it comes to defining\nnested groups, an excluded component type `T` is treated as being an observed\ntype `not_T`. Therefore, consider these two definitions:\n\n* `registry.group<sprite, transform>()`.\n* `registry.group<sprite, transform>(entt::exclude<rotation>)`.\n\nThey are treated as if users were defining the following groups:\n\n* `group<sprite, transform>()`.\n* `group<sprite, transform>(entt::get<not_rotation>)`.\n\nWhere `not_rotation` is an empty tag present only when `rotation` is not.\n\nBecause of this, to define a new group that is more restrictive than an existing\none, it's enough to take the list of component types of the latter and extend it\nby adding new component types either owned, observed or excluded, without any\nprecautions depending on the case.<br/>\nThe opposite is also true. To define a _larger_ group, it will be enough to take\nan existing one and remove _constraints_ from it, in whatever form they are\nexpressed.<br/>\nNote that the greater the number of component types involved by a group, the\nmore restrictive it is.\n\nDespite the extreme flexibility of nested groups which allow to independently\nuse component types either owned, observed or excluded, the real strength of\nthis tool lies in the possibility of defining a greater number of groups that\n**own** the same components, thus offering the best performance in more\ncases.<br/>\nIn fact, given a list of component types involved by a group, the greater the\nnumber of those owned, the greater the performance of the group itself.\n\nAs a side note, it's no longer possible to sort all groups when defining nested\nones. This is because the most restrictive groups share the elements with the\nless restrictive ones and ordering the latter would invalidate the former.<br/>\nHowever, given a family of nested groups, it's still possible to sort the most\nrestrictive of them. To prevent users from having to remember which of their\ngroups is the most restrictive, they offer the `sortable` member function to\nknow if their items can be sorted or not.\n\n## Types: const, non-const and all in between\n\nThe `registry` class offers two overloads when it comes to constructing views\nand groups: a const version and a non-const one. The former accepts both const\nand non-const types as template parameters, the latter accepts only const types\ninstead.<br/>\nIt means that views and groups can be constructed from a const registry and they\npropagate the constness of the registry to the types involved. As an example:\n\n```cpp\nentt::view<const position, const velocity> view = std::as_const(registry).view<const position, const velocity>();\n```\n\nConsider the following definition for a non-const view instead:\n\n```cpp\nentt::view<position, const velocity> view = registry.view<position, const velocity>();\n```\n\nIn the example above, `view` can be used to access either read-only or writable\n`position` components while `velocity` components are read-only in all\ncases.<br/>\nSimilarly, these statements are all valid:\n\n```cpp\nposition &pos = view.get<position>(entity);\nconst position &cpos = view.get<const position>(entity);\nconst velocity &cpos = view.get<const velocity>(entity);\nstd::tuple<position &, const velocity &> tup = view.get<position, const velocity>(entity);\nstd::tuple<const position &, const velocity &> ctup = view.get<const position, const velocity>(entity);\n```\n\nIt's not possible to get non-const references to `velocity` components from the\nsame view instead and these will result in compilation errors:\n\n```cpp\nvelocity &cpos = view.get<velocity>(entity);\nstd::tuple<position &, velocity &> tup = view.get<position, velocity>(entity);\nstd::tuple<const position &, velocity &> ctup = view.get<const position, velocity>(entity);\n```\n\nThe `each` member functions also propagates constness to its _return values_:\n\n```cpp\nview.each([](auto entity, position &pos, const velocity &vel) {\n    // ...\n});\n```\n\nA caller can still refer to the `position` components through a const reference\nbecause of the rules of the language that fortunately already allow it.\n\nThe same concepts apply to groups as well.\n\n## Give me everything\n\nViews and groups are narrow windows on the entire list of entities. They work by\nfiltering entities according to their components.<br/>\nIn some cases there may be the need to iterate all the entities still in use\nregardless of their components. The registry offers a specific member function\nto do that:\n\n```cpp\nregistry.each([](auto entity) {\n    // ...\n});\n```\n\nIt returns to the caller all the entities that are still in use.<br/>\nAs a rule of thumb, consider using a view or a group if the goal is to iterate\nentities that have a determinate set of components. These tools are usually much\nfaster than combining this function with a bunch of custom tests.<br/>\nIn all the other cases, this is the way to go.\n\nThere exists also another member function to use to retrieve orphans. An orphan\nis an entity that is still in use and has no assigned components.<br/>\nThe signature of the function is the same of `each`:\n\n```cpp\nregistry.orphans([](auto entity) {\n    // ...\n});\n```\n\nTo test the _orphanity_ of a single entity, use the member function `orphan`\ninstead. It accepts a valid entity identifer as an argument and returns true in\ncase the entity is an orphan, false otherwise.\n\nIn general, all these functions can result in poor performance.<br/>\n`each` is fairly slow because of some checks it performs on each and every\nentity. For similar reasons, `orphans` can be even slower. Both functions should\nnot be used frequently to avoid the risk of a performance hit.\n\n## What is allowed and what is not\n\nMost of the _ECS_ available out there don't allow to create and destroy entities\nand components during iterations.<br/>\n`EnTT` partially solves the problem with a few limitations:\n\n* Creating entities and components is allowed during iterations in most cases.\n\n* Deleting the current entity or removing its components is allowed during\n  iterations. For all the other entities, destroying them or removing their\n  components isn't allowed and can result in undefined behavior.\n\nIn these cases, iterators aren't invalidated. To be clear, it doesn't mean that\nalso references will continue to be valid.<br/>\nConsider the following example:\n\n```cpp\nregistry.view<position>([&](const auto entity, auto &pos) {\n    registry.assign<position>(registry.create(), 0., 0.);\n    pos.x = 0.; // warning: dangling pointer\n});\n```\n\nThe `each` member function won't break (because iterators aren't invalidated)\nbut there are no guarantees on references. Use a common range-for loop and get\ncomponents directly from the view or move the creation of components at the end\nof the function to avoid dangling pointers.\n\nIterators are invalidated instead and the behavior is undefined if an entity is\nmodified or destroyed and it's not the one currently returned by the iterator\nnor a newly created one.<br/>\nTo work around it, possible approaches are:\n\n* Store aside the entities and the components to be removed and perform the\n  operations at the end of the iteration.\n\n* Mark entities and components with a proper tag component that indicates they\n  must be purged, then perform a second iteration to clean them up one by one.\n\nA notable side effect of this feature is that the number of required allocations\nis further reduced in most of the cases.\n\n### More performance, more constraints\n\nGroups are a (much) faster alternative to views. However, the higher the\nperformance, the greater the constraints on what is allowed and what is\nnot.<br/>\nIn particular, groups add in some rare cases a limitation on the creation of\ncomponents during iterations. It happens in quite particular cases. Given the\nnature and the scope of the groups, it isn't something in which it will happen\nto come across probably, but it's good to know it anyway.\n\nFirst of all, it must be said that creating components while iterating a group\nisn't a problem at all and can be done freely as it happens with the views. The\nsame applies to the destruction of components and entities, for which the rules\nmentioned above apply.\n\nThe additional limitation pops out instead when a given component that is owned\nby a group is iterated outside of it. In this case, adding components that are\npart of the group itself may invalidate the iterators. There are no further\nlimitations to the destruction of components and entities.<br/>\nFortunately, this isn't always true. In fact, it almost never is and this\nhappens only under certain conditions. In particular:\n\n* Iterating a type of component that is part of a group with a single component\n  view and adding to an entity all the components required to get it into the\n  group may invalidate the iterators.\n\n* Iterating a type of component that is part of a group with a multi component\n  view and adding to an entity all the components required to get it into the\n  group can invalidate the iterators, unless users specify another type of\n  component to use to induce the order of iteration of the view (in this case,\n  the former is treated as a free type and isn't affected by the limitation).\n\nIn other words, the limitation doesn't exist as long as a type is treated as a\nfree type (as an example with multi component views and partial- or non-owning\ngroups) or iterated with its own group, but it can occur if the type is used as\na main type to rule on an iteration.<br/>\nThis happens because groups own the pools of their components and organize the\ndata internally to maximize performance. Because of that, full consistency for\nowned components is guaranteed only when they are iterated as part of their\ngroups or as free types with multi component views and groups in general.\n\n# Empty type optimization\n\nAn empty type `T` is such that `std::is_empty_v<T>` returns true. They are also\nthe same types for which _empty base optimization_ (EBO) is possibile.<br/>\n`EnTT` handles these types in a special way, optimizing both in terms of\nperformance and memory usage. However, this also has consequences that are worth\nmentioning.\n\nWhen an empty type is detected, it's not instantiated in any case. Therefore,\nonly the entities to which it's assigned are made available. All the iterators\nas well as the `get` member functions of the registry, the views and the groups\nwill return temporary objects. Similarly, some functions such as `try_get` or\nthe raw access to the list of components aren't available for this kind of\ntypes. Finally, the `sort` functionality accepts only callbacks that require to\nreturn entities rather than components:\n\n```cpp\nregistry.sort<empty_type>([](const entt::entity lhs, const entt::entity rhs) {\n    return entt::registry::entity(lhs) < entt::registry::entity(rhs);\n});\n```\n\nOn the other hand, iterations are faster because only the entities to which the\ntype is assigned are considered. Moreover, less memory is used, since there\ndoesn't exist any instance of the component, no matter how many entities it is\nassigned to.\n\nFor similar reasons, wherever a function type of a listener accepts a component,\nit cannot be caught by a non-const reference. Capture it by copy or by const\nreference instead.\n\nMore in general, none of the features offered by the library is affected, but\nfor the ones that require to return actual instances.<br/>\nThis optimization can be disabled by defining the `ENTT_DISABLE_ETO` macro. In\nthis case, the empty types will be treated like all other types, no matter what.\n\n# Multithreading\n\nIn general, the entire registry isn't thread safe as it is. Thread safety isn't\nsomething that users should want out of the box for several reasons. Just to\nmention one of them: performance.<br/>\nViews, groups and consequently the approach adopted by `EnTT` are the great\nexception to the rule. It's true that views, groups and iterators in general\naren't thread safe by themselves. Because of this users shouldn't try to iterate\na set of components and modify the same set concurrently. However:\n\n* As long as a thread iterates the entities that have the component `X` or\n  assign and removes that component from a set of entities, another thread can\n  safely do the same with components `Y` and `Z` and everything will work like a\n  charm. As a trivial example, users can freely execute the rendering system and\n  iterate the renderable entities while updating a physic component concurrently\n  on a separate thread.\n\n* Similarly, a single set of components can be iterated by multiple threads as\n  long as the components are neither assigned nor removed in the meantime. In\n  other words, a hypothetical movement system can start multiple threads, each\n  of which will access the components that carry information about velocity and\n  position for its entities.\n\nThis kind of entity-component systems can be used in single threaded\napplications as well as along with async stuff or multiple threads. Moreover,\ntypical thread based models for _ECS_ don't require a fully thread safe registry\nto work. Actually, users can reach the goal with the registry as it is while\nworking with most of the common models.\n\nBecause of the few reasons mentioned above and many others not mentioned, users\nare completely responsible for synchronization whether required. On the other\nhand, they could get away with it without having to resort to particular\nexpedients.\n\n## Iterators\n\nA special mention is needed for the iterators returned by views and groups. Most\nof the times they meet the requirements of random access iterators, in all cases\nthey meet at least the requirements of bidirectional iterators.<br/>\nIn other terms, they are suitable for use with the parallel algorithms of the\nstandard library. If it's not clear, this is a great thing.\n\nAs an example, this kind of iterators can be used in combination with\n`std::for_each` and `std::execution::par` to parallelize the visit and therefore\nthe update of the components returned by a view or a group, as long as the\nconstraints previously discussed are respected:\n\n```cpp\nauto view = registry.view<position, const velocity>();\n\nstd::for_each(std::execution::par_unseq, view.begin(), view.end(), [&view](auto entity) {\n    // ...\n});\n```\n\nThis can increase the throughput considerably, even without resorting to who\nknows what artifacts that are difficult to maintain over time.\n\nUnfortunately, because of the limitations of the current revision of the\nstandard, the parallel `std::for_each` accepts only forward iterators. This\nmeans that the iterators provided by the library cannot return proxy objects as\nreferences and **must** return actual reference types instead.<br/>\nThis may change in the future and the iterators will almost certainly return\nboth the entities and a list of references to their components sooner or later.\nMulti-pass guarantee won't break in any case and the performance should even\nbenefit from it further.\n\n# Beyond this document\n\nThere are many other features and functions not listed in this document.<br/>\n`EnTT` and in particular its ECS part is in continuous development and some\nthings could be forgotten, others could have been omitted on purpose to reduce\nthe size of this file. Unfortunately, some parts may even be outdated and still\nto be updated.\n\nFor further information, it's recommended to refer to the documentation included\nin the code itself or join the official channels to ask a question.\n\n\n",
    "readme_filenames": [
      "./README.md",
      "./docs/md/core.md",
      "./docs/md/entity.md"
    ],
    "github_workflows": {
      ".github/workflows/build.yml": "name: build\n\non: [push, pull_request]\n\njobs:\n\n  linux:\n    timeout-minutes: 10\n\n    strategy:\n      matrix:\n        compiler: [g++, clang++]\n\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v1\n    - name: Compile tests\n      working-directory: build\n      env:\n        CXX: ${{ matrix.compiler }}\n      run: |\n        cmake -DBUILD_TESTING=ON -DBUILD_LIB=ON ..\n        make -j4\n    - name: Run tests\n      working-directory: build\n      env:\n        CTEST_OUTPUT_ON_FAILURE: 1\n      run: ctest --timeout 5 -C Debug -j4\n\n  windows:\n    timeout-minutes: 10\n\n    strategy:\n      matrix:\n        os: [windows-latest, windows-2016]\n        toolset: [clang-cl, default]\n        include:\n          - toolset: clang-cl\n            toolset_option: -T\"ClangCl\"\n        exclude:\n          - os: windows-2016\n            toolset: clang-cl\n\n    runs-on: ${{ matrix.os }}\n\n    steps:\n    - uses: actions/checkout@v1\n    - name: Compile tests\n      working-directory: build\n      run: |\n        cmake -DBUILD_TESTING=ON -DBUILD_LIB=ON ${{ matrix.toolset_option }} ..\n        cmake --build . -j 4\n    - name: Run tests\n      working-directory: build\n      env:\n        CTEST_OUTPUT_ON_FAILURE: 1\n      run: ctest --timeout 5 -C Debug -j4\n\n  macos:\n    timeout-minutes: 10\n    runs-on: macOS-latest\n\n    steps:\n    - uses: actions/checkout@v1\n    - name: Compile tests\n      working-directory: build\n      run: |\n        cmake -DBUILD_TESTING=ON -DBUILD_LIB=ON ..\n        make -j4\n    - name: Run tests\n      working-directory: build\n      env:\n        CTEST_OUTPUT_ON_FAILURE: 1\n      run: ctest --timeout 5 -C Debug -j4\n",
      ".github/workflows/coverage.yml": "name: coverage\n\non: [push, pull_request]\n\njobs:\n\n  codecov:\n    timeout-minutes: 10\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v1\n    - name: Compile tests\n      working-directory: build\n      env:\n        CXXFLAGS: \"-O0 --coverage -fno-inline -fno-inline-small-functions -fno-default-inline\"\n        CXX: g++\n      run: |\n        cmake -DBUILD_TESTING=ON -DBUILD_LIB=ON ..\n        make -j4\n    - name: Run tests\n      working-directory: build\n      env:\n        CTEST_OUTPUT_ON_FAILURE: 1\n      run: ctest --timeout 5 -C Debug -j4\n    - name: Upload coverage to Codecov\n      working-directory: build\n      env:\n        CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}\n      run: |\n        wget https://codecov.io/bash -O codecov\n        chmod +x codecov\n        ./codecov -t $CODECOV_TOKEN -B $GITHUB_REF -s test/\n"
    }
  },
  "llm_calls_before_build": 30,
  "github_workflows_found": [
    ".github/workflows/build.yml",
    ".github/workflows/coverage.yml"
  ],
  "dockerfile_attempt_1": 1,
  "dockerfile": "FROM ubuntu:22.04\n\n# Install system dependencies and tools\nRUN apt-get update && \\\n    DEBIAN_FRONTEND=noninteractive apt-get install -y \\\n    build-essential \\\n    cmake \\\n    git \\\n    ca-certificates \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Clone repository and checkout specific commit from the issue\nRUN git clone https://github.com/skypjack/entt.git /entt\nWORKDIR /entt\nRUN git checkout 210eebc0dc967f65d48a75f10ff05e766f20c638\n\n# Create build directory and configure project\nWORKDIR /entt/build\nRUN cmake -DENTT_BUILD_TESTING=ON -DENTT_BUILD_LIB=ON ..\n\n# Build project with all available cores\nRUN cmake --build . -- -j$(nproc)",
  "dockerfile_build_success": true,
  "successful_candidate_index": 1,
  "successful_candidate_attempt": 1,
  "successful_candidate_improvement_attempt": 0,
  "llm_calls_total": 35
}