[
  {
    "number": 7991,
    "title": "Setting RequestContext by IIncomingGrainCallFilter from a gRPC service",
    "created_at": "2022-09-22T17:10:05Z",
    "closed_at": "2022-09-22T22:32:28Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7991",
    "body": "As far as I understood correctly, when RequestContext.Set is called the given metadata is passed to every grain method call from that point automatically. What is not clear for me in the docs whether the same metadata is being passed to another grain if that is created using GrainFactory.GetGrain<>() during a call that has the metadata passed to already by the mentioned mechanism.\r\n\r\nThe metadata I need to pass is a context identifier that can be used to identify the user and other contextual info. I would use the grain filter mechanism (IIncomingGrainCallFilter) for the purpose. However, I do not know how to pass the required information to the filter.\r\n\r\nI use a gRPC service endpoint that gets the IClusterClient from service provider, then creates a grain and calls some of its methods. The context information that I would like to set to the RequestContext comes from the ServerCallContext parameter of the gRPC method. These 3 (service endpoint, grain filter, grain) could run in different threads, I presume. The filter is instantiated by Orleans so I have no control over its life cycle.  As I experienced it is created as a singleton, no matter how I register it in the DI container.\r\n\r\nWhat is the suggested way of passing data to the grain filter?\r\nIn which thread is the Invoke method called? Can I use some thread synchronization mechanism to communicate between the gRPC method and the grain filter?\r\n\r\nAny suggestions are appreciated. Thank you.\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7991/comments",
    "author": "danielleiszen",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2022-09-22T19:14:58Z",
        "body": "Thanks for the question, @danielleiszen.\r\n\r\n`GrainFactory.GetGrain<T>(...)` does not create a grain, it just creates a reference to a grain (think of it like creating a URI, but with a type). \r\n\r\nThe `RequestContext` is async-local, which means that it will flow along your async calls. So, to implement what you want, you should propagate the `ServerCallContext` to the `RequestContext` in your gRPC server method bodies. I'm not sure what a grain call filter would be necessary for here, unless you have some other ambient context which you could access from there to flow to `RequestContext`.\r\n\r\nDoes that answer it?"
      },
      {
        "user": "danielleiszen",
        "created_at": "2022-09-22T22:32:28Z",
        "body": "Thank you for your fast reply @ReubenBond \r\n\r\nYes that's clarifies everything. Now I just had to call RequestContext.Set from outside all grain code in my gRPC method body and all the subsequent grain method calls could use the given metadata.\r\n\r\nThank you for your help. This issue can be closed."
      }
    ]
  },
  {
    "number": 7957,
    "title": "Cannot transform data from IEnumerable between two assemblies",
    "created_at": "2022-08-31T10:55:00Z",
    "closed_at": "2022-09-01T23:02:56Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered",
      "Status: Resolved"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7957",
    "body": "Hi! I have two services and one of them take a Grain which was specified in another service. So after i take it we execute method which shold return class object with fields smth like that\r\n```\r\nclass Person{\r\npublic string Name{get;set;}\r\npublic IEnumerable<Children> ChildrenList {get;set;}\r\n. . .\r\n}\r\n```\r\nAfter method execution we handle the break point in another service where we calculating that data in IEnumerable (we have local function that makes some calculations). Like this\r\n\r\n```\r\npublic class PeopleHandler{\r\npublic async Task ExecuteAsync(personName){\r\nvar name = _context.People.First(_ => _.Name == personName);\r\nvar children = GetChildren(name);\r\n\r\nreturn new Person(name, childrens)\r\n\r\nIEnumerable GetChildren (string personName){\r\nvar children =  _context.GetChildren.Select(. . .) . . .\r\n\r\n return children;\r\n }\r\n}\r\n}\r\n```\r\n\r\nAttention. We don't use ToList() at the end. We handle it like that to another service. So we execute method \r\n\r\n```\r\npublic async Task GetPersonInformation (personName){\r\n  var peopleHandler = _client.GetGrain<PeopleHandler>(grainId);\r\n  var person = await peopleHandler.ExecuteAsync(personName);\r\n\r\n var childrens = person.ChildrenList.ToList() // or any other method that makes programm to calculate data 'First() etc.'\r\n}\r\n```\r\n\r\nAfter that we got an exception about NullReferenceException in Children. We can't calculate data between services. I decided to make it ToList() before we return data from the ExecuteAsync method and i got a result but what was the reason of that? If it wasn't a local function i understand that private functions can be not visible in first assembly but this is local function and we need to know everything about public method including it's private methods inside of it. So i changed return Type of GetChildren and got my result. What do you think?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7957/comments",
    "author": "NikitaPozharskyi",
    "comments": [
      {
        "user": "mnmr",
        "created_at": "2022-09-01T08:45:47Z",
        "body": "When you call a method on a grain, the data (objects) get serialized into a stream of bytes. These bytes are then sent over the network to the receiving grain, where the objects are re-created. However, if you do not call ToList() before sending the data, there is no data to send (because LINQ lazy-evaluates the query).\r\n\r\nAs a general recommendation, use concrete types (i.e. List<T> instead of IList<T> or IEnumerable<T>) when passing data between grains. This avoids surprises and is more explicit than relying on the serialization logic to automagically do the right thing."
      },
      {
        "user": "NikitaPozharskyi",
        "created_at": "2022-09-01T09:00:46Z",
        "body": "> When you call a method on a grain, the data (objects) get serialized into a stream of bytes. These bytes are then sent over the network to the receiving grain, where the objects are re-created. However, if you do not call ToList() before sending the data, there is no data to send (because LINQ lazy-evaluates the query).\r\n> \r\n> As a general recommendation, use concrete types (i.e. List instead of IList or IEnumerable) when passing data between grains. This avoids surprises and is more explicit than relying on the serialization logic to automagically do the right thing.\r\n\r\nThanks for your message! I thought in that way too so i resolved that pretty fast so I just want to be sure that is working like that"
      }
    ]
  },
  {
    "number": 7688,
    "title": "Calling IGrainFactory.GetGrain<T>(pk) from constructor is a bad practice ?",
    "created_at": "2022-04-14T03:49:37Z",
    "closed_at": "2022-04-14T18:40:53Z",
    "labels": [
      "question",
      ":heavy_check_mark: Resolution: Answered"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7688",
    "body": "I'm doing some experiments with the Orleans.\r\n\r\nI tried to find the answer but i could not...\r\n\r\nIs it a bad idea reusing another grain gathered from the constructor like this ?\r\n\r\n```csharp\r\npublic class MainGrain : Grain, IMainGrain\r\n{\r\n    private readonly IOtherGrain _otherGrain;\r\n\r\n    public MainGrain(IGrainActivationContext context, IGrainFactory grainFactory) \r\n    {\r\n        _otherGrain = grainFactory.GetGrain<IOtherGrain>(context.GrainIdentity.PrimaryKeyString);\r\n    }\r\n\r\n    public ValueTask<Item> GetCurrentValue() =>\r\n        _otherGrain.GetItem();\r\n\r\n   //others methods here\r\n}\r\n````\r\n\r\nMainGrain stay in memory longer then IOtherGrain... (Calling GetCurrentValue() may call a already collected grain)",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7688/comments",
    "author": "fernandozago",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2022-04-14T03:53:19Z",
        "body": "It's fine to call GetGrain in the grain's constructor.\r\n\r\nGetGrain doesn't return the grain itself, just a reference to it. It's similar to a URL or a typed HttpClient wrapper. It's a fast, synchronous operation and doesn't perform any IO."
      },
      {
        "user": "fernandozago",
        "created_at": "2022-04-14T03:55:43Z",
        "body": "> It's fine to call GetGrain in the grain's constructor.\r\n> \r\n> GetGrain doesn't return the grain itself, just a reference to it. It's similar to a URL or a typed HttpClient wrapper. It's a fast, synchronous operation and doesn't perform any IO.\r\n\r\nThanks for the quick reply!\r\n\r\nEven if the `OtherGrain` eventually gets `Deactivated`, it should reactivate again when i call `GetItem()` ?\r\n\r\nThank you @ReubenBond "
      },
      {
        "user": "ReubenBond",
        "created_at": "2022-04-14T03:57:18Z",
        "body": "That's exactly right, Orleans will make sure to activate it on-demand for you"
      }
    ]
  },
  {
    "number": 7073,
    "title": "[Question]: Difference between MemoryStreams and SimpleMessageStreamProvider",
    "created_at": "2021-05-08T13:43:04Z",
    "closed_at": "2021-09-03T14:38:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/7073",
    "body": "Hi;\r\nWhat is the difference between SimpleMessageStreamProvider and MemoryStreams? \r\nThe guide document only mentions SMS and there is no explanation for MemoryStreams.\r\nWhere can I study the difference between them?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/7073/comments",
    "author": "doctorcode-org",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2021-09-02T20:50:29Z",
        "body": "Hi @doctorcode-org, the difference is roughly this:\r\n\r\nSMS (Simple Message Stream Provider) uses direct grain messaging from the producers of a message to all consumers.\r\nMemoryStream uses an in-memory buffer to decouple producers and consumers.\r\n\r\nBoth should be considered *best efforts* as neither uses persistent storage to store messages.\r\nI hope that helps.\r\n\r\ncc @benjaminpetit are we missing documentation here?"
      },
      {
        "user": "doctorcode-org",
        "created_at": "2021-09-03T03:57:33Z",
        "body": "Hi @ReubenBond \r\nThank you so much. Your explanation was excellent and helped me a lot. "
      }
    ]
  },
  {
    "number": 6368,
    "title": "Explanation regarding IAsyncStream<T>.GetAllSubscriptionHandles()",
    "created_at": "2020-02-28T13:47:26Z",
    "closed_at": "2020-03-09T11:39:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/6368",
    "body": "Hi,\r\n\r\nI am working on the subscription logic in our app to ensure that I resubscribe to a stream instead of creating a new handle each time (whenever possible).\r\nWhat I expected from the `IAsyncStream<T>.GetAllSubscriptionHandles()` function is to return the handles for a given grain type + primary key. Since we're only subscribing once to each stream in our grains, I assumed that I should only have one handle in the list (if a previous subscription already existed obviously) and that I could reuse it to resubscribe.\r\n\r\nBut after a few tests, I realized that different activations of a grain were retrieving the handles from other activations too.\r\n\r\nSo I decided to test this pattern in a sample project, and I couldn't reproduce it. In the end, when I created two activations of a grain, `IAsyncStream<T>.GetAllSubscriptionHandles()` only retrieved the handles for each specific activation (which is the pattern I expected). So I gave a look at the JSON payload and I noticed a few differences between my main and my test projects.\r\n\r\nHere is the JSON of my test project :\r\n```json\r\n{\r\n  \"$id\": \"1\",\r\n  \"$type\": \"Orleans.Streams.PubSubGrainState, Orleans.Runtime\",\r\n  \"Producers\": {\r\n    \"$type\": \"System.Collections.Generic.HashSet`1[[Orleans.Streams.PubSubPublisherState, Orleans.Core]], System.Collections\",\r\n    \"$values\": []\r\n  },\r\n  \"Consumers\": {\r\n    \"$type\": \"System.Collections.Generic.HashSet`1[[Orleans.Streams.PubSubSubscriptionState, Orleans.Core]], System.Collections\",\r\n    \"$values\": [\r\n      {\r\n        \"$id\": \"2\",\r\n        \"$type\": \"Orleans.Streams.PubSubSubscriptionState, Orleans.Core\",\r\n        \"Stream\": {\r\n          \"$id\": \"3\",\r\n          \"$type\": \"Orleans.Streams.StreamId, Orleans.Core\",\r\n          \"Guid\": \"79dd573a-efc3-4e3a-9957-3f0b7452d51a\",\r\n          \"ProviderName\": \"SMS\",\r\n          \"Namespace\": \"test\"\r\n        },\r\n        \"SubscriptionId\": {\r\n          \"$id\": \"4\",\r\n          \"$type\": \"Orleans.Runtime.GuidId, Orleans.Core.Abstractions\",\r\n          \"Guid\": \"f0b37117-16db-4cf1-9cf6-3373740aaf22\"\r\n        },\r\n        \"consumerReference\": {\r\n          \"$type\": \"Orleans.Streams.OrleansCodeGenStreamConsumerExtensionReference, Orleans.Core\",\r\n          \"GrainId\": \"0000000000000000000000000000000103ffffffc024bd45\",\r\n          \"GenericArguments\": \"\"\r\n        }\r\n      },\r\n      {\r\n        \"$id\": \"5\",\r\n        \"$type\": \"Orleans.Streams.PubSubSubscriptionState, Orleans.Core\",\r\n        \"Stream\": {\r\n          \"$ref\": \"3\"\r\n        },\r\n        \"SubscriptionId\": {\r\n          \"$id\": \"6\",\r\n          \"$type\": \"Orleans.Runtime.GuidId, Orleans.Core.Abstractions\",\r\n          \"Guid\": \"99a2600d-c107-4485-a05f-1fcd51e15c7c\"\r\n        },\r\n        \"consumerReference\": {\r\n          \"$type\": \"Orleans.Streams.OrleansCodeGenStreamConsumerExtensionReference, Orleans.Core\",\r\n          \"GrainId\": \"0000000000000000000000000000000203ffffffc024bd45\",\r\n          \"GenericArguments\": \"\"\r\n        }\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\nEach subscription has a different `GrainId`, one for the activation with `1` as the primary key, and `2` for the other.\r\n\r\nHere is the one from my main project :\r\n```json\r\n{\r\n  \"$id\": \"1\",\r\n  \"$type\": \"Orleans.Streams.PubSubGrainState, Orleans.Runtime\",\r\n  \"Producers\": {\r\n    \"$type\": \"System.Collections.Generic.HashSet`1[[Orleans.Streams.PubSubPublisherState, Orleans.Core]], System.Collections\",\r\n    \"$values\": [\r\n      {\r\n        \"$id\": \"2\",\r\n        \"$type\": \"Orleans.Streams.PubSubPublisherState, Orleans.Core\",\r\n        \"Stream\": {\r\n          \"$id\": \"3\",\r\n          \"$type\": \"Orleans.Streams.StreamId, Orleans.Core\",\r\n          \"Guid\": \"6395d740-6e55-11e8-b566-0800200c9a66\",\r\n          \"ProviderName\": \"SMS\",\r\n          \"Namespace\": \"M7.Heartbeat\"\r\n        },\r\n        \"producerReference\": {\r\n          \"$type\": \"Orleans.Streams.OrleansCodeGenStreamProducerExtensionReference, Orleans.Core\",\r\n          \"GrainId\": \"450a8ec3eeba4965f566fb006ede70950400000000000000\",\r\n          \"ObserverId\": \"23706d43-baaf-4a48-8301-4d6a767e0a82\",\r\n          \"GenericArguments\": \"\"\r\n        }\r\n      }\r\n    ]\r\n  },\r\n  \"Consumers\": {\r\n    \"$type\": \"System.Collections.Generic.HashSet`1[[Orleans.Streams.PubSubSubscriptionState, Orleans.Core]], System.Collections\",\r\n    \"$values\": [\r\n      {\r\n        \"$id\": \"4\",\r\n        \"$type\": \"Orleans.Streams.PubSubSubscriptionState, Orleans.Core\",\r\n        \"Stream\": {\r\n          \"$ref\": \"3\"\r\n        },\r\n        \"SubscriptionId\": {\r\n          \"$id\": \"5\",\r\n          \"$type\": \"Orleans.Runtime.GuidId, Orleans.Core.Abstractions\",\r\n          \"Guid\": \"75abe7f9-390f-4ce1-a26a-67d1cc028c2b\"\r\n        },\r\n        \"consumerReference\": {\r\n          \"$type\": \"Orleans.Streams.OrleansCodeGenStreamConsumerExtensionReference, Orleans.Core\",\r\n          \"GrainId\": \"450a8ec3eeba4965f566fb006ede70950400000000000000\",\r\n          \"ObserverId\": \"583016d5-3639-43e5-885b-5aa6b32c9df7\",\r\n          \"GenericArguments\": \"\"\r\n        }\r\n      },\r\n      {\r\n        \"$id\": \"6\",\r\n        \"$type\": \"Orleans.Streams.PubSubSubscriptionState, Orleans.Core\",\r\n        \"Stream\": {\r\n          \"$ref\": \"3\"\r\n        },\r\n        \"SubscriptionId\": {\r\n          \"$id\": \"7\",\r\n          \"$type\": \"Orleans.Runtime.GuidId, Orleans.Core.Abstractions\",\r\n          \"Guid\": \"a2338aff-2ef7-4acd-bef9-ee37c6488718\"\r\n        },\r\n        \"consumerReference\": {\r\n          \"$type\": \"Orleans.Streams.OrleansCodeGenStreamConsumerExtensionReference, Orleans.Core\",\r\n          \"GrainId\": \"450a8ec3eeba4965f566fb006ede70950400000000000000\",\r\n          \"ObserverId\": \"583016d5-3639-43e5-885b-5aa6b32c9df7\",\r\n          \"GenericArguments\": \"\"\r\n        }\r\n      },\r\n      {\r\n        \"$id\": \"8\",\r\n        \"$type\": \"Orleans.Streams.PubSubSubscriptionState, Orleans.Core\",\r\n        \"Stream\": {\r\n          \"$ref\": \"3\"\r\n        },\r\n        \"SubscriptionId\": {\r\n          \"$id\": \"9\",\r\n          \"$type\": \"Orleans.Runtime.GuidId, Orleans.Core.Abstractions\",\r\n          \"Guid\": \"a25178cd-61ec-4fa1-bd31-2803033b3142\"\r\n        },\r\n        \"consumerReference\": {\r\n          \"$type\": \"Orleans.Streams.OrleansCodeGenStreamConsumerExtensionReference, Orleans.Core\",\r\n          \"GrainId\": \"450a8ec3eeba4965f566fb006ede70950400000000000000\",\r\n          \"ObserverId\": \"583016d5-3639-43e5-885b-5aa6b32c9df7\",\r\n          \"GenericArguments\": \"\"\r\n        }\r\n      },\r\n      {\r\n        \"$id\": \"10\",\r\n        \"$type\": \"Orleans.Streams.PubSubSubscriptionState, Orleans.Core\",\r\n        \"Stream\": {\r\n          \"$ref\": \"3\"\r\n        },\r\n        \"SubscriptionId\": {\r\n          \"$id\": \"11\",\r\n          \"$type\": \"Orleans.Runtime.GuidId, Orleans.Core.Abstractions\",\r\n          \"Guid\": \"3aad6d49-6792-4bd2-b6a2-3c7320afa268\"\r\n        },\r\n        \"consumerReference\": {\r\n          \"$type\": \"Orleans.Streams.OrleansCodeGenStreamConsumerExtensionReference, Orleans.Core\",\r\n          \"GrainId\": \"450a8ec3eeba4965f566fb006ede70950400000000000000\",\r\n          \"ObserverId\": \"583016d5-3639-43e5-885b-5aa6b32c9df7\",\r\n          \"GenericArguments\": \"\"\r\n        }\r\n      },\r\n      {\r\n        \"$id\": \"12\",\r\n        \"$type\": \"Orleans.Streams.PubSubSubscriptionState, Orleans.Core\",\r\n        \"Stream\": {\r\n          \"$ref\": \"3\"\r\n        },\r\n        \"SubscriptionId\": {\r\n          \"$id\": \"13\",\r\n          \"$type\": \"Orleans.Runtime.GuidId, Orleans.Core.Abstractions\",\r\n          \"Guid\": \"35820dd5-adb6-4ce2-bf01-c7af0ff90a43\"\r\n        },\r\n        \"consumerReference\": {\r\n          \"$type\": \"Orleans.Streams.OrleansCodeGenStreamConsumerExtensionReference, Orleans.Core\",\r\n          \"GrainId\": \"450a8ec3eeba4965f566fb006ede70950400000000000000\",\r\n          \"ObserverId\": \"583016d5-3639-43e5-885b-5aa6b32c9df7\",\r\n          \"GenericArguments\": \"\"\r\n        }\r\n      },\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\nI have a few more activations subscribing to the same topic, but here is the thing : Every subscription has the same `GrainId` + an `ObserverId` which is also the same every time. I guess then this is why the `IAsyncStream<T>.GetAllSubscriptionHandles()` function returns all the handles everytime, but the thing is that these subscriptions are made in different activations and even in different grains.\r\nThis main project has a bit of a different pattern than my test one, especially regarding which class actually do the subscription, etc. But even when trying to reapply this pattern, I am not able to have that `ObserverId` in the JSON.\r\n\r\nEDIT : There is one thing that I forgot to mention and which seems to make a difference : The streams for which GrainId is always the same + there is an observer id, are streams that were created (and for which producers) are within a nugget package that is referenced in our main project. I don't see why this would make things behave differently, but I have been able to reproduce the pattern by subscribing with a simple client to streams in that nugget, whereas all the other streams in my app do have a different GrainId + no observerId.\r\n\r\nSo my questions are :\r\n- First of all, do I misinterpret how  `IAsyncStream<T>.GetAllSubscriptionHandles()`  should be working ?\r\n- What is the signification of that `ObserverId` inside the JSON payload ?\r\n- What could make different grains, and different activations have the same ids inside that JSON ?\r\n\r\nThank you in advance for your help.\r\n\r\nRegards,\r\nNicolas",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/6368/comments",
    "author": "DiAifU",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2020-03-05T22:51:06Z",
        "body": "I'm a bit confused by the terminology here. When you say \"a grain activation\" I *think* you actually mean \"a grain\" as a grain with a unique key withing the grain class. Is this correct? We use the term \"grain activation\" for a different purpose, to mean \"instantiation of a grain at a certain point in time.\"\r\n\r\nThe scope of stream subscription is indeed the grain. So, when a grain calls `GetAllSubscriptionHandles()`, it receives only the its own subscriptions. There's also a way to subscribe on behalf of a grain, but I'll leave it out for now for simplicity.\r\n\r\n`ObserverId` is for client observers. Do you have clients producing events to or consuming them from the streams?"
      },
      {
        "user": "DiAifU",
        "created_at": "2020-03-06T00:24:42Z",
        "body": "Hi,\r\nSorry about the confusion, I am indeed talking about a grain with a unique key when I was using \u00ab\u00a0grain activation\u00a0\u00bb.\r\nSo in this case, let\u2019s say I have a grain A (class name), with a primary key 1, producing on a stream with guid a-a-a-a, and grains B with different primary keys (1 to 10 for example), consuming that  a-a-a-a stream, should each B grain get 1 handle if they subscribe once, or get all the handles ?\r\n \r\nBecause depending on whether I run my test project or my main project, I seem to have different results.\r\n\r\nRegarding `ObserverId`, these specific streams have only grains producing and consuming them within the silo. No client is subscribed to these streams"
      },
      {
        "user": "sergeybykov",
        "created_at": "2020-03-06T00:31:19Z",
        "body": ">should each B grain get 1 handle if they subscribe once, or get all the handles ?\r\n\r\nEach grain would get only its own handle. Unless it subscribes more than once to the same stream, which is also supported."
      },
      {
        "user": "DiAifU",
        "created_at": "2020-03-06T00:39:33Z",
        "body": "And my problem is here. As you can see in the second json within my first post, each consumer seems to be from the same grain, but it is not. It's actually from different grains, and whenever I call `GetAllSubscriptionHandles()` from one of these grains, I also get the handles from the others."
      },
      {
        "user": "sergeybykov",
        "created_at": "2020-03-06T03:43:33Z",
        "body": "I'm not sure I understand. All consumers seem to have the same GrainId - `450a8ec3eeba4965f566fb006ede70950400000000000000`."
      },
      {
        "user": "DiAifU",
        "created_at": "2020-03-06T07:38:13Z",
        "body": "This is what I see too, but to build this JSON, I actually subscribed from different grains"
      },
      {
        "user": "sergeybykov",
        "created_at": "2020-03-06T19:17:06Z",
        "body": "Could this JSON be from a different case? Unless I'm missing something, it shows 5 subscriptions from the same grain - `450a8ec3eeba4965f566fb006ede70950400000000000000`. `ObserverId` confuses me. This looks as if these are for client subscriptions.\r\n\r\n/cc @jason-bragg in case he has a different insight."
      },
      {
        "user": "jason-bragg",
        "created_at": "2020-03-06T22:53:04Z",
        "body": "Is it possible that the test code is running the subscription logic outside of the grain's context?  I ask because that used to cause an error, but we added support for grain calls to be called from outside grains, which may also allow subscription creation from outside the context.  If this was done then all of the subscriptions from outside the grain context would all look like they are from the same grain.\r\n\r\nSubscribing to a stream from outside a grain context (unless through the client) is not supported, but it may be doing the wrong thing instead of failing, due to the change.  Please check storage and see what the pubsub state is for that stream.  If the grain ID in the pubsub is not the same as it should be it may be the ID of the system target that handles the grain calls made when outside the grain context instead of the grain the subscribe logic lives in."
      },
      {
        "user": "DiAifU",
        "created_at": "2020-03-09T11:39:40Z",
        "body": "That was exactly it, I made sure to stay in the orleans context for the grains calls, but not the subscriptions. It definitly fixed my problem, thank you for your help !"
      }
    ]
  },
  {
    "number": 6129,
    "title": "[Question] Possible integration scenario using Event Hub streaming",
    "created_at": "2019-11-18T20:31:44Z",
    "closed_at": "2019-11-25T07:17:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/6129",
    "body": "Hello all,\r\n\r\nI was able to find a couple of topics around Orleans Streaming + Event Hub, but I haven't been able to find something around the scenario that I've just tried.\r\n\r\nI'd like to integrate a couple of applications and I'd like to take advantage of the rewindable streaming support from Orleans+Event Hub. Direct connection between those products is not doable, but the following setup seems to work fine. \r\n\r\nIf each application bootstraps their own localhost silo and configure the same Event Hub stream provider, they will be able to pass events between each other, maintain their own cursor, or if I start a new silo and create a new subscriber, it will just ingest everything until it catches up. Fortunately, this is exactly what I need.\r\n\r\nAm I missing something? Is this a valid approach? What are the possible issues I can get into (from the Orleans standpoint/Event Hub standpoint)?\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/6129/comments",
    "author": "cosmintiru",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2019-11-20T04:38:57Z",
        "body": "As I understand, you are looking to connect two Orleans-based applications via EventHub streams. If that's indeed the case, I don't see a problem with your approach. It's the easiest case when events are produced to and consumed from streams by Orleans.\r\n\r\nA more elaborate case is when either producer or consumer of event is non-Orleans code. In that case one has to take care of formatting the event data, so that it would be correctly interpreted by both sides."
      },
      {
        "user": "cosmintiru",
        "created_at": "2019-11-25T07:17:22Z",
        "body": "Thank you @sergeybykov , from my point of view this can be closed. "
      }
    ]
  },
  {
    "number": 5969,
    "title": "Is it safe to inject ITimerRegistry using DI?",
    "created_at": "2019-09-23T17:02:33Z",
    "closed_at": "2019-09-27T20:33:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5969",
    "body": "Hi everyone!\r\n\r\nI found out that there is `Orleans.Timers.ITimerRegistry` interface, which is injectable as a service using DI.\r\n\r\nSuppose we have `FooGrain`, `BarService` and `ITimerRegistry`:\r\n\r\n```\r\npublic class FooGrain : Grain\r\n{\r\n    private readonly BarService _barService;\r\n\r\n    public FooGrain(BarService barService)\r\n    {\r\n        _barService = barService;\r\n    }\r\n\r\n    public Task DoFoo()\r\n    {\r\n        _barService.DoBar();\r\n\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n\r\npublic class BarService\r\n{\r\n    private readonly ITimerRegistry _timerRegistry;\r\n\r\n    public BarService(ITimerRegistry timerRegistry)\r\n    {\r\n        _timerRegistry = timerRegistry;\r\n    }\r\n\r\n    public void DoBar()\r\n    {\r\n        _timerRegistry.RegisterTimer(\r\n            grain: null,\r\n            asyncCallback: _ =>\r\n            {\r\n                Console.WriteLine(nameof(DoBar));\r\n                return Task.CompletedTask;\r\n            },\r\n            state: null,\r\n            dueTime: TimeSpan.FromSeconds(1),\r\n            period: TimeSpan.FromSeconds(10)\r\n        );\r\n    }\r\n}\r\n```\r\n\r\nAs you can see, I've passed `null` as a `grain` parameter to `ITimerRegistry.RegisterTimer`, and it still works, the timer does tick.\r\n\r\nMy question is: is it safe? I AFAIR timers are participants of grain messaging system and are alvays scheduled with Orleans scheduler.\r\n\r\nBut if I passed `null` as a grain, what schedule does they participate? Can I be sure that timers, that were created in the way I've shown above, are scheduling in the correct way and never run concurrently with other tasks?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5969/comments",
    "author": "vyshkant",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2019-09-24T02:40:24Z",
        "body": "Users are not supposed to interact directly with `ITimerRegistry` but it's possible to inject it and use it. I would recommend that you do not pass `null` for the grain since that will *not* produce valid behavior. You must have an instance of the grain to register the timer for, otherwise the timer will not be associated with any grain and will be scheduled on a null context"
      }
    ]
  },
  {
    "number": 5882,
    "title": "Reminders spinning up on silos with different clusterId",
    "created_at": "2019-08-21T20:05:13Z",
    "closed_at": "2019-08-23T14:15:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5882",
    "body": "Hi, I have an orleans setup where we have different silos with different clusterId's (staging, dev, prod, etc). I noticed that every now and then a reminder that was created on staging would spin up in dev silos.\r\n\r\nI am using AdoNetReminderService with SQL Server, when I looked at the ReminderTable, I noticed that it only had ServiceId as the column, no reference to ClusterId, so I changed all of the silos to have different serviceId's to prevent the issue. However, it was brought to my attention that the Orleans documentation recommends keeping all of the ServiceId's of the silos the same. Am I missing anything? Are reminders supposed to be able to distinguish between silos with different clusterId's even with same ServiceId's?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5882/comments",
    "author": "TulkasLaugh",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2019-08-21T21:40:59Z",
        "body": "`ServiceId` acts as a high-level application ID. It stays the same over time through multiple subsequent versions of the application (clusters) getting deployed one after another. Hence, application state that needs continuity through those deployments id keyed off `ServiceId`. Reminders and grain state are examples of that.\r\n\r\n`ClusterId` is a unique ID for a set of silos (cluster) running at some point in time. Typically, only one cluster is up at a time for any `ServiceId`. `ClusterId` is used for silos and clients to discover each other.\r\n\r\nYou likely want to use different `ServiceId`s for staging, dev, and prod clusters, and for sure a unique `ClusterId` for each of them."
      }
    ]
  },
  {
    "number": 5797,
    "title": "How to structure Grains for fast loading of historical data?",
    "created_at": "2019-07-29T22:53:45Z",
    "closed_at": "2019-09-20T04:48:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5797",
    "body": "Hello and thanks for building such an incredible framework. I\u2019m beginning the process of sorting out how to leverage Orleans in a major revision of a project that I work on and have several high level questions that I\u2019m hoping to receive some guidance on so I can avoid starting down the wrong path. If there is a better place or way to ask these questions, I\u2019d be happy to change venues. Also, since I feel that an example application to tie together some of these concepts would help me personally as well as other newcomers in the IoT space I am very interested in contributing an example/quick start once I have a solid path to head down.\r\n\r\nThe platform that I\u2019m working on handles the dispatching of work to drivers with the complexity that it is a multi-tenant application so we need to ensure each organization\u2019s data is exclusive to their users and tablets. We currently provide this by putting each tenant\u2019s data in their own SQL DB that only their users have access to (every tenant has a connection string to the correct DB). The dispatchers are using a windows desktop back office application with a companion ReactJS web app for viewing realtime/historical locations and the drivers are using an Android tablet app. We currently tie this all together with a blend of RESTish (there\u2019s some RPC endpoints in it too) WebAPI that makes heavy use of Azure Event Hubs for incoming data from the tablets (processing happens in windows services that are subscribed to the hubs something that we want to move to Orleans), uses SignalR for pushing realtime data to the browser, and loads most things out of each tenant\u2019s SQL DB (which are not all in the same datacenter as the API).\r\n\r\nSo now that the \u201cwhat\u201d of what I\u2019m trying to improve is out of the way, where I need help is how we\u2019re going to best utilize Orleans to improve our API. Using Orleans for the basic activity of the application feels really straight forward (although perhaps I\u2019m over simplifying it) in that we can easily assign a Job to a Driver and trigger a push notification to the Device that the driver is using. When data comes in from a Device we can use an Event Hub based stream to queue the processing of its data and push the new location to the web app in realtime with SignalR. The challenging part for me is how to structure all this so that historical data can be easily and quickly retrieved as well as avoid packing too much data into a single Grain.\r\n\r\nAn example of this is that dispatchers may want to see the path a driver traveled to get to a job. Currently we load that data from the tenant\u2019s DB and I would assume that is still the best way to handle it since loading data for a single driver is relatively quick. Where performance becomes challenging is loading the location of all devices from a particular point in time. Would it be reasonable to have a `ITenantGrain.LoadDeviceLocationAsOf(DateTime time)` that returns a list of all devices with their last known location at that point in time? If so, what is the recommendation for implementing something like that? Would it work to asyncly iterate through all the devices asking each of them to figure out where they where (there can be 100 - 1000ish devices per tenant)? We currently make this perform reasonably well by constantly building per-minute time windowed data for each tenant that is persisted separately so we can grab the time window that holds the locations we\u2019re looking for. This is expensive from a storage standpoint so we trash the time windows after 7 days and queries for older data become slow. This feels like an area of our application that we should be able to improve with the power of Orleans, but I\u2019m struggling to come up with an architecture that feels like a winner (likely because my optics are based in the way we\u2019ve already solved it). If the pre-calculated time windows are still the best bet, is there an example out there of how to do this in Orleans (essentially a per-minute list of all the location changes for all devices belonging to a tenant). \r\n\r\nThis question is getting too long, so I\u2019ll leave it rooted in the historical data persistence and retrieval for now and as I gain a better understanding of the Orleans way of accomplishing some of this I\u2019ll drill into other challenging aspects of the application.\r\n\r\nIf there\u2019s some documentation that I should be reading to help come up with a solution or an example that I should be referencing instead of asking for help, please share and I\u2019ll gladly keep trying to sort this out on my own. Thank you very much for your time!",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5797/comments",
    "author": "jeddawson",
    "comments": [
      {
        "user": "Cloud33",
        "created_at": "2019-08-06T03:28:03Z",
        "body": "Can i persist the statistics first? (I understand that the data should not change) dynamically calculate the thermal data"
      },
      {
        "user": "sergeybykov",
        "created_at": "2019-08-15T21:08:35Z",
        "body": "Sorry about delay. I was under the false impression this was replied to.\r\n\r\nMy impression is that you are asking a more general question of organizing data, and Orleans is only a factor in the picture because of how it helps load and keep pieces of state in memory on demand. The potential solutions seem to boil down to how to denormalize the data for efficient access in both OLTP style and querying of time series data. Did I get it right?\r\n\r\n>Would it work to asyncly iterate through all the devices asking each of them to figure out where they where (there can be 100 - 1000ish devices per tenant)?\r\n\r\nThis could work at a low scale, but I'm afraid it's not sustainable or efficient.\r\n\r\nThe approach with per-tenant location history grains seems more scalable to me. That would help retrieve (and potentially store) historical data in a way that is more suitable for querying state of drivers at a point in time. Per-tenant data could be further partitioned by larger time windows (e.g. a grain per day/hour) or geo-location (a grain per geographic tile), to help the system scale.\r\n\r\nI hope this helps. But I'm not 100% sure I answered your question."
      },
      {
        "user": "jeddawson",
        "created_at": "2019-08-23T23:37:54Z",
        "body": "@sergeybykov you definitely got it right and your advice on how to scope the grains does indeed help. I've taken a couple pretty naive stabs at this in our testing environment and feel like your advice has me on the right track. Thank you for taking the time to read my extra-long question and provide some valuable insight."
      },
      {
        "user": "sergeybykov",
        "created_at": "2019-08-29T17:15:39Z",
        "body": "Great! Can we close this issue now?"
      },
      {
        "user": "jeddawson",
        "created_at": "2019-09-20T04:48:55Z",
        "body": "Yep, thanks @sergeybykov"
      }
    ]
  },
  {
    "number": 5383,
    "title": "How to access Orleans inside Service Fabric from outside? ",
    "created_at": "2019-02-21T16:47:18Z",
    "closed_at": "2019-02-22T13:00:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5383",
    "body": "Hi, I'm trying to deploy Orleans Silo to a Service Fabric cluster. I need my Orleans client to be outside of the SF cluster. With the sample code, the address saved in the Membership table is the internal SF ip.\r\nHow can I properly configure Orleans Silo to expose the external addresses for the client to use?\r\nOr maybe there is a way to use Static clustering to connect to the service fabric service?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5383/comments",
    "author": "drakerunner",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2019-02-21T16:59:53Z",
        "body": "You can change the `EndpointOptions.AdvertisedIPAddress` property, but you should only access the cluster from within a given network: it should not be exposed to the Internet.\r\n\r\nInstead, put a web server in front of it."
      },
      {
        "user": "drakerunner",
        "created_at": "2019-02-22T13:00:54Z",
        "body": "Thanks. I was trying to test as a proof of concept. But the real scenario everything will be in the same vnet. In that case I won't have any problems... "
      }
    ]
  },
  {
    "number": 5366,
    "title": "Question about Transaction",
    "created_at": "2019-02-14T01:24:34Z",
    "closed_at": "2019-03-12T05:40:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5366",
    "body": "I need some advice on using Orleans.Transaction.\r\n\r\nTo use Orleans.Transaction it is required to declare TransactionOption on the Grain interface.\r\nIt means that if you make a method that can be called in or not in Transaction, you have to double it.\r\n\r\nSo I thought this way would be easier to use this way.\r\n```csharp\r\nawait wallet.PerformUpdate(balance => balance.Pop(100));\r\n \r\n \r\nvar inventoryGrain = GetGrain<InventoryGrain>(userId, TransactionOption.Join);\r\nawait inventoryGrain.AddItem(\"Healing Potion\");\r\n```\r\nLike the code above, I thought it would be nice if a transaction starts when requester wants to.\r\nThis way there's no way to find out the method's TransactionOption on the declaration.\r\n\r\n```csharp\r\npublic interface ISomeGrain : IGrainWithStringKey\r\n{\r\n    [Transaction(TransactionOption.Create)]     \r\n    Task<TReturn> NoneTransactionalRequest<TReturn>(MethodInfo mi, params object[] parameters);\r\n\r\n    [Transaction(TransactionOption.Join)]\r\n    Task<TReturn> TransactionalRequest<TReturn>(MethodInfo mi, params object[] parameters);\r\n}\r\n```\r\nSo we made a custom layer and call it `Service` layer.\r\nA Service is matched with a Grain.\r\nWhen a Service request something to another Service, It sends through Grain.\r\nAnd at Grain level, we decide which way to go, NoneTransactionalRequest or TransactionalRequest.\r\n\r\nIf the request is NoneTransactionalRequest, create a new transaction.\r\nif the request is TransactionalRequest, join the current transaction.\r\n\r\nHere are the questions.\r\nFirst, I want to know how you think of this way.\r\nSecond, Is this way of using Orleans.Transaction is too much?\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5366/comments",
    "author": "danpat04",
    "comments": [
      {
        "user": "danpat04",
        "created_at": "2019-02-19T04:58:47Z",
        "body": "I thought I could get an immediate reply.  \r\nIs this a hard question? or need more details?"
      },
      {
        "user": "jason-bragg",
        "created_at": "2019-02-19T16:06:26Z",
        "body": "> To use Orleans.Transaction it is required to declare TransactionOption on the Grain interface.\r\n\r\nYes.  This is the case because most of the options (other than create) are relevant to the caller, so the information needs exist on the interface.\r\n\r\n> It means that if you make a method that can be called in or not in Transaction, you have to double it.\r\n\r\nYes.  Transactions deal with persisted state.  This state can only be operated on transactionally.  If is invalid to read or modify this state outside the context of a transaction.\r\n\r\n> If the request is NoneTransactionalRequest, create a new transaction.\r\nif the request is TransactionalRequest, join the current transaction.\r\n\r\nOne should be able to get this behavior by marking the transaction CreateOrJoin.  If the call is made from within a transaction, it will join it.  If the call is made from outside the context of a transaction it will create one.\r\n"
      },
      {
        "user": "danpat04",
        "created_at": "2019-02-26T05:17:08Z",
        "body": "Thanks for the explanations.\r\nBut my real questions were at the bottom of the issue.\r\n\r\n> First, I want to know how you think of this way.\r\nSecond, Is this way of using Orleans.Transaction is too much?"
      },
      {
        "user": "jason-bragg",
        "created_at": "2019-03-06T18:13:40Z",
        "body": "@danpat04,\r\n\r\n> I want to know how you think of this way.\r\n\r\nI don't think this is approach is necessary.\r\nI think you can get the same result with the supported TransactionOption CreateOrJoin.\r\n\r\n\"One should be able to get this behavior by marking the transaction CreateOrJoin. If the call is made from within a transaction, it will join it. If the call is made from outside the context of a transaction it will create one.\"\r\n\r\n> Is this way of using Orleans.Transaction is too much?\r\n\r\nNo, I don't think so, it's not too much, but it's just not necessary.\r\n"
      },
      {
        "user": "danpat04",
        "created_at": "2019-03-12T05:40:15Z",
        "body": "Thanks, I understood what your saying is."
      },
      {
        "user": "pellesantiago",
        "created_at": "2019-05-16T20:21:18Z",
        "body": "Hi there,\r\nI'm new to Orleans. I'm still learning from the  #documentation.\r\n\r\nIn my experience, transaction are related to BUSINESS LOGIC layer. \r\nI'm currently thinking in Orleans as a INFRAESTRUCTURE layer. \u00bfMaybe i'm wrong?\r\n\r\nIn the furure, if i want to change Orleans library for another library in the infrastructure layer, i should keep transaction operation logic in business layer, not in Orleans layer. Again...\u00bfmaybe i'm wrong?\r\n\r\nSo, i think that the solution proposed by danpat04 is more accurately. I dont know if its posible to develop inside Orleans..\r\n\r\nWith current Orleans solution, \u00bfcan you manipulate transaction logic (create, join, commit,rollback) from business layer instead of Orleans layer?\r\n\r\nThanks for your reply.\r\n\r\nRegards,\r\nSantiago"
      }
    ]
  },
  {
    "number": 5330,
    "title": "Every call to the grain sends a packet over the network for a request? ",
    "created_at": "2019-01-23T16:46:36Z",
    "closed_at": "2019-01-24T02:49:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5330",
    "body": "Is there a way to get the requested data directly to silo, because each time the requested parameter is a complex object, it will take some time to make a memory copy and then send it over the network. Assuming my program is only running on one server, the above operations will waste a lot of performance.\r\nThank you for reading\u3002",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5330/comments",
    "author": "guopenglun",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2019-01-23T16:55:57Z",
        "body": "If a call to a grain is made within the same silo where that grain is activated, no data is sent over the network, only memory copy of the arguments is performed. Memory copy can be eliminated by wrapping argument type with `Immutable<>`. However, in that case the code must not mutate the arguments after making a call."
      },
      {
        "user": "guopenglun",
        "created_at": "2019-01-24T02:49:56Z",
        "body": "Thank you for your reply, very helpful :)"
      }
    ]
  },
  {
    "number": 5316,
    "title": "Is storing state data inside of a grain redundant?",
    "created_at": "2019-01-16T10:33:08Z",
    "closed_at": "2019-01-17T08:27:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5316",
    "body": "Hi guys.\r\nI'm wondering if it makes any sense to store State data inside a grain.\r\nI'm adding State to a `Foo` grain.\r\n\r\nWhen it was stateless (`Foo : Grain`), having `_bar` did make sense.\r\nNow that a state has been added and persisted, Foo's Bar can be accessed though its State, so I totally see `_bar` as redundant info, but just in case I'm missing something.\r\n\r\n```c#\r\n    [StorageProvider(ProviderName = \"MyProvider\")]\r\n    public class Foo : Grain<Bar>\r\n    {\r\n        private readonly Bar _bar;  // Redundant?\r\n        // ...\r\n    }\r\n\r\n    public class Bar\r\n    {\r\n        public int A { get; set; }\r\n\r\n        public double B { get; set; }\r\n    }\r\n```\r\n\r\nThanks in advance for your answers!",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5316/comments",
    "author": "eduherminio",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2019-01-16T17:55:28Z",
        "body": "Yes, if for `Foo : Grain<Bar>` it would be redundant to keep another copy of the same state of type `Bar` in `_bar`. "
      },
      {
        "user": "eduherminio",
        "created_at": "2019-01-17T08:27:25Z",
        "body": "Thanks for the clarification!"
      }
    ]
  },
  {
    "number": 5299,
    "title": "Grain Persistence and GrainCancellationTokenSource",
    "created_at": "2019-01-07T19:57:25Z",
    "closed_at": "2019-03-05T22:26:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5299",
    "body": "Hi, I am creating grain persistence for a master grain that manages the work of other worker grains. I am utilizing GrainCancellationTokenSource so the master grain can cancel all of the worker grains, however when I try to use Grain Persistence for the GrainCancellationTokenSource I get an error saying that GrainCancellationTokenSource cannot be deep copied. Do you guys have any recommendations around this error or have any recommendations for managing cancellation of worker grains? Thanks.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5299/comments",
    "author": "TulkasLaugh",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2019-01-08T00:00:06Z",
        "body": "`GrainCancellationTokenSource` is not meant to be persistent. It's a transient object that allows to try to cancel an in-flight requests. Why do you want to persist it when it has no meaning after the grain call it's used for completes?"
      },
      {
        "user": "TulkasLaugh",
        "created_at": "2019-01-08T17:46:58Z",
        "body": "I was thinking that if a silo goes down in the middle of polling a job that's taking a long time and needs to be reactivated it would need the same CancellationTokenSource in order to still be able to cancel. Do you have a recommendation on trying to handle that kind of scenario?"
      },
      {
        "user": "sergeybykov",
        "created_at": "2019-01-08T21:19:05Z",
        "body": "The general recommendation is not to make long running calls. Instead, make a call to *initiate* a long running operation, and get later notified (via a grain call, an observer or a stream) about its completion. If the grain that is executing the long running operation (on a separate thread or on the thread pool to avoid blocking grain threads) is marked as `[Reentrant]`, it can receive an explicit request to cancel the operation (without using the cancellation token) or get polled about the progress of the operation.\r\n\r\nIn other words, the recommended pattern is to make quick grain calls and manage any long running process via a series of them instead of a one long call. This pattern is more robust in the face of failures and in general makes the app logic more responsive and flexible."
      }
    ]
  },
  {
    "number": 5283,
    "title": "What's the real benefit of stateless workers?",
    "created_at": "2018-12-31T08:38:03Z",
    "closed_at": "2019-01-04T05:02:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5283",
    "body": "I was just leaving a comment on someone's code, and I told them they could do something with a static class instead of using stateless workers. This got me thinking: what's the real benefit of stateless workers? They provide two benefits as far as I can tell:\r\n\r\n1. They'll limit the number of concurrent operations, but at the added cost of a grain method call (which I believe can be significant if the operation itself is simple).\r\n2. They'll provide single-thread guarantees.\r\n\r\nI don't really know about number 1 (someone with more knowledge could probably shed some light), but number two is rather meaningless if there *really is no state*. Rather, the main benefit I can think of is when a stateless worker has *some* state, but the state is transient. Then, you could have timers and do some work based on previous state and whatnot (take the aggregator pattern for example), which makes the name *stateless* worker rather counter-intuitive. I can only assume stateless actually means no *persistent* state.\r\n\r\nAm I missing something? More importantly, am I correct in assuming that any truly stateless operation can be implemented (probably with better performance) as a static method on a static class rather than a method on a stateless worker grain?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5283/comments",
    "author": "Arshia001",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2019-01-02T18:42:00Z",
        "body": "Consider the following scenario, which is actually how `StatelessWorker` grains came to be.\r\n\r\nClient sends encrypted messages to the cluster. Inside each message there's an identity of the target user (grain). Before the message can be send to the user grain for processing, it needs to get decrypted and the user ID extracted, so that it can be passed to `GetGrain<IUserGrain>(id)`. A `StatelessWorker` grain provides an 'endpoint' for clients to send such messages to. Activations of that grain are always local to the silo that receives a request (client gateway), and they automatically scale out with the load."
      },
      {
        "user": "Arshia001",
        "created_at": "2019-01-02T20:04:09Z",
        "body": "My nodes have always been symmetric, so I wasn't considering silo clients at all... Thanks! "
      },
      {
        "user": "sergeybykov",
        "created_at": "2019-01-02T20:36:39Z",
        "body": "There are also scenarios for `StatelessWorker` grains that don't involve clients. For example, if you need to report an aggregate metric across many thousands of grains in the cluster, it won't work if you try to have each grain sends its report to a single aggregator grain because it would become the obvious bottleneck. Instead, you can have those grains call a `StatelessWorker` 'pre-aggregator' grain. That would cause them invoking local (within the same silo) 1 or N (depending on what you specify) activations of the pre-aggregator.\r\n\r\nThe pre-aggregator grains can then periodically, on timer, report their individual aggregates to the final aggregator grain. Since there will be much fewer of those calls, the final aggregator won't be overloaded with calls from the pre-aggregators.\r\n\r\nThis pattern has been successfully applied in multiple production systems."
      },
      {
        "user": "Arshia001",
        "created_at": "2019-01-03T05:51:06Z",
        "body": "Yes, that's exactly the transient state I was thinking about. I think it's safe to assume that \"putting stateless logic which is meant to be consumed from within silos inside static classes is a better choice\". This implies that maybe two thirds of my stateless workers so far have only been slowing the system down... \ud83e\udd26\u200d\u2642\ufe0f"
      },
      {
        "user": "sergeybykov",
        "created_at": "2019-01-04T00:11:57Z",
        "body": ">\"putting stateless logic which is meant to be consumed from within silos inside static classes is a better choice\".\r\n\r\nYes, unlike with statics, with stateless workers you get the single-threading guarantee."
      },
      {
        "user": "Arshia001",
        "created_at": "2019-01-04T05:02:55Z",
        "body": "Thanks! "
      }
    ]
  },
  {
    "number": 5182,
    "title": "Message broadcasting",
    "created_at": "2018-11-19T13:44:44Z",
    "closed_at": "2018-11-30T18:23:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5182",
    "body": "Normally when a message is published into a stream is received by one grain that as subscribed that stream.\r\nThere is any stream provider that does broadcasting to all grain that has subscribed that channel ?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5182/comments",
    "author": "matteofabbri",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-11-27T22:56:21Z",
        "body": "All grains subscribed to a stream receive every event published to the stream. Is that not what you are seeing?"
      },
      {
        "user": "matteofabbri",
        "created_at": "2018-11-30T18:23:35Z",
        "body": "Thanks a lot "
      }
    ]
  },
  {
    "number": 5147,
    "title": "Unexpected token 'Error' introducing type specifier when calling grain method. ",
    "created_at": "2018-10-30T12:41:33Z",
    "closed_at": "2018-10-31T15:17:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/5147",
    "body": "Hi! Im getting\r\n\"Unexpected token 'Error' introducing type specifier \" every time when i call method Recieve on my grain  which have following signature:\r\n\r\n```\r\nTask Recieve(IEnumerable<GrainsInterfaces.EventData> messages)\r\n\r\npublic class EventData\r\n    {\r\n        public ArraySegment<byte> Body { get; set; }\r\n\r\n        public IDictionary<string, object> Properties { get; set; }\r\n\r\n        public SystemPropertiesCollection SystemProperties { get; set; }\r\n\r\n        public sealed class SystemPropertiesCollection : Dictionary<string, object>\r\n        {\r\n            public long SequenceNumber { get; set; }\r\n\r\n            public DateTime EnqueuedTimeUtc { get; set; }\r\n\r\n            public string Offset { get; set; }\r\n\r\n            public string PartitionKey { get; set; }\r\n        }\r\n    }\r\n```\r\n\r\nGrain has  [StatelessWorker] and [Reentrant] attributes.\r\n\r\nOther method, which has simplier signature:\r\n\r\n Task<string> SayHello(string greetings) works ok.\r\n\r\nDo you know what can cause this? Is there any limitation if comes to data contract? ",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/5147/comments",
    "author": "darthkurak",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-10-30T17:59:36Z",
        "body": "`IEnumerable<T>` is not supported as an argument or return type because it is evaluated lazily. Try using `IList<T>` or something like that instead."
      },
      {
        "user": "darthkurak",
        "created_at": "2018-10-31T08:55:19Z",
        "body": "Works now, thanks! "
      }
    ]
  },
  {
    "number": 4822,
    "title": "Which code files are maintained for memberships tables and grain directory tables?",
    "created_at": "2018-08-07T14:35:42Z",
    "closed_at": "2018-08-16T09:10:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4822",
    "body": "  I'm studying the implementation of Orleans, but I've found that I can't find the specific maintenance code for the memberships table and the grain directory table. Including the entry of members, normal exit and abnormal exit, Grain activation and deactivation, and node failure when the table recovery operations.\r\n\r\n  Could you tell me which files are the specific implementation codes of these operations?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4822/comments",
    "author": "buzzers",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-08-13T18:27:39Z",
        "body": "Did you inside the following folders?\r\n\r\n`src\\Orleans.Runtime\\MembershipService`\r\n`src\\Orleans.Runtime\\GrainDirectory`\r\n\r\nIs that not what you are looking for?"
      },
      {
        "user": "buzzers",
        "created_at": "2018-08-14T10:01:11Z",
        "body": "I also read the code under these two folders, but I didn't know where the remote request was received and caused the two services to be invoked."
      },
      {
        "user": "sergeybykov",
        "created_at": "2018-08-16T02:34:19Z",
        "body": "Take a look at `MembershipOracle` and `RemoteGrainDirectory` classes."
      },
      {
        "user": "buzzers",
        "created_at": "2018-08-16T09:10:27Z",
        "body": "Thank you.\r\nI use Visual Studio to do single step tracing to study the code. There is a clue. Thank you for your reply."
      }
    ]
  },
  {
    "number": 4705,
    "title": "Server Core OS support",
    "created_at": "2018-06-22T11:21:18Z",
    "closed_at": "2018-06-22T11:24:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4705",
    "body": "Hi,\r\n\r\nI can't find a list of supported operating systems in any documentation.  Is Orleans supported running on Server 2016 Core?  My assumption is it is but wanted confirmation.\r\n\r\nThanks.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4705/comments",
    "author": "MatthewFawcett",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2018-06-22T11:23:16Z",
        "body": "@jjjurrb as long as it can run .NET Core then it can run Orleans"
      },
      {
        "user": "MatthewFawcett",
        "created_at": "2018-06-22T11:24:35Z",
        "body": "I'll take that as a yes \ud83d\udc4d   Thanks."
      },
      {
        "user": "ReubenBond",
        "created_at": "2018-06-22T11:25:42Z",
        "body": "Yes, sorry, I should have been more clear \ud83d\ude0a"
      }
    ]
  },
  {
    "number": 4700,
    "title": "Grain Disambiguation",
    "created_at": "2018-06-19T22:04:19Z",
    "closed_at": "2018-06-20T07:07:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4700",
    "body": "I am working on the project that some grain implementations inherit from an abstract grain implementation . \r\nSome just like this:\r\npublic abstract class A: Grain, IGrainInterface\r\n{\r\nabstract method(); \r\n}\r\n\r\npublic class B: A\r\n{\r\noverride method();\r\n}\r\n\r\npublic class C: A\r\n{\r\noverride method()\r\n}\r\n\r\nIt seems I can use a grainClassNamePrefix to solve this problem, but I haven't found any documents to describe how to use it. \r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4700/comments",
    "author": "w14525555",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-06-19T23:17:45Z",
        "body": "You can pass a fully qualified class name to `GetGrain()` as optional parameter:\r\n```csharp\r\nGetGrain<IGrainInterface>(key, \"your-namespace.B\");\r\nGetGrain<IGrainInterface>(key, \"your-namespace.C\");\r\n```\r\n\r\nor just a prefix of the fully qualified name, if the grain classes are defined in different namespaces:\r\n```csharp\r\nGetGrain<IGrainInterface>(key, \"B-namespace\");\r\nGetGrain<IGrainInterface>(key, \"C-namespace\");\r\n```\r\nThe namespace approach works well for switching between different implementations of multiple grain classes, for example, between test and production."
      }
    ]
  },
  {
    "number": 4523,
    "title": "Orleans call grain within a grain",
    "created_at": "2018-04-27T17:19:10Z",
    "closed_at": "2018-04-27T21:15:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4523",
    "body": "I've got a requirement to call a grain within a grain. I had tried this in version 1.5 not sure how it works in 2.0. If somebody can provide a sample it would be great. This was what I was trying.\r\n\r\n public class CustomerRule : Grain, ICustomerRule\r\n{\r\n    private ISomeGrain _someGrain;\r\n    public override async Task OnActivateAsync()\r\n        {\r\n              _someGrain = GrainFactory.GetGrain<ISomeGrain>(this.GetPrimaryKeyString());\r\n              await base.OnActivateAsync();\r\n         }\r\n     public Task<bool> TestHello(GrainCancellationToken tc, string customer)\r\n     {\r\n               var string =  _someGrain.SayHello(tc, customer);\r\n              return Task.FromResult(string);\r\n      }\r\n}\r\n\r\nDue to some reason SayHello() is not being invoked. \r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4523/comments",
    "author": "satishviswanathan",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-04-27T18:00:58Z",
        "body": "The code is missing `await` in front of `_someGrain.SayHello(tc, customer);`. Is this the exact code or pseudo-code?\r\n\r\n`GrainFactory.GetGrain(this.GetPrimaryKeyString());` doesn't look right either."
      },
      {
        "user": "satishviswanathan",
        "created_at": "2018-04-27T18:23:16Z",
        "body": "Sorry that was a psedo code.\r\n\r\npublic  async Task TestHello(GrainCancellationToken tc, string customer)\r\n{\r\nvar string = await _someGrain.SayHello(tc, customer);\r\nreturn await Task.FromResult(string);\r\n}\r\n\r\nWhat I'm not sure is how we can access another grain within the CustomerRule grain. Any sample code ?\r\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2018-04-27T18:37:18Z",
        "body": "You can simply do\r\n```csharp\r\npublic async Task TestHello(GrainCancellationToken tc, string customer)\r\n{\r\n  return await _someGrain.SayHello(tc, customer);\r\n}\r\n```\r\nor even\r\n```csharp\r\npublic Task TestHello(GrainCancellationToken tc, string customer)\r\n{\r\n  return _someGrain.SayHello(tc, customer);\r\n}\r\n```\r\ninstead of that code.\r\n\r\n>What I'm not sure is how we can access another grain within the CustomerRule grain. \r\n\r\nCalling a grain from another grain is a bread-and-butter scenario for Orleans. The code you wrote should just work for that. How do you determine that `SayHello` is not getting invoked? Do you get a error/exception?"
      },
      {
        "user": "satishviswanathan",
        "created_at": "2018-04-27T19:29:22Z",
        "body": "How is this _someGrain created on the calling grain in this case CustomerRule ?\r\n\r\nbasically I was not getting any results from the method SayHello(). also I had a break point and log return to see if it hits there but both didn't work."
      },
      {
        "user": "ReubenBond",
        "created_at": "2018-04-27T19:33:47Z",
        "body": "@satishviswanathan `Grain` has a `GrainFactory` property, so you can create the grain reference, `_someGrain`, by using `this.GrainFactory.GetGrain<ICustomerGrain>(customer)`.\r\n\r\nIn the end, your method might look like this:\r\n\r\n```C#\r\npublic Task TestHello(GrainCancellationToken tc, string customer)\r\n{\r\n  var grain = this.GrainFactory.GetGrain<ICustomerGrain>(customer)\r\n  return grain.SayHello(tc, customer);\r\n}\r\n```\r\n\r\nHere I am assuming you have `ICustomerRuleGrain` with a `TestHello` method and it calls into `ICustomerGrain`'s `SayHello` method."
      },
      {
        "user": "satishviswanathan",
        "created_at": "2018-04-27T21:00:54Z",
        "body": "@ReubenBond The was my mistake I had an error being thrown from one of the grain and that was blowing the brain grain to return the result.\r\n\r\nThanks a lot for your support."
      },
      {
        "user": "ReubenBond",
        "created_at": "2018-04-27T21:05:23Z",
        "body": "We are happy to help, @satishviswanathan :)\r\n\r\nIs this issue resolved now?"
      },
      {
        "user": "satishviswanathan",
        "created_at": "2018-04-27T21:07:24Z",
        "body": "Yes the issue is resolved now."
      }
    ]
  },
  {
    "number": 4478,
    "title": "Is it possible to configure silo using DNS name instead of IP address",
    "created_at": "2018-04-16T21:16:38Z",
    "closed_at": "2018-04-18T14:54:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4478",
    "body": "Team,\r\nBelow is code snippet for Silo host. Is there any option where I can configure endpoint using DNS name instead of IP address.\r\n\r\n            var siloPort = Convert.ToInt32(ConfigurationManager.AppSettings[\"SiloPort\"]);\r\n            var gatewayPort = Convert.ToInt32(ConfigurationManager.AppSettings[\"GatewayPort\"]);\r\n            var advertisedIp = IPAddress.Parse(ConfigurationManager.AppSettings[\"AdvertisedIP\"]);\r\n            var builder = new SiloHostBuilder()\r\n                .Configure<ClusterOptions>(options =>\r\n                {\r\n                    options.ClusterId = ConfigurationManager.AppSettings(\"CLUSTER_ID\");\r\n                    options.ServiceId = ConfigurationManager.AppSettings(\"SERVICE_ID\");\r\n                })\r\n                .ConfigureEndpoints(siloPort: siloPort, gatewayPort: gatewayPort, advertisedIP: advertisedIp)\r\n                .UseConsulClustering(gatewayOptions =>\r\n                {\r\n                    gatewayOptions.Address =\r\n                        new Uri(ConfigurationManager.AppSettings(\"ServiceDiscoverEndPoint\"));\r\n                })\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4478/comments",
    "author": "srinathgnath",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2018-04-16T21:36:52Z",
        "body": "HI @srinathgnath, there is an overload of ConfigureEndpoints which accepts a hostname:\r\n```C#\r\npublic static ISiloHostBuilder ConfigureEndpoints(\r\n    this ISiloHostBuilder builder, \r\n    string hostname, \r\n    int siloPort, \r\n    int gatewayPort,\r\n    AddressFamily addressFamily = AddressFamily.InterNetwork,\r\n    bool listenOnAnyHostAddress = false)\r\n```\r\n\r\nDoes that work for you?"
      }
    ]
  },
  {
    "number": 4466,
    "title": "Question - Heterogenous Silo configuration in runtime",
    "created_at": "2018-04-13T11:32:38Z",
    "closed_at": "2020-01-14T18:15:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4466",
    "body": "Hello guys, \r\nis it possible to make Heterogenous Silos configuration by supplying the same build package with all grain implementations, but configuring which parts to host by AddApplicationParts or any similar way (but still referencing all grains)?\r\nWe are just considering to supply the silo with some config and select required set of grains ( and dependent services to inject etc. ) to host when starting the silo. \r\nIt will be very useful if you have the silo capable of hosting N feature-sets, and when the demand arises for some parts of functionality/services, you can choose for which features you need to allocate more resources (and resource configurations required) and start additional silos only for these, instead of running the one big silo.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4466/comments",
    "author": "tinpl",
    "comments": [
      {
        "user": "DarkCow",
        "created_at": "2018-04-13T15:21:46Z",
        "body": "I think placement directors are a better option... I made a role placement director. Then you decorate your Grain class with `[RolePlacement( \"fileserver\" )]`\r\n\r\nYou can use it by calling `siloHostBuilder.AddPlacementDirector<RolePlacementStrategy, RolePlacementDirector>( )`\r\n\r\nUsing this technique, I can change the roles of servers during runtime, and their cache will be fixed every min or so. I leave the implementation of m_SiloRoleRepository to you. But it is a service that returns SiloAddress <--> Supported Roles\r\n\r\n```\r\n    [Serializable]\r\n    public class RolePlacementStrategy : PlacementStrategy\r\n    {\r\n        public string RoleName { get; private set; }\r\n\r\n        internal RolePlacementStrategy( string roleName )\r\n        {\r\n            RoleName = roleName;\r\n        }\r\n\r\n        public override string ToString( )\r\n        {\r\n            return String.Format( $\"RolePlacementStrategy(role={RoleName})\" );\r\n        }\r\n\r\n        public override bool Equals( object obj )\r\n        {\r\n            if( obj is RolePlacementStrategy other )\r\n                return other.RoleName == RoleName;\r\n            else\r\n                return false;\r\n        }\r\n\r\n        public override int GetHashCode( )\r\n        {\r\n            return GetType( ).GetHashCode( ) ^ RoleName.GetHashCode( );\r\n        }\r\n    }\r\n```\r\n```\r\n    public class RolePlacementDirector : IPlacementDirector\r\n    {\r\n        public RolePlacementDirector( ISiloRoleRepository siloRoleRepository )\r\n        {\r\n            m_SiloRoleRepository = siloRoleRepository;\r\n        }\r\n\r\n        public virtual async Task<SiloAddress> OnAddActivation( PlacementStrategy strategy, PlacementTarget target, IPlacementContext context )\r\n        {\r\n            var allSilos = context.GetCompatibleSilos( target );\r\n            var rolePlacementStrategy = (RolePlacementStrategy)strategy;\r\n            var siloRoleInfos = await GetSiloRoleInfosAsync( );\r\n\r\n            var silosInRole = siloRoleInfos\r\n                .Where( r => r.Roles.Contains( rolePlacementStrategy.RoleName ) )\r\n                .Join( allSilos,\r\n                    r => r.IPAddress,\r\n                    s => s.Endpoint,\r\n                    ( r, s ) => new { SiloRoleInfo = r, SiloAddress = s } )\r\n                .ToList( );\r\n\r\n\r\n            if( silosInRole.Count == 0 )\r\n                throw new SiloRoleNotFoundException( rolePlacementStrategy.RoleName );\r\n\r\n            return silosInRole[ m_Random.Next( silosInRole.Count ) ].SiloAddress;\r\n        }\r\n\r\n        protected async Task<List<SiloRoleInfo>> GetSiloRoleInfosAsync( )\r\n        {\r\n            var siloRoleInfos = m_MemoryCache.Get<List<SiloRoleInfo>>( \"SiloRoleInfo\" );\r\n\r\n            if( siloRoleInfos == null )\r\n            {\r\n                await m_CacheLock.WaitAsync( );\r\n\r\n                try\r\n                {\r\n                    // Check twice\r\n                    siloRoleInfos = m_MemoryCache.Get<List<SiloRoleInfo>>( \"SiloRoleInfo\" );\r\n\r\n                    if( siloRoleInfos == null )\r\n                    {\r\n                        siloRoleInfos = await m_SiloRoleRepository.GetAsync( );\r\n\r\n                        m_MemoryCache.Set( \"SiloRoleInfo\", siloRoleInfos, DateTime.Now.Add( ms_Interval ) );\r\n                    }\r\n                }\r\n                finally\r\n                {\r\n                    m_CacheLock.Release( );\r\n                }\r\n            }\r\n\r\n            return siloRoleInfos;\r\n        }\r\n\r\n        private Random m_Random = new Random( );\r\n        private ISiloRoleRepository m_SiloRoleRepository;\r\n        private MemoryCache m_MemoryCache = new MemoryCache( new MemoryCacheOptions( ) );\r\n        private SemaphoreSlim m_CacheLock = new SemaphoreSlim( 1, 1 );\r\n        private ILogger m_Logger = Log.ForContext<RolePlacementDirector>( );\r\n        private static readonly TimeSpan ms_Interval = TimeSpan.FromMinutes( 1 );\r\n    }\r\n```\r\n```\r\n    /// <summary>\r\n    /// Directs Orleans to only place new activations on a Silo supporting the Role\r\n    /// </summary>\r\n    [AttributeUsage( AttributeTargets.Class, AllowMultiple = false )]\r\n    public sealed class RolePlacementAttribute : PlacementAttribute\r\n    {\r\n        public string Role { get; private set; }\r\n\r\n        public RolePlacementAttribute( string role ) :\r\n            base( new RolePlacementStrategy( role ) )\r\n        {\r\n            Role = role;\r\n        }\r\n    }\r\n```\r\n"
      },
      {
        "user": "ReubenBond",
        "created_at": "2018-04-16T04:02:49Z",
        "body": "I said I would comment on this, so here goes:\r\nThere are a few ways to exclude grains from a silo. The placement solution mentioned by @DarkCow is one of them. Another is using `GrainClassOptions.ExcludedGrainTypes`:\r\n``` C#\r\nsiloBuilder.Configure<GrainClassOptions>(options.ExcludedGrainTypes.Add(typeof(MyGrain).FullName)));\r\n```\r\n\r\nI was originally thinking of another method, but it's quite ugly. You would replace the default `ApplicationPartManager` / `IApplicationPartManager` with your own implementation which filters out the unwanted grain classes from `GrainClassFeature` when it's being populated (in `PopulateFeature`). I don't recommend that approach."
      },
      {
        "user": "tinpl",
        "created_at": "2018-04-20T19:00:08Z",
        "body": "Thank you for your responses, both of them do what we want to achieve!\r\n\r\n`ApplicationPartManager` seems to be more conventional way to configure the silo at the startup, if you don't want to change hosted types in the future. Kind of you are building the silo here, so that should be the place to define what should it host. Maybe adding one more class (similar to `AssemblyPart`),something like `GrainPart: IAssemblyPart { ... }`, which can be added like `builder.AddApplicationPart(typeof(GrainClass))` will do the work. So if you want to just put in the assembly, use one method. If you need more control -> add Grains explicitly one by one (or `IEnumerable<IAssemblyPart>` of them, probably, this will be more common usage).\r\nExcluded Grain types approach functionally seems to be good one, but intuitively you expect to tell what to Include, not what to Exclude (so if I don't say to Include this grain/assembly of grains -> it shouldn't be here). imho, seems to be slightly misleading.\r\nPlacement director seems to be the most flexible one, with the possibility to add additional rules etc. \r\n\r\nSeems my solution will look like:\r\n1. Set basic capabilities for a silo from config using `ExcludedGrainTypes` (when deploying you just don't want to have some kind of Grains to be on this silo because of this instance resource constraints)\r\n2. Arrange some custom placement strategy using the `PlacementDirector`, based on the Silo's capabilities in terms of hosted 'features' and results of monitoring/metrics, or something similar.\r\n\r\nAny drawbacks in this approach? Or maybe places I should consider to put more attention in, because of possible reliability/performance issues?"
      },
      {
        "user": "ReubenBond",
        "created_at": "2020-01-14T18:15:15Z",
        "body": "Apologies for the extremely slow response. Your points both look fine to me. Closing"
      }
    ]
  },
  {
    "number": 4458,
    "title": "Questions related to reliability",
    "created_at": "2018-04-12T13:00:14Z",
    "closed_at": "2018-06-21T21:55:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4458",
    "body": "Your implementation of the Actor pattern is obviously more geared around intuitiveness and implicit reliability than other implementations.  I do really like how intuitive things are however have 2 questions:\r\n\r\n1. You obviously support streams which means one grain can fire off some request into a stream and then exit.  My question is; should streams be optional?  My understanding from reading the docs is that the most simple and intuitive route to follow is to not use them and to block (asynchronously) while dependant grains execute. However I think that I could easily get into more trouble using Orleans in this way than I would by developing traditional locking code.\r\n\r\nSay I have a Grain A which depends on Grain B, which depends on Grain C, etc.  If Grain C maintains state but A and B don't then are potential activations of A and B blocked until C completes, even though work could be performed in A and B during this period - perhaps A and B don't even always lead to C.\r\n\r\nHopefully it's clear what I'm trying to say.  In a sentence, it makes perfect sense to make grains atomic however I'm not so sure about chains of grains.  \r\n\r\nHave I misinterpreted the architecture? Assuming I haven't, I'll repeat that I know I can use streams and there will be certain patterns I can follow to help me here.  I'm just wondering if there is any value in going the simple/intuitive route (if indeed it's better than a more traditional approach)?\r\n\r\n2. I understand why streams are reliable and it's very nice to have this.  I'm not clear how to best use them though.  I'll give an example to demonstrate my question - along with some extra detail so you can correct me if I'm missing something fundamental:\r\n\r\nGrain A posts a message to Stream A (it blocks while it's posting to the stream but after this can then return and handle further activations).  Now if for whatever reason the message posted to the stream isn't processed as expected (e.g. the grain which consumes the message doesn't die but somehow drops the message).  I'm assuming I have to build checks into my system for this type of thing?\r\n\r\nIf it is the case that I've got to build these checks into my system I'm wondering if it's worth paying the cost for the reliable stream?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4458/comments",
    "author": "tdinucci",
    "comments": [
      {
        "user": "jason-bragg",
        "created_at": "2018-04-12T21:18:24Z",
        "body": "**Regarding 1**\r\n\r\nStreams, imo, are separate from the actor model.  Streams are a feature we support and are integrated with the actor model but are logically separable and opt-in only.  Our implementations of streams are built (wisely or not) on top of the actor model which constrains the feature to limitations of the actor model, but that is mostly an implementation detail.\r\n\r\nThe behavior of streams, unfortunately, is very implementation specific.  For instance, the type of chaining behavior you describe is a concern when using the simple messaging streams (SMS), but would not be a concern while using any of the persistent streams (Memory Streams for instance).  This is due to the fact that the OnNextAsync task on a persistent stream resolves when the event is successfully stored in the queue rather than upon successful processing of the event by all subscribers (as is the behavior in SMS).\r\n\r\n**Regarding 2**\r\n\r\nStreams are not necessarily reliable, we support various levels of reliability.\r\n\r\nSMS and Memory streams are not reliable, as they keep messages in memory and can lose messages under some error conditions.\r\n\r\nSome persistent streams support limited recovery of unordered data.  Azure queue is an example of this.  It should reliably deliver all messages at least once to each subscriber, but the data is unordered, and duplicates are possible (even likely).\r\n\r\nSome persistent streams support ordered reliable data.  EventHub stream provider is an example.  These streams will deliver events in order with ordering information in the form of sequence tokens which can be used to remove duplicate events or rewind the stream to an earlier point in order to recover from transient errors.\r\n\r\nUnfortunately streaming, while conceptually simple, is non-trivial and means different things to different people.  Prior to a deeper dive into the subject, I advocate users consider their application needs.  While we make efforts to simplify the usage patterns, the ordered, reliable, recoverable, high speed processing of events in a distributed system is not something that we\u2019ve managed to deliver an entirely simplified model of, nor have we managed to avoid technical tradeoffs which only the application developer can choose to make. :/\r\n\n\n---\n\n@tdinucci,\r\n\r\n>Grain A posts a message to Stream A (it blocks while it's posting to the stream but after this can then return and handle further activations). Now if for whatever reason the message posted to the stream isn't processed as expected (e.g. the grain which consumes the message doesn't die but somehow drops the message). I'm assuming I have to build checks into my system for this type of thing?\r\n\r\nAs described in my previous post, this sort of recoverable stream processing is only supported by persistent streams and may vary by implementation.  For ordered reliable streams, the expected behavior is that should an event delivered to a subscriber to be processed fail, the streaming infrastructure will retry until it succeeds or a set retry period is reached.  If the streaming infrastructure eventually gives up on delivering the event, the application layer is notified of this via the OnErrorAsync and a local callback to an IStreamFailureHandler, should the application provide one.  The local callback is necessary as the OnErrorAsync is unreliable, because if the grain is unreachable for event delivery then it may not be available for error notification.\r\n\r\nThe reliability in the recoverable streams is geared towards transient errors, allowing resilience against temporary outages (usually less than 5 minutes).  It doesn't ensure the processing of poison messages or message processing under other non-recoverable or long standing errors, only notifying the application layer that these have occurred, so either user or automated action can be taken.\r\n\r\nThese behaviors are tested using the ImplicitSubscritionRecoverableStreamTestRunner."
      },
      {
        "user": "tdinucci",
        "created_at": "2018-04-12T22:21:16Z",
        "body": "Thanks very much @jason-bragg for the thorough response :+1: \r\n\r\nYou said:\r\n> Streams, imo, are separate from the actor model.\r\n\r\nI had understood streams to be the broadly equivalent to the mailboxes which are part of the actor model - obviously the mailboxes would be at the ends of the streams.  \r\n\r\nWith this (potentially incorrect) understanding I would think that if you don't use streams then you don't have mailboxes.  If you don't have mailboxes then either; a) initiating actors/grains cannot receive responses, or b) chains are effectively synchronous and all grains within the chain are locked.  Is this correct?\r\n\r\nIn relation to stream reliability, in your second post you said:\r\n\r\n> For ordered reliable streams, the expected behavior is that should an event delivered to a subscriber to be processed fail, the streaming infrastructure will retry until it succeeds or a set retry period is reached.\r\n\r\nI'm not totally clear on what this means.  Is the assurance that if a message fails to be processed it's retried or just if it fails to be delivered?  I guess you could be opening a can of worms by retrying messages that failed to be processed on the stock streams.\r\n"
      },
      {
        "user": "jason-bragg",
        "created_at": "2018-04-12T23:58:01Z",
        "body": "@tdinucci\r\n\r\n>chains are effectively synchronous and all grains within the chain are locked. Is this correct?\r\n\r\nI'm unfamiliar with mail boxes, but regarding chaining behaviors, the default behavior for a chain of A->B->C would be that A,B, and C would not be able to process other grain calls until C returns, at which time only A and B would be unavailable until B returns, and so on.  Streaming, if configured to use a persistent stream, would avoid this since an event generated on a stream consumed by A could generate a new event on a different stream to be consumed by B and so on, avoiding blocking for long call chains at the cost of putting the event in a queue between each grain.  Am I understanding your question?\r\n\r\n>Is the assurance that if a message fails to be processed it's retried or just if it fails to be delivered?\r\n\r\nEither.  Delivery of a stream event to a consumer is performed as a grain call.  If the grain call does not succeed (due to application error, timeout, grain activation failure, duplicate activation, ..?), it will be redelivered.  This retry logic will persist for a configured period of time (default is 1 minute).  In the case of a silo failure, this retry logic may reactivate the grain on another silo.  If this leads to data loss from processed messages which may not have been persisted yet, the grain can rewind the stream to the last point the grain stored processed results and reprocess the lost events.  This ability to rewind the stream is limited by the amount of data the stream provider is configured to cache for recovery purposes.  The larger the cache, the further back in time a recovering grain can rewind its stream.\r\n\r\n"
      },
      {
        "user": "tdinucci",
        "created_at": "2018-04-13T00:29:56Z",
        "body": "@jason-bragg you have understood my questions and answered them.  Thanks very much for your time!"
      },
      {
        "user": "martinothamar",
        "created_at": "2018-04-18T11:02:19Z",
        "body": "For the grain call chain locking in the absence of streams, there is the `OneWay`-attribute which can be added to methods on the grains interface. When a grain calls on that attributed method it will immediately return. Not sure how persistent streams compare to this attribute in terms for performance and reliability."
      }
    ]
  },
  {
    "number": 4229,
    "title": "Is IServiceCollection.AddScoped seemingly invalid in Orleans?",
    "created_at": "2018-03-15T12:53:57Z",
    "closed_at": "2018-03-21T02:08:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4229",
    "body": "",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4229/comments",
    "author": "lfzm",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2018-03-16T02:23:21Z",
        "body": "@aqa510415008 each grain activation has its own scope, so when you call AddScoped, you are adding a service which is created per activation"
      },
      {
        "user": "xiazen",
        "created_at": "2018-03-20T20:14:49Z",
        "body": "Thanks reuben for answering. @aqa510415008 does this answer your question? or do you have further questions? "
      },
      {
        "user": "lfzm",
        "created_at": "2018-03-21T02:08:55Z",
        "body": "@ReubenBond @xiazen Thank you, I understand"
      }
    ]
  },
  {
    "number": 4168,
    "title": "RequestContext not available in next operation",
    "created_at": "2018-03-08T11:06:29Z",
    "closed_at": "2018-03-12T09:02:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/4168",
    "body": "We have a Grain that uses the RequestContext to pass along the user information. When we use the same Grain instance twice in our calling code, the second call no longer has access to the RequestContext, which seems normal since it (the second operation) is completed on another thread. However it would seem to me that the RequestContext should be migrated to the new thread, or am I completely missing the point?\r\nShould every Grain instance be used only once? Likely refetching the instance would resolve the issue (not tested, will try this out later).\r\n\r\nClient:\r\nRequestContext.Set(\"User\", User.Id);\r\nvar grain = ClusterClient.GetGrain<OurGrain>();\r\ngrain.Operation1();\r\ngrain.Operation2();\r\n\r\nOurGrain:\r\nOperation1():\r\nRequestContext.Get(\"User\") => Fine\r\n\r\nOperation2():\r\nRequestContext.Get(\"User\") => null",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/4168/comments",
    "author": "wiezykrwi",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2018-03-08T18:58:33Z",
        "body": "`RequestContext` is mean to be set per grain call.\r\n\r\nSince a grain can be called in parallel by multiple callers (clients and other grains), between `grain.Operation1()` and `grain.Operation2()` it could have processed a number of requests from other callers, and you probably don't want those calls to be process with the request context you set before `grain.Operation1()`. Likewise, you most likely don't want `grain.Operation2()` to operate with a context set by other caller. Hence, the behavior of request context only use for a single call."
      },
      {
        "user": "wiezykrwi",
        "created_at": "2018-03-12T09:02:09Z",
        "body": "I see your point, but still feel like the context could be reapplied when calling the second time as is done the first time. However I will close the issue, thank you for taking the time to answer!"
      },
      {
        "user": "Jens-G",
        "created_at": "2020-12-13T23:14:04Z",
        "body": "Old thread but ran into same situation today. And found it a bit unexpected, as the OP did. \r\n\r\n**Suggestion:** Can we have some sort of an optional flag that allows to have values persistent on a per-key basis?\r\nWould be perfectly fine to have the default set to the current behaviour."
      }
    ]
  },
  {
    "number": 3903,
    "title": "how to use IClusterClient ",
    "created_at": "2018-01-25T02:41:41Z",
    "closed_at": "2018-01-25T06:23:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3903",
    "body": "1.Create a static IClusterClient, all use it. ex: static IClusterClient clusterClient = clusterClient.Connect().Wait();\r\n\r\n2.or each client's method build a instance (IClusterClient clusterClient=IClientBuilder.Build() cost 0.5second),\r\nthen clusterClient.Connect()-> todo->clusterClient.Dispose(),  \r\nnext time IClusterClient clusterClient=IClientBuilder.Build()  clusterClient.Connect()-> todo->clusterClient.Dispose()\r\n\r\nWhich one? or other?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3903/comments",
    "author": "Qoooooooooooo",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2018-01-25T03:27:35Z",
        "body": "Use **1**. Share a single client.\r\nBuild & Connect the client when the app starts and stop it when the application finishes."
      },
      {
        "user": "Qoooooooooooo",
        "created_at": "2018-01-25T06:23:55Z",
        "body": "@ReubenBond thx:)"
      }
    ]
  },
  {
    "number": 3847,
    "title": "Dependency Injection in ASP.NET Core",
    "created_at": "2018-01-10T11:04:51Z",
    "closed_at": "2018-01-11T02:31:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3847",
    "body": "Hi there .. for orleans 2.0, what I should register to IServiceCollection? ClientBuilder? what will be its lifetimes? Transient or Scoped or Singleton? Thanks for help.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3847/comments",
    "author": "darting",
    "comments": [
      {
        "user": "alirezajm",
        "created_at": "2018-01-10T15:46:38Z",
        "body": "From my short experience with orleans:\r\nWithin a grain the scope is the lifetime of the grain activation.\r\n\r\nSo as the grains will live a long time normally (2 hours I believe is the default), which means the same instance will process requests, the services are injected only once per activation (If you're doing constructor injection). And when you resolve services within a grain yourself you'll get the same instance if you register them as scoped. So it's \"a little\" different compared to per request scopes like in asp.net mvc."
      },
      {
        "user": "ReubenBond",
        "created_at": "2018-01-10T21:38:41Z",
        "body": "The lifetime is whatever you decide: Singleton, Scoped (per-activation), or Transient\r\n\r\nAs for what you should register to: there is only one IServiceCollection per ClientBuilder or SiloHostBuilder, so it doesn't matter how you register a service."
      },
      {
        "user": "SebastianStehle",
        "created_at": "2018-01-10T21:50:17Z",
        "body": "I think the question was, what he should register TO the asp.net core application.\r\n\r\nI would register the IClusterClient as Singleton to the Asp.Net Core DI. "
      },
      {
        "user": "ReubenBond",
        "created_at": "2018-01-10T22:10:54Z",
        "body": "Oh, got it!\r\n\r\nYes, register the `IClusterClient` as a singleton.\r\nOptionally also register it as `IGrainFactory` in case that's all you need."
      },
      {
        "user": "SebastianStehle",
        "created_at": "2018-01-10T22:23:57Z",
        "body": "The `IGrainFactory` is also nice for co-hosting. Then you have 2 DI containers. One for the Silo and the other one for the asp.net part. But I need to access the grains from both parts. The IGrainFactory is a common interface and therefore you do not have to care, whether you are in the Silo or not."
      },
      {
        "user": "darting",
        "created_at": "2018-01-11T02:09:39Z",
        "body": "Hey all, got it .. thanks"
      }
    ]
  },
  {
    "number": 3242,
    "title": "What is ServiceId & DeploymentId when running under Service Fabric?",
    "created_at": "2017-07-20T12:40:43Z",
    "closed_at": "2017-07-22T12:11:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3242",
    "body": "I wanted to ask what we should be setting these to be while running under service fabric? Our deployment would look something like the following. We have one silo \"Silo A\" that is responsible for grains 1 & 2. The silo will be deployed on 3 nodes in the service fabric cluster.\r\n\r\n- Node 1\r\n-- Silo A\r\n--- Grain 1\r\n--- Grain 2\r\n- Node 2\r\n-- Silo A\r\n--- Grain 1\r\n--- Grain 2\r\n- Node 3\r\n-- Silo A\r\n--- Grain 1\r\n--- Grain 2\r\n\r\nDeploymentId is required for the Azure Queue stream provider so I need to set it to something. However, i wasnt sure what the semantics were around these two values and what they control.",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3242/comments",
    "author": "charleszipp",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2017-07-21T03:37:36Z",
        "body": "@charleszipp set `ServiceId` and `DeploymentId` to a value which is consistent between all silos and clients in the cluster."
      },
      {
        "user": "sergeybykov",
        "created_at": "2017-07-21T14:51:01Z",
        "body": "`ServiceId` is supposed to stay the same across multiple deployments of the same service over time as you deploy new versions of the deployment/cluster."
      },
      {
        "user": "charleszipp",
        "created_at": "2017-07-22T12:11:12Z",
        "body": "Thanks for the responses @ReubenBond and @sergeybykov ! That gives me what i needed to know."
      },
      {
        "user": "talarari",
        "created_at": "2017-11-08T17:48:44Z",
        "body": "@ReubenBond  @sergeybykov Does DeploymentId need to be different across deployments?\r\nwhat will happen if i just set it to a hardcoded string?"
      },
      {
        "user": "sergeybykov",
        "created_at": "2017-11-22T22:02:52Z",
        "body": ">@ReubenBond @sergeybykov Does DeploymentId need to be different across deployments?\r\nwhat will happen if i just set it to a hardcoded string?\r\n\r\nThe danger here is that you may end up deploying at some point have a different service/cluster with the same DeploymentId. "
      },
      {
        "user": "talarari",
        "created_at": "2017-11-22T22:10:03Z",
        "body": "Im not sure i understand what's the purpose of deployment id.\r\nWhat is it used for?"
      },
      {
        "user": "sergeybykov",
        "created_at": "2017-11-22T22:24:28Z",
        "body": "It should have been caller `ClusterId` instead. It is the unique identifier of a cluster, and silos in a cluster find each other using it as a key.\r\n"
      },
      {
        "user": "talarari",
        "created_at": "2017-11-22T22:41:03Z",
        "body": "Ok that sounds more clear to me.\r\nI was under the impression that deployment id should be different between two vervsion deployments to the same cluster, something like a versionid.\r\nSo basically if its the only orleans cluster running on those machines this can just be a costant name?\r\nOr is it used for things like versioned grains and placements strategies?"
      },
      {
        "user": "sergeybykov",
        "created_at": "2017-11-22T22:46:30Z",
        "body": ">So basically if its the only orleans cluster running on those machines this can just be a costant name?\r\n\r\nYes.\r\n\r\n>Or is it used for things like versioned grains and placements strategies?\r\n\r\nNo.\r\n\r\nIt's just a key for silos and clients to find each other in the membership table."
      }
    ]
  },
  {
    "number": 3132,
    "title": "[Question] Bootstrapping DI and logging",
    "created_at": "2017-06-15T13:26:27Z",
    "closed_at": "2017-06-16T16:56:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3132",
    "body": "I have a simple question: when bootstrapping my services in the `Startup` class using dependency injection I want to do some logging using Orleans logger. But how will I get a logger instance in my `ConfigureServices` method?",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3132/comments",
    "author": "peter-perot",
    "comments": [
      {
        "user": "jdom",
        "created_at": "2017-06-15T16:27:29Z",
        "body": "Hmmm, interesting question, but it is currently not possible. The logging infrastructure should be configured by then, but it's not really accessible from the startup type.\r\nIf this is temporary just to troubleshoot a few things, what you can do for now is use reflection to get the logger. Note that this might not be supported in the future, especially since we are looking to migrate to `Microsoft.Extensions.Logging` in the release following 1.5 (but this hack will work in 1.5 still). Nevertheless, once we move to that, the logger will be usable when configuring the silo, so hopefully no hack will be necessary.\r\n\r\nTo get the logger via reflection, you'd have to do something like this:\r\n```csharp\r\n// Call LogManager.GetLogger(this.GetType().Name) with reflection, as it's internal\r\nvar getLoggerMethod = typeof(LogManager).GetMethod(\"GetLogger\", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static, null, new Type[] { typeof(string) }, null);\r\nLogger logger = (Logger)getLoggerMethod.Invoke(null, new object[] { this.GetType().Name });\r\n\r\nlogger.Info(\"Now I can use the logger\");\r\n```"
      },
      {
        "user": "peter-perot",
        "created_at": "2017-06-16T08:54:40Z",
        "body": "@jdom Thank you, it works! :-)"
      }
    ]
  },
  {
    "number": 3009,
    "title": "Unable to immediately restart a Silo after entire cluster shuts down unexpectedly.",
    "created_at": "2017-05-10T14:02:06Z",
    "closed_at": "2017-05-11T16:23:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/3009",
    "body": "Hey there,\r\n\r\nAs noted in the title, it appears that we are unable to restart a Silo after the entire cluster dies unexpectedly.\r\n\r\nTo replicate this issue, we have two Silos running together on the same machine. \r\nOne is using Port 22222 and Proxy Port 40000 (Silo A), the other Port 22223 and Proxy Port 40001 (Silo B). \r\nAfter them running for a period of time (the length of which doesn't seem to matter), we close both of them together.\r\nAt this point the OrleansMembershipTable displays both Silos as Active (3) due to nothing being able to update this.\r\nWe then restart the Silo A.\r\nThis then takes 5 minutes (almost exactly) before failing to initialize the Silo.\r\nIt then reports that Silo A became unavailable for messaging.\r\n\r\nUpon inspecting the OrleansMembershipTable at this point, we can see that Silo A has had its status changed to 'Joining' (2).\r\n\r\nAfter this, starting Silo A or B is fine, regardless of their current status in the OrleansMembershipTable.\r\n\r\nThrough some investigation, we've managed to determine that the issue is in SiloHost.StartOrleansSilo();\r\n\r\nWhat we're wanting to know is if there is any way around this issue.\r\n\r\nThank you\r\n\r\nExtra Info:\r\nOrleans Version 1.3\r\n\r\nStartupError Log (Side note: the C:\\w\\Git\\Orleans_GeoSamples\\src\\OrleansRuntime\\Silo\\Silo.cs is not my directory)\r\n\r\n>2017-05-10-10.34.19.856ZZ\r\n>ERROR starting Orleans silo name=[REDACTED] Exception=\r\n>Exc level 0: System.AggregateException: One or more errors occurred.\r\n>   at System.Threading.Tasks.Task.ThrowIfExceptional(Boolean includeTaskCanceledExceptions)\r\n>   at System.Threading.Tasks.Task.Wait(Int32 millisecondsTimeout, CancellationToken cancellationToken)\r\n>   at System.Threading.Tasks.Task.Wait(TimeSpan timeout)\r\n>   at Orleans.OrleansTaskExtentions.WaitWithThrow(Task task, TimeSpan timeout) in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\TaskExtensions.cs:line 210\r\n>   at Orleans.Runtime.Silo.DoStart() in C:\\w\\Git\\Orleans_GeoSamples\\src\\OrleansRuntime\\Silo\\Silo.cs:line 550\r\n>   at Orleans.Runtime.Silo.Start() in C:\\w\\Git\\Orleans_GeoSamples\\src\\OrleansRuntime\\Silo\\Silo.cs:line 439\r\n>   at Orleans.Runtime.Host.SiloHost.StartOrleansSilo(Boolean catchExceptions) in C:\\w\\Git\\Orleans_GeoSamples\\src\\OrleansRuntime\\Silo\\SiloHost.cs:line 178\r\n>Exc level 1: Orleans.Runtime.OrleansException: -Silo S127.0.0.1:22222:232108136 failed to update its status to Active in the table due to failures (socket failures or table read/write failures) after 38 attempts: ExecuteWithRetries has exceeded its max execution time of 00:05:00. Now is 2017-05-10 10:34:19.828 GMT, started at 2017-05-10 10:29:17.236 GMT, passed 00:05:02.5922384\r\n>   at Orleans.Runtime.MembershipService.MembershipOracle.<UpdateMyStatusGlobal>d__48.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\OrleansRuntime\\MembershipService\\MembershipOracle.cs:line 390\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.Runtime.MembershipService.MembershipOracle.<BecomeActive>d__30.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\OrleansRuntime\\MembershipService\\MembershipOracle.cs:line 168\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.Runtime.Scheduler.SchedulerExtensions.<>c__DisplayClass1_0.<<QueueTask>b__0>d.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\OrleansRuntime\\Scheduler\\ShedulerExtensions.cs:line 38\r\n>Exc level 2: System.TimeoutException: ExecuteWithRetries has exceeded its max execution time of 00:05:00. Now is 2017-05-10 10:34:19.828 GMT, started at 2017-05-10 10:29:17.236 GMT, passed 00:05:02.5922384\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 185\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.AsyncExecutorWithRetries.<ExecuteWithRetriesHelper>d__5`1.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\Orleans\\Async\\AsyncExecutorWithRetries.cs:line 179\r\n>--- End of stack trace from previous location where exception was thrown ---\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n>   at Orleans.Runtime.MembershipService.MembershipOracle.<UpdateMyStatusGlobal>d__48.MoveNext() in C:\\w\\Git\\Orleans_GeoSamples\\src\\OrleansRuntime\\MembershipService\\MembershipOracle.cs:line 366",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/3009/comments",
    "author": "Saraphite",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2017-05-11T05:18:08Z",
        "body": "This is by design. Silo A is waiting for silo B to respond. One workaround is to start both silos . Another workaround is to wipe the table before you restart.\r\nThere is also a way to shorten the wait period, so silo a will wait less time for b. I will add a details of the config parameter to do that later.\n\n---\n\nThe third and easiest option is to set orleansConfig.Globals.ValidateInitialConnectivity to false. \r\n\r\nThat will completely disable the check in A of B. A will start OK and will just ignore this old entry of B saying Active.\r\nOnce B will start, it will mark its own old entry in the table as Dead and write a new entry and will be OK.\r\n"
      },
      {
        "user": "Saraphite",
        "created_at": "2017-05-11T15:34:26Z",
        "body": "Initial impressions seem to be that this worked!\r\n\r\nThank you."
      }
    ]
  },
  {
    "number": 2544,
    "title": "AzureSilo Config TableName",
    "created_at": "2016-12-24T08:15:24Z",
    "closed_at": "2017-01-03T08:20:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/2544",
    "body": "Hello\r\nIn AzureSilo's Config it is possible to configure TableName (by default OrleansGrainState). I was expecting to be able to configure TableName in AzureClient; I could no find how to set that value.\r\nEven changing TableName in the AzureSilo the AzureClient kept working, this raised a couple of questions:\r\n1. How does AzureClient know about AzureSilos?\r\n2. Having multiple silos (with different grains each), should I use different GrainState tables or just one is good enough?\r\nThank you",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/2544/comments",
    "author": "mauriciomagni",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2017-01-03T05:30:07Z",
        "body": "There seems to be some confusion here. Grain state isn't visible or accessible to clients. So the `TableName` setting, when it comes to grain state, makes sense only on the silo side.\r\n\r\nThe cluster membership protocol, on the other hand, is what, among other things, allows clients to discover silos to connect to them. That's kind of the answer to your first question.\r\n\r\n>2. Having multiple silos (with different grains each), should I use different GrainState tables or just one is good enough?\r\n\r\nAll silo use the same configuration because grains are not permanently affiliated with any silo, and only get activated on a particular silo for some time. Hence, all silos need to write and read grain state to/from the same storage, table-based or nor."
      }
    ]
  },
  {
    "number": 2101,
    "title": "Stream throwing an exception",
    "created_at": "2016-08-28T02:04:08Z",
    "closed_at": "2016-09-05T21:42:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/2101",
    "body": "I'm writing a tracking service where the devices connect to the server via TCP and I need to report to a company the status of the devices, I have a DeviceGrain where I deserialize the message, make some calculations and then, via a stream, report the data to a CompanyGrain, on my OnActivateAsync I have the following piece of code:\n\n```\n_stream = GetStream();\n\n            //when a new message arrive\n            _stream.SubscribeAsync((data, token) =>\n            {\n                if (data.GetType().ToString().Contains(\"Alert\"))\n                {\n                    _notificationHub.Invoke(\"SendAlert\", new object());\n                }\n                else if(data.GetType().ToString().Contains(\"Notification\"))\n                {\n                    var status = (StatusNotification)data;\n                    DeviceStatus deviceStatus;\n                    var exists = devicesStatus.TryGetValue(status.Id, out deviceStatus);\n                    if (exists)\n                    {\n                        devicesStatus[status.Id] = status.Status;\n                    }\n                    else\n                    {\n                        devicesStatus.Add(status.Id, status.Status);\n                    }\n                }\n```\n\nThe method GetStream is written as follows:\n\n```\nprivate IAsyncStream<object> GetStream()\n\n        {\n            var streamProvider = base.GetStreamProvider(\"SMSProvider\");\n            var companyStream = streamProvider.GetStream<object>(this.GetPrimaryKey(), \"Devices\");\n            return companyStream;\n        }\n```\n\nEverything works fine, the code inside the SuscribeAsync gets executed as it should (when a message arrives) bue it always throws the exception written below.\n\nExtension not installed on grain GrainCollection.DeviceGrain attempting to invoke type Orleans.Streams.OrleansCodeGenStreamConsumerExtensionMethodInvoker from invokable Orleans.Runtime.ActivationData\nException = Orleans.Runtime.GrainExtensionNotInstalledException: Extension not installed on grain GrainCollection.DeviceGrain attempting to invoke type Orleans.Streams.OrleansCodeGenStreamConsumerExtensionMethodInvoker from invokable Orleans.Runtime.ActivationData\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/2101/comments",
    "author": "miker1423",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2016-08-29T02:23:34Z",
        "body": "Is it possible you are missing await before subscribe?\n"
      },
      {
        "user": "miker1423",
        "created_at": "2016-08-29T02:28:34Z",
        "body": "I thought so, I added async and await and the error persisted.\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-08-29T22:25:07Z",
        "body": "Just to clarify, you changed the code to `await _stream.SubscribeAsync((data, token) =>`?\n"
      },
      {
        "user": "miker1423",
        "created_at": "2016-08-29T22:28:27Z",
        "body": "Exactly.\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-08-29T22:38:19Z",
        "body": "This is very strange. Even though the lambda should be totally fine. Can you try defining the callback as a method on the grain class? Just to compare.\n"
      },
      {
        "user": "jason-bragg",
        "created_at": "2016-08-30T00:59:22Z",
        "body": "As Sergey stated, you must await the subscribe call or this can occure.  Assuming you are:\n\nIs your grain marked reentrant?  That could cause this behavior.\n\nAre there any conditions under which your grain could activate without subscribing?\n\nWhat stream provider are you using?\n\nAre you using implicit subscriptions or explicit subscriptions?  Looks like implicit..\n"
      },
      {
        "user": "ReubenBond",
        "created_at": "2016-08-30T01:17:56Z",
        "body": "@jason-bragg even if the grain is marked as reentrant, we should not be allowing reentrancy before activation has completed - should we? It's like allowing calls to a half-constructed object.\n\n@miker1423 I think a larger code snippet would be useful here.\n"
      },
      {
        "user": "miker1423",
        "created_at": "2016-08-30T04:49:02Z",
        "body": "@jason-bragg answering your questions:\n1.- The grain isn't reentrant.\n2.- No, the stream is created inside the OnActivateAsync method as well as the suscribe method.\n3.- I'm using the simple message stream as my provider\n4.- I'm using Implicit subscriptions\n\n@ReubenBond, the thing is that the only thing I'm doing in the OnActivateAsync method...\nI'll omit all the trivial code only leaving the stream part.\n\n```\nusing Orleans;\nusing Orleans.Streams;\nusing Orleans.Runtime;\nnamespace GrainCollection\n{\n         [ImplicitStreamSubscription(\"Devices\")]\n         public class CompanyGrain : Grain, ICompanyGrain\n         {\n                 private IAsyncStream<DeviceNotification> _stream;\n\n                public override async Task OnActivateAsync()\n                {\n                        _stream = GetStream();\n                        await _stream.SuscribeAsync((data, token) => \n                          {\n                            if(data.IsAlert){ TriggerAlerts(data); }\n                            else { UpdateStatus(data); }\n                          }\n                }\n\n                private IAsyncStream<DeviceNotification> GetStream()\n                {\n                      var streamProvider = base.GetStreamProvider(\"SMSProvider\");\n                      var companyStream = streamProvider.GetStream<DeviceNotification>(this.GetPrimaryKey(), \"Devices\");\n                      return companyStream;\n                }\n\n         }\n}\n```\n"
      },
      {
        "user": "jason-bragg",
        "created_at": "2016-08-30T17:29:40Z",
        "body": "@miker1423 \nThe referenced exception reports that the grain having issue is \"GrainCollection.DeviceGrain\", but the code you've referenced is from GrainCollection.CompanyGrain.  Does GrainCollection.DeviceGrain have a [ImplicitStreamSubscription(\"Devices\")] attribute on it?\n"
      },
      {
        "user": "miker1423",
        "created_at": "2016-08-30T18:08:40Z",
        "body": "@jason-bragg sorry, my fault, wrong class, I'll edit it. \nEDIT: I remembered why I showed that code, the exception is raised when the Company grain is executed.\n\nBut here is the device grain Code also:\n\n```\nusing Orleans;\nusing Orleans.Streams;\nusing Orleans.Runtime;\nusing Orleans.Runtime.Configuration;\n\nnamespace GrainCollection\n{\n         [ImplicitStreamSubscription(\"Devices\")]\n         public class DeviceGrain : Grain, IDeviceGrain, IRemindable\n         {\n                private IAsyncStream<DeviceNotification> _stream;\n\n                public override Task OnActivateAsync()\n                {\n                       _stream = GetStream();\n                       return TaskDone.Done;\n                }\n\n                private Task UpdateLocation(Point newLocation)\n                {\n                       _stream.OnNextAsync(new DeviceNotification {\n                            Id = this.GetPrimaryKeyLong(),\n                            Status = _status, //Private variable\n                            Location = newLocation,\n                            IsAlert = false\n                        });\n                }\n         }\n}\n```\n"
      },
      {
        "user": "ReubenBond",
        "created_at": "2016-08-30T19:08:16Z",
        "body": "@miker1423 your `DeviceGrain` class has an `[ImplicitSubscription(...)]`, but you are not subscribing to that stream in `OnActivateAsync`\n"
      },
      {
        "user": "jason-bragg",
        "created_at": "2016-08-30T19:31:43Z",
        "body": "TL;DR - Remove the ImplicitSubscription attribute from the DeviceGrain.\n\nThe ImplicitSubscription attribute is used on grains that one wants to implicitly subscribe to a stream.  The DeviceGrain produces on the stream but does not subscribe to it.  By having an ImplicitSubscription attribute on the grain, the streaming infrastructure is trying to deliver events to DeviceGrains, and getting the referenced exception because those activations are not subscribing to the stream during grain activation.\n"
      },
      {
        "user": "miker1423",
        "created_at": "2016-09-05T21:42:24Z",
        "body": "Thanks! that made it. :smile: \n"
      }
    ]
  },
  {
    "number": 1736,
    "title": "Configuring Reminders with the silo process",
    "created_at": "2016-05-05T18:56:46Z",
    "closed_at": "2016-05-06T16:10:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1736",
    "body": "We have implemented our silohost in a windows service. We have a number of grains, which should run \"batch-like\". Some with 2-hour interval, some with 24-hour interval and some with monthly interval. We thought a good implementation of that would be as reminders.\n\nWe need a place to configure these reminders in Orleans, and we thought a natural place for that is when starting the windows, service which holds the silo. Something like the below.\n\nHowever, Orleans will not let use GrainClient to get a reference to a grain. And as I understand we need a grain to register a reminder. We get an error \"You are running inside the provider code, on the silo. GrainClient.GrainFactory should only be used on the client side. Inside the provider code use GrainFactory that is passed via IProviderRuntime (use providerRuntime.GrainFactory).\"\n\nIs there any way to register a grain when starting the silo host process?\n\n```\n        _siloHost = new SiloHost(\"MySilo\", ClusterConfiguration.LocalhostPrimarySilo());\n        _siloHost.InitializeOrleansSilo();\n        _siloHost.StartOrleansSilo();\n\n        GrainClient.GrainFactory.GetGrain<IMyBatchGrain>(\"MyBatchGrain\").Register();\n```\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1736/comments",
    "author": "FenrisWolfAtMiddleEarth",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2016-05-05T19:14:10Z",
        "body": "You should write this code inside bootstrap provider.\n\nYour other option is to create a grain client inside a separate app domain, or even process. But it cannot be in the same memory domain with the silo and not inside provider or grain.\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2016-05-05T21:58:09Z",
        "body": "> We need a place to configure these reminders in Orleans, and we thought a natural place for that is when starting the windows, service which holds the silo. Something like the below.\n\nIf those reminders need to be registered once, then trying to do the same upon each restart of each node seems excessive to me. Reminders survive restarts and redeployments of a service. I think it would be more logical to execute an explicit 'configuration' task once right after a first deployment via a separate process or something, and not deal with that after.\n"
      },
      {
        "user": "FenrisWolfAtMiddleEarth",
        "created_at": "2016-05-06T16:10:42Z",
        "body": "Thanks\nBootstrapprovider seems to do the job nicely for us.\nWe understand your suggestion about an explicit configuration task which just runs once. however that just complicates spinning up a fresh system on a phoenix server. (We do that for automated integration tests etc.)\nHopefully silo nodes are rarely restarted, so re-registering at those rare occasions should not be a problem.\n"
      }
    ]
  },
  {
    "number": 1220,
    "title": " Hosting AzureSilo and Web layer on the same worker role",
    "created_at": "2015-12-31T20:21:25Z",
    "closed_at": "2016-01-07T03:37:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1220",
    "body": "This is a question . In Azure, can a same worker role be a Client (http but selfhosted webapi)  as well as host the Orleans Silo.  As per the examples I have seen they are separate roles.  \n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1220/comments",
    "author": "loneshark99",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2016-01-01T01:35:45Z",
        "body": "They can. But you need to host the client in a separate app domain. There are some examples in samples and unit tests.\n"
      },
      {
        "user": "loneshark99",
        "created_at": "2016-01-07T02:49:14Z",
        "body": "@gabikliot thank you, worked perfectly.\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2016-01-07T03:37:33Z",
        "body": "Great.\n"
      }
    ]
  },
  {
    "number": 1025,
    "title": "Orleans Namespace Convention",
    "created_at": "2015-11-16T20:55:05Z",
    "closed_at": "2015-11-17T15:24:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/1025",
    "body": "It's not so obvious for most of us what is the rationale behind Orleans namespace structure.\n\nFor example the file `Orleans\\Logging\\ILogConsumer.cs` is under namespace `Orleans.Runtime`...\n\nIs that any reason for it? Its a bit confusing for newcomers to get handy on Orleans code since VS automatically creates namespaces based on directories under the project and following the Default Namespace setting on project properties.\n\nSo, should we normalize all the projects in order to follow VS conventions or should be just follow as is?\n\nThanks\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/1025/comments",
    "author": "galvesribeiro",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2015-11-17T05:46:56Z",
        "body": "Yes, there was a reasoning behind that.\nBasically, the thinking was: put most useful APIs in the one root namespace, `Orleans`. Keep it slim and only for the core programming abstractions, so the new user can  see only what is really required and not all the advanced stuff.\nThe rest, more advanced stuff, put in derived namespaces. \nAlso, don't have to follow Java practice of matching folders to packages. Again, the goal is to make it easier for the user of Orleans: simple stuff is in one namespace `Orleans`, more advanced stuff is in a couple (and not 25) namespaces.\nWe got advice to organize it this way from a professional .NET API design gurus in MS.\n\nClearly, this is quite subjective and can be reviewed and changed.\n"
      }
    ]
  },
  {
    "number": 741,
    "title": "Accessing GrainFactory from IBootstrapProvider in 1.0.9.",
    "created_at": "2015-08-26T21:17:31Z",
    "closed_at": "2015-08-27T13:38:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/741",
    "body": "I have been working through the process of upgrading to orleans 1.0.9 from 1.0.8.  We have some code that implements IBootstrapProvider, which is used to load some starting data into the system at startup.  \nBefore: \n`var cropGrain = GrainFactory.GetGrain<ICrop>(crop.CropId);`\n\nAfter:\n`var cropGrain = GrainClient.GrainFactory.GetGrain<ICrop>(crop.CropId);`\n\nThis was working fine in 1.0.8.  Now, the calls to get grain references from the GrainFactory are failing due to the GrainClient not being initialized.  Since this code is running on the Silo, I wouldn't expect to need to configure a client.  Attempts to do so have failed.\n\nAre there any examples of how to properly interact with grains in the bootstrap providers, which are set up to be deployed on Azure?  \n\nThanks\nPhil\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/741/comments",
    "author": "philreindl",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2015-08-26T21:24:37Z",
        "body": "The `GrainFactory` is available via a member field in `IProviderRuntime` that is passed to `IBootstrapProvider.Init()`.\n"
      },
      {
        "user": "philreindl",
        "created_at": "2015-08-27T13:38:38Z",
        "body": "So it is.  Thanks for getting me straightened out!\n"
      }
    ]
  },
  {
    "number": 699,
    "title": "Usage of C# 6.0 features breaks code generation",
    "created_at": "2015-08-15T20:40:05Z",
    "closed_at": "2015-08-15T23:29:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/699",
    "body": "What is the status of being able to use C#6 features?\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/699/comments",
    "author": "ellern",
    "comments": [
      {
        "user": "ReubenBond",
        "created_at": "2015-08-15T23:26:27Z",
        "body": "When #528 merges, the new language features will be available.\n"
      },
      {
        "user": "ellern",
        "created_at": "2015-08-15T23:29:53Z",
        "body": "Great, then this can be closed.\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-08-15T23:40:50Z",
        "body": "Searching for the like button on @ReubenBond's comment. \n:+1: \n"
      }
    ]
  },
  {
    "number": 692,
    "title": "Grain faulted state",
    "created_at": "2015-08-12T15:55:13Z",
    "closed_at": "2015-08-12T20:32:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/692",
    "body": "Trying to figure out what is the approach for the following scenario.\n\nThere is operation (async method) in grain which updates the state and the state persisted at the end. In case there is failure during state change (logical Exception) or while writing to storage, I want to \"rollback\". By \"rollback\" I mean:\n- Either re-read the state from storage and throw exception, so the caller will be aware that operation failed\n- Or kill (deactivate?) the grain\n\nIn first case there also possibility that the re-read state will also fail, which takes me to second approach. \n\nWhat is the best practice to handle faulted state of actors in Orleans?\n\nThanks.\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/692/comments",
    "author": "jenyayel",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2015-08-12T18:01:57Z",
        "body": "Both are valid approaches. You can force activation to deactivate by calling `DeactovateOnIdle`. On the other hand, the 1st approach allows you a more fined grained and application specific error recovery.\nWe deliberately did not want to constrain the system to only do 1 or 2, and allow the app to pick its own.\n\nWe do have an open work item to treat eTag mismatch exceptions from the storage automatically. We will use strategy 2 - if the grain got eTag mismatch exception upon write, we plan to automatically deactivate this activation. The reason is that eTag mismatch exception basically means we got 2 activations of that grain, which is an error condition, and one of the activations should be deactivated anyway. But for other errors we leave it to the app code to handle.\n"
      },
      {
        "user": "jenyayel",
        "created_at": "2015-08-12T20:32:32Z",
        "body": "I understand. For me, instead of figuring out how to rollback in each specific case, the simpler approach is just to deactivate the grain. Thanks for clarifying. \n"
      }
    ]
  },
  {
    "number": 662,
    "title": "grain call from grain: \"You must initialize the Grain Client before accessing the GrainFactory\"",
    "created_at": "2015-07-29T10:06:41Z",
    "closed_at": "2015-07-29T17:02:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/662",
    "body": "Hi,\n\nSince I updated to 1.09 I have a problem with a grainfunction that calls another grain. The call throws an exception \"You must initialize the Grain Client before accessing the GrainFactory\".\n\nThe problem only occurs if I get the grain with \"GrainClient.GrainFactory.GetGrain<IMyGrain>(grainid)\". If I use the autogenerated (deprecated) grainfactory everything works as before. \n\nIn GrainClient.cs from the orleanscode I see the comment \"//TODO: prevent client code from using this from inside a Grain\". Does that mean, that you should not (or cannot) use a grain from another grain?\n\nThanks for any hints.\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/662/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2015-07-29T16:04:14Z",
        "body": "From within a grain it's `this.GrainFactory.GetGrain(grainid)`. `GrainClient` is to be used only from outside of a silo.\n"
      },
      {
        "user": "ghost",
        "created_at": "2015-07-29T16:43:34Z",
        "body": "oh, i see.  thanks!\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-07-29T17:49:32Z",
        "body": "I added a more explicit and more helpful exception here: #663.\n"
      }
    ]
  },
  {
    "number": 524,
    "title": "Orleans azure deployment ",
    "created_at": "2015-06-16T15:11:21Z",
    "closed_at": "2015-07-14T09:07:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/524",
    "body": "Hi, \nI have an Orleans application with silos planned to be deployed as azure worker roles and an existing client application hosted as azure web roles. If I want silos and client to live in separate deployments, I need to specify the deployment ID of silos during AzureClient initialization when web roles started. So when a new silo version is deployed I need to roll all my clients roles with the new deployment ID. Is it right or is there a better practice for aligning the clients when silos deployment changed?\nThanks.\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/524/comments",
    "author": "2mike2",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2015-06-16T15:30:20Z",
        "body": "You don't necessarily have to use Azure's Hosted Service deployment ID (that's what AzureSilo class does). Instead you can instantiate SiloHost class directly, and pass it your own deployment ID that's independent from Hosted Service deployment. Similarly on the client side, instead of using AzureClient with its logic of using Hosted Service deployment ID, you can use GrainClient directly pass your own deployment ID.\n\nOne other thing to ensure is direct network connectivity between these client and silo deployments. You may need to use an Azure Virtual Network for that.\n"
      },
      {
        "user": "2mike2",
        "created_at": "2015-06-16T16:47:22Z",
        "body": "Thank you for getting back. \n1. By connectivity issue you mean that client deployment wont have access to the silo endpoints (the TCP ports) unless it is in the same deployment as silo or in the same virtual network as you've suggested?\n2. If I use SiloHost class directly in azure worker and use the appropriate initialize / start / stop interfaces, are there any other nuances I should be aware of when SiloHost is used in worker role as opposed to AzureSilo?\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2015-06-16T17:05:24Z",
        "body": "1. Yes. My understanding is two hosted services cannot talk to each other's internal endpoints unless connected with a vNet.\n2. The other thing that's a bit complicated with Azure is finding location of the config file, especially client config in web role. But that code is in ClientConfiguration.StandardLoad() that is used by GrainClient underneath.\n"
      },
      {
        "user": "2mike2",
        "created_at": "2015-06-16T17:16:38Z",
        "body": "Ok,Thank you.\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2015-06-16T17:20:49Z",
        "body": "No problem.\n"
      },
      {
        "user": "2mike2",
        "created_at": "2015-06-16T18:46:34Z",
        "body": "On the worker side, I see that AzureSilo class has a couple of start overloads that accepts deploymentId:\npublic bool Start(string deploymentId, RoleInstance myRoleInstance, ClusterConfiguration config)\nso can I use it for providing custom deploymentId instead of using SiloHost? \n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2015-06-16T19:37:40Z",
        "body": "These overloads have been recently refactored/removed (post 1.0.8).\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-07-13T23:52:33Z",
        "body": "Hi @2mike2 . Do you still have open questions on this issue? Can it be closed?\n"
      },
      {
        "user": "2mike2",
        "created_at": "2015-07-14T09:07:54Z",
        "body": "Yes. thank you.\n"
      }
    ]
  },
  {
    "number": 350,
    "title": "Grain implementing more than one IGrain-derived interface?",
    "created_at": "2015-04-20T15:55:44Z",
    "closed_at": "2015-04-20T18:54:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/350",
    "body": "Hi.\n\nI'd like to \"partition\" Grains public interface according to access from different front-ends.\n\nIs possible and/or convenient implementing different IGrain-derived interfaces on same Grain?\n\nThanks!\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/350/comments",
    "author": "maiorfi",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2015-04-20T16:50:23Z",
        "body": "Yes, it's totally possible and easy for a grain to implement more than one grain interface.\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-04-20T18:32:42Z",
        "body": "@maiorfi , it is currently supported and works.\n"
      }
    ]
  },
  {
    "number": 258,
    "title": "is StatelessWorker single-thread  necessary?",
    "created_at": "2015-03-23T13:56:59Z",
    "closed_at": "2015-03-24T16:40:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/258",
    "body": "StatelessWorker Grain may have many activations. if one client and 10 silo. Message processing is not in order.  \n     Do ,why make  StatelessWorker Grain  single-thread? if not single-thread, will improve throughput.  \n     Imagine why? \n     Do you want to control the maximum request count in one StatelessWorker grain? like the example code TweetDispatcherGrain,  HashtagGrain which is a  common grain  could do this. Doesn't need   TweetDispatcherGrain controls the maximum amount of request.  \n     Please consider giving a new implementation for StatelessWorker Grain. if something wrong ,please correct me.\n\n``` csharp\n[StatelessWorker]\npublic class TransferTransactionProcessManager : Orleans.Grain, ITransferTransactionProcessManager\n { \n        private int counter = 0;\n        async Task ITransferTransactionProcessManager.ProcessTransferTransaction(Guid fromAccountId, Guid toAccountId, decimal amount)\n        {\n            counter += 1;\n            Console.WriteLine(\"<---------------------before delay\" + counter + \"----------------------------------->\");\n            var tcs = new TaskCompletionSource<int>();\n\n            Task.Delay(5 * 1000).ContinueWith((t) =>\n            {\n                Console.WriteLine(\"<---------------------------delay\"+counter+\"----------------------------------->\");\n                tcs.SetResult(1);\n            });\n            await tcs.Task;\n            return;\n         }\n}\n```\n\nconsole \n\n```\n<---------------------before delay1----------------------------------->\n<---------------------------delay1----------------------------------->\n<---------------------before delay2----------------------------------->\n<---------------------------delay2----------------------------------->\n<---------------------before delay3----------------------------------->\n<---------------------------delay3----------------------------------->\n```\n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/258/comments",
    "author": "witterlee",
    "comments": [
      {
        "user": "sergeybykov",
        "created_at": "2015-03-23T14:35:18Z",
        "body": "The main reason for the single-threaded execution of grain activations is to prevent concurrency issues and a need for thread synchronization in the grain code. A StatelessWorker grain may have private data structures that in general would have to be protected with locks in case of a multi-threaded execution. So the thought is that having multiple single-threaded activations is safer than a single multi-threaded activation.\n"
      },
      {
        "user": "witterlee",
        "created_at": "2015-03-23T14:52:52Z",
        "body": "If I have two choices  \nA : control concurrency safe by myself,and get better throughput  \nB : control concurrency safe by single-threaded execution of grain.\n\nI perfer A much more than B.\nlike the code I show.\n1start-->wait 5 seconds-->1end -->2start-->wait 5senonds-->2end.\n\nif 100 request/seconds, when sending 6-8 request\uff0c subsequent requests will timeout.  but the request queue maybe not long enough to create a new activation for this StatelessWorker grain.\n\nSo,I suggestion implement StatelessWorker grain not single-threaded. \nLike the blow code,I only add a syncLocker protect counter for multi-thread update, but I get better throughput.\n\n``` csharp\n[StatelessWorker]\npublic class TransferTransactionProcessManager : Orleans.Grain, ITransferTransactionProcessManager\n { \n        private int counter = 0;\n        private object syncLocker=new object();\n        async Task ITransferTransactionProcessManager.ProcessTransferTransaction(Guid fromAccountId, Guid toAccountId, decimal amount)\n        {\n            lock(syncLocker) counter += 1;\n            Console.WriteLine(\"<---------------------before delay\" + counter + \"----------------------------------->\");\n            var tcs = new TaskCompletionSource<int>();\n\n            Task.Delay(5 * 1000).ContinueWith((t) =>\n            {\n                Console.WriteLine(\"<---------------------------delay\"+counter+\"----------------------------------->\");\n                tcs.SetResult(1);\n            });\n            await tcs.Task;\n            return;\n         }\n}\n```\n\nanybody agree with me?\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2015-03-23T15:21:25Z",
        "body": "If a grain becomes such a bottleneck that it makes you consider making it multi-threaded, I would take a harder look at the decomposition of the app logic. The grain model assumes that grains are small enough pieces of state and logic that none of them individually requires a lot of resources. Such an approach has its limits, of course, but in our opinion it helps scalability a great deal.\n\nLeveraging thread synchronization mechanisms from within grain code can easily reduce throughput or block execution altogether by preventing other grains from running. If you believe you have a need for such a multi-threaded high throughput component, I would suggest to consider putting it outside Orleans.\n"
      },
      {
        "user": "gabikliot",
        "created_at": "2015-03-23T16:13:50Z",
        "body": "You have lots of alternatives: \n1) use a set of StatelessWorker grains and round robin between them (different grain ids). \n2) use Thread Pool for concurrency (Task.Run) within the StatelessWorker activation and manage concurrency yourself.\n3) Consider re-design, as Sergey suggested.\n\nActors are single threaded, by definition. I doubt we will consider changing such a fundamental programming model guarantee.\n"
      },
      {
        "user": "alan-geller",
        "created_at": "2015-03-23T22:14:11Z",
        "body": "A subtle reason for keeping actors single-threaded is that it lets the Orleans scheduler make some simplifying assumptions about processor usage that allow it to run very efficiently in most situations. By default, Orleans allocates a worker thread per logical core, and runs a single actor per worker thread. There\u2019s no preemption; it\u2019s cooperative multiprocessing.\n\nBecause the number of threads matches the number of logical cores, in general the threads don\u2019t block and there are no thread context switches. This isn\u2019t quite true because of threads used for messaging and other IO, but the number of thread switches per minute on Orleans is much, much lower than is common on more highly multi-threaded platforms. In particular, the number of context switches per minute doesn\u2019t go up when system load increases.\n\nAll of this lets Orleans run smoothly at over 90% CPU usage, where (in my experience) typical rule of thumb is to limit servers to no more than 80% usage because otherwise context switch (and other kernel) overhead will bring things to a screeching halt\u2026\n\nDoing a bunch of multithreaded computation within a grain will break this assumption and likely make the silo as a whole perform worse. If you split the computation out of the grain and run it in a logically separate compartment that you make asynch requests to, as if it were an IO service, then you can play with the Orleans config to tell the Orleans scheduler to use fewer worker threads; this will let the silo run smoothly on one set of cores while the computation runs using its own separate set.\n"
      },
      {
        "user": "witterlee",
        "created_at": "2015-03-24T05:16:46Z",
        "body": "Thanks for correct me. I have a wrong understand about grain single-thread.\n"
      }
    ]
  },
  {
    "number": 106,
    "title": "Unordered attribute",
    "created_at": "2015-02-10T19:30:10Z",
    "closed_at": "2015-03-25T22:50:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/orleans/issues/106",
    "body": "This one is not documented anywhere but is visible on API's public surface.. It' also the only one which targets grain interface (all other attributes target grain implemenation classes).\n\nWhat does it do? \n",
    "comments_url": "https://api.github.com/repos/dotnet/orleans/issues/106/comments",
    "author": "yevhen",
    "comments": [
      {
        "user": "gabikliot",
        "created_at": "2015-02-10T21:37:00Z",
        "body": "By default calls to a grain are ordered. You can mark the grain as unordered and then ordering is not maintained.\n\nOne place it is used now is if the grain is stateless worker it is implicitly unordered. We take advantage of that in the way we pick gateways. For ordered grains all msgs to the same grain go via the same gw, to maintain order. For stateless workers msgs sent to a stateless worker grain will be round robined between different gateways. That way if let\u2019s say you have one client and 10 silos, and you have some heavy operation you want to load balance across multiple stateless workers on multiple silos, this will happen since we will send msgs to different gateways and each gateway will have local stateless workers.\n"
      },
      {
        "user": "yevhen",
        "created_at": "2015-02-18T20:59:09Z",
        "body": "@gabikliot \n\n> One place it is used now is if the grain is stateless worker it is implicitly unordered. \n\nSo that attribute doesn't make sense in conj with `StatelessWorker`, right?\n\nI'm not sure I completely understand what _order_ means here. I'd like to understand why it's needed and when I (as developer) would want to change it? What would you write in the documentation? What are the use-cases?\n\nP.S. Awaiting the task naturally orders message delivery, from the perspective of single sender (per-session order).  But, when there multiple autonomous senders - then order doesn't really matter. They cannot make decisions that rely on global order, since there is no global ordering in Orleans.\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2015-02-19T06:49:12Z",
        "body": "'Ordered' is probably too strong of a claim here. Client (frontend) when talking to silos (gateways) tries to maintain order by sending messages to a particular grain through a single gateway (via consistent hashing). In other words, even though a client is connected to a number of gateways, it spreads messages across them via a consistent mapping based on the target grain IDs.\n\nNow, StatelessWorkers are a special case. They may have multiple activations per grain ID, and even on different silos. If client were to send messages to a StatelessWorkers grain with the 'ordering' scheme described above, it would only send them to a single gateway, which would limit its throughput. StatelessWorkers are a good fit for scenarios when they perform a functional operation with no affinity to a context. An example is the Presence sample. In these scenarios is it desirable to evenly spread messages across all gateways, and often time a single ID is used for all StatelessWorkers grain activations in the system. Hence, Unordered is automatically implied for StatelessWorker grains.\n"
      },
      {
        "user": "yevhen",
        "created_at": "2015-02-19T15:49:31Z",
        "body": "Ok. It looks like this attribute is something internal, no?\n"
      },
      {
        "user": "sergeybykov",
        "created_at": "2015-02-19T18:43:29Z",
        "body": "I can't think of another use case for it other than StatelessWorker off the top of my head. So it is kind of internal in that sense.\n"
      },
      {
        "user": "yevhen",
        "created_at": "2015-03-25T22:50:06Z",
        "body": "Answered. Thanks!\n"
      }
    ]
  }
]