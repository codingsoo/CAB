[
  {
    "number": 8548,
    "title": "Preload function doesn't load soft-deleted entities",
    "created_at": "2022-01-20T10:39:40Z",
    "closed_at": "2022-02-18T20:50:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/8548",
    "body": "## Issue Description\r\nWhen i want to preload a soft deleted entity (entities with deleted_at field not null), it returns undefined.\r\nI'm using it to update my entity, so i have a condition in order to throw an error if the preloaded entity is empty.\r\n\r\n### Expected Behavior\r\nI expect that the preload function returns the entity even if the entity is soft deleted.\r\nOR\r\nAdd a parameter that allow us to load soft deleted entities\r\n\r\n### Actual Behavior\r\nThe preload function doesn't load the soft deleted entities  and then it returns undefined.\r\n\r\nMy code:\r\n```typescript\r\nconsole.log({ id });\r\nconst project = await queryRunner.manager.preload(Project, {\r\n        id,\r\n        ...projectDto,\r\n });\r\n\r\nconsole.log({ project });\r\nif (!project) {\r\n   throw new NotFoundException(`Project with id \"${id}\" not found`);\r\n}\r\n```\r\nThe logs:\r\n```\r\n{ id: '85c6d6c2-e279-4993-a0bb-53dafdaed5f2' }\r\n{ project: undefined }\r\nError: Project with id \"85c6d6c2-e279-4993-a0bb-53dafdaed5f2\" not found\r\n```\r\nMy entity (exported as json from my db):\r\n```json\r\n[\r\n\t{\r\n\t\t\"id\": \"85c6d6c2-e279-4993-a0bb-53dafdaed5f2\",\r\n\t\t\"name\": \"Oxygen\",\r\n\t\t\"created_at\": \"2022-01-20 09:10:04.531245+00\",\r\n\t\t\"created_by\": null,\r\n\t\t\"updated_at\": \"2022-01-20 09:10:04.531245+00\",\r\n\t\t\"updated_by\": null,\r\n\t\t\"deleted_at\": \"2022-01-20 09:10:04.53+00\",\r\n\t\t\"deleted_by\": null,\r\n\t\t...\r\n\t}\r\n]\r\n```\r\n\r\n### Steps to Reproduce\r\n1. Create an entity with deleted_at not null in your database\r\n2. Try to preload it\r\n\r\n### My Environment\r\n\r\n<!--\r\n  Please add any other relevant dependencies to this table at the end.\r\n  For example: Electron, React Native, or NestJS.\r\n-->\r\n\r\n| Dependency          | Version  |\r\n| ---                 | ---      |\r\n| Operating System    |  macOs 12.1\r\n| Node.js version     | 16.13.1 \r\n| Typescript version  | 4.5.4 \r\n| TypeORM version     | 0.2.41\r\n| @nestjs/typeorm     | 7.1.5\r\n\r\n### Relevant Database Driver(s)\r\n\r\n| DB Type              | Reproducible  |\r\n| ---                  | ---           |\r\n| `aurora-data-api`    | x            |\r\n| `aurora-data-api-pg` | x            |\r\n| `better-sqlite3`     | x            |\r\n| `cockroachdb`        | x            |\r\n| `cordova`            | x            |\r\n| `expo`               | x            |\r\n| `mongodb`            | x            |\r\n| `mysql`              | x            |\r\n| `nativescript`       | x            |\r\n| `oracle`             | x            |\r\n| `postgres`           | yes            |\r\n| `react-native`       | x            |\r\n| `sap`                | x            |\r\n| `sqlite`             | x            |\r\n| `sqlite-abstract`    | x            |\r\n| `sqljs`              | x            |\r\n| `sqlserver`          | x            |\r\n\r\n\r\n### Are you willing to resolve this issue by submitting a Pull Request?\r\n\r\n - \u2716\ufe0f Yes, I have the time, and I know how to start.\r\n - \u2705 Yes, I have the time, but I don't know how to start. I would need guidance.\r\n - \u2716\ufe0f No, I don\u2019t have the time, but I can support (using donations) development.\r\n - \u2716\ufe0f No, I don\u2019t have the time and I\u2019m okay to wait for the community / maintainers to resolve this issue.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/8548/comments",
    "author": "Anxium",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2022-02-18T20:50:30Z",
        "body": "Looks like a question. Just load it using `.find` method in combination with `withDeleted` option."
      },
      {
        "user": "Anxium",
        "created_at": "2022-02-19T08:19:50Z",
        "body": "Indeed, sorry for the wrong tag.\r\n\r\nBased on the pull request in which this issue was mentioned, do you recommend not using the \"soft delete\" feature and doing a custom implementation in our project ? \r\n\r\nBecause the fact that the preload function will not load the soft-deleted entities is not specified in the doc, it can leads to some issues or maybe a duplicate of this issue, what is a waste of time. Then, can I suggest to add it in the doc ?\r\n\r\nThanks for you response !\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2022-02-19T09:47:18Z",
        "body": "> Based on the pull request in which this issue was mentioned, do you recommend not using the \"soft delete\" feature and doing a custom implementation in our project ?\r\n\r\nuse it until it satisfy your needs. If it becomes a bottleneck and you miss some features - you can go with your own implementation.\r\n\r\n> Because the fact that the preload function will not load the soft-deleted entities is not specified in the doc, it can leads to some issues or maybe a duplicate of this issue, what is a waste of time. Then, can I suggest to add it in the doc ?\r\n\r\nI'm not sure about future of `preload` method. Better to use `find` to load entity. May I know your use cases (simplified) of `preload` method and why you use it instead of using `find`?"
      },
      {
        "user": "Anxium",
        "created_at": "2022-02-19T10:59:58Z",
        "body": "> May I know your use cases (simplified) of preload method and why you use it instead of using find?\r\n\r\nI'm using it to load the entity and all its relations, and replace the data in one-time. It seemed faster than find and replace. \r\nBut the work-around I did, is what you answered, i'm using a find with `withDeleted: true` now"
      }
    ]
  },
  {
    "number": 5470,
    "title": "Question: How to continue  to next value ( aport ) if there a duplications error ",
    "created_at": "2020-02-04T13:37:15Z",
    "closed_at": "2020-10-06T06:38:48Z",
    "labels": [
      "question",
      "driver: mysql",
      "driver: mariadb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5470",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\nI'm scraping from multiple websites and I save the data on MySQL type database using nestJS and TypeOrm frameworks. \r\n\r\nI have a cron job that runs that scraper service every day checking for new data available and inserted into my SQL database, the problem I don't wanna duplication data so I did a unique column in my table, so any duplicated data not getting be saved.\r\n\r\nNow I got the `dup error` as I expected but I can't find a way to handle this error to just ignore that row and continue for the rest instead of stopping everything.\r\n\r\nThe code for saving the data: \r\n```typescriprt\r\nasync clonningFromScraper() {\r\n   //my scraper data ( array of objects )\r\n    let articles = await this.articlesScraper.articles('1'); \r\n\r\n    articles = articles.map( article => ({ ...article, key: decodeURIComponent(article.url).substring(0, 255) }));\r\n\r\n // saving the data into my database\r\n    return this.articleRepository\r\n        .save(articles);\r\n}\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5470/comments",
    "author": "heshaShawky",
    "comments": [
      {
        "user": "aatecey",
        "created_at": "2020-02-07T13:46:48Z",
        "body": "Don't think save has an option to handle this. Could use the query builder for this case though. Not tested this but something like:\r\n\r\n        await this.articleRepository.createQueryBuilder()\r\n            .insert()\r\n            .orIgnore()\r\n            .into(Article)\r\n            .values(articles)\r\n            .execute();"
      },
      {
        "user": "heshaShawky",
        "created_at": "2020-02-09T23:39:52Z",
        "body": "> Don't think save has an option to handle this. Could use the query builder for this case though. Not tested this but something like:\r\n> \r\n> ```\r\n>     await this.articleRepository.createQueryBuilder()\r\n>         .insert()\r\n>         .orIgnore()\r\n>         .into(Article)\r\n>         .values(articles)\r\n>         .execute();\r\n> ```\r\nthe `save` method supposed to do that as it's documented \r\n```\r\n /**\r\n     * Saves all given entities in the database.\r\n     * If entities do not exist in the database then inserts, otherwise updates.\r\n     */\r\n```\r\nYour code works well for me, thanks.\r\n\r\n"
      }
    ]
  },
  {
    "number": 5064,
    "title": "TypeORM + Webpack: RepositoryNotFoundError: No repository for \"User\" was found. Looks like this entity is not registered in current \"default\" connection?",
    "created_at": "2019-11-10T17:41:46Z",
    "closed_at": "2019-11-12T11:44:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5064",
    "body": "**Issue type:**\r\n\r\n[x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHi,\r\n\r\nI am using Webpack to build my Typescript app with TypeORM.\r\n\r\nWhen I run the built artefact I have the following problem:\r\n```\r\nRepositoryNotFoundError: No repository for \"User\" was found. Looks like this entity is not registered in current \"default\" connection?\r\n```\r\nAfaik, the reason for this error is that Webpack bundle all files into a single file, which causes the entity setting not correct anymore.\r\n\r\nHas anyone been able to setup TypeORM with Webpack? Please share your config :).\r\n\r\nThanks in advance.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5064/comments",
    "author": "dong-dohai",
    "comments": [
      {
        "user": "rustamwin",
        "created_at": "2019-11-12T07:22:36Z",
        "body": "Could you provide your config?"
      },
      {
        "user": "dong-dohai",
        "created_at": "2019-11-12T11:44:48Z",
        "body": "I managed to solve my issue.\r\n\r\nThe problem is that Webpack bundles all of our code into a single file, so my config, which using blob can't find my entities. I fixed the above issue by importing and passing the class directly to `entities` property in my connection option."
      },
      {
        "user": "gtpan77",
        "created_at": "2020-08-04T09:51:04Z",
        "body": "If you are using SnakeNamingStrategy of \"typeorm-naming-strategies\" library, then you can't use entity classes for getting repositories if their name is not in snake case.\r\nI created a entity class UserLedger.\r\n`import { UserLedger } from \"../entity/UserLedger\";`\r\n`this.userLedger = getRepository(UserLedger);`\r\nIt was failing and throwing error. RepositoryNotFoundError: No Repository for \"UserLedger\" was found.\r\n\r\nchanged the entity name to \"user_ledger\", it fixed the issue.\r\n`this.userLedger = getRepository(\"user_ledger\");`"
      },
      {
        "user": "prashant-padwal",
        "created_at": "2020-12-02T11:30:16Z",
        "body": "@dong-dohai can you please provide the code snippets how you have configured it in orm.config.ts ?\r\n\r\nThe problem is that Webpack bundles all of our code into a single file, so my config, which using blob can't find my entities. I fixed the above issue by importing and passing the class directly to entities property in my connection option.\r\n\r\n "
      },
      {
        "user": "Pomile",
        "created_at": "2021-07-18T13:24:24Z",
        "body": "I resolved this issue by setting the entities property to  ```[path.join(__dirname, '/../**/', '*.entity.{ts,js}')]``` in the connection option e.g ```entities: [path.join(__dirname, '/../**/', '*.entity.{ts,js}')]```"
      },
      {
        "user": "Alynva",
        "created_at": "2022-02-23T21:46:37Z",
        "body": "> If you are using SnakeNamingStrategy of \"typeorm-naming-strategies\" library, then you can't use entity classes for getting repositories if their name is not in snake case. I created a entity class UserLedger. `import { UserLedger } from \"../entity/UserLedger\";` `this.userLedger = getRepository(UserLedger);` It was failing and throwing error. RepositoryNotFoundError: No Repository for \"UserLedger\" was found.\r\n> \r\n> changed the entity name to \"user_ledger\", it fixed the issue. `this.userLedger = getRepository(\"user_ledger\");`\r\n\r\nThis solved for me, but as I'm using ts, I had to add `EntityTarget<ContribuicaoEntity>` as the type of the string, so the typings aren't `unkown`"
      }
    ]
  },
  {
    "number": 4718,
    "title": "TypeORM tries to drop views that are needed by the pg_stat_statements extension",
    "created_at": "2019-09-10T08:49:04Z",
    "closed_at": "2020-10-04T02:50:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4718",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n1. Enable extension pg_stat_statments\r\n2. Start your application with the synchronize option set to true\r\n\r\nThe error that is caused:\r\n\r\n`QueryFailedError: cannot drop view pg_stat_statements because extension pg_stat_statements requires it`\r\n\r\nWhy is TypeORM trying to drop a view that is needed by the extension? Is TypeORM not compatible with pg_stat_statements?\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4718/comments",
    "author": "lucaslenz",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-10-16T08:32:03Z",
        "body": "I don't know this extension, but it looks like it creates it's own tables/views in your schema. Typeorm while synchronizing deletes every database object which isn't described using typeorm decorators(or entity schemas). It can't distinguish if such object is no longer necessary or is it something completely not related to your app code.\r\n\r\nIf you want to use typeorm with tables/views not related to your app code you probably need to make dummy view/table in typeorm and disable synchronization for it - just empty class decorated with Column/ViewEntity with `synchronize:false` and proper name."
      },
      {
        "user": "lucaslenz",
        "created_at": "2019-10-28T12:50:33Z",
        "body": "Thanks for your advice.\r\nI solved the problem by only using Migrations instead of the synchronization feature as you suggested.\r\n\r\nCan be closed."
      },
      {
        "user": "zveljkovic",
        "created_at": "2022-02-25T15:33:15Z",
        "body": "I would like this to be reopened as we have a need to reset the database and would like to use `schema:drop` but it fails with\r\n\r\n`\r\nquery: 'DROP VIEW IF EXISTS \"public\".\"pg_stat_statements\" CASCADE;',\r\n  parameters: undefined,\r\n  driverError: error: must be owner of view pg_stat_statements\r\n`\r\n\r\nIt would be nice to exclude some views/tables from dropping by config."
      },
      {
        "user": "Ginden",
        "created_at": "2022-02-25T16:26:18Z",
        "body": "@zveljkovic You can describe these views and mark them with `synchronize: false`."
      }
    ]
  },
  {
    "number": 4258,
    "title": "Prevent nullification of missing related entities",
    "created_at": "2019-06-08T09:25:52Z",
    "closed_at": "2019-06-22T21:52:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4258",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.17` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nIn our backend system, we face the problem of editing entities with relations by several clients. Given the following scenario:\r\n\r\n\r\n```@Entity(\"game\")\r\nexport class game {\r\n\t...some columns ...\r\n\r\n\t@OneToMany(type => gamelanguagerelation, gamelanguagerelations =>\r\n\tgamelanguagerelations.fk_gameid, { cascade: ['insert', 'update'] })\r\n\tgamelanguagerelations:gamelanguagerelation[];\r\n}\r\n```\r\n\r\nIf one client (user A) now creates a new game and submits this to the backend, a second user (user B) could create a new `gamelanguagerelation` for this game on his side. He will submit this relation within the whole game object to the backend. Then, the user A uses its offline copy of this game to also add a new `gamelanguagerelation` with a new (UUID) primary key. When sending this new relation (also within a game object) to the backend, typeorm tries to nullify the first relation (which was inserted by user B) since it is not part of the entity of user A. This even happens if cascade is only set to insert or update (but not remove). Unfortunately, save operation fails in this case because the foreign key (fk_gameid in gamelanguagerelation) is not nullable. Even if it would succeed, I don't want to 'orphanize' missing relations.\r\n\r\nIs there a way in typeorm to not nullify missing relations in a data set, that gets saved?\r\n\r\nThanks in advance!\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4258/comments",
    "author": "mgreg89",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-06-22T14:31:05Z",
        "body": "Ok, so problem is that you've got an entity which doesn't have actual data and it destroys some of your new data on `save`? You should use `preload` to load an actual state of data or use an query builder(probably even a relationalQueryBuilder)."
      },
      {
        "user": "mgreg89",
        "created_at": "2019-06-22T15:01:43Z",
        "body": "Thank you for that tip regarding preload! I wasn't aware of this function. But it looks like it is exactly what I was looking for :)\r\n\r\nBut nevertheless, wouldn't it be more intuitive if such missing data will only be removed from the database when `cascade: true` or `cascade: ['remove']` was explicitly set?"
      },
      {
        "user": "Kononnable",
        "created_at": "2019-06-22T21:52:44Z",
        "body": "`cascade:remove` is pretty complex subject and is discussed in few other issues.\r\n\r\nAs for why it is removed - you're telling typeorm to save a state of an object(an entity). Part of the object is the relation(doesn't matter where it is stored) - you're telling it to set entity as empty table(or at least 'not so full'), so it does that. Cascades do something different - they define if related entity should also be saved - other entity fields, not just state of the relation."
      }
    ]
  },
  {
    "number": 4240,
    "title": "how to create table without @Entity",
    "created_at": "2019-06-05T02:22:58Z",
    "closed_at": "2019-06-05T09:35:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4240",
    "body": "**Issue type:**\r\n\r\nquestion\r\n\r\n**Database system/driver:**\r\n\r\nmysql\r\n\r\n**TypeORM version:**\r\n\r\nlatest\r\n\r\n\r\n\ud83d\ude00\uff1aI want to generate a database table through code control.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4240/comments",
    "author": "AntoninSorrento",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-06-05T07:00:52Z",
        "body": "You can use `QueryRunner.createTable(...)` method."
      },
      {
        "user": "AntoninSorrento",
        "created_at": "2019-06-05T08:59:17Z",
        "body": "Thanks a lot @vlapo "
      }
    ]
  },
  {
    "number": 4216,
    "title": "How do you get mongodb buildConnectionUrl from TypeORM Connection",
    "created_at": "2019-05-31T05:33:35Z",
    "closed_at": "2019-05-31T14:36:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4216",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[x] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nIs there any way to get mongodb MongoClient instance or mongodb connection url from below connection.\r\n```typescript\r\nconst connection = await createConnection(connectionOptions);\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4216/comments",
    "author": "firecrackerz",
    "comments": [
      {
        "user": "rustamwin",
        "created_at": "2019-05-31T07:16:53Z",
        "body": "Did you mean \"Underlying mongodb library\" ?\r\nIf yes then\r\n```typescript\r\nconst connection = await createConnection(connectionOptions);\r\nconst mongodb = connection.driver.mongodb\r\nmongodb.MongoClient // It's mongodb client instance\r\n```\r\n"
      },
      {
        "user": "firecrackerz",
        "created_at": "2019-05-31T11:50:58Z",
        "body": "@rustamwin Property 'mongodb' does not exist on type 'Driver'.ts(2339)"
      },
      {
        "user": "rustamwin",
        "created_at": "2019-05-31T12:59:14Z",
        "body": "@firecrackerz you can use a bit hack ;)\r\n```typescript\r\nconst connection = await createConnection(connectionOptions);\r\nconst mongodb = (connection.driver as any).mongodb\r\nmongodb.MongoClient // It's mongodb client instance\r\n```"
      },
      {
        "user": "firecrackerz",
        "created_at": "2019-05-31T14:36:53Z",
        "body": "@rustamwin thanks."
      },
      {
        "user": "shamanov-d",
        "created_at": "2020-10-14T13:37:24Z",
        "body": "@rustamwin, @firecrackerz \r\nYour decision is wrong.\r\n\r\n```javascript\r\nconst connection = await createConnection(connectionOptions);\r\nconst mongodb = (connection.driver as any).mongodb;\r\nmongodb.MongoClient; // It's mongodb client prototype!!!\r\n// it does not contain connection data\r\n```\r\nIt works.\r\n```javascript\r\nconst connection = await createConnection(connectionOptions);\r\nconst ClientDb = (connection.driver as any).queryRunner.databaseConnection; // class instance\r\nconsole.log(await ClientDb.db(\"pictureDev\").collection('goods').find({}).toArray()); // query example\r\n```\r\n\r\n\r\n"
      }
    ]
  },
  {
    "number": 4200,
    "title": "Multiple unique keys when using one to one",
    "created_at": "2019-05-27T15:45:43Z",
    "closed_at": "2019-05-29T13:34:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4200",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.17` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHi guys, I'm trying to have unique keys with foreign key associated with one of them but I think typeorm is creating different unique keys.\r\n\r\nHere is my model file:\r\n\r\n```ts\r\nimport {\r\n  Column,\r\n  Entity,\r\n  JoinColumn,\r\n  OneToOne,\r\n  PrimaryGeneratedColumn,\r\n  Unique,\r\n} from 'typeorm';\r\n\r\nimport { BotModel } from './bot.model';\r\n\r\n@Entity('intent')\r\n@Unique(['botId', 'name'])\r\nexport class IntentModel {\r\n  @PrimaryGeneratedColumn('uuid')\r\n  intentId: string;\r\n\r\n  @Column()\r\n  botId: string;\r\n\r\n  @OneToOne(() => BotModel, { cascade: true })\r\n  @JoinColumn({\r\n    name: 'botId',\r\n    referencedColumnName: 'botId',\r\n  })\r\n  bot: BotModel;\r\n\r\n  @Column({ length: 16 })\r\n  name: string;\r\n\r\n  @Column({\r\n    length: 128,\r\n    nullable: true,\r\n  })\r\n  description: string;\r\n}\r\n```\r\n\r\nMy `create table intent` from mysql:\r\n\r\n```mysql\r\nCREATE TABLE `intent` (\r\n  `intentId` varchar(36) NOT NULL,\r\n  `botId` varchar(255) NOT NULL,\r\n  `name` varchar(16) NOT NULL,\r\n  `description` varchar(128) DEFAULT NULL,\r\n  PRIMARY KEY (`intentId`),\r\n  UNIQUE KEY `REL_94de4914fe0a743917de52fe8e` (`botId`),\r\n  UNIQUE KEY `IDX_94de4914fe0a743917de52fe8e` (`botId`),\r\n  UNIQUE KEY `IDX_78750387b2c61fb51adb75b5ab` (`botId`,`name`),\r\n  CONSTRAINT `FK_94de4914fe0a743917de52fe8e7` FOREIGN KEY (`botId`) REFERENCES `bot` (`botId`) ON DELETE NO ACTION ON UPDATE NO ACTION\r\n) ENGINE=InnoDB DEFAULT CHARSET=latin1\r\n```\r\n\r\nWhen I try to insert different name with id(already inserted) I'm getting this:\r\n```mysql\r\nER_DUP_ENTRY: Duplicate entry '0b387f8b-d330-4b39-93d2-5637f11001b7' for key 'REL_94de4914fe0a743917de52fe8e'\r\n```\r\n\r\nI tried in different ways but no success.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4200/comments",
    "author": "lucasmonstrox",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-05-28T17:44:07Z",
        "body": "It shouldn't be `ManyToOne` relation? I mean you want allow one `BotModel` to be related with many `IntentModel`.\r\n\r\n`OneToOne` is reason of first `UNIQUE KEY 'REL_94de4914fe0a743917de52fe8e' ('botId'),` but I do not understand second one `UNIQUE KEY 'IDX_94de4914fe0a743917de52fe8e' ('botId'),`. It does not appear in my test."
      },
      {
        "user": "lucasmonstrox",
        "created_at": "2019-05-29T13:34:58Z",
        "body": "Working :-D\r\n\r\nThanks"
      }
    ]
  },
  {
    "number": 4197,
    "title": "Many to Many relation not using jointable when updating entity",
    "created_at": "2019-05-26T21:22:32Z",
    "closed_at": "2019-05-29T07:27:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4197",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest` (`^0.2.17`)\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nWhen I try to add a group to a user and update the user entity, the update query results in a an error (`ER_BAD_FIELD_ERROR`). \r\n\r\nTypeorm tries to set the user id, which should go into the join table, to the user table itself. The code should explain the problem a little bit better.\r\n\r\n**TinyUser.ts**\r\n```javascript\r\nimport {Entity, JoinTable, ManyToMany, PrimaryGeneratedColumn} from \"typeorm\";\r\nimport {TinyGroup} from \"./TinyGroup\";\r\n\r\n@Entity()\r\nexport class TinyUser {\r\n    /**\r\n     * Contains the unique number for the Page\r\n     *\r\n     * @name id\r\n     * @type number\r\n     */\r\n    @PrimaryGeneratedColumn()\r\n    id: number = 0;\r\n\r\n    /**\r\n     * Contains the user groups\r\n     *\r\n     * @name groups\r\n     * @type TinyGroup[]\r\n     */\r\n    @ManyToMany(() => TinyGroup)\r\n    @JoinTable({\r\n        name: 'tiny_user_groups',\r\n        joinColumn: {referencedColumnName: 'id', name: 'user_id'},\r\n        inverseJoinColumn: {referencedColumnName: 'id', name: 'group_id'}\r\n    })\r\n    groups?: TinyGroup[];\r\n}\r\n```\r\n\r\n**TinyGroup.ts**\r\n```javascript\r\nimport {Entity, JoinTable, ManyToMany, PrimaryGeneratedColumn} from \"typeorm\";\r\nimport {TinyUser} from \"./TinyUser\";\r\n\r\n@Entity()\r\nexport class TinyGroup\r\n{\r\n    /**\r\n     * Contains the unique number for the Page\r\n     *\r\n     * @name id\r\n     * @type number\r\n     */\r\n    @PrimaryGeneratedColumn()\r\n    id: number = 0;\r\n\r\n    /**\r\n     * Contains the user groups\r\n     *\r\n     * @name users\r\n     * @type TinyUser[]\r\n     */\r\n    @ManyToMany(() => TinyUser)\r\n    @JoinTable({\r\n        name: 'tiny_user_groups',\r\n        joinColumn: {referencedColumnName: 'id', name: 'group_id'},\r\n        inverseJoinColumn: {referencedColumnName: 'id', name: 'user_id'}\r\n    })\r\n    users?: TinyUser[];\r\n}\r\n```\r\n\r\n**App.ts**\r\n```javascript\r\nimport {ConnectionOptions, createConnection} from \"typeorm\";\r\nimport {TinyUser} from \"./Models/TinyUser\";\r\nimport {TinyGroup} from \"./Models/TinyGroup\";\r\nimport {MysqlConnectionOptions} from \"typeorm/driver/mysql/MysqlConnectionOptions\";\r\n\r\n(async function ()\r\n{\r\n    const config: MysqlConnectionOptions = {\r\n        \"type\": \"mysql\",\r\n        \"host\": \"localhost\",\r\n        \"port\": 3306,\r\n        \"username\": \"root\",\r\n        \"password\": \"root\",\r\n        \"database\": \"test\",\r\n        \"synchronize\": true\r\n        , entities: [__dirname + '/Models/*.js']\r\n    };\r\n\r\n    const connection = await createConnection(config);\r\n\r\n    const gr = connection.getRepository(TinyGroup);\r\n    const ur = connection.getRepository(TinyUser);\r\n\r\n    const u: TinyUser = new TinyUser();\r\n    const g: TinyGroup = new TinyGroup();\r\n\r\n    await ur.save(u);\r\n    await gr.save(g);\r\n\r\n    u.groups = [g];\r\n\r\n    try {\r\n        await ur.update(u, {id: 1});\r\n    } catch(e) {\r\n        console.error(e);\r\n    }\r\n})();\r\n```\r\n\r\nThis code results in an `ER_BAD_FIELD_ERROR: Unknown column 'user_id' in 'field list'` error.\r\n\r\nMy expectation would be a query like this:\r\n```SQL\r\nINSERT INTO `tiny_user_groups` SET `user_id` = ?, `group_id` = ?\r\n```\r\n\r\nThe generated query however is the following:\r\n```SQL\r\nUPDATE `tiny_user` SET `id` = 1, `user_id` = NULL WHERE `id` = 1\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4197/comments",
    "author": "YannikSc",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-05-27T20:33:44Z",
        "body": "You have to use `save`. `update` is only raw update and skip most of ORM based magic features like relations.\r\n```ts\r\nconst gr = connection.getRepository(TinyGroup);\r\nconst ur = connection.getRepository(TinyUser);\r\n\r\nconst u: TinyUser = new TinyUser();\r\nconst g: TinyGroup = new TinyGroup();\r\n\r\nawait ur.save(u);\r\nawait gr.save(g);\r\n\r\nu.groups = [g];\r\n\r\nawait ur.save(u);\r\n```"
      },
      {
        "user": "YannikSc",
        "created_at": "2019-05-29T07:27:36Z",
        "body": "Thanks a lot. Worked for me! :+1: "
      }
    ]
  },
  {
    "number": 3731,
    "title": "Question: How to keep all relations when only filtering by one of them",
    "created_at": "2019-02-28T10:42:23Z",
    "closed_at": "2019-03-01T04:38:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3731",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[X] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI have a User table and  a Category table, the relation is many-to-many,\r\n\r\nI want to select all users who are under a specific category.\r\n\r\n```ts\r\n    users = await userRepository\r\n      .createQueryBuilder('user')\r\n      .leftJoinAndSelect('user.categories', 'category')\r\n      .where('category.categoryId = :id', { id: catId})\r\n      .orderBy('user.age', 'DESC', 'NULLS LAST')\r\n      .getMany();\r\n```\r\n\r\nIt filters correct users, but under each user, only the requested category Id is kept. But I want to keep all the categories under each user. I did not find a similar question for this and did not find a solution in the docs.\r\n\r\ni.e.\r\n\r\n```ts\r\nusers = [\r\n{ id = 1, categories: [ cat1, cat2, cat3...] },\r\n{ id = 2, categories: [ cat1, cat2, cat3...] }\r\n...\r\n]\r\n```\r\n\r\nnot \r\n\r\n```ts\r\nusers = [\r\n{ id = 1, categories: [cat2] },\r\n{ id = 2, categories: [cat2] }\r\n...\r\n]\r\n```\r\n\r\nMy current solution is using findByIds with relations, passing in all the userIds got from the previous step,  I can get what I want but I don't think it is optimal.\r\n\r\nDoes anyone know how to handle such query?\r\n\r\nThanks a lot.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3731/comments",
    "author": "Sheng-Xuan",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-02-28T22:29:35Z",
        "body": "Just fast tip but try this:\r\n```typescript\r\nusers = await userRepository\r\n      .createQueryBuilder('user')\r\n      .leftJoin('user.categories', 'category')\r\n      .leftJoinAndSelect('user.categories', 'categorySelect')\r\n      .where('category.categoryId = :id', { id: catId})\r\n      .orderBy('user.age', 'DESC', 'NULLS LAST')\r\n      .getMany();\r\n```"
      },
      {
        "user": "Sheng-Xuan",
        "created_at": "2019-03-01T04:38:29Z",
        "body": "@vlapo That works. Thanks a lot! "
      }
    ]
  },
  {
    "number": 3628,
    "title": "Order by a computed field/column in createQueryBuilder",
    "created_at": "2019-02-12T16:53:30Z",
    "closed_at": "2019-02-14T19:53:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3628",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nHi guys,\r\n\r\nI need to order my results by a computed field with `createQueryBuilder`.\r\n\r\nIn the docs, I see that `.orderBy` wants a column as a paramenter, but I cannot compute a column (in this case a boolean colum) with `createQueryBuilder`.\r\n\r\nConsider this simple entity:\r\n```ts\r\nclass Store {\r\n    @Column({ type: 'time' })\r\n    from: string;\r\n    \r\n    @Column({ type: 'time' })\r\n    to: string;\r\n\r\n}\r\n```\r\n\r\nNow, i want to retrieve all products from stores and sort them in order to show first all the products available in that moment (so the store has to be open) and after all the products that are not available.\r\n\r\nThis is the raw sql query to find all stores and order them based on the availability at a specific time:\r\n\r\n```sql\r\nSELECT *, (:time BETWEEN stores.from AND stores.to) as is_open\r\nFROM stores\r\nORDER BY is_open DESC\r\n```\r\n\r\nIs it possible to do this without `getRawMany`?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3628/comments",
    "author": "ootkin",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-02-13T23:07:53Z",
        "body": "Did you even try find solution here in issues ? :) You can do custom selects and order by:\r\n```typescript\r\nawait connection.getRepository(Store)\r\n        .createQueryBuilder(\"stores\")\r\n        .select()\r\n        .addSelect(\"(:time BETWEEN stores.from AND stores.to)\", \"is_open\")\r\n        .orderBy(\"is_open\")\r\n        .getMany();\r\n```\r\nor use `getRawAndEntities` if you need `is_open` too."
      },
      {
        "user": "ootkin",
        "created_at": "2019-02-14T09:42:39Z",
        "body": "Hi vlapo, yes I tried to find the solution in other issues, but I didn't find this particular case.\r\n\r\nAnyway, I tried your solutions and it works with that simple entity.\r\n\r\nIn my real case, Store entity is more complex and it has more than one time slot (from, to) and they are handled with another entity (TimeTable) that specify even a week day.\r\n\r\nSo i create a subquery in `addSelect` like this:\r\n\r\n```ts\r\nawait connection.getRepository(Store)\r\n            .createQueryBuilder('store')\r\n            .select()\r\n            .addSelect(sq => {\r\n                return sq\r\n                    .select('bool_or(:day = timeTable.day AND :time BETWEEN timeTable.from AND timeTable.to)', 'is_open')\r\n                    .from('stores', 'sqStore')\r\n                    .innerJoin('sqStore.timeTables', 'timeTable')\r\n                    .where('sqStore.id = store.id')\r\n                    .setParameter('time', time)\r\n                    .setParameter('day', 0);\r\n\r\n            }, 'is_open')\r\n            .orderBy('is_open', 'DESC')\r\n            .getMany()\r\n```\r\n\r\nFor each store I check if it's open in at least one time slot and then with `bool_or` I'm able to aggregate the is_open result and assign it to every row.\r\n\r\nSeems like to works now.\r\n\r\nThanks for help me to figure it out! :)"
      },
      {
        "user": "vlapo",
        "created_at": "2019-02-14T19:53:59Z",
        "body": "You are welcome :)"
      },
      {
        "user": "phucsang0spt",
        "created_at": "2021-01-01T19:21:00Z",
        "body": "hi @vlapo , i did the same when order by additional field and I got this error: \"for SELECT DISTINCT, ORDER BY expressions must appear in select list\". But there is no any DISTINCT in my sql query :|"
      },
      {
        "user": "elapshynov",
        "created_at": "2024-04-19T08:53:39Z",
        "body": "> hi @vlapo , i did the same when order by additional field and I got this error: \"for SELECT DISTINCT, ORDER BY expressions must appear in select list\". But there is no any DISTINCT in my sql query :|\r\n\r\nDistinct might be added by take/skip"
      },
      {
        "user": "amiralammohawk",
        "created_at": "2024-06-04T15:39:57Z",
        "body": "@phucsang0spt  same error"
      }
    ]
  },
  {
    "number": 3614,
    "title": "Update Date column from SQL",
    "created_at": "2019-02-10T15:19:31Z",
    "closed_at": "2019-02-10T16:59:28Z",
    "labels": [
      "question",
      "comp: query builder"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3614",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n---\r\n\r\nIs there a way to update `Date` column from SQL. Something like\r\n\r\n```\r\n        await connection\r\n            .createQueryBuilder()\r\n            .update(Session)\r\n            .set({ ip_address: ip, last_login: 'CURRENT_TIMESTAMP'})\r\n            .where('session.user_id = :id', { id: userId })\r\n            .execute()\r\n```\r\n\r\n\r\n`UpdateDateColumn` does not work for me because I need to update the column only in some save actions whereas `UpdateDateColumn` gets triggered in all save actions",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3614/comments",
    "author": "thellimist",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-02-10T16:08:37Z",
        "body": "Did you try \r\n```typescript\r\n.set({ ip_address: ip, last_login: () => 'CURRENT_TIMESTAMP'})\r\n```"
      },
      {
        "user": "thellimist",
        "created_at": "2019-02-10T16:59:15Z",
        "body": "works \ud83d\udc4d "
      }
    ]
  },
  {
    "number": 3575,
    "title": "ID gets appended to field name",
    "created_at": "2019-02-04T15:43:16Z",
    "closed_at": "2019-02-04T16:20:45Z",
    "labels": [
      "question",
      "comp: relations"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3575",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nI have a problem regarding many to one\r\n```ts\r\n@Entity()\r\nexport class Post {\r\n    @PrimaryGeneratedColumn({type: 'int'})\r\n    id: number\r\n    @ManyToOne(type => User, user => user.id)\r\n    @Column({type: 'int'})\r\n    authorId: User\r\n}\r\n```\r\n```ts\r\n@Entity()\r\nexport class User {\r\n    @PrimaryGeneratedColumn({type: 'int'})\r\n    id: number\r\n}\r\n```\r\nWhen I try to get all posts via\r\n```ts\r\nconst posts = await this.postRepository.find({\r\n                       relations: ['authorId']\r\n                       })\r\n```\r\nI get a ER_BAD_FIELD_ERROR with the message: Unknown column 'Post.authorIdId' in 'field list'\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3575/comments",
    "author": "Murbal",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-02-04T16:14:09Z",
        "body": "You have `ManyToOne` and `Column` defined for one property. if you want to have `authorId` and `author` property in your `Post` entity:\r\n```typescript\r\n@Entity()\r\nexport class Post {\r\n    @PrimaryGeneratedColumn({type: 'int'})\r\n    id: number\r\n\r\n    @Column({type: 'int'})\r\n    authorId: number\r\n\r\n    @ManyToOne(type => User, user => user.id)\r\n    author: User;\r\n}\r\n```\r\nand of course call find like this:\r\n```typescript\r\nconst posts = await this.postRepository.find({\r\n      relations: ['author']\r\n})\r\n```"
      },
      {
        "user": "Murbal",
        "created_at": "2019-02-04T16:21:07Z",
        "body": "Thanks this solved my issue"
      }
    ]
  },
  {
    "number": 3562,
    "title": "How to make a many to many relationship to a junction table",
    "created_at": "2019-02-02T09:27:24Z",
    "closed_at": "2019-02-02T19:42:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3562",
    "body": "**Issue type:**\r\n[*] question\r\n\r\nSuppose `A `and `B` are two distinct entities with many to many relationship which results in `AB` junction table. We have another entity named `C` which has many to many relationship with`AB`.  To my knowledge in typeorm to make relationships we need to have entities to be defined and loaded. But there is no entity for a junction table. So how in this case `C` can be related to `AB`?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3562/comments",
    "author": "P0oOOOo0YA",
    "comments": [
      {
        "user": "saurabhpati",
        "created_at": "2019-02-02T16:09:05Z",
        "body": "I was searching for a different issue for my problem but landed upon this question. \r\n\r\nI think **maybe** I can help with this.\r\n\r\nSo if you have many to many relationship between A and B and you are needing a many to many relationship between another entity C and AB, \r\n\r\nIt **may be** possible for you to redesign to have \r\n\r\nA <--many2many --> B\r\n\r\nA <--many2many --> C\r\n\r\nB <--many2many --> C\r\n\r\nwhich would create separate join tables AB, AC and BC.\r\n\r\nsuppose you require C for a given value of A and B,\r\nyou can query your repository like \r\nA JOIN B \r\nJOIN C \r\nWHERE A == conditionalParamOfA \r\nAND WHERE B == conditionalParamOfB\r\n\r\nsuppose you require C for a given value of A.\r\nyou can query repository like\r\nA JOIN C \r\nWHERE A == conditionalParamOfA\r\n\r\nand so on and so forth.\r\n\r\nDoes it help?"
      },
      {
        "user": "P0oOOOo0YA",
        "created_at": "2019-02-02T19:30:01Z",
        "body": "@saurabhpati thanks this helps for sure."
      }
    ]
  },
  {
    "number": 3444,
    "title": "Hydration of Embedded (json) types into proper class instances",
    "created_at": "2019-01-18T00:40:21Z",
    "closed_at": "2019-01-18T09:35:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3444",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n\r\n**Database system/driver:**\r\n\r\n[x] `postgres`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n\r\nWhen working with JSON fields, we end up embedding a lot of objects that aren't just data blobs (but have utility methods attached to them too).\r\n\r\nOne (rather simple) example:\r\n\r\n```\r\n@Entity(\"Tenants\")\r\nexport class Tenant extends Schema {\r\n    @Column(\"varchar\", { length: 64 })\r\n    public slug: string;\r\n\r\n    @Column(\"uuid\")\r\n    public addressId: string;\r\n\r\n    @Column(\"jsonb\", {\r\n        transformer: {\r\n            to: value => value,\r\n            from: value => plainToClass(Organization, value)\r\n        }\r\n    })\r\n    public organization: Organization;\r\n}\r\n```\r\n\r\nWhile the Organization class looks like this\r\n```\r\nexport class Organization {\r\n    public legalName: string;\r\n\r\n    public test(): string {\r\n        return \"test\";\r\n    }\r\n}\r\n```\r\n\r\nThe goal is to be able to do `const tenant = await repo.findOne(someId); tenant.organization.test()` (effectively).\r\n\r\nI tried this:\r\n\r\n```\r\n    @Column(type => Organization)\r\n    public organization: Organization;\r\n```\r\n\r\nBut as the docs state, this isn't what I want (pulls in the fields from Org into the base Tenant class). \r\n\r\nMy query is, is using the transformer the proper way to get the right instance, or does TypeORM have something built in that can assist with this?\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3444/comments",
    "author": "Wintereise",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2019-01-18T09:25:01Z",
        "body": "no, TypeORM doesn't have anything for this functionality and I don't think it will. Converting plain objects to class instances is a tricky thing (for example if it has inner objects we need to introduce extra decorator to get known about its type, just like class-transformer's `@Type`), this is out of TypeORM scope. So yes, in your case using transformer option is a right way to do things.\n\n---\n\nAnd generally I don't recommend using classes, use plain objects - it will save your life in most cases. Separate utility classes is a good place for your utility functions in most cases."
      }
    ]
  },
  {
    "number": 3339,
    "title": "Unable to run an update using getMongoRepository",
    "created_at": "2018-12-28T06:49:57Z",
    "closed_at": "2019-01-04T20:23:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3339",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[x] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.10` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nThe current model looks like this.\r\n\r\n```typescript\r\n\r\nimport { Answer } from \"./Answer\";\r\n\r\n@Entity({ database: DATABASE_MONGO_NAME })\r\n\r\nexport class StudentRecord {\r\n  @ObjectIdColumn()\r\n  _id: ObjectID;\r\n\r\n /* many more columns */\r\n\r\n  @Column()\r\n  answers: Answer[];\r\n\r\n}\r\n\r\n```\r\n\r\nThe `Answer` collection model looks like this\r\n\r\n```typescript\r\n@Entity({ database: DATABASE_MONGO_NAME })\r\n\r\nexport class Answer {\r\n  @ObjectIdColumn()\r\n  _id: ObjectID;\r\n\r\n /* many more columns */\r\n\r\n  @ObjectIdColumn()\r\n  mongo_id_question: ObjectID;\r\n\r\n  @Column()\r\n  selected: string[];\r\n}\r\n\r\n```\r\nSo essentially the data stored in a document looks like this \r\n\r\n```json\r\n{\r\n    \"_id\": {\r\n        \"$oid\": \"5c1e60352f73e9000494e33f\"\r\n    },\r\n    \"answers\": [\r\n        {\r\n            \"_id\": {\r\n                \"$oid\": \"5c0e507f0da2560004c9003e\"\r\n            },\r\n            \"mongo_id_question\": {\r\n                \"$oid\": \"5c0e507f0da2560004c9003e\"\r\n            },\r\n            \"selected\": [\r\n                \"5c0e507f0da2560004c9003b\"\r\n            ]\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\nThe query I am trying to run, sets the `updatedAt` column for an object with a given `mongo_id_question` in the `answers` list based on a given `record_id` \r\n\r\n```typescript\r\nStudentRecordsRepository.update(\r\n      {\r\n        _id: new ObjectID(record_id),\r\n        \"answers.mongo_id_question\": new ObjectID(\"5c0e507f0da2560004c9003e\"),\r\n      },\r\n      { $set: { \"answers.$.updatedAt\": new Date() } },\r\n    );\r\n```\r\nI get the following error in `typescript`\r\n\r\n```typescript\r\nerror TS2345: Argument of type '{ _id: ObjectID; \"answers.mongo_id_question\": ObjectID; }' is not assignable to parameter of type 'string | number | Date | ObjectID | FindConditions<StudentRecord> | string[] | number[] | Date[] | ObjectID[]'.\r\n  Object literal may only specify known properties, and '\"answers.mongo_id_question\"' does not exist in type 'string | number | Date | ObjectID | FindConditions<StudentRecord> | string[] | number[] | Date[] | ObjectID[]'\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3339/comments",
    "author": "judemanutd",
    "comments": [
      {
        "user": "mohamed-badaoui",
        "created_at": "2018-12-28T10:33:00Z",
        "body": "IMHO I never got why people need an ORM for mongoDb. It is already object oriented. What advantages bring an ORM ? \r\nUsing an ORM for mongoDB means that models are stored as relational models and that's a pity because you loose all the benefits of an object oriented database.\r\n\r\nIn PHP world, Doctrine try to do it with DoctrineODM but it was a failure and poorly used "
      },
      {
        "user": "judemanutd",
        "created_at": "2018-12-28T17:54:57Z",
        "body": "> IMHO I never got why people need an ORM for mongoDb. It is already object oriented. What advantages bring an ORM ?\r\n> Using an ORM for mongoDB means that models are relational models and that's a pity because you loose all the benefits of an object oriented database.\r\n> \r\n> In PHP world, Doctrine try to do it with DoctrineODM but it was a failure and poorly used\r\n\r\nBe that as it may, this seems like a question for stack overflow and not the answer to the current issue that is being faced.\n\n---\n\n@mohamed-badaoui tried that, didn't work, I'm guessing because the `dot` in a key is not counted as a valid json key so it throws even more errors. \r\n\r\n```typescript\r\n[ERROR] 23:24:34 \u2a2f Unable to compile TypeScript:\r\nsrc/repo/StudentRecordsRepo.ts(160,16): error TS1005: ',' expected.\r\nsrc/repo/StudentRecordsRepo.ts(160,34): error TS1005: ',' expected.\r\nsrc/repo/StudentRecordsRepo.ts(160,40): error TS1005: ':' expected.\r\nsrc/repo/StudentRecordsRepo.ts(160,9): error TS2304: Cannot find name 'answers'.\r\nsrc/repo/StudentRecordsRepo.ts(160,16): error TS2345: Argument of type '{ _id: ObjectID; answers: any; (Missing): any; new: any; }' is not assignable to parameter of type 'string | number | Date | ObjectID | FindConditions<StudentRecord> | string[] | number[] | Date[] | ObjectID[]'.\r\n  Object literal may only specify known properties, and '(Missing)' does not exist in type 'string | number | Date | ObjectID | FindConditions<StudentRecord> | string[] | number[] | Date[] | ObjectID[]'.\r\nsrc/repo/StudentRecordsRepo.ts(160,40): error TS2348: Value of type 'typeof ObjectID' is not callable. Did you mean to include 'new'?\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2019-01-04T08:59:18Z",
        "body": "You should use `updateOne` or `updateMany` methods instead."
      },
      {
        "user": "judemanutd",
        "created_at": "2019-01-04T20:23:48Z",
        "body": "It was as simple as that, thank you @pleerock "
      }
    ]
  },
  {
    "number": 3281,
    "title": "Relation entity does not load on findOne",
    "created_at": "2018-12-18T22:06:16Z",
    "closed_at": "2018-12-19T06:41:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3281",
    "body": "**Issue type:**\r\n[X] bug report\r\n\r\n**Database system/driver:**\r\n[X] `mysql` / `mariadb`\r\n\r\n**TypeORM version:**\r\n[X] `@next`\r\n\r\nOn 2.9.0, with findOne repository method, we can load association with FindOptions **relations**  \r\nSo that code line will return Entity and its association\r\n`await connection.getRepository(Entity).findOne({id: 12}, {relations: ['association']});`\r\n\r\nThe same call **does not work** on on @next branch 3.0.0-alpha22\r\nIt return the entity WITHOUT the association. The only way it works is to give as it first parameter directly the id number. So we can't use query :(\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3281/comments",
    "author": "mohamed-badaoui",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-12-19T06:28:20Z",
        "body": "Why you don't use `await connection.getRepository(Entity).findOne({ where: {id: 12}, relations: ['association']});`\n\n---\n\nI don't remember motivation of this change, but probably it was made to prevent a confusion since second argument also can have its own `where` argument."
      },
      {
        "user": "mohamed-badaoui",
        "created_at": "2018-12-19T06:41:01Z",
        "body": "All right, thanks @pleerock.\r\n"
      }
    ]
  },
  {
    "number": 3250,
    "title": "[psql] Creating migration for already existing table",
    "created_at": "2018-12-14T00:15:16Z",
    "closed_at": "2018-12-14T13:07:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3250",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nI'm trying to create migration that would work with already existing database. I have a table which has two fields:\r\n\r\n```\r\nid BIGSERIAL PRIMARY KEY,\r\norg_id BIGSERIAL UNIQUE,\r\n```\r\n\r\nand in the TS class I have fields defined in the following way:\r\n\r\n```ts\r\n@PrimaryGeneratedColumn()\r\nreadonly id: number;\r\n\r\n@Column(\"bigint\", { name: \"org_id\", unique: true })\r\norgId: number;\r\n```\r\n\r\nand it keeps creating migrations for those two fields. Is there a way to define those two fields that would not create migration?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3250/comments",
    "author": "lukejagodzinski",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-12-14T03:55:49Z",
        "body": "Try following:\r\n\r\n```ts\r\n@PrimaryColumn(\"bigint\")\r\n@Generated()\r\nreadonly id: number;\r\n\r\n@Column(\"bigint\", { name: \"org_id\", unique: true })\r\n@Generated()\r\norgId: number;\r\n```"
      },
      {
        "user": "lukejagodzinski",
        "created_at": "2018-12-14T13:07:33Z",
        "body": "@pleerock thanks! It worked!"
      }
    ]
  },
  {
    "number": 2924,
    "title": "BeforeInsert Issue",
    "created_at": "2018-10-12T23:56:44Z",
    "closed_at": "2018-10-24T20:17:28Z",
    "labels": [
      "question",
      "comp: subscribers and listeners"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2924",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nPlacing @BeforeInsert() and @AfterInsert do not work\r\n\r\n```\r\n@AfterInsert()\r\n  modifyText() {\r\n    console.log(\"Something is being inserted\");\r\n  }\r\n```\r\n\r\n```\r\n@BeforeInsert()\r\n  modifyText() {\r\n    this.text = `${this.text} was modified before insert`;\r\n  }\r\n```\r\n\r\n```\r\n@BeforeInsert()\r\nhashpassword(){\r\n   this.password = ........\r\n}\r\n```\r\n\r\nI've seen this in other issues and they were closed but the issue was never actually resolved.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2924/comments",
    "author": "JamesCoonce",
    "comments": [
      {
        "user": "billyjov",
        "created_at": "2018-10-14T20:18:34Z",
        "body": "@JamesCoonce  `@BeforeInsert` work for me using version `0.2.7`. You have to be extra careful when working with asynchronous processes e.g your last use case for hashing a password.\r\n\r\nIt should work with the folowing syntax: \r\n\r\n```\r\n@BeforeInsert\r\nasync hashpassword() {\r\n    this.password = await your-hash-process;\r\n}\r\n```"
      },
      {
        "user": "rustamwin",
        "created_at": "2018-10-15T10:25:47Z",
        "body": "try it in subscribers"
      },
      {
        "user": "JamesCoonce",
        "created_at": "2018-10-16T13:50:22Z",
        "body": "I'm also using 0.2.7. Here is a basic example. This doesn't even work. It does no modify.\r\n```\r\nimport { Entity, Column, PrimaryGeneratedColumn, BeforeInsert} from 'typeorm';\r\n\r\n@Entity()\r\nexport class Todo {\r\n  @PrimaryGeneratedColumn()\r\n  id: number;\r\n\r\n  @Column({ length: 500 })\r\n  text: string;\r\n\r\n  @Column()\r\n  complete: boolean;\r\n\r\n  @BeforeInsert()\r\n  modifyText() {\r\n    this.text = `${this.text} was modified before insert`;\r\n  }\r\n}\r\n```\r\n\r\nInside of my todoService I have this\r\n\r\n```\r\npublic async create(todo: CreateTodosDTO): Promise<Todo> {\r\n        return await this.todoRepository.save(todo);\r\n    }\r\n```"
      },
      {
        "user": "feather-jmalone",
        "created_at": "2018-10-16T14:23:33Z",
        "body": "what does the value of `todo` look like? is it an object that has the properties of `Todo` (e.g. `{id: 1, text: 'text', complete: true}`, or is it an actual instance (e.g. `const todo = new Todo()`)?"
      },
      {
        "user": "JamesCoonce",
        "created_at": "2018-10-16T14:31:23Z",
        "body": "When I send the post request it's \r\n\r\n```\r\n{\r\n  \"text\": \"Today is Monday\",\r\n  \"complete\": false\r\n}\r\n```\r\n\r\nWhat I get back is \r\n\r\n```\r\n{\r\n\t\"text\": \"Today is Monday\",\r\n\t\"complete\": false,\r\n\t\"id\": 5\r\n}\r\n```\r\n\r\nI check the database and it's the same. It's not being modified before insert."
      },
      {
        "user": "feather-jmalone",
        "created_at": "2018-10-16T14:44:06Z",
        "body": "i could be wrong about this, but my understanding is that because `BeforeInsert` is an instance-level method, you need an actual instance of `Todo` in order for it to be invoked (you can't reference `this.password` if there's no `this`). The object you're passing in the request is just an object that happens to have the same properties as `Todo`. "
      },
      {
        "user": "JamesCoonce",
        "created_at": "2018-10-16T15:53:42Z",
        "body": "That works. I need to create an actual instance first."
      },
      {
        "user": "gintsgints",
        "created_at": "2018-10-21T09:33:42Z",
        "body": "@JamesCoonce consider closing issue then."
      },
      {
        "user": "pilattebe",
        "created_at": "2019-06-19T18:24:37Z",
        "body": "I know why this works that way but it shouldn\u2019t IMO. "
      },
      {
        "user": "vinimdocarmo",
        "created_at": "2019-08-14T15:15:22Z",
        "body": "> That works. I need to create an actual instance first.\r\n\r\nHow can one call a validation method using repository.save passing just a plain object instead of an entity instance?"
      },
      {
        "user": "liqwid",
        "created_at": "2019-10-11T00:39:29Z",
        "body": "> > That works. I need to create an actual instance first.\r\n> \r\n> How can one call a validation method using repository.save passing just a plain object instead of an entity instance?\r\n\r\n`Entity.prototype[methodName].apply(object, args)`\r\ngiven entity often is a DTO, that's useful IMO\r\n\r\nof course this brings the problem that any other instance methods would be unavailable in the call\r\n\r\nanother obvious solution is to instantiate.\r\n\r\nAnyway it should be explicitly mentioned in docs that instantiation is _required_ to use hooks"
      },
      {
        "user": "niyodusengaclement",
        "created_at": "2021-03-12T08:11:10Z",
        "body": "You can use the create method to create an instance`const data = repository.create(yourDto)` and then save returned data `repository.save(data)`\r\n\r\nThis will solve the issue"
      }
    ]
  },
  {
    "number": 2577,
    "title": "Is there a reason why listeners and subscribers would not work at all?",
    "created_at": "2018-07-24T16:22:46Z",
    "closed_at": "2018-09-29T10:49:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2577",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\nUsing getRepository(Entity).save(data) or entityManager.save(Entity, data) will not fire the @AfterUpdate or @AfterInsert methods on the entity.\r\n\r\n```\r\n@AfterInsert()\r\n@AfterUpdate()\r\nsomeMethod() { \r\n console.log(\"It worked!\")\r\n}\r\n```\r\n\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2577/comments",
    "author": "joebieb",
    "comments": [
      {
        "user": "joebieb",
        "created_at": "2018-07-24T16:28:27Z",
        "body": "Actual project code:\r\n```\r\n  /**\r\n   * Create a new ReportDetail\r\n   * @param req\r\n   * @param res\r\n   * @param next\r\n   */\r\n  public async save(req: Request, res: Response, next: NextFunction) {\r\n    let result = getRepository(ReportDetail)\r\n                .save(req.body)\r\n                .then(result => res.send(result))\r\n                .catch(error => console.log(error));\r\n  };\r\n```\r\nEntity:\r\n```\r\nImports ...\r\n@Entity()\r\nexport class ReportDetail {\r\ncolumns ...\r\n\r\n  @UpdateDateColumn({ type: 'timestamp without time zone', name: 'updated_at' })\r\n  updatedAt: Date;\r\n\r\n  @AfterUpdate()\r\n  @AfterInsert()\r\n  someMethod() {\r\n    console.log(\"This worked!\");\r\n  }\r\n}\r\n```\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2018-07-28T09:50:56Z",
        "body": "I guess its because your `req.body` is not instance of `ReportDetail`, and since its not instance of `ReportDetail` there is no method to call on `req.body`, e.g. you can't call `req.body.someMethod()`"
      },
      {
        "user": "joebieb",
        "created_at": "2018-07-28T20:18:11Z",
        "body": "Thank you for the help. This code works and fires the @AfterUpdate method. There's probably a better way to map the req.body to the new ReportDetail object, but this works.\r\n\r\n```\r\n  public async save(req: Request, res: Response, next: NextFunction) {\r\n    let _detail = new ReportDetail();\r\n    for(var key in req.body) _detail[key]=req.body[key];\r\n    let result = getRepository(ReportDetail)\r\n                .save(_detail)\r\n                .then(result => res.send(result))\r\n                .catch(error => console.log(error));\r\n  };\r\n```"
      }
    ]
  },
  {
    "number": 2374,
    "title": "Create relation entity question",
    "created_at": "2018-06-21T01:33:17Z",
    "closed_at": "2018-06-25T06:36:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2374",
    "body": "Issue type:\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\nDatabase system/driver:\r\n\r\n[ ] cordova\r\n[ ] mongodb\r\n[ ] mssql\r\n[x ] mysql / mariadb\r\n[ ] oracle\r\n[ ] postgres\r\n[ ] sqlite\r\n[ ] sqljs\r\n[ ] react-native\r\n\r\nTypeORM version:\r\n\r\n[ ] latest\r\n[ ] @next\r\n[^2.0.0 ] 0.x.x (or put your version here)\r\n\r\nSteps to reproduce or a small repository showing the problem:\r\n\r\nI have two table.\r\nOne is userBasic and other is userextensions\r\nuserBasic is onetomany to userextensions\r\n\r\nbelong is my schema\r\n```javascript\r\n@Entity(\"UserBasic\")\r\nexport class UserBasic {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n     ....\r\n\r\n    @OneToMany(type => UserExtension, userextensions => userextensions.userbasic,\r\n        {\r\n            cascade: true,\r\n            onDelete: \"CASCADE\",\r\n            onUpdate: \"CASCADE\",\r\n        })\r\n    userextensions: UserExtension[];\r\n\r\n}\r\n```\r\n```javascript\r\n@Entity(\"UserExtension\")\r\nexport class UserExtension {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id:number;\r\n        \r\n    @ManyToOne(type => UserBasic, userbasic=> userbasic.userextensions)\r\n    @JoinColumn({ name:'fk_id'})\r\n    userbasic:UserBasic;\r\n    \r\n    .....\r\n\r\n    @Column(\"tinyint\",{ \r\n        nullable:true,\r\n        default:\"NULL\",\r\n        name:\"K_Delete\"\r\n        })\r\n    K_Delete:number;\r\n```\r\n\r\nI want only create a new userextension \r\n\r\n**my Json**\r\n```javascript\r\n{ id: null,\r\n  Admit_Type:  'aa',\r\n  Unit:  'aa',\r\n  Title: 'aa',\r\n  Date_Start: '2018-06-05',\r\n  Date_Leave: '2018-06-05',\r\n  Lead_Class:  'aa',\r\n  Office_Tel:  'aa',\r\n  Office_Ext:  'aa',\r\n  Update_Date: '2018-06-21T09:20:42+08:00',\r\n  Update_User: 'test',\r\n  fk_id: '1' }\r\n```\r\nhow can i save userextension  ?\r\n\r\nwhen I save\r\n```javascript\r\nthis.userExtensionRepository.save(userExtension);\r\n```\r\n\r\nI got this error\r\n```javascript\r\nerror:\"ER_NO_DEFAULT_FOR_FIELD: Field 'fk_id' doesn't have a default value\"\r\n```\r\nwhen I create\r\n```javascript\r\nrtnVal = this.userExtensionRepository.create(userExtension);\r\n```\r\n\r\nnothing saved in database\r\n\r\nbut I can update and deletet...\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2374/comments",
    "author": "lalalalaluk",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-06-22T12:28:47Z",
        "body": "you create a user object, fill values, then you create user extension object and set this object to user and save it. Please follow typeorm homepage tutorials to understand more how typeorm relations work, this is very basic question."
      },
      {
        "user": "lalalalaluk",
        "created_at": "2018-06-25T01:30:28Z",
        "body": "Really thank you!"
      }
    ]
  },
  {
    "number": 2373,
    "title": "Primary Key column not included in returned object if primary key is is a foreign key of one-to-one relationship",
    "created_at": "2018-06-20T19:44:43Z",
    "closed_at": "2021-07-09T05:39:26Z",
    "labels": [
      "question",
      "driver: cordova"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2373",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[x] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI have a table (ProjectSettings) whose primary key is also the foreign key of a one-to-one relation. My entities look like this:\r\n```\r\n@Entity()\r\nexport class Project {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n    @OneToOne(number => ProjectSettings, projectSettings => projectSettings.project, { onDelete: 'CASCADE', cascade: true })\r\n    settings: ProjectSettings;\r\n}\r\n```\r\nand\r\n```\r\n@Entity()\r\nexport class ProjectSettings {\r\n    @JoinColumn()\r\n    @OneToOne(type => Project, { primary: true })\r\n    project: Project;\r\n}\r\n```\r\n\r\nHowever, if I use the repository to find the ProjectSettings by the Project, the returned class does not contain the projectId:\r\n```\r\nlet repository = getConnection().getRepository(ProjectSettings);\r\nrepository.findOne({ project: project }).then(projectSettings => { ...})\r\n```\r\nThus, when trying to persist the ProjectSettings again, a new entry is created, as the projectId is unknown.\r\nActually I've tried many combinations of various annotation properties, however I am not able to get it working.\r\n\r\nCould someone advise what I am doing wrong here?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2373/comments",
    "author": "dominic-simplan",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-06-22T13:28:25Z",
        "body": "> the returned class does not contain the projectId:\r\n\r\nbecause your class does not contain projectId property.\r\n\r\nTo avoid this kind of issues we are deprecating this format of definition of primary foreign keys in favour of following format:\r\n\r\n```ts\r\n@Entity()\r\nexport class ProjectSettings {\r\n\r\n    @PrimaryColumn()\r\n    projectId: number;\r\n\r\n    @OneToOne(type => Project)\r\n    @JoinColumn()\r\n    project: Project;\r\n}\r\n```\r\n\r\nplease use it and probably you'll get rid of \"strange\" issues."
      },
      {
        "user": "dominic-simplan",
        "created_at": "2018-06-26T06:56:58Z",
        "body": "@pleerock thanks for the explanation! Saving and loading is working fine now, however I am getting an error when trying to delete the Project entity. (I want that the ProjectSettings are cascaded on insert, update and delete of the Project entity.)\r\n\r\n```\r\n@Entity('Project')\r\nexport class Project {\r\n    @OneToOne(type => ProjectSettings, projectSettings => projectSettings.project, { cascade: true }) \r\n    settings: ProjectSettings;\r\n}\r\n```\r\n\r\n```\r\n@Entity('ProjectSettings')\r\nexport class ProjectSettings {\r\n    @PrimaryColumn()\r\n    projectId: number;\r\n    @JoinColumn({ name: \"projectId\" })\r\n    @OneToOne(type => Project, project => project.settings, { onDelete: 'CASCADE' })\r\n    project: Project;\r\n}\r\n```\r\n\r\nTrying to delete the project:\r\n```\r\ngetConnection().getRepository(Project).remove(project);\r\n```\r\ncreates an INSERT statement for the ProjectSettings, which fails because the ProjectSettings already exist:\r\n```\r\nquery failed:  INSERT INTO \"ProjectSettings\"(\"projectId\", \"otherColumn\", ) VALUES (?, ?) -- PARAMETERS: [17,\"2018-06-25T00:00:00Z\"]\r\n```\r\n\r\nI wonder why this INSERT statement is created? \r\nIf I change the @OneToOne and set the cascade to update only, deletion is working, however the cascade insert is not working anymore (obviously):\r\n```\r\n@OneToOne(type => ProjectSettings, projectSettings => projectSettings.project, { cascade: [\"update\"] }) \r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2018-06-26T19:56:02Z",
        "body": "that is strange, deletion can't cause cascade insert anyhow, this is something I need to investigate.\r\n\r\nCan you contribute and create a failing test for this issue?"
      },
      {
        "user": "dominic-simplan",
        "created_at": "2018-06-27T08:19:25Z",
        "body": "Hi,\r\nI've created a PR with an according test case: #2416.\r\nIf you need any other information please let me know!"
      },
      {
        "user": "imnotjames",
        "created_at": "2021-07-09T05:39:26Z",
        "body": "I've fixed the tests in your test PR.  You forgot to `await` the `remove` call.\r\n\r\nThey pass locally and I'll be confirming they pass in the CI as well.\n\n---\n\nThe tests passed in CI.  I think they overlap a few other tests we have so I won't be merging them in.\r\n\r\nThey also show that this is not an actual issue.  I think you need to `await`."
      }
    ]
  },
  {
    "number": 2301,
    "title": "How to add a comment to the reference fields",
    "created_at": "2018-06-07T08:07:21Z",
    "closed_at": "2018-06-08T10:50:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2301",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n\r\nIn an ordinary column, this is done like this:\r\n    @Column({\r\n        nullable: true,\r\n        comment: 'MyComment' // <---\r\n    })\r\n    my_field: string;\r\n\r\n\r\nHow do I add a comment to reference types?\r\n    @ManyToOne(type => Appeal, appeal => appeal.callphoneIdappeals, {\r\n        nullable: true\r\n    })\r\n    @JoinColumn({ name: 'idappeal' })\r\n    appeal: Appeal;\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2301/comments",
    "author": "nikolay-rogovoy",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-06-07T12:00:28Z",
        "body": "You can create a column with the same name and attach comment to it:\r\n\r\n```ts\r\n@column({\r\nnullable: true,\r\ncomment: 'MyComment' // <---\r\n})\r\nmy_field: string;\r\n\r\n@Column({ nullable: true, comment: 'your comment' })\r\nidappeal: number;\r\n\r\n@manytoone(type => Appeal, appeal => appeal.callphoneIdappeals, {\r\nnullable: true\r\n})\r\n@joincolumn({ name: 'idappeal' })\r\nappeal: Appeal;\r\n```\r\n\r\np.s. please format your code properly."
      },
      {
        "user": "nikolay-rogovoy",
        "created_at": "2018-06-08T10:50:42Z",
        "body": "Thank you so much!"
      },
      {
        "user": "Hilson-Alex",
        "created_at": "2021-10-12T17:47:08Z",
        "body": "> \r\n> \r\n> You can create a column with the same name and attach comment to it:\r\n> \r\n> ```ts\r\n> @column({\r\n> nullable: true,\r\n> comment: 'MyComment' // <---\r\n> })\r\n> my_field: string;\r\n> \r\n> @Column({ nullable: true, comment: 'your comment' })\r\n> idappeal: number;\r\n> \r\n> @manytoone(type => Appeal, appeal => appeal.callphoneIdappeals, {\r\n> nullable: true\r\n> })\r\n> @joincolumn({ name: 'idappeal' })\r\n> appeal: Appeal;\r\n> ```\r\n> \r\n> p.s. please format your code properly.\r\n\r\nSo.. I using TypeORM to synchronize a group project database, and we used this solution to comment a foreign key column. \r\nIt works for who already had the db, but it causes error (duplicated column) when creating the table for those who run it for the first time.\r\n\r\nWould be cool a way to comment our relations that doesn't break the synchronize scripts when creating a table."
      },
      {
        "user": "greenkarmic",
        "created_at": "2023-10-08T23:09:14Z",
        "body": "Is there really still no other way to add a comment to a reference field then duplicating the column this way?"
      }
    ]
  },
  {
    "number": 2080,
    "title": "@CreateDateColumn does not auto populate upon insertion.",
    "created_at": "2018-05-04T00:29:39Z",
    "closed_at": "2018-05-10T19:36:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2080",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.2` \r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nSample entity definition.\r\n```\r\nexport class MyEntity {\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n\r\n    @Column({type: \"int\"})\r\n    public password_reset_id: number;\r\n\r\n    @Column({type: \"varchar\"})\r\n    public password_hash: string;\r\n\r\n    @CreateDateColumn()\r\n    public created_at: Date;\r\n\r\n    @UpdateDateColumn()\r\n    public updated_at: Date;\r\n\r\n    @Column({type: \"timestamp\"})\r\n    public deleted_at: Date;\r\n}\r\n```\r\n\r\nIt would seem that after updating to version `0.2.2` my `created_at` columns are no longer being populated upon record insertion. Has the `@CreateDateColumn()` decorator changed in someway? Am I missing something completely obvious?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2080/comments",
    "author": "jonathan-palumbo",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-05-04T10:32:02Z",
        "body": "Can you please check on latest version?"
      },
      {
        "user": "lihue",
        "created_at": "2018-05-04T16:10:28Z",
        "body": "I have the same problem with version 0.2.5"
      },
      {
        "user": "pleerock",
        "created_at": "2018-05-04T19:44:34Z",
        "body": "sounds strange, there are tests which confirm this functionality...  can you please provide a reproduction repo?"
      },
      {
        "user": "jonathan-palumbo",
        "created_at": "2018-05-04T21:52:27Z",
        "body": "I have since rolled back to `0.1.9` which was the version I was on before upgrading to `0.2.2`. Prior to rolling back I had noticed that the `INSERT` queries where using the `DEFAULT` keyword for the `CreatedDateColumns` in `0.2.2` where as in `0.1.9` they contain a string literal of the current timestamp.\r\n\r\nQuery in `0.1.9`:\r\n\r\n```\r\nINSERT INTO `table_name`(`created_at`, `updated_at`) VALUES (?,?) -- PARAMETERS: [\"2018-05-04T21:07:38.711Z\",\"2018-05-04T21:07:38.711Z\"]\r\n```\r\n\r\nQuery in `0.2.2`:\r\n\r\n```\r\nINSERT INTO `table_name`(`created_at`, `updated_at`) VALUES (?,?) -- PARAMETERS: [DEFAULT,DEFAULT]\r\n```\r\n\r\nI am not entirely sure of the mechanism TypeORM is using to get the timestamp in place of `DEFAULT`. Does the database schema need to be altered in anyway to accommodate this? \r\n\r\nFurthermore, for what it is worth we are using mysql 5.6 if that could possible be the difference. If I can find the time I will try to provided an example that exhibits the observed behavior.\r\n\r\n\n\n---\n\nI forked the repository in the hopes of running the tests locally and perhaps trying the tests against a `mysql 5.6` container. However I cannot seem to get the tests to pass in their current state even though they appear to be passing in the CI build?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-05-05T07:56:01Z",
        "body": "okay, so in 0.1.x we used our own value as a date. Now in 0.2.x we are using column's DEFAULT which is equal to NOW(). You don't have created date because you schema is not in sync."
      },
      {
        "user": "jonathan-palumbo",
        "created_at": "2018-05-07T14:42:56Z",
        "body": "So I should just define defaults for `CURRENT_TIMESTAMP` for both my created and updated  columns in my schema?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-05-09T08:52:53Z",
        "body": "yes"
      },
      {
        "user": "jonathan-palumbo",
        "created_at": "2018-05-10T19:36:40Z",
        "body": "\ud83d\udc4d Thanks pleerock "
      },
      {
        "user": "dcworldwide",
        "created_at": "2018-07-26T11:50:50Z",
        "body": "@pleerock  @jonathan-palumbo  Just upgraded to 0.2.x and hit the same issue.\r\n\r\nI can't rebuild the production schema. Instead I need to patch it via sql with zero outage. If I ran the following for all createdAt updatedAt columns (postgres) and then afterwards deploy the new code (with 0.2.x) can I expect any issues?\r\n\r\n`ALTER TABLE ONLY \"public\".\"app_config\" ALTER COLUMN \"createdAt\" SET DEFAULT CURRENT_DATE;`\r\n"
      },
      {
        "user": "mrsauravsahu",
        "created_at": "2020-06-18T14:42:12Z",
        "body": "you can try \r\n```\r\n@CreateDateColumn({ default: () => 'NOW()' })\r\ncreatedAt: Date\r\n```\r\nin your entity. This should generate the right migration."
      },
      {
        "user": "emmyduruc",
        "created_at": "2022-07-05T10:04:25Z",
        "body": "> you can try\r\n> \r\n> ```\r\n> @CreateDateColumn({ default: () => 'NOW()' })\r\n> createdAt: Date\r\n> ```\r\n> \r\n> in your entity. This should generate the right migration.\r\n\r\ni have tried this and it did not work either"
      },
      {
        "user": "mrsauravsahu",
        "created_at": "2022-07-07T12:02:24Z",
        "body": "> > you can try\r\n> > ```\r\n> > @CreateDateColumn({ default: () => 'NOW()' })\r\n> > createdAt: Date\r\n> > ```\r\n> > \r\n> > \r\n> >     \r\n> >       \r\n> >     \r\n> > \r\n> >       \r\n> >     \r\n> > \r\n> >     \r\n> >   \r\n> > in your entity. This should generate the right migration.\r\n> \r\n> i have tried this and it did not work either\r\n\r\nOdd, tried this again. I'm still able to generate the right migration.\r\n\r\n```typescript\r\nimport { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn } from \"typeorm\"\r\n\r\n@Entity()\r\nexport class User {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id: number\r\n\r\n    @Column()\r\n    firstName: string\r\n\r\n    @Column()\r\n    lastName: string\r\n\r\n    @Column()\r\n    age: number\r\n\r\n    @CreateDateColumn({ default: () => 'NOW()' })\r\n    createdAt: Date\r\n}\r\n```\r\n\r\n```bash\r\nnpm run typeorm -- migration:generate src/migration/InitialCreate -d src/data-source.ts\r\n```\r\n\r\nwhich generated this migration\r\n\r\n```typescript\r\nimport { MigrationInterface, QueryRunner } from \"typeorm\";\r\n\r\nexport class InitialCreate1657194989813 implements MigrationInterface {\r\n    name = 'InitialCreate1657194989813'\r\n\r\n    public async up(queryRunner: QueryRunner): Promise<void> {\r\n        await queryRunner.query(`CREATE TABLE \"user\" (\"id\" SERIAL NOT NULL, \"firstName\" character varying NOT NULL, \"lastName\" character varying NOT NULL, \"age\" integer NOT NULL, \"createdAt\" TIMESTAMP NOT NULL DEFAULT NOW(), CONSTRAINT \"PK_cace4a159ff9f2512dd42373760\" PRIMARY KEY (\"id\"))`);\r\n    }\r\n\r\n    public async down(queryRunner: QueryRunner): Promise<void> {\r\n        await queryRunner.query(`DROP TABLE \"user\"`);\r\n    }\r\n\r\n}\r\n```\r\n\r\n```typescript\r\nimport \"reflect-metadata\"\r\nimport { AppDataSource } from \"./data-source\"\r\nimport { User } from \"./entity/User\"\r\n\r\nAppDataSource.initialize().then(async () => {\r\n\r\n    console.log(\"Inserting a new user into the database...\")\r\n    const user = new User()\r\n    user.firstName = \"Saurav\"\r\n    user.lastName = \"Sahu\"\r\n    user.age = 25\r\n    await AppDataSource.manager.save(user)\r\n    console.log(\"Saved a new user with id: \" + user.id)\r\n\r\n    console.log(\"Loading users from the database...\")\r\n    const users = await AppDataSource.manager.find(User)\r\n    console.log(\"Loaded users: \", users)\r\n}).catch(error => console.log(error))\r\n```\r\n\r\nwhich fills the `createdAt` property with the current timestamp\r\n```\r\n\u2514\u2500$ npm start\r\n\r\n> repro-postgres-auto-populate-dates@1.0.0 start\r\n> ts-node src/index.ts\r\n\r\nInserting a new user into the database...\r\nSaved a new user with id: 1\r\nLoading users from the database...\r\nLoaded users:  [\r\n  User {\r\n    id: 1,\r\n    firstName: 'Saurav',\r\n    lastName: 'Sahu',\r\n    age: 25,\r\n    createdAt: 2022-07-07T06:27:59.987Z\r\n  }\r\n]\r\n```"
      }
    ]
  },
  {
    "number": 2009,
    "title": "Set sqlite database path programmatically.",
    "created_at": "2018-04-24T04:25:32Z",
    "closed_at": "2018-04-24T15:17:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2009",
    "body": "**Issue type:**\r\n\r\n[ x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ x ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[ x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI'm writing an app in electron, and I want to set the path to my sqlite databse like this:\r\n`${require('os').homedir()}/.HyperAI/database.sqlite`\r\n\r\nIs there a code example of how to do this programmatically?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2009/comments",
    "author": "cjackson234",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-04-24T05:24:34Z",
        "body": "use create connection and pass connection options:\r\n\r\n```ts\r\nimport {createConnection} from \"typeorm\";\r\n\r\ncreateConnection({\r\n     type: \"sqlite\",\r\n     database: `${require('os').homedir()}/.HyperAI/database.sqlite`\r\n});\r\n```"
      },
      {
        "user": "cjackson234",
        "created_at": "2018-04-24T15:17:18Z",
        "body": "Thanks, @pleerock ! "
      }
    ]
  },
  {
    "number": 2008,
    "title": "\u201cCONSTRAINT PK_payment_vendor PRIMARY KEY (vendor_id ASC)\u201c",
    "created_at": "2018-04-24T03:37:44Z",
    "closed_at": "2018-04-24T06:11:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2008",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `mysql` / `mariadb`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `0.1.20` \r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nIn MYSQL, create constraint is: CONSTRAINT PK_payment_vendor PRIMARY KEY (vendor_id ASC)\r\n\r\nhow to write in Typeorm? Thanks!\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2008/comments",
    "author": "JingMo",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-04-24T05:23:37Z",
        "body": "you don't need to define a CONSTRAINT with typeorm. Instead you create an entity and add a property with `@PrimaryColumn` decorator applied."
      }
    ]
  },
  {
    "number": 1945,
    "title": "invalid input syntax for uuid for PrimaryGeneratedColumn(\"uuid\") when initializing property",
    "created_at": "2018-04-15T01:01:39Z",
    "closed_at": "2018-04-19T12:55:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1945",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[X] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[X] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n```ts\r\n\r\nexport class EntityBase {\r\n  @PrimaryGeneratedColumn(\"uuid\") public id: string = \"\"; // NOTICE: I'm initializing this property to \"\"\r\n  @CreateDateColumn() public created: Date = new Date();\r\n  @UpdateDateColumn() public updated: Date = new Date();\r\n  @Column() public inactive: boolean = false;\r\n}\r\n\r\n@Entity(\"user_accounts\")\r\nexport class User extends EntityBase {\r\n  @Index(\"username_unique\", { unique: true })\r\n  @Column()\r\n  public username: string = \"\";\r\n\r\n  @Column() public passwordHash: string = \"\";\r\n  public password: string | undefined;\r\n}\r\n\r\n```\r\n\r\nTrying to insert entries of the above entity type but getting an error when calling `save` on the repository. My TypeScript project is set to `strict: true`, which requires property initialization.  I recently upgraded to `typeorm@next` (currently `0.2.0-alpha.46`) and began having this problem.  Before, I was running an earlier version of 0.2.0 and using `sqlite` instead of `postgres`. \r\n\r\nIn one of my other entities, I was initializing a relation property to empty array (`[]`) and received an error in the console, which was very clear that I shouldn't initialize that property.  \r\n\r\nI remove the initialization code and everything is now working.\r\n\r\nIs this something that TypeOrm could detect and throw a clearer error for?\r\n\r\n```\r\nQueryFailedError: invalid input syntax for uuid: \"\"\r\n    at new QueryFailedError (/src/error/QueryFailedError.ts:7:9)\r\n    at Query.callback (/src/driver/postgres/PostgresQueryRunner.ts:170:26)\r\n    at Query.handleError (/node_modules/pg/lib/query.js:143:17)\r\n    at Connection.connectedErrorHandler (/node_modules/pg/lib/client.js:132:26)\r\n    at emitOne (events.js:116:13)\r\n    at Connection.emit (events.js:211:7)\r\n    at Socket.<anonymous> (/pg/lib/connection.js:117:12)\r\n    at emitOne (events.js:116:13)\r\n    at Socket.emit (events.js:211:7)\r\n    at addChunk (_stream_readable.js:263:12)\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1945/comments",
    "author": "marpstar",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-04-19T12:55:18Z",
        "body": "`uuid` column value is generated by database in case if you did not specify your own value. In your case you specified your own value (empty string) and it thinks that you pass your own uuid and does not use default database's uuid generation. But since empty string is not equal to uuid you have an error. Solution is to generate a proper uuid or remove value assignment. \r\n\r\nAlso I recommend you to consider value of strict property initialization and put \"!\" to your properties instead of initialization if you think that value is higher then overhead.  \n\n---\n\nLet me know if I did not answer your question."
      }
    ]
  },
  {
    "number": 1944,
    "title": "Is it possible to use the joined entity instead?",
    "created_at": "2018-04-14T18:58:59Z",
    "closed_at": "2018-04-16T15:07:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1944",
    "body": "**Issue type:**\r\n\r\n[ x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[x ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[2.0.0] `0.x.x` (or put your version here)\r\n\r\nI wasn't able to gather from the docs and this question go no traction on SO.\r\n\r\n**Question:**\r\n\r\nI've got an auth_token table and user table. I'd like to resolve a user from a given auth token using the query builder. The issue I'm having is that after joining, the return type still thinks it's going to be an AuthToken. Is there a way to tell the query builder to use the joined entity instead?\r\n\r\n```\r\nreturn await this.authTokenRepository\r\n  .createQueryBuilder()\r\n  .where({\r\n    token: token\r\n  })\r\n  .innerJoinAndSelect(User, 'user')\r\n  .getOne();\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1944/comments",
    "author": "micah-williamson",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-04-16T08:21:19Z",
        "body": "If you want a user, you need to select use and join token, are you doing your query from the wrong side. If you need a user, you take a user repository, join token, say where token is equal to token and thats all.\r\n\r\n```ts\r\nreturn await this.userRepository\r\n  .createQueryBuilder(\"user\")\r\n  .innerJoinAndSelect(\"user.authToken\", \"authToken\", \"authToken.token = :token\", { token })\r\n  .getOne();\r\n```"
      },
      {
        "user": "micah-williamson",
        "created_at": "2018-04-16T15:07:38Z",
        "body": "Makes sense. I arrived at this eventually but wanted to leave the question open in case it were possible to resolve the user in the way I was trying. Thank you"
      }
    ]
  },
  {
    "number": 1916,
    "title": "Find where for sub relation fields",
    "created_at": "2018-04-12T08:34:30Z",
    "closed_at": "2018-04-12T09:54:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1916",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHello!\r\nIs that possible to do something like this ? \r\n```\r\nconst [results,count] = await this.repository.findAndCount({\r\n\twhere: {\r\n\t\trelation: [\r\n\t\t\t{\r\n\t\t\t\tsubRelation: [\r\n\t\t\t\t\tsubRelationField: value\r\n\t\t\t\t]\r\n\t\t\t}\r\n\t\t]\r\n\t}\r\n});\r\n```\r\nI want to get and count rows, but params which i need to match is one of nested relation fields.\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1916/comments",
    "author": "hyze2d",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-04-12T09:10:34Z",
        "body": "you need to use QueryBuilder for this purpose. It will be much cleaner btw."
      },
      {
        "user": "hyze2d",
        "created_at": "2018-04-12T09:51:24Z",
        "body": "Thank you! Can you give some example ? How to query this with query builder."
      },
      {
        "user": "pleerock",
        "created_at": "2018-04-12T09:53:22Z",
        "body": "see docs on site on how to use query builder. Basically its something like this:\r\n\r\n```ts\r\nrepository.createQueryBuilder(\"photo\")\r\n    .innerJoin(\"photo.albums\", \"album\", \"album.name = :name\", { name })\r\n    .getManyAndCount()\r\n```"
      }
    ]
  },
  {
    "number": 1827,
    "title": "Question on query building to select a single column of the original table",
    "created_at": "2018-03-26T20:48:43Z",
    "closed_at": "2018-03-28T15:34:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1827",
    "body": "```\r\n@Entity()\r\nexport class Script {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    name: string;\r\n\r\n    @OneToMany(type => Session, session => session.script)\r\n    sessions: Session[];\r\n\r\n    @ManyToMany(type => User)\r\n    @JoinTable()\r\n    users: User[];\r\n}\r\n```\r\n\r\n```\r\n@Entity()\r\nexport class User {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    username: string;\r\n\r\n    @OneToMany(type => Session, session => session.user)\r\n    sessions: Session[];\r\n}\r\n```\r\n\r\nI am trying to select the Script.name of users who have Script.\r\n\r\n```\r\n    async findScripts(username: string): Promise<Script[]> {\r\n        return await this.scriptRepository\r\n            .createQueryBuilder('script')\r\n            .select('script.name')\r\n            .leftJoin('script.users', 'user')\r\n            .where('user.username = :name', { name: username })\r\n            .getMany();\r\n    }\r\n```\r\n\r\n```\r\n[\r\n  {\r\n    \"name\": \"Script A\",\r\n    \"users\": [\r\n      \r\n    ]\r\n  },\r\n  {\r\n    \"name\": \"Script B\",\r\n    \"users\": [\r\n      \r\n    ]\r\n  }\r\n]\r\n```\r\n\r\nIt works, only issue is my left join is also adding an unwanted empty users array, I'm sure it is something dumb I overlooked. Any tips?\r\n\r\nBeen playing around with NestJS / TypeORM today overall very pleased and happy with this library, hats off to the contributors this is absolutely fantastic.\r\n\r\nThanks.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1827/comments",
    "author": "Tyler-V",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-03-27T04:34:25Z",
        "body": "First, you must select primary columns, its a requirement. Second, you need to use `leftJoinAndSelect` if you want users to be returned in the array"
      },
      {
        "user": "Tyler-V",
        "created_at": "2018-03-27T14:11:21Z",
        "body": "Hey thanks for the reply @pleerock \r\n\r\nI should clarify, I am trying to only get the names of the scripts and not the users array however that is the relationship between the two tables.\r\n\r\nThis is what I am trying to achieve, how would I write this in typeorm using the query builder?\r\n\r\n```\r\nSELECT DISTINCT name FROM script\r\nLEFT JOIN script_users_user ON script_users_user.scriptId\r\nLEFT JOIN user ON script_users_user.userId\r\nWHERE username = 'User A'\r\n```\r\n\r\n```\r\n[\r\n  {\r\n    \"name\": \"Script A\",\r\n  },\r\n  {\r\n    \"name\": \"Script B\",\r\n  }\r\n]\r\n```\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2018-03-28T07:16:55Z",
        "body": "I don't understand why you need two joins when you don't use them. Is `username` part of `script` ?\r\n\r\nSomething like this shall work:\r\n\r\n```ts\r\nthis.scriptRepository\r\n            .createQueryBuilder('script')\r\n            .select('script.name', 'name')\r\n// add joins and wheres here\r\n            .groupBy(\"user.name\")\r\n            .getRawMany();\r\n ```"
      },
      {
        "user": "Tyler-V",
        "created_at": "2018-03-28T15:24:33Z",
        "body": "@pleerock the difference in all of this was using getMany() vs getRawMany()\r\n\r\nThis indeed returns what I am looking for, returning the entities returned from getRawMany() only returns the script names.\r\n\r\n```\r\n        return await this.scriptRepository\r\n            .createQueryBuilder('script')\r\n            .select('name')\r\n            .leftJoin('script.users', 'user')\r\n            .where('user.username = :name', { name: username })\r\n            .getRawMany();\r\n```\r\n```\r\n[\r\n  {\r\n    \"name\": \"Script A\"\r\n  },\r\n  {\r\n    \"name\": \"Script B\"\r\n  }\r\n]\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2018-03-28T15:42:15Z",
        "body": "btw, can you try it on `@next`? On `@next` for sure it should not return empty users array if you are not using `leftJoinAndSelect`\n\n---\n\n`@next` is the latest version (0.2.0 final will be released soon) that contains lot of changes and fixed we have made in past 6 month. Try it via `npm i typeorm@next`"
      },
      {
        "user": "Tyler-V",
        "created_at": "2018-03-28T15:45:05Z",
        "body": "Using @next,\r\n\r\n```\r\n        return await this.scriptRepository\r\n            .createQueryBuilder('script')\r\n            .select('name')\r\n            .leftJoinAndSelect('script.users', 'user')\r\n            .where('user.username = :name', { name: username })\r\n            .getMany();\r\n```\r\nReturns just an empty array\r\n\r\n```\r\n[\r\n\r\n]\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2018-03-28T15:50:36Z",
        "body": "Something is definitely wrong, can you please show your script and user entities?"
      },
      {
        "user": "Tyler-V",
        "created_at": "2018-03-28T15:52:49Z",
        "body": "```\r\n@Entity()\r\nexport class Script {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column({ unique: true })\r\n    name: string;\r\n\r\n    @OneToMany(type => Session, session => session.script)\r\n    sessions: Session[];\r\n\r\n    @ManyToMany(type => User)\r\n    @JoinTable()\r\n    users: User[];\r\n}\r\n```\r\n\r\n```\r\n@Entity()\r\nexport class User {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column({ unique: true })\r\n    email: string;\r\n\r\n    @Column({ unique: true })\r\n    username: string;\r\n\r\n    @Column()\r\n    password: string;\r\n\r\n    @OneToMany(type => Session, session => session.user)\r\n    sessions: Session[];\r\n}\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2018-03-28T15:55:48Z",
        "body": "ah, wait. QueryBuilder code is not correct. Correct is:\r\n\r\n```ts\r\n        return await this.scriptRepository\r\n            .createQueryBuilder('script')\r\n            .select('script.name')\r\n            .leftJoinAndSelect('script.users', 'user')\r\n            .where('user.username = :name', { name: username })\r\n            .getMany();\r\n```\r\n\r\nAlso, try \r\n\r\n```ts\r\n        return await this.scriptRepository\r\n            .createQueryBuilder('script')\r\n            .select('script.name')\r\n            .leftJoin('script.users', 'user')\r\n            .where('user.username = :name', { name: username })\r\n            .getMany();\r\n```"
      },
      {
        "user": "Tyler-V",
        "created_at": "2018-03-28T16:02:51Z",
        "body": "1. Returns the script name and full user entity, instead of just the script.name as desired.\r\n\r\n```\r\n[\r\n  {\r\n    \"name\": \"Script A\",\r\n    \"users\": [\r\n      {\r\n        \"id\": 1,\r\n        \"email\": \"email1\",\r\n        \"username\": \"user1\",\r\n        \"password\": \"password1\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"name\": \"Script B\",\r\n    \"users\": [\r\n      {\r\n        \"id\": 1,\r\n        \"email\": \"email1\",\r\n        \"username\": \"user1\",\r\n        \"password\": \"password1\"\r\n      }\r\n    ]\r\n  }\r\n]\r\n```\r\n\r\n2. Returns the desired result, just the script names.\r\n\r\n```\r\n[\r\n  {\r\n    \"name\": \"Script A\"\r\n  },\r\n  {\r\n    \"name\": \"Script B\"\r\n  }\r\n]\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2018-03-28T16:08:33Z",
        "body": "okay so everything as expected"
      },
      {
        "user": "Tyler-V",
        "created_at": "2018-03-28T16:16:43Z",
        "body": "Yes looks good! Let me know if I can help with anything else @pleerock "
      },
      {
        "user": "webmobiles",
        "created_at": "2018-12-04T05:33:34Z",
        "body": "@Tyler-V what about select only the field users.email ? where use '.select()' ?\r\nis not working with me, only select direct fields from the join table. thanks"
      },
      {
        "user": "jaimedeverall",
        "created_at": "2020-03-20T11:20:15Z",
        "body": "Hi there, is there any follow up on @webmobiles question. I can select fields of `script` just fine but can't select the fields of the relation table, `user`"
      },
      {
        "user": "elle86a",
        "created_at": "2020-07-29T08:53:23Z",
        "body": "I Have the same issues, can't select the leftjoin column in version 0.2.25"
      },
      {
        "user": "webmobiles",
        "created_at": "2020-07-29T09:34:14Z",
        "body": "try to do:\r\n\r\n      .select([\r\n        'secondtable.name as name2',\r\n        'SUM(investments.amount) as startup_amount_invested_in',\r\n        'COUNT(lists) as startup_list_count'\r\n      ])"
      },
      {
        "user": "lakhandeshpande",
        "created_at": "2020-08-14T03:07:09Z",
        "body": "   return await this.scriptRepository\r\n            .createQueryBuilder('script')\r\n            .select('script.name')\r\n            .leftJoin('script.users', 'user')\r\n            .where('user.username = :name', { name: username })\r\n            .getMany();\r\n\r\nI would like to know how this get executed or called? In which file I should write this code to execute?"
      }
    ]
  },
  {
    "number": 1688,
    "title": "@next QueryBuilder IN clause error",
    "created_at": "2018-03-02T01:39:03Z",
    "closed_at": "2018-03-02T06:54:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1688",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[ x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ x] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce:**\r\nWhen use IN clause using QueryBuilder and pass array of numbers, an error happens:\r\n\r\n```\r\ntypeorm:query:error parameters: [ [ 1, 2, 3 ] ]\r\ntypeorm:query:error error:  { error: invalid input syntax for integer: \"{\"1\",\"2\",\"3\"}\"\r\n```\r\nQuey:\r\n`query.andWhere(\"entity.id IN (:idInParam)\", { idInParam: [1, 2, 3] })`\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1688/comments",
    "author": "hugoserrana",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-03-02T03:15:15Z",
        "body": "Syntax for array parameter has been changed. New syntax for array parameters is:\r\n\r\n```ts\r\n\"entity.id IN (:...idInParam)\"\r\n```\r\n\r\nPurpose of this change is to support native arrays, before it was not possible to use them for example this way:\r\n\r\n```ts\r\n\"entity.id = ANY(:idInParam)\"\r\n```\r\n\r\nNow it is."
      },
      {
        "user": "hugoserrana",
        "created_at": "2018-03-02T03:44:29Z",
        "body": "This worked! \r\nI didn't knew that syntax had changed. \r\nThanks @pleerock!!"
      },
      {
        "user": "pleerock",
        "created_at": "2018-03-02T06:54:02Z",
        "body": "yw"
      }
    ]
  },
  {
    "number": 1673,
    "title": "How to wirte 'decimal(5,2)' in entity?",
    "created_at": "2018-02-28T07:42:24Z",
    "closed_at": "2018-02-28T16:51:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1673",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `mysql` / `mariadb`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n\r\n**How to wirte 'decimal(5,2)' in entity?:**\r\n\r\nI want to set the field in the table. the field type is decimal, store like data: $123.23.\r\n\r\nIn entity, how to wirte?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1673/comments",
    "author": "kaimiyang",
    "comments": [
      {
        "user": "AlexMesser",
        "created_at": "2018-02-28T08:08:29Z",
        "body": "```typescript\r\n@Column(\"decimal\", { precision: 5, scale: 2 })\r\nvalue: number;\r\n```"
      },
      {
        "user": "kaimiyang",
        "created_at": "2018-02-28T08:17:50Z",
        "body": "@AlexMesser thank you!\r\nmany times I write like this : \r\n`@Column({\r\n    type: 'decimal',\r\n    precision: 5,\r\n    scale: 2,\r\n    default: 0,\r\n  })\r\n`\r\nand then `desc tablename`, result in:\r\n`\r\ndecimal(5,0)\r\n`\r\n\r\nnow is okey!"
      },
      {
        "user": "rinoymjoseph",
        "created_at": "2018-09-03T06:11:17Z",
        "body": "For me below one worked..\r\n` @Column({ name: \"R1ContentWidth\", type: \"decimal\", precision: 2, scale: 2, nullable: true })\r\n    r1ContentWidth: number`\r\nresulted in a column with Decimal(2,2) in DB"
      }
    ]
  },
  {
    "number": 1608,
    "title": "Create from nested object with lazy relation",
    "created_at": "2018-02-19T04:30:29Z",
    "closed_at": "2018-02-19T08:59:03Z",
    "labels": [
      "question",
      "comp: lazy loading"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1608",
    "body": "**Issue type:**\r\n\r\n[] question\r\n[ ] bug report\r\n[x] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nGiven\r\n```ts\r\nimport { BaseEntity, ManyToOne, OneToMany } from 'typeorm'\r\n\r\nclass Author extends BaseEntity {\r\n  @Column()\r\n  name: string\r\n\r\n  @OneToMany(() => Post)\r\n  posts: Promise<Post[]>\r\n}\r\n\r\nclass Post extends BaseEntity {\r\n  @ManyToOne(() => Author, 'posts', { cascadeInsert: true })\r\n  author: Promise<Author>\r\n}\r\n\r\nawait Post.create({author: Promise.resolve({name: 'author1'})}).save\r\n```\r\n\r\nGot\r\n```\r\nSTART TRANSACTION\r\nexecuting query:  INSERT INTO \"author\" DEFAULT VALUES  RETURNING \"id\"\r\nquery failed:  INSERT INTO \"author\" DEFAULT VALUES  RETURNING \"id\"\r\nerror:  { error: null value in column \"name\" violates not-null constraint\r\n...\r\n```\r\n\r\nBut eager relation works:  `Post.create({author: {name: 'author1'}})`\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1608/comments",
    "author": "gutenye",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-02-19T07:05:11Z",
        "body": "You need to use following syntax:\r\n\r\n```ts\r\nawait Post.create({author: PromiseUtils.create({name: 'author1'})}).save\r\n```\r\n\r\nLazy relations aren't what people usually need to use. Just be aware."
      },
      {
        "user": "gutenye",
        "created_at": "2018-02-21T10:44:14Z",
        "body": "@pleerock\r\n It works, thanks.\r\n\r\nI use `typeorm` with `GraphQL`. If I understand it right, Lazy relations are the only way to use inside `GraphQL` resolvers. \r\n\r\nBut lazy relations are more complex than eager relations in many cases, is there a way to use eager relations with `GraphQL`?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-02-21T11:26:10Z",
        "body": "I don't use lazy relations with graphql. Instead I created abstraction and use `connection.relationIdLoader` (can be found in latest `@next`) to find related entities for relation resolvers. I'll publish a framework with concrete implementation in the near future."
      }
    ]
  },
  {
    "number": 1586,
    "title": "nullable column/relation option set to false only works on undefined",
    "created_at": "2018-02-13T19:54:02Z",
    "closed_at": "2018-02-16T14:16:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1586",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI have two fields within my entity that have _nullable_ set to _false_, which will set the field null during an update (both in the relation and column).\r\n\r\n```ts\r\n@Entity('Account')\r\nexport class AccountEntity {\r\n\r\n    @ManyToOne(type => RecordTypeEntity, {\r\n        nullable: false\r\n    })\r\n    @JoinColumn({ name: 'RecordTypeId' })\r\n    recordType: RecordTypeEntity;\r\n\r\n    @Column({\r\n        name: 'Phone',\r\n        type: 'varchar',\r\n        nullable: false\r\n    })\r\n    phone: string;\r\n}\r\n```\r\n\r\nHowever, when running (I'm showing the Jest test I have it in), setting the fields to null will set them null in the database during the update, and the test will fail. **This does happen in the running server, I'm just showing the test because it's more concise.**\r\n\r\n```ts\r\nreturn AccountEntity.save(account).then(() => {\r\n    return AccountEntity.findOneById(account.sfid, {\r\n        join: {\r\n            alias: 'account',\r\n            innerJoinAndSelect: {\r\n                'recordType': 'account.recordType'\r\n            }\r\n        }\r\n    }).then(result => {\r\n\r\n        result.phone = null;\r\n        result.recordType = null;\r\n\r\n        return AccountEntity.save(result).then(() => {\r\n            return AccountEntity.findOneById(account.sfid, {\r\n                join: {\r\n                    alias: 'account',\r\n                    innerJoinAndSelect: {\r\n                        'recordType': 'account.recordType'\r\n                    }\r\n                }\r\n            }).then(result => {\r\n\r\n                expect(result).toBeDefined();\r\n\r\n                expect(result.recordType).toEqual(account.recordType);\r\n                expect(result.phone).toEqual(account.phone);\r\n\r\n            });\r\n        });\r\n\r\n    });\r\n\r\n});\r\n```\r\n\r\nThis is spit out in the logs during the test - so you can see that it's updating the field.\r\n\r\n```console\r\nconsole.log node_modules/typeorm/platform/PlatformTools.js:207\r\nexecuting query:  START TRANSACTION\r\n\r\nconsole.log node_modules/typeorm/platform/PlatformTools.js:207\r\nexecuting query:  UPDATE `Account` SET `Phone`=?, `RecordTypeId`=?  WHERE `Id`=? -- PARAMETERS: [null,null,\"1e6ecbc2-6890-44bd\"]\r\n\r\nconsole.log node_modules/typeorm/platform/PlatformTools.js:207\r\nexecuting query:  COMMIT\r\n```\r\n\r\nThe only way I can get it to work is to set the fields to undefined instead of null\r\n\r\n```ts\r\nresult.phone = undefined;\r\nresult.recordType = undefined;\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1586/comments",
    "author": "anigenero",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-02-15T06:16:15Z",
        "body": "`nullable: false` means it will set your column `NOT NULL` constraint in the database, it does not mean it will skip your columns from the updation if they are equal to null. So, behaviour you are getting is expected."
      },
      {
        "user": "anigenero",
        "created_at": "2018-02-15T15:36:41Z",
        "body": "Ok. Was expecting that the behavior on that would be similar to how JPA deals with non-nullable columns, and the way the documentation is worded, it seemed that it would. Is this something you would consider putting in as a feature for instances like this? Or is that not within the scope of the project?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-02-16T05:13:06Z",
        "body": "We could add a check and throw an exception if some of the values are null. The only difference will be that instead of database throwing error orm will be doing that. Im not sure if its a good design because it is only one database constraint we'll check. But there are other constraints that database has besides NOT NULL checks and its not possible for orm to check them all (even half of them). So, Im not really sure about \"validate some constraints, left others for database to check\" design."
      },
      {
        "user": "anigenero",
        "created_at": "2018-02-16T14:16:49Z",
        "body": "Ok. Not optimal, but I understand your overall reasoning why not to include it. So, in my case I just need to do the check for the null values I'm validating. Thanks for your help."
      }
    ]
  },
  {
    "number": 1490,
    "title": "Undefined does not affect model objects",
    "created_at": "2018-01-23T04:33:54Z",
    "closed_at": "2018-01-23T06:17:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1490",
    "body": "When trying to update a user, I mistakenly ran the following commands:\r\n```\r\n      user.resetPasswordToken = undefined;\r\n      user.resetPasswordExpires = undefined;\r\n      userRepo.save(user)\r\n```\r\n\r\nBut I noticed that it wasn't doing anything to the user object. However, when I changed this to:\r\n```\r\n      user.resetPasswordToken = null;\r\n      user.resetPasswordExpires = null;\r\n      userRepo.save(user)\r\n```\r\n\r\nIt had the expected behavior. This could be different from most people's expectations (even if this is expected behavior from the project), and should be clearly documented",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1490/comments",
    "author": "crutchcorn",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-01-23T06:10:21Z",
        "body": "Its by design and allows partial updations. You can lets say do `userRepo.save({ id: 1, middleName: \"Lalala\" })` without being worried that other data will be removed. Also setting properties to `null` is actually making column values null in the database as well, so logically everything fit good.\r\n\r\nand btw you always can contribute in documentation, its quite easy to do and will help others to solve issues you faced."
      },
      {
        "user": "crutchcorn",
        "created_at": "2018-01-23T06:12:07Z",
        "body": "I understand and think it's a great design choice. \n\nI know I can contribute, and do plan to, but often find these bugs in the middle of a code session and just need to log them out. I'll try getting a PR in with doc additions here soon. "
      }
    ]
  },
  {
    "number": 1418,
    "title": "BUG or SUPPORT something wrong with joinable tables",
    "created_at": "2018-01-07T15:16:29Z",
    "closed_at": "2018-01-23T06:22:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1418",
    "body": "I have `TestEntity.ts`:\r\n```js\r\n@Entity('test_1288');\r\nexport class TestEntity {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column(type => JoinEntity)\r\n    jName: JoinEntity = new JoinEntity({spec: \"fffffffff\"});\r\n}\r\n```\r\nand joinable table `JoinEntity.ts`:\r\n```js\r\n@Entity(\"join_1288\")\r\nexport class JoinEntity {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    spec: string;\r\n}\r\n```\r\n\r\nand of course `test.ts`:\r\n```js\r\ndescribe(\"github issues > #1288 check calculated columns (sql in @Column)\", () => {\r\n\r\n    let connections: Connection[];\r\n    before(async () => {\r\n        return connections = await createTestingConnections({\r\n            entities: [__dirname + \"/entity/*{.js,.ts}\"]\r\n        });\r\n    });\r\n    beforeEach(() => {\r\n        return reloadTestingDatabases(connections);\r\n    });\r\n    after(() => {\r\n        return closeTestingConnections(connections);\r\n    });\r\n\r\n    it(\"should persist successfully and return entity\", () => Promise.all(connections.map(async connection => {\r\n        // create objects to save\r\n        const joinEntity1 = new JoinEntity();\r\n        joinEntity1.spec = \"Entity #1 spec (for TestEntity)\";\r\n\r\n        const testEntity1 = new TestEntity();\r\n        testEntity1.name = \"Entity #1\";\r\n        testEntity1.jName.spec = \"Entity #1 some spec\";\r\n\r\n        const testEntity2 = new TestEntity();\r\n        testEntity2.name = \"Entity #2\";\r\n\r\n        // persist\r\n        await connection.manager.save([\r\n            testEntity1,\r\n            testEntity2\r\n        ]);\r\n```\r\n\r\nbut what I see in a query?:\r\n```SQL\r\nINSERT INTO \"test_1288\"(\"name\", \"jNameSpec\") VALUES ($1,$2)  RETURNING \"id\", \"jNameId\"\r\n```\r\nany comments about this?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1418/comments",
    "author": "cybermerlin",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-01-08T13:20:56Z",
        "body": "Thank you for clear example. Looks correct. What issue do you have? What do you think is wrong?\r\n  \n\n---\n\nYou are using a concept called \"embedded entities\". When you embed entity it merges all properties from it into your original entity. In your case result will be `test_1288` table with 4 columns:\r\n\r\n* id\r\n* name\r\n* jNameId\r\n* jNameSpec\r\n\r\nWhere `id` and `jNameSpec` are both primary columns and they are resulted in a *composite primary key*. This is how embedded entities are working. Im not sure why are you using \"joinable\" table terminology here, but looks like you are confusing this with concept of real relations (many-to-many, one-to-many, etc.) \r\n\r\nAlso there are two issues with your code:\r\n\r\n* your second entity does not need a decorator. Remove `@Entity(\"join_1288\")` from JoinEntity.\r\n* you have multiple primary keys and both are auto-generated columns - this is not supported (and will not be because of database-level limitations)"
      },
      {
        "user": "cybermerlin",
        "created_at": "2018-01-13T10:42:01Z",
        "body": "I was thinking something like: \r\ntables: test_1288, join_1288\r\n and \r\ntest_1288.jName are FK to join_1288.id \r\n      and if I have to get spec value then all I need is just call testEntity1.jName.spec (like in ibatis on advanced types)\n\n---\n\nthank for waiting for my reaction (I was very busy)."
      },
      {
        "user": "pleerock",
        "created_at": "2018-01-15T09:22:47Z",
        "body": "you need to use relations, not `@Column(() => Entity)` syntax for your purpose."
      },
      {
        "user": "cybermerlin",
        "created_at": "2018-01-21T20:00:43Z",
        "body": "thx.\r\nmaybe u show me some link to that helping page, it's will be helpful for me?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-01-23T06:22:47Z",
        "body": "open a documentation site and take a look on section panel, you'll see \"Relations\" there."
      }
    ]
  },
  {
    "number": 1345,
    "title": "Is it possible to define (A | B)[] relation?",
    "created_at": "2017-12-14T17:34:07Z",
    "closed_at": "2017-12-14T22:57:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1345",
    "body": "First of all, thank you all for this great package \u2013 it's a breeze \ud83d\ude47\ud83c\udffb\u200d\u2642\ufe0f\r\n\r\nQuestion I have is this.\r\n\r\n```ts\r\n@Entity()\r\nclass A {\r\n  @Column()\r\n  a: string\r\n}\r\n\r\n@Entity()\r\nclass B {\r\n  @Column()\r\n  b: number\r\n}\r\n```\r\n\r\n**how to make such `C`?**\r\n\r\n```ts\r\n@Entity()\r\nclass C {\r\n  @Column(/* ??? */)\r\n  entries: (A | B)[]\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1345/comments",
    "author": "dempfi",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-12-14T19:52:48Z",
        "body": "no, its not possible. If you want to bind C with A and B you need to create two relations in C with A and with B"
      },
      {
        "user": "dempfi",
        "created_at": "2017-12-14T22:54:33Z",
        "body": "I somehow missed simple fact \u2013 I can do whatever I want with the `C` class (like define entries aggregated getter). Thank you @pleerock."
      }
    ]
  },
  {
    "number": 1342,
    "title": "Left-joining single table multiple time with different conditions",
    "created_at": "2017-12-14T04:29:00Z",
    "closed_at": "2017-12-14T09:25:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1342",
    "body": "When trying to join a single table multiple times with different conditions, parameter values don't seem to be updated:\r\n\r\n```js\r\n        this.createQueryBuilder('claim')\r\n            .select('claim.id')\r\n            .leftJoin(ClaimHistory, 'repairerDelivery',\r\n                '\"repairerDelivery\".\"claimId\" = claim.id AND \"repairerDelivery\".status = :status',\r\n                { status: 80 })\r\n            .leftJoin(ClaimHistory, 'buyerDelivery',\r\n                '\"buyerDelivery\".\"claimId\" = claim.id AND \"buyerDelivery\".status = :status',\r\n                { status: 100 })\r\n            .where('claim.\"repairerId\" = :id', { id: \"1\" })\r\n            .getRawMany();\r\n```\r\n\r\nGives this query\r\n\r\n```sql\r\nexecuting query:  SELECT \"claim\".\"id\" AS \"claim_id\" FROM \"claim\" \"claim\"\r\nLEFT JOIN \"claim_history\" \"repairerDelivery\" ON \"repairerDelivery\".\"claimId\" = \"claim\".\"id\" AND \"repairerDelivery\".status = $1 \r\nLEFT JOIN \"claim_history\" \"buyerDelivery\" ON \"buyerDelivery\".\"claimId\" = \"claim\".\"id\" AND \"buyerDelivery\".status = $2\r\nWHERE claim.\"repairerId\" = $3 -- PARAMETERS: [80,80,\"1\"] <---\r\n```\r\nIs this expected?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1342/comments",
    "author": "bytely",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-12-14T06:07:21Z",
        "body": "yes, parameter names must be unique across single query, you need to provide `status1` and `status2` variable names instead of single `status`"
      },
      {
        "user": "bytely",
        "created_at": "2017-12-14T09:25:26Z",
        "body": "I see, thank you."
      },
      {
        "user": "pookdeveloper",
        "created_at": "2019-06-21T11:07:30Z",
        "body": "Example:\r\n\r\n````javascript\r\n  var manager = getManager().getRepository(\"usuarios\").createQueryBuilder(\"usuarios\");\r\n        manager\r\n            .innerJoinAndSelect(\"usuarios.persona\", \"persona\")\r\n            .innerJoinAndSelect(\"usuarios.empleado\", \"empleado\")\r\n            .where(\"1 = 1\")\r\n            .andWhere(\"usuarios.id_categoria = :id_categoria\", { id_categoria: 1 })\r\n            .andWhere(\"persona.dni = :dni\", { dni: \"5399522a\" })\r\n            .andWhere(\"empleado.dni = :dni2\", { dni2: \"5399522d\" })\r\n\r\n        const datos = await manager.getMany();\r\n````"
      }
    ]
  },
  {
    "number": 1331,
    "title": "typeorm with pure SQL output",
    "created_at": "2017-12-11T19:23:07Z",
    "closed_at": "2017-12-22T13:43:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1331",
    "body": "I have been using knex for a while and I know it is totally different from typeorm, but I didnt found one feature that is present there. The `.toString()` method that returns an array of query strings filled out with the correct values based on bindings, etc.\r\n\r\nEx.: \r\n```javascript\r\nvar toStringQuery = knex.select('*').from('users').where('id', 1).toString();\r\n\r\n// Outputs: console.log(toStringQuery); \r\n// select * from \"users\" where \"id\" = 1\r\n\r\n```\r\n\r\nIs there some similar feature on typeorm?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1331/comments",
    "author": "calebeaires",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-12-12T07:03:45Z",
        "body": "Yes you can use `getSql` method or `printSql` to instantly print sql query to console:\r\n\r\n```ts\r\nconst sql = connection.createQueryBuilder()\r\n    .select(\"user\")\r\n    .from(User, \"user\")\r\n    .where(\"user.id = :id\", { id: 1 })\r\n    .getSql();\r\n```\r\n\r\nor\r\n\r\n```ts\r\nconst users = await connection.createQueryBuilder()\r\n    .select(\"user\")\r\n    .from(User, \"user\")\r\n    .where(\"user.id = :id\", { id: 1 })\r\n    .printSql()\r\n    .getMany();\r\n```"
      },
      {
        "user": "calebeaires",
        "created_at": "2017-12-22T13:43:36Z",
        "body": "Awesome"
      },
      {
        "user": "guotie",
        "created_at": "2018-05-16T08:30:56Z",
        "body": "why printSql() did not print sql to console\r\n\r\nversion: 0.2.5\r\n"
      },
      {
        "user": "DcsPeterDickten",
        "created_at": "2018-09-15T08:21:16Z",
        "body": "> why printSql() did not print sql to console\r\n> \r\n> version: 0.2.5\r\n\r\nMake sure you have logging enabled (in the database connection or the ormconfig.json file):\r\n\"logging\": true,\r\n"
      },
      {
        "user": "muamichali",
        "created_at": "2018-09-18T17:40:24Z",
        "body": "When I turn on logging in the database connection, I get ALL of the queries not just the ones with printSql (upgrading to 0.2.7 -- this used to work as I expect it to in older typeorm versions)"
      },
      {
        "user": "sanderboom",
        "created_at": "2018-11-05T12:44:31Z",
        "body": "Is there a handy way to print raw SQL with integrated parameters when I'm using not using the QueryBuilder but e.g. `this.connection.query(sql, parameters)`?\r\n\r\nI know when using mysql/mariadb the extra `debug: ['ComQueryPacket']` option will give me the query and a lot more, but something like `getSql()` would be extremely handy :)"
      },
      {
        "user": "darkyelox",
        "created_at": "2018-11-18T15:23:01Z",
        "body": "printSql must print SQL without the logging: true parameter, it doesn't"
      },
      {
        "user": "havenchyk",
        "created_at": "2018-11-18T18:07:43Z",
        "body": "@darkyelox could you please create a new issue for this?"
      },
      {
        "user": "werts",
        "created_at": "2019-05-10T06:28:13Z",
        "body": "> > why printSql() did not print sql to console\r\n> > version: 0.2.5\r\n> \r\n> Make sure you have logging enabled (in the database connection or the ormconfig.json file):\r\n> \"logging\": true,\r\n\r\nAha, you save my life"
      },
      {
        "user": "kuklei",
        "created_at": "2019-10-26T15:04:07Z",
        "body": "And now it prints it twice. Once by the logger in the ormconfig and once by the directive"
      },
      {
        "user": "awHamer",
        "created_at": "2020-09-11T16:39:27Z",
        "body": "> > why printSql() did not print sql to console\r\n> > version: 0.2.5\r\n> \r\n> Make sure you have logging enabled (in the database connection or the ormconfig.json file):\r\n> \"logging\": true,\r\n\r\nIn this case it will turn on logging for any query (including the one we want to print - it will print it twice) \r\n+ it prints with an array of parameters instead of print a RAW sql in the way it will go to db...\r\n\r\nI want to log exactly what goes to db w/o having manually put data replacing each `?` mark.\r\nAny progress ? It's very important thing :( Enabling all query log creates a lot of mess and it's hard to get a correct one + it also doesn't print RAW sql."
      },
      {
        "user": "royalcala",
        "created_at": "2020-09-14T15:38:05Z",
        "body": "printSql and getSql it's only avaible for print queries?, I didn't see in jsDoc how to print from table definitions. \r\nlike \r\nknex.schema.createTable('users', function (table) {\r\n  table.increments();\r\n  table.string('name');\r\n  table.timestamps();\r\n}).toQuery()\r\nprints:\r\ncreate table `users` (`id` integer not null primary key autoincrement, `name` varchar(255), `created_at` datetime, `updated_at` datetime)\r\n\r\nthanks,\r\nregards. \r\n"
      },
      {
        "user": "mimoid-prog",
        "created_at": "2021-03-13T20:12:00Z",
        "body": "`printSql` still doesn't work in 2021. The only way I can see the sql queries right now is by setting `logging: true`, which is not good because it prints every possible query."
      }
    ]
  },
  {
    "number": 1322,
    "title": "queryBuilder parameters: duplicated parameters name",
    "created_at": "2017-12-09T05:52:28Z",
    "closed_at": "2017-12-16T10:38:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1322",
    "body": "        const tokens = s.split(' ');\r\n        for (const token of tokens) {\r\n          queryBuilder.andWhere(new Brackets(tokenQb => {\r\n            tokenQb.where('person.name ILIKE :token');\r\n            tokenQb.orWhere('person.lastName ILIKE :token');\r\n          })).setParameters({token: token});\r\n        }\r\n\r\nWhen s = \"foo bar\", I should get the query ... WHERE (person.firstName ILIKE 'foo' OR person.lastName ILIKE 'foo') AND (person.firstName ILIKE 'bar' OR person.lastName ILIKE 'bar').\r\n\r\nHowever, I got ... WHERE (person.firstName ILIKE 'bar' OR person.lastName ILIKE 'bar') AND (person.firstName ILIKE 'bar' OR person.lastName ILIKE 'bar') instead.\r\n\r\nHow can I achieve this?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1322/comments",
    "author": "dvh312",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-12-12T12:03:22Z",
        "body": "Parameters must be unique. The way you can change your code:\r\n\r\n```ts\r\ns.split(' ').forEach((token, index) => {\r\n      const parameterName = \"token\" + index;\r\n      queryBuilder.andWhere(new Brackets(tokenQb => {\r\n        tokenQb.where('person.name ILIKE :' + parameterName);\r\n        tokenQb.orWhere('person.lastName ILIKE :' + parameterName);\r\n      })).setParameter(parameterName, token);\r\n    });\r\n```"
      },
      {
        "user": "dvh312",
        "created_at": "2017-12-16T07:59:16Z",
        "body": "Thanks!"
      },
      {
        "user": "pimplibence",
        "created_at": "2018-11-10T14:00:31Z",
        "body": "> Parameters must be unique. The way you can change your code:\r\n> \r\n> ```ts\r\n> s.split(' ').forEach((token, index) => {\r\n>       const parameterName = \"token\" + index;\r\n>       queryBuilder.andWhere(new Brackets(tokenQb => {\r\n>         tokenQb.where('person.name ILIKE :' + parameterName);\r\n>         tokenQb.orWhere('person.lastName ILIKE :' + parameterName);\r\n>       })).setParameter(parameterName, token);\r\n>     });\r\n> ```\r\n\r\n@pleerock why should be the parameters unique? Programatically the parameter naming belongs to the it own 'where' function scope. If you would like to use a huge parameter bag you have to use query level naming despite of function scope level. "
      },
      {
        "user": "lovinu99",
        "created_at": "2021-09-13T15:14:17Z",
        "body": "for someone looking the way to combine conditions into your queryBuilder, u r right to come here \u270c\ufe0f this answer saved my life \ud83d\udcaf  "
      }
    ]
  },
  {
    "number": 1225,
    "title": "Property mapping in querybuilder",
    "created_at": "2017-11-23T18:17:23Z",
    "closed_at": "2017-11-24T12:01:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1225",
    "body": "Does the querybuilder map the entity properties to their database column names when filtering?\r\n\r\n```javascript\r\n@Entity(\"users\")\r\nexport class User {\r\n    @PrimaryGeneratedColumn()\r\n    id:number;\r\n\r\n    @Column(\"varchar\",{\r\n        name: \"first_name\"\r\n    })\r\n    firstName: string;\r\n\r\n    @Column(\"varchar\",{\r\n        name: \"last_name\"\r\n    })\r\n    lastName: string;\r\n}\r\n```\r\n\r\nCan i use ***firstName***  here or do i have to do use the actual column name that is in the database?\r\n\r\n```javascript\r\nconst user = await getManager()\r\n    .createQueryBuilder(User, \"user\")\r\n    .where(\"user.firstName = :bind\", { bind: \"John\" })\r\n    .getOne();\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1225/comments",
    "author": "ibox4real",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-11-24T04:25:21Z",
        "body": "Correct, it maps. You must use property names, not database names."
      },
      {
        "user": "ibox4real",
        "created_at": "2017-11-24T12:01:15Z",
        "body": ":thumbsup:"
      }
    ]
  },
  {
    "number": 1213,
    "title": "How to show rows changed from createQueryBuilder",
    "created_at": "2017-11-22T08:19:52Z",
    "closed_at": "2017-11-22T08:51:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1213",
    "body": "Given a simple query like this:\r\n\r\n```typescript\r\ntypeorm.connection.manager\r\n       .createQueryBuilder()\r\n       .insert()\r\n       .into(User)\r\n       .values(req.body)\r\n       .execute()\r\n       .then((user: User) => console.info('user =', user, ';'))\r\n```\r\n\r\nIt succeeds, but the output is: `user = [] ;`. How do I show the created rows?\r\n\r\nOr do I need to add a select query in the `.then` callback?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1213/comments",
    "author": "SamuelMarks",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-11-22T08:50:50Z",
        "body": "correct, you need to select data, insert query just inserts your entity, nothing more."
      }
    ]
  },
  {
    "number": 1185,
    "title": "Can not use alias in find()",
    "created_at": "2017-11-15T13:11:32Z",
    "closed_at": "2017-11-16T11:23:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1185",
    "body": "Hi,\r\n\r\ntypeorm:0.0.11\r\n\r\nwhen i use \r\n```\r\n...find({alias: 'test'});\r\n```\r\n\r\nthen typeorm throws unhandled rejections: \r\n```\r\nUnhandled rejection Error: ER_BAD_FIELD_ERROR: Unknown column 'test.alias' in 'where clause'\r\n```\r\n\r\nis it fixed in newest version? i.e. typeorm@0.1.2?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1185/comments",
    "author": "szymonskirgajllo",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-11-16T06:07:28Z",
        "body": "Yes new version find syntax is simplified and does not have an `alias` parameter. Find now accepts set of typeorm-specific options or conditions, e.g. entity column - value set. See updated find options docs on site."
      },
      {
        "user": "szymonskirgajllo",
        "created_at": "2017-11-16T11:23:42Z",
        "body": "@pleerock thanks, so we need to update typeorm ;)"
      }
    ]
  },
  {
    "number": 1127,
    "title": "postresql primary column with type \"bigint\" maps property as string",
    "created_at": "2017-11-01T12:13:13Z",
    "closed_at": "2017-11-01T13:02:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1127",
    "body": "Hello, \r\nI noticed that primary column with type `bigint` maps property as `string` instead of `number`",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1127/comments",
    "author": "darioxtx",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-11-01T12:44:38Z",
        "body": "Its a correct behaviour because regular `number` has `integer` length and cannot contain a bigint number values."
      },
      {
        "user": "darioxtx",
        "created_at": "2017-11-01T13:02:56Z",
        "body": "Thank you, I forgot about that."
      }
    ]
  },
  {
    "number": 999,
    "title": "Update/remove all with auto-completion",
    "created_at": "2017-10-05T03:12:53Z",
    "closed_at": "2017-10-16T13:20:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/999",
    "body": "Is there a simple syntax to update or remove multiple entities via Active Record or Data-Mapper? I'm looking for something like (in sequelize):\r\n\r\n`await User.update({ name: 'a' }, { where: { name: 'b' } });`\r\n`// UPDATE users SET name = 'a' WHERE name = 'b';`\r\n\r\nand\r\n\r\n`await User.update({ name: 'a' });`\r\n`// UPDATE users SET name = 'a';`\r\n\r\nEntityManager throws `Cannot find entity to update by a given criteria` if there are no matches, and only updates one record:\r\n\r\n`await connection.manager.update(User, { name: 'a' }, { name: 'b' });`\r\n`await connection.manager.update(User, { where: { name: 'a'  } }, { name: 'b' });`\r\n\r\nQueryBuilder works, but is verbose and has no type checking on `.where()`:\r\n\r\n```\r\nawait User.createQueryBuilder('user')\r\n      .update({ name: 'b' })\r\n      .where('user.name = :name', { name: 'a' }) // hard to maintain, no type check\r\n      .execute();\r\n```\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/999/comments",
    "author": "soncodi",
    "comments": [
      {
        "user": "daniel-lang",
        "created_at": "2017-10-05T13:37:08Z",
        "body": "Repositories have an update function that has a very similar syntax. Only, that the parameters are switched (first the condition and than the part you want to change)\r\n\r\n```typescript\r\nawait repository.update({ firstName: \"Timber\" }, { firstName: \"Rizzrak\" });\r\n// executes UPDATE user SET firstName = Rizzrak WHERE firstName = Timber\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2017-10-05T17:21:11Z",
        "body": "@daniel-lang is right, in your case its  a method from `BaseEntity`:\r\n\r\n```ts\r\nawait User.update({ firstName: \"Timber\" }, { firstName: \"Rizzrak\" });\r\n```\r\n"
      },
      {
        "user": "soncodi",
        "created_at": "2017-10-05T17:50:55Z",
        "body": "@daniel-lang, @pleerock: I tried the following (`0.1.0-alpha.50`) with both AR and DM:\r\n\r\nAR\r\n`await User.update({ name: 'a' }, { name: 'b' });`\r\n`await User.update({ where: { name: 'a' } }, { name: 'b' });`\r\n\r\nDM\r\n`await UserRepo.update({ name: 'a' }, { name: 'b' });`\r\n`await UserRepo.update({ where: { name: 'a' } }, { name: 'b' });`\r\n\r\n\r\nLogger results:\r\n\r\n    executing query:  SELECT `User`.`id` AS `User_id`, `User`.`name` AS `User_name` FROM `users` `User` WHERE `User`.`name`=? -- PARAMETERS: [\"a\"]\r\n    executing query:  SELECT `subject`.`id` AS `subject_id`, `subject`.`name` AS `subject_name` FROM `users` `subject` WHERE `subject`.`id`=? -- PARAMETERS: [2]\r\n    executing query:  START TRANSACTION\r\n    executing query:  UPDATE `users` SET `name`=?  WHERE `id`=? -- PARAMETERS: [\"b\",2]\r\n    executing query:  COMMIT\r\n\r\nObserved this behavior:\r\n- issues a `SELECT` first\r\n- only updates the first user.\r\n- errors if no rows matched `Error: Cannot find entity to update by a given criteria`\r\n\r\nExpected this behavior:\r\n- no `SELECT` issued, just a direct query\r\n- updates all users\r\n- no failure if no rows match `WHERE` clause\r\n\r\n\r\n"
      },
      {
        "user": "daniel-lang",
        "created_at": "2017-10-05T18:46:39Z",
        "body": "You are right. Looking at the source code it executes `findOne()` and than updates the found entity if it exists, otherwise throws an error.\r\nSo even though it's the same syntax, the `update` function does something every different. Sorry, for suggesting it, I should have checked the source code.\r\n\r\nSo I guess the only way to do what you want is with the QueryBuilder.\r\n@pleerock is that true?"
      },
      {
        "user": "soncodi",
        "created_at": "2017-10-05T18:57:41Z",
        "body": "It seems the goal is to act as an entity cache layer in front of the db. That's valid design but, for my use-case, it would be great to be able to opt-out of that behavior, and just use TypeORM as a simple mapper with type-checking. It could essentially be a drop-in replacement for Sequelize. I assumed this was implied by disabling `cache` on the connection, but I have not yet looked through the code.\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2017-10-06T03:58:40Z",
        "body": "`update` method currently using `find` and `save methods. Instead it should just use update query builder functionality. Ive got sick, thats why release is delayed this week, I'll fix update methods next week and publish a new version with those changes."
      },
      {
        "user": "soncodi",
        "created_at": "2017-10-06T04:07:30Z",
        "body": "@pleerock perfect, thanks!"
      },
      {
        "user": "pleerock",
        "created_at": "2017-10-16T13:20:09Z",
        "body": "I have updated `update` methods. Now they should work fine. This change will be released in `0.1.1`"
      }
    ]
  },
  {
    "number": 917,
    "title": "[Question] findByIds with another field",
    "created_at": "2017-09-20T06:21:28Z",
    "closed_at": "2017-09-20T17:04:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/917",
    "body": "Hello everyone :)\r\n\r\nAfter some researches I do not find an answer to my question. Thus, I post here.\r\n\r\nIs it possible to use  SQL `IN` in where clause of a query or an equivalent of `findByIds` with another field than id ?\r\n\r\nFor instance, I have Users that have an email. I want to load users where their emails match an email in a list.\r\nIn SQL that will look something like that : \r\n`SELECT * FROM users WHERE email IN ('aa@aa.aa', 'bb@bb.bb');`\r\n\r\nThanks.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/917/comments",
    "author": "Porquepix",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-09-20T06:36:04Z",
        "body": "Hi, \r\n\r\nyes for your purpose you need to use `QueryBuilder`:\r\n\r\n```ts\r\nconst users = await manager.createQueryBuilder(User, \"user\")  // manager can be repository or connection objects too\r\n    .where(\"user.email IN (:emails)\", { emails: [...] })\r\n    .getMany();\r\n```"
      }
    ]
  },
  {
    "number": 899,
    "title": "Repository: differents between .save() and .persist() and would a .insert() be possible?",
    "created_at": "2017-09-18T06:19:49Z",
    "closed_at": "2017-09-18T06:29:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/899",
    "body": "The title more or less says it all, what is the difference right know (or the difference planed) between `.save()` and `.persist()` of a repository? Since looking at the source code, would suggest, that they do the same.\r\nAnd is there a way to just insert the entities without the check beforehand? Because when I try to insert 700 entities at once a select statement is executed for each one of them, which isn't neccesary in every use case. Mine for example is, inserting entities that have been loaded from an api where I can be certain, that they do not exist in the table.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/899/comments",
    "author": "daniel-lang",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-09-18T06:25:28Z",
        "body": "> .save() and .persist()\r\n\r\n`persist` is just old name of `save`. It just calls save method right now and there is zero difference, just naming. persist method is deprecated and will be removed in the future. Its there only because of old users who use persist when there was not save method.\r\n\r\n> And is there a way to just insert the entities without the check beforehand?\r\n\r\nYes, using insert functionality of `QueryBuilder`. Example:\r\n\r\n```ts\r\n        await connection.createQueryBuilder()\r\n            .insert()\r\n            .into(User)\r\n            .values([\r\n                { name: \"Umed Khudoiberdiev\" }, // or your entities\r\n                { name: \"Bakhrom Baubekov\" },\r\n                { name: \"Bakhodur Kandikov\" },\r\n            ])\r\n            .execute();\r\n```"
      },
      {
        "user": "daniel-lang",
        "created_at": "2017-09-18T06:29:20Z",
        "body": "Okay, thanks for clearing that up for me!"
      }
    ]
  },
  {
    "number": 877,
    "title": "How to set Current time stamp as default value",
    "created_at": "2017-09-13T12:12:40Z",
    "closed_at": "2017-09-13T14:04:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/877",
    "body": "How to set Current time stamp as default value",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/877/comments",
    "author": "imhari213",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-09-13T12:14:33Z",
        "body": "How do you do it in your database using sql? I guess its something like:\r\n\r\n```ts\r\n@Column({ type: \"timestamp\", default: () => \"CURRENT_TIMESTAMP\"))\r\ntime: string;\r\n```\r\n\r\n`() => ` syntax for `default` allows to use SQL expressions."
      },
      {
        "user": "imhari213",
        "created_at": "2017-09-13T13:08:41Z",
        "body": "THANK YOU :)"
      },
      {
        "user": "roeehershko",
        "created_at": "2018-05-29T21:38:52Z",
        "body": "For the copy paste lovers like me (typo):\r\n```\r\n    @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP'})\r\n```"
      },
      {
        "user": "armanfatahi",
        "created_at": "2019-07-25T06:22:50Z",
        "body": "There is something else you need to consider:\r\n\r\nCURRENT_TIMESTAMP should be used with `timestamp with time zone`:\r\n\r\n```\r\n  @Column('timestamp with time zone', { nullable: false, default: () => 'CURRENT_TIMESTAMP' })  \r\n  created: Date;\r\n```\r\n\r\nUnless the Postgres converts the value to the timezone _AGAIN_ which will cause some trouble later on.\r\n"
      },
      {
        "user": "billyjov",
        "created_at": "2020-02-17T01:16:37Z",
        "body": "> How do you do it in your database using sql? I guess its something like:\r\n> \r\n> ```ts\r\n> @Column({ type: \"timestamp\", default: () => \"CURRENT_TIMESTAMP\"))\r\n> time: string;\r\n> ```\r\n> \r\n> `() => ` syntax for `default` allows to use SQL expressions.\r\n\r\n@pleerock i get an error trying to use an SQL statement with the syntax: \r\n\r\n```\r\ndefault: () => 'DATE_ADD(NOW(), INTERVAL 2 HOUR)',\r\n\r\n```\r\n\r\nnot working as expected and typeorm throw an error: \r\n\r\n```\r\n errno: 1064,\r\n  sqlMessage:\r\n   'You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near \\'DATE_ADD(NOW(), INTERVAL 2 HOUR)\\' at line 1',\r\n  sqlState: '42000',\r\n  index: 0,\r\n  sql:\r\n   'ALTER TABLE `dueDate` CHANGE `dueDate` `dueDate` timestamp NOT NULL DEFAULT DATE_ADD(NOW(), INTERVAL 2 HOUR)' }\r\n```\r\nPS. i use mysql with the latest typorm version."
      },
      {
        "user": "jdnichollsc",
        "created_at": "2020-07-18T17:16:15Z",
        "body": "Other option could be this:\r\n```\r\n@CreateDateColumn({ type: 'timestamp without time zone', default: 'NOW()' })\r\ncreatedAt: Date\r\n\r\n@UpdateDateColumn({ type: 'timestamp without time zone', onUpdate: 'NOW()', nullable: true })\r\nupdatedAt: Date\r\n```\r\nWhat do you think?"
      },
      {
        "user": "baublet",
        "created_at": "2021-02-02T22:26:12Z",
        "body": "FYI, for those looking as of Tuesday, February 2, 2021, for some reason TypeORM converts `default: () => \"CURRENT_TIMESTAMP\"` to `now()` when using postgres 9.6. This meant that TypeORM generates new migrations changing their default type from `now()` to `CURRENT_TIMESTAMP` every time you try to generate new migrations.\r\n\r\nThe fix for us was to use this instead:\r\n\r\n```ts\r\n@Column({ type: \"timestamp\", default: () => \"now()\"))\r\ntime: string;\r\n```"
      },
      {
        "user": "xiongsongsong",
        "created_at": "2021-04-25T08:48:08Z",
        "body": "In MySQL 8:\r\n```\r\n@Column('date', { default: () => '(CURRENT_DATE)' })\r\nlast_date: Date;\r\n```"
      },
      {
        "user": "ghost",
        "created_at": "2021-06-01T12:18:31Z",
        "body": "Can we use a Javascript function in the default instead of a SQL expression? For scenarios like calculating the year based on some current date conditions. I am using MySQL"
      },
      {
        "user": "seltsamonkel",
        "created_at": "2021-07-30T02:09:37Z",
        "body": "For postgres I first created a migration with\r\n```\r\n@Column('date', { default: () => 'CURRENT_DATE::text::date' })\r\nlast_date: Date;\r\n```\r\nThis created the column in postgres as `default ((CURRENT_DATE))`, then I changed the code to\r\n```\r\n@Column('date', { default: () => '((CURRENT_DATE))' })\r\nlast_date: Date;\r\n```\r\nWith this change, the TypeORM generated default and the default on postgres are both `((CURRENT_DATE))`, so no migrations are created afterward."
      },
      {
        "user": "NateFerrero",
        "created_at": "2021-11-24T04:44:45Z",
        "body": "When creating a table using `queryRunner` on Postgres, I didn't need to use `() => ` to get an expression default:\r\n\r\n```TypeScript\r\nawait queryRunner.createTable(\r\n  new Table({\r\n  name: 'my-table',\r\n  columns: [\r\n    {\r\n      name: \"status\",\r\n      default: \"'created'\", // constant default\r\n      type: \"text\"\r\n    },\r\n    {\r\n      name: \"created_at\",\r\n      type: \"timestamp(0) without time zone\",\r\n      default: 'now()' // expression default\r\n    }\r\n  ]\r\n  }),\r\n  true, true, true\r\n)\r\n```"
      },
      {
        "user": "PRossetti",
        "created_at": "2022-07-21T21:56:09Z",
        "body": "You can do \r\n```\r\n@Column({ type: \"timestamp\", default: () => \"now()\" })\r\ntime: Date;\r\n```\r\n\r\nHave in mind this is not the same as doing:\r\n```\r\n@Column({ type: \"timestamp\", default: \"now()\" })\r\ntime: Date;\r\n```\r\n\r\nThis last option in my case at least throw error in CI because it wasn't doing what it looks, so try going with the first alternative I mentioned."
      },
      {
        "user": "abu18saud",
        "created_at": "2023-11-15T20:25:39Z",
        "body": "using () => 'CURRENT_TIMESTAMP' with add 2 years by nestjs?"
      }
    ]
  },
  {
    "number": 825,
    "title": "Question - Joining tables.",
    "created_at": "2017-09-05T05:40:39Z",
    "closed_at": "2017-09-12T06:10:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/825",
    "body": "I'm trying to introduce some privilege control to my project. \r\n\r\nFirst, I have a File entity here. Each file has a owner group, and only members of its owner group can see the file.\r\n\r\n``` typescript\r\n@Entity()\r\nexport class File {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n\r\n    @Column('varchar')\r\n    public content: string;\r\n\r\n    @Column('int')\r\n    public groupId: number,\r\n\r\n}\r\n```\r\n\r\nAnd I have a group_map entity to store the relations between users and groups.\r\n\r\n``` typescript\r\n@Entity()\r\nexport class GroupMap {\r\n\r\n  @PrimaryColumn('int')\r\n  public groupId: number;\r\n\r\n  @PrimaryColumn('int')\r\n  public userId: number;\r\n\r\n}\r\n```\r\n\r\nWhen a particular user tries to list all the files that he could access, I would like to check whether this user belongs to the owner group of the file.  So to achieve this goal I would like to join the second table ON **File.groupId = groupMap.groupId AND groupMap.userId = :currentUserId (passed in as a parameter)**. \r\n\r\nI'm not sure whether this is possible using relations (or something else?) provided by TypeORM.\r\n\r\nAppreciate any help.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/825/comments",
    "author": "codgician",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-09-05T20:22:48Z",
        "body": "so, why dont you use relations?:\r\n\r\n```ts\r\n@Entity()\r\nexport class File {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n\r\n    @Column('varchar')\r\n    public content: string;\r\n\r\n    @ManyToOne(type => Group) // you told one file has one group, right?\r\n    public group: Group;\r\n\r\n}\r\n```\r\n\r\n```ts\r\n@Entity()\r\nexport class Group {\r\n\r\n  @PrimaryColumn('int')\r\n  public id: number;\r\n\r\n  @ManyToMany(type => User) // you told each user can have their own groups, right?\r\n  @JoinTable() // or this can be on User side if you want a bi-directional relation \r\n  public users: User[];\r\n\r\n}\r\n```\r\n\r\nNow if you need to files with groups owned by a current user:\r\n\r\n```ts\r\nconst files = await fileRepository.createQueryBuilder(\"file\")\r\n    .innerJoin(\"file.group\", \"fileGroup\")\r\n    .innerJoin(\"fileGroup.users\", \"fileGroupUser\", \"fileGroupUser.id = :currentUserId\")\r\n    .setParameter(\"currentUserId\", currentUserId)\r\n    .getMany();\r\n```"
      },
      {
        "user": "codgician",
        "created_at": "2017-09-06T07:25:10Z",
        "body": "Thanks for your solution!\r\nAnd does that mean when I'm adding a user to a group I'll have to fetch the user instance and then group.users = [UserInstance]?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-06T07:42:15Z",
        "body": "right"
      },
      {
        "user": "codgician",
        "created_at": "2017-09-06T13:47:43Z",
        "body": "Emm, one more question (sorry), is it possible if I want to add another column \"privilege\" into the mapping table? Like a member of a group can either be a common user or a group administrator? Thanks. \ud83c\udf39 "
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-06T14:00:12Z",
        "body": "in many-to-many table? If yes, then no, its not possible. You can too create entity and add there 3 columns with proper relations."
      },
      {
        "user": "codgician",
        "created_at": "2017-09-06T14:14:33Z",
        "body": "You mean I can create a standalone entity \"GroupMap\" and put two ManyToOne relationships inside, like:\r\n``` typescript\r\n\r\n@Entity()\r\nexport class GroupMap {\r\n\r\n  @ManyToOne(type => Group)\r\n  @JoinColumn()\r\n  public group: Group;\r\n\r\n  @ManyToOne(type => User)\r\n  @JoinColumn()\r\n  public user: User;\r\n\r\n  @Column('int')\r\n  public privilege: number;\r\n\r\n}\r\n```\r\n\r\nIs that appropriate? Thanks for your patience.\r\n\r\nP.S. If the method above won't work, does that mean I can't use relations to achieve this? Then how can I join the mapping table in a query?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-06T14:17:48Z",
        "body": "Yes,  right"
      },
      {
        "user": "codgician",
        "created_at": "2017-09-06T14:45:39Z",
        "body": "So is it possible to create index on user and group as well if they have ManyToOne and JoinColumn decorators (perhaps a stupid question)?  "
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-06T15:03:03Z",
        "body": "You can use `@Index` decorator if you want to create index."
      },
      {
        "user": "codgician",
        "created_at": "2017-09-12T06:10:22Z",
        "body": "Solved. Thanks for your help."
      },
      {
        "user": "ruslanchek",
        "created_at": "2018-07-05T20:42:30Z",
        "body": "Ok then DTO has to include User Object. How to create records in this case?"
      }
    ]
  },
  {
    "number": 788,
    "title": " Docs: Use case for migrations?",
    "created_at": "2017-08-21T19:08:00Z",
    "closed_at": "2017-08-22T15:33:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/788",
    "body": "Since entities (ie. `@Entities` in code) are the source of truth, and can be synced to the DB schema with `typeorm schema:sync`, what is the use case for manually running migrations?\r\n\r\nAre migrations and `schema:sync` meant to be used together for different use cases? Or is it one or the other, depending on your risk tolerance? Or am I totally missing the point here?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/788/comments",
    "author": "bcherny",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-08-21T20:58:51Z",
        "body": "on production you may want more control. Schema sync can simply drop your exist data, in migrations you can write code which prevents it. For example first you copy exist data into new table then delete column with all data."
      },
      {
        "user": "bcherny",
        "created_at": "2017-08-21T23:10:50Z",
        "body": "Thanks for the quick response @pleerock.\r\n\r\nWould you avoid using schema sync in production, and stick to just migrations? It would be nice if there there was a \"safe\" mode for schema sync, which threw on destructive changes and suggested the user create a migration instead."
      },
      {
        "user": "pleerock",
        "created_at": "2017-08-22T10:58:11Z",
        "body": "you can run `typeorm schema:log` to see what sql queries `schema:sync` will execute. On production you can use it before running schema:sync. You run it and check and analyze what sql queries orm will execute. If you are okay with all queries and sure it wont hard your database you run schema:sync. If you aren't okay with changes you can create a migration and write sql code manually to make schema updation as your production needs"
      }
    ]
  },
  {
    "number": 700,
    "title": "Creating a relation with a join table",
    "created_at": "2017-07-24T19:36:32Z",
    "closed_at": "2017-07-24T21:32:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/700",
    "body": "Hey, This is a great project. Really well done.\r\n\r\nI have a  a many to many relationship between two entities (ex: `Vendor` and `Material`) which creates a join table. I have a separate entity `Quote` that I would like to relate to the join table of the previous relationship. How would I go about achieving that?\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/700/comments",
    "author": "BrainMaestro",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-07-24T20:35:44Z",
        "body": "instead of using `@ManyToMany` relation you create a new entity called like `VendorMaterialQuote` with proper many-to-one/one-to-many relations inside to `Vendor`, `Material` and `Quote`. Its not possible to add something to the table generated by `@ManyToMany` decorator - because it is used only to generate basic relationship. If you need something more you just create your own entity with proper relations."
      },
      {
        "user": "BrainMaestro",
        "created_at": "2017-07-24T21:32:47Z",
        "body": "Alright, I guess that works. Thanks!"
      }
    ]
  },
  {
    "number": 698,
    "title": "Raw query with json columns (Postgres)",
    "created_at": "2017-07-23T22:45:26Z",
    "closed_at": "2017-07-26T10:01:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/698",
    "body": "Folks, I am trying to build a query like this\r\n\r\n  ```\r\n  let query = `SELECT \"incident\".* FROM \"incident\" \"incident\"  \r\n     WHERE incidents::jsonb @> '[{\"name\":$1}]' ORDER BY \"incident\".\"id\" ASC`;\r\n\r\n    const results: any = await repository.query(query, ['Briga']);\r\n```\r\nI want to add the value of the json as a parameter, but I am getting an error\r\n\r\n`error during executing query:error: invalid input syntax for type json\r\n`\r\n\r\nThe final query I want is this one:\r\n```\r\nSELECT \"incident\".* \r\nFROM \"incident\" \"incident\" WHERE incidents::jsonb @> '[{\"name\":\"briga\"}]' \r\nORDER BY \"incident\".\"id\" ASC\r\n```\r\n\r\nI searched in the documentation how to parametrize queries with json fields but could not find anything. Could you help me?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/698/comments",
    "author": "brunosiqueira",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-07-25T07:51:34Z",
        "body": "`repository.query` calls underlying `pg` package's query method and uses its parameters syntax. Refer to `pg` package how to resolve your problem. But in my opinion you should do: \r\n`incidents::jsonb @> $1` and set to parameter the whole json."
      },
      {
        "user": "brunosiqueira",
        "created_at": "2017-07-25T16:26:29Z",
        "body": "Perfect, @pleerock! It worked!"
      },
      {
        "user": "ghost",
        "created_at": "2020-11-17T20:49:36Z",
        "body": "@pleerock @brunosiqueira This saved me! It was hard to find an example similar to this one. Thank you."
      }
    ]
  },
  {
    "number": 676,
    "title": "Junction tables not generated for ManyToMany relation.",
    "created_at": "2017-07-16T22:21:01Z",
    "closed_at": "2017-07-18T20:39:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/676",
    "body": "Hi there,\r\n\r\nI have a rather simple many to many relationship in my project, some properties have been removed for brevity:\r\n\r\n```\r\n@Entity()\r\nexport class Item {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n    \r\n    @JoinColumn()\r\n    @ManyToMany(type => Location, location => location.items)\r\n    public locations: Location[];\r\n}\r\n```\r\nand\r\n```\r\n@Entity()\r\nexport class Location {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n\r\n    @Column({ length: 128 })\r\n    public name: string;\r\n    \r\n    @JoinColumn()\r\n    @ManyToMany(type => Item, item => item.locations, { \r\n        cascadeInsert: true,\r\n        cascadeUpdate: true\r\n    })\r\n    public items: Item[];\r\n}\r\n```\r\nUnfortunately no junction table is being generated, it seems the properties in question are simply being ignored as the SQL debug output shows.\r\n\r\n```\r\nexecuting query: START TRANSACTION\r\nexecuting query: CREATE TABLE `location` (`id` int(11) NOT NULL PRIMARY KEY AUTO_INCREMENT, `name` varchar(128) NOT NULL, `updated_at` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), `created_at` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6)) ENGINE=InnoDB\r\nexecuting query: CREATE TABLE `item` (`id` int(11) NOT NULL PRIMARY KEY AUTO_INCREMENT, `name` varchar(128) NOT NULL, `description` varchar(512) NOT NULL, `price` int(11) NOT NULL, `updated_at` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), `created_at` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6)) ENGINE=InnoDB\r\nexecuting query: CREATE TABLE `tag` (`id` int(11) NOT NULL PRIMARY KEY AUTO_INCREMENT, `name` varchar(255) NOT NULL, `updated_at` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), `created_at` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6)) ENGINE=InnoDB\r\nexecuting query: COMMIT\r\n```\r\n\r\nPlatform: Windows 10\r\nDatabase: MariaDB\r\nVersion: typeorm@0.1.0-alpha.31\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/676/comments",
    "author": "crystalbyte",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-07-17T08:38:10Z",
        "body": "for many-to-many you should use `@JoinTable` instead of `@JoinColumn` - and only on one side (owner side), e.g.:\r\n\r\n```ts\r\n@Entity()\r\nexport class Location {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n\r\n    @Column({ length: 128 })\r\n    public name: string;\r\n    \r\n    @ManyToMany(type => Item, item => item.locations, { \r\n        cascadeInsert: true,\r\n        cascadeUpdate: true\r\n    })\r\n    @JoinTable()\r\n    public items: Item[];\r\n}\r\n```"
      },
      {
        "user": "crystalbyte",
        "created_at": "2017-07-18T20:39:59Z",
        "body": "Thanks for pointing me to the right direction, the junction table is now being generated."
      },
      {
        "user": "raghav196",
        "created_at": "2019-06-14T09:37:16Z",
        "body": "@pleerock \r\n\r\nI'm also facing this issue of junction table not getting generated for ManyToMay relation. And I'm using `@JoinTable()` decorator.\r\n```typescript\r\nimport { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn, ManyToMany, JoinTable } from 'typeorm';\r\nimport { Role } from '../role/role.entity';\r\n\r\n@Entity('users')\r\nexport class User {\r\n  @PrimaryGeneratedColumn()\r\n  id: number;\r\n\r\n  @Column({ type: 'uuid' })\r\n  remoteId: string;\r\n\r\n  @Column({ type: 'varchar', length: 255, nullable: false })\r\n  name: string;\r\n\r\n  @Column({ type: 'varchar', length: 3, nullable: false })\r\n  countryCode: string;\r\n\r\n  @Column({ type: 'varchar', length: 15, nullable: false })\r\n  phone: string;\r\n\r\n  @Column({ type: 'varchar', length: 255, nullable: false })\r\n  email: string;\r\n\r\n  @CreateDateColumn({ type: 'timestamptz' })\r\n  createdAt: Date;\r\n\r\n  @UpdateDateColumn({ type: 'timestamptz' })\r\n  updatedAt: Date;\r\n\r\n  @ManyToMany(type => Role, role => role.users, {\r\n    eager: true,\r\n    nullable: false\r\n  })\r\n  @JoinTable()\r\n  roles: Role[]\r\n}\r\n```\r\n\r\nand \r\n\r\n```typescript\r\nimport { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn, ManyToMany, JoinTable } from 'typeorm';\r\nimport { User } from '../user/user.entity';\r\n\r\n@Entity('roles')\r\nexport class Role {\r\n  @PrimaryGeneratedColumn({ type: 'integer' })\r\n  id: number;\r\n\r\n  @Column({ type: 'integer' })\r\n  remoteId: number;\r\n\r\n  @Column({ type: 'varchar' })\r\n  role: string;\r\n\r\n  @CreateDateColumn({ type: 'timestamptz' })\r\n  createdAt: Date;\r\n\r\n  @UpdateDateColumn({ type: 'timestamptz' })\r\n  updatedAt: Date;\r\n\r\n  @ManyToMany(type => User, user => user.roles)\r\n  users: User[]\r\n\r\n}\r\n```\r\nI'm using **postgres**.\r\n\r\nI'm unable to figure out what can be the issue."
      }
    ]
  },
  {
    "number": 662,
    "title": "Updating an entity without selecting beforehand.",
    "created_at": "2017-07-13T20:56:07Z",
    "closed_at": "2017-07-14T07:20:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/662",
    "body": "Hi there,\r\n\r\nis there a way to update an entity without fetching it beforehand?\r\n\r\nRegards",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/662/comments",
    "author": "crystalbyte",
    "comments": [
      {
        "user": "yonilerner",
        "created_at": "2017-07-14T00:51:43Z",
        "body": "Just instantiate an instance of the model class and make sure it has a primary key, and then persist it.\r\n\r\nExample:\r\n```javascript\r\n@Entity()\r\nclass Person {\r\n  @PrimaryGeneratedColumn()\r\n  id: number\r\n\r\n  @Column()\r\n  name: string\r\n}\r\n\r\nconst person = new Person()\r\nperson.id = 1\r\nperson.name = 'Yoni'\r\nawait entityManager.getRepository(Person).persist(person) // value is essentially upserted\r\n"
      },
      {
        "user": "crystalbyte",
        "created_at": "2017-07-14T07:20:19Z",
        "body": "Beautiful, thank you :)"
      },
      {
        "user": "pleerock",
        "created_at": "2017-07-14T08:21:22Z",
        "body": "note you shall use `save` instead of `persist` method because `persist` is deprecated in latest versions."
      },
      {
        "user": "crystalbyte",
        "created_at": "2017-07-16T20:25:51Z",
        "body": "Thanks for the update."
      },
      {
        "user": "aseerkt",
        "created_at": "2021-12-13T02:42:10Z",
        "body": "I want to increment the value of column `comment_count` without fetching it beforehand. Is it possible? @pleerock \r\n```ts\r\nawait Post.update({ id: postId }, { commentCount:  { /* How to deal with this section */ } } );\r\n```"
      }
    ]
  },
  {
    "number": 642,
    "title": "Data type \"boolean\" is not supported in \"mysql\" database.",
    "created_at": "2017-07-10T09:59:36Z",
    "closed_at": "2017-07-12T06:17:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/642",
    "body": "typeorm `0.1.0-alpha.28` is giving now error `Data type \"boolean\" is not supported in \"mysql\" database.` if using boolean datatype. Running with sqlite this works fine. \r\n\r\nThis used to work with 0.0.11. I suppose I could fallback to tinyint as solution for now.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/642/comments",
    "author": "jounii",
    "comments": [
      {
        "user": "hugoserrana",
        "created_at": "2017-07-10T10:47:59Z",
        "body": "@jounii The MySql does not have internal BOOLEAN data type. Types like BOOLEAN and BOOL are TINYINT(1) internally. \r\n\r\nIn Changelog the TypeOrm team wrote this:\r\n> some column types were removed. Now orm uses directly column types of underlying database\r\n\r\nI think they made the right decision because the types are mapped explicitly. I imagine this will reduce errors in maintaining this awesome library."
      },
      {
        "user": "pleerock",
        "created_at": "2017-07-10T13:56:26Z",
        "body": "@jounii if you define column type explicitly then you must use `tinyint` because explicitly defined types are now only database-supported types as @hugoserrana said. \r\n\r\nBut if you variable is `boolean` you can simply omit type definition and it will be converted to tinyint automatically, e.g. for `@Column() enabled: boolean` you don't need to specify type - its automatically mapped to tinyint."
      },
      {
        "user": "jounii",
        "created_at": "2017-07-12T05:57:35Z",
        "body": "Mysql does have alias for BOOLEAN and BOOL to mapped to TINYINT. If you logic is right, shouldn't the sqlite implementation driver also rule tinyint and others out too? Sqlite uses internally only \"integer\" type and aliases rest.\r\n\r\nHave to try if the boolean entity member is properly mapped if I don't specify the types manually. \n\n---\n\nWorks ok without defining the type. Problem solved for now, thanks. \r\n\r\nRelated to this is if the tinyint (and others specific data size types) go out of fashion, the Column options would need some sort of data length/type hinting options so the driver could choose best suiting internal type.\r\n\r\nMaybe possibility to define data type converter class/function so you could customise these yourself. I suppose I could override the DriverFactory to provide own wrapper driver, but it'll be exercise for later. "
      },
      {
        "user": "feather-jmalone",
        "created_at": "2017-08-25T00:02:48Z",
        "body": "maybe i'm missing something, but in `0.1.0-alpha.34` and `0.1.0-alpha.35`, i'm unable to work around the issue as recommended. i tried the following in my entity definition:\r\n\r\n`@Column({\r\n        nullable: false,\r\n        default: false\r\n    })\r\n    someFlag: boolean;`\r\n\r\nand also \r\n\r\n`@Column()\r\n    someFlag: boolean;`\r\n\r\nboth result in the following exception: `TypeORM connection error:  { DataTypeNotSupportedError: Data type \"\" is not supported in \"mysql\" database.`\r\n\r\ndid something change?\r\n\r\ni can't get the column working unless i specify `'tinyint'` as the first parameter for `@Column`. consequently, values come back as `1` or `0` instead of `true` or `false`. "
      },
      {
        "user": "pleerock",
        "created_at": "2017-08-25T16:11:21Z",
        "body": "Looks like it cannot figure out parameter type. Parameter type is automatically determined only if you setup reflect-metadata properly and setup tsconfig properly. Read more about them on a homepage"
      },
      {
        "user": "feather-jmalone",
        "created_at": "2017-08-25T21:06:42Z",
        "body": "ah, you're right. i did not have `reflect-metadata`. however, when i added `import \"reflect-metadata\"` to my main `app.ts` file as the docs suggested, i still got the error. adding the same line to the entity `.ts` file is what ultimately fixed the issue.\r\n\r\nthanks for the help!"
      },
      {
        "user": "pleerock",
        "created_at": "2017-08-26T06:09:33Z",
        "body": "reflect-metadata should be loaded before any your entity is loaded. Probably you have loaded entities before your imported reflect-metadata in your app.ts "
      },
      {
        "user": "feather-jmalone",
        "created_at": "2017-08-26T07:06:26Z",
        "body": "i don't think so, but i am still new to TypeScript and TypeORM. here's an abbreviated version of my `app.ts` (took out Express-related code in the `createConnection` callback), does anything seem strange to you?\r\n\r\n```\r\nimport {createConnection} from 'typeorm';\r\nimport \"reflect-metadata\";\r\n\r\n// Establish the database connection before doing anything else\r\ncreateConnection({\r\n    type: 'mysql',\r\n    host: process.env.DB_HOST,\r\n    port: process.env.DB_PORT,\r\n    username: process.env.DB_USER,\r\n    password: process.env.DB_PASS,\r\n    database: process.env.DB_NAME,\r\n    entities: [\r\n        __dirname + '/entity/*.js'\r\n    ],\r\n    autoSchemaSync: true\r\n}).then(connection => {\r\n\r\n    // Initialize Express and other things\r\n\r\n// Log database connection errors\r\n}).catch(error => \r\n{\r\n    console.log('TypeORM connection error: ', error)\r\n});\r\n```\r\nthanks again for your help. although my particular issue is solved, i wanna help with future documentation if this is in fact a scenario that's unaccounted for."
      },
      {
        "user": "pleerock",
        "created_at": "2017-08-26T17:46:26Z",
        "body": "its not an unaccounted scenario, Im sure its something on your side. You can create a demo git repo with problem reproduction and I'll take why its happening on you"
      }
    ]
  },
  {
    "number": 635,
    "title": "Specifying relations to support legacy database",
    "created_at": "2017-07-09T17:40:09Z",
    "closed_at": "2017-07-10T17:23:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/635",
    "body": "Hi,\r\n\r\nI'm rewriting data-related part of an older application which was created for non-SPA environment with dynamic pages (MVC app with some AJAX parts) approach. I chose to rewrite API with TS & Node.js because of decorators and all the things that make code easily readable. However, I wanted to reconstruct database with entities in typeorm, so in case that application is bootstrapped from zero (without existing DB), the database doesn't need any script to be run in order to initialize it. Database which I'm using is MySQL. To achieve that I need to retain the whole structure of fields in tables, but there must be also defined some foreign keys and other things which are needed to preserve relations. I already rewrote current tables into entities, but the part with relations seems a bit impossible to do for me at the moment. I tried to use `@ManyToOne` decorator for defining foreign key in one table, but I always get another field in table which doesn't have correct name. Here is the example:\r\n\r\nWe have two entities - User and Post. User can create zero or more posts, but post is always created by a single user. So we should have the following two tables:\r\n\r\n- user - user_id (PK), name, username, password, email\r\n- post - post_id (PK), title, content, publish_date, user_id (FK)\r\n\r\nSo we would specify both models as:\r\n```\r\n@Entity()\r\nexport class User {\r\n\r\n  @PrimaryGeneratedColumn()\r\n  user_id: number;\r\n\r\n  @Column({ length: 255 })\r\n  name: string;\r\n\r\n  @Column({ length: 20, unique: true })\r\n  @Index()\r\n  username: string;\r\n\r\n  @Column({ length: 128 })\r\n  password: string;\r\n\r\n  @Column({ length: 255, unique: true })\r\n  email: string;\r\n\r\n}\r\n```\r\n\r\n```\r\n@Entity()\r\nexport class Post {\r\n\r\n  @PrimaryGeneratedColumn()\r\n  post_id: number;\r\n\r\n  @Column({ length: 255 })\r\n  @Index()\r\n  title: string;\r\n\r\n  @Column(\"text\")\r\n  content: string;\r\n\r\n  @Column(\"date\")\r\n  publish_date: Date;\r\n\r\n  @Column(\"int\")\r\n  user_id: number;\r\n\r\n}\r\n```\r\n\r\nAs stated above, I need to retain user_id in Post entity to support the existing state of database entries. I tried to add `@ManyToOne` decorator to Post's user_id as ...\r\n\r\n```\r\n@Column(\"int\")\r\n@ManyToOne(() => User)\r\nuser_id: number;\r\n```\r\n\r\nBut that didn't work well, because then I got the following structure of table:\r\n\r\n- post - post_id (PK), title, content, publish_date, user_id, **userUserId (FK)**\r\n\r\nSo the problem here is that the foreign key is always being inserted at the end of table and has specific naming strategy which isn't ok in my case. So my question here it is - do I have to handle my case manually and run database init script in case of a new environment, or I am missing something and there actually is a way to support such cases?\r\n\r\nAny answer/recommendation will be highly appreciated. Thanks in advance!",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/635/comments",
    "author": "truewt",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-07-10T07:16:44Z",
        "body": "relations should always be objects. To specify a custom referenced column name try this apporach:\r\n\r\n```ts\r\n@ManyToOne(() => User)\r\n@JoinColumn({ name: \"user_id\" })\r\nuser: User;\r\n```"
      },
      {
        "user": "truewt",
        "created_at": "2017-07-10T16:24:55Z",
        "body": "Thanks, it worked. I have additional questions about `@ManyToOne` and `@JoinColumn`. I changed parameters of decorators to:\r\n```\r\n@ManyToOne(() => User, { nullable: false, lazy: true })\r\n@JoinColumn({ name: \"user_id\" })\r\nuser: User;\r\n```\r\nI added `nullable: false` because each post must have user_id (cannot not be null) and `lazy: true`. If I understand correctly, this lazy is not executed until object (actually promise) returned in results is not awaited?\r\n\r\nDo I have to specify `referencedName` in `@JoinColumn` if it's same as `name`?\r\nI got additional question, looking at the User object in Post. What's the correct way to insert Post then - do I have to do another lookup for user before I'm assigning it to Post, or can I just create new User and assign it ID I already know (example below)?\r\n```\r\nlet user = new User();\r\nuser.user_id = 5; // actual value retrieved from token/session\r\n// or do I have to run find on User table to get the whole object back with all properties?\r\n// user = await userRepository.findOne(user);\r\n\r\nlet post = new Post();\r\npost.title = \"Testing Post\";\r\npost.content = \"Testing Content\";\r\npost.publish_date = new Date();\r\npost.user = user;\r\n\r\nawait postRepository.persist(post);\r\n```\r\nThank you in advance!"
      },
      {
        "user": "pleerock",
        "created_at": "2017-07-10T17:10:49Z",
        "body": "> If I understand correctly, this lazy is not executed until object (actually promise) returned in results is not awaited?\r\n\r\nright\r\n\r\n> Do I have to specify referencedName in @JoinColumn if it's same as name?\r\n\r\nyou specify `referencedName` only if you need it. If you don't it by default referenced to entity primary keys.\r\n\r\n> and assign it ID I already know\r\n\r\nyes you can update by simply assign an id"
      },
      {
        "user": "truewt",
        "created_at": "2017-07-10T17:23:03Z",
        "body": "Thanks! :)"
      }
    ]
  },
  {
    "number": 631,
    "title": "join not working in case of findOptions",
    "created_at": "2017-07-09T11:34:50Z",
    "closed_at": "2017-07-25T13:43:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/631",
    "body": "\"typeorm\": \"0.1.0-alpha.31\",\r\n\r\nI tried writing join query using entity manager and query builder. It works fine using query builder but  the related table data is not loaded when using findOptions.\r\n\r\nQuerBuilder: `claims` array added to the `roles`\r\n```javascript\r\nconst [roles, count] = await this.roleRepository.createQueryBuilder(\"role\")\r\n            .where(\"role.tenantId = tenantId\", { tenantId: ctx.state.user.tenantId })\r\n            .leftJoinAndSelect(\"role.claims\", \"claims\")\r\n            .offset(offset)\r\n            .limit(limit)\r\n            .getManyAndCount();\r\n```\r\nFindOptions: `claims` array **not** added to the `roles`\r\n```javascript\r\nconst [roles, count] = await this.roleRepository.findAndCount({\r\n            where: { tenantId: ctx.state.user.tenantId },\r\n            alias: \"role\",\r\n            leftJoinAndSelect: {\r\n                \"claims\": \"role.claims\"\r\n            },\r\n            limit: limit,\r\n            offset: offset\r\n        });\r\n```\r\n\r\nFollowing are the entities:\r\n\r\n```javascript\r\n@Entity()\r\nexport class Role extends BaseTenantEntity{\r\n\r\n    @Column({ nullable: false })\r\n    name: string;\r\n\r\n    @Column({ nullable: false })\r\n    description: string;\r\n\r\n    @ManyToMany(type => User, user => user.roles, {\r\n        cascadeInsert: true,\r\n        cascadeUpdate: true\r\n    })\r\n    users: User[]; \r\n    @OneToMany(type => RoleClaim, roleClaim => roleClaim.role, {\r\n        cascadeInsert: true,\r\n        cascadeUpdate: true\r\n    })\r\n    claims: RoleClaim[];\r\n}\r\n\r\n@Entity()\r\nexport class RoleClaim extends BaseEntity {\r\n\r\n    @Column({ nullable: false })\r\n    claimType: string;\r\n\r\n    @Column({ nullable: false })\r\n    claimValue: string;\r\n\r\n    @ManyToOne(type => Role, role => role.claims, {\r\n        cascadeInsert: true,\r\n        cascadeUpdate: true,\r\n        cascadeRemove: true\r\n    })\r\n    role: Role;\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/631/comments",
    "author": "adnan-kamili",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-07-10T07:21:39Z",
        "body": "In latest versions `FindOptions` syntax has changed. Use joins this way:\r\n\r\n```ts\r\nconst posts = await connection.manager.find(Post, {\r\n                join: {\r\n                    alias: \"post\",\r\n                    innerJoinAndSelect: {\r\n                        category: \"post.category\"\r\n                    }\r\n                },\r\n                order: {\r\n                    category: \"ASC\"\r\n                }\r\n            });\r\n```"
      },
      {
        "user": "adnan-kamili",
        "created_at": "2017-07-10T08:05:56Z",
        "body": "Thanks a lot, it worked now. It wasted my lot of time. \r\n\r\nPlease update the docs. And thanks for creating this amazing ORM. "
      },
      {
        "user": "pleerock",
        "created_at": "2017-07-10T14:01:00Z",
        "body": "> Please update the docs.\r\n\r\nplease feel free to contribute"
      }
    ]
  },
  {
    "number": 593,
    "title": "ManyToMany Mysql database only stores one row",
    "created_at": "2017-06-28T12:16:51Z",
    "closed_at": "2017-06-29T11:14:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/593",
    "body": "Hello. I have 2 files, Playlist.ts and Song.ts\r\n\r\n```import {Entity, PrimaryGeneratedColumn, Column, ManyToMany, JoinTable} from \"typeorm\";\r\nimport {Song} from \"./Song\";\r\n@Entity()\r\nexport class Playlist {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    name: string;\r\n\r\n    @Column()\r\n    users: string;\r\n\r\n    @ManyToMany(type => Song, song => song.playlists, { \r\n        cascadeInsert: true,\r\n        cascadeUpdate: true,\r\n    })\r\n    @JoinTable()\r\n    songs: Song[] =[];\r\n```\r\n\r\n\r\n```import {Entity, Column, PrimaryGeneratedColumn, ManyToMany} from \"typeorm\";\r\nimport {Playlist} from \"./Playlist\";\r\n\r\n@Entity()\r\nexport class Song {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    name: string;\r\n\r\n    @Column()\r\n    mainArtist: string;\r\n\r\n    @Column()\r\n    allArtists: string;\r\n\r\n    @Column()\r\n    thumbnailURL: string;\r\n\r\n    @ManyToMany(type => Playlist, playlist => playlist.songs, {\r\n        cascadeInsert: true,\r\n        cascadeUpdate: true\r\n    })\r\n    playlists: Playlist[] = [];\r\n}\r\n```\r\n\r\nThen I run this snippet.\r\n\r\n```\r\n var db = req.app.locals.db;\r\n    var params = req.params;\r\n    let newSong = new Song();\r\n      newSong.mainArtist = \"Drake\";\r\n      newSong.allArtists = \"Drake\";\r\n      newSong.name = \"Signs\"\r\n      newSong.thumbnailURL = \"random_url\";\r\n      \r\n    let playlist = await db\r\n    .getRepository(Playlist)\r\n    .findOneById(1);\r\n\r\n    newSong.playlists.push(playlist);\r\n    let songRepository = db.getRepository(Song)\r\n    .save(newSong)\r\n    .then(song => console.log(\"Song has been saved\"))\r\n    .catch(error => console.log(\"Cannot save. Error: \", error));\r\n```\r\n\r\nThe mysql joined table is `playlist_songs_song_playlists`, but there is only one row at a time. It always just adds the latest one. It is like it is overwriting the table. Any ideas why this is happening? I would appreciate the help!\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/593/comments",
    "author": "AAAstorga",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-06-28T12:52:50Z",
        "body": "try to remove intitialization from all your relations, e.g. `songs: Song[] =[];` replace to `songs: Song[];` and assign array manually when you write value. You have such problem because you are loading object without loading its elements and when you save it again with empty array ORM thinks you removed all items from your relation and removes them from the database."
      },
      {
        "user": "AAAstorga",
        "created_at": "2017-06-29T11:14:00Z",
        "body": "That seemed to do it! Thank you so much."
      }
    ]
  },
  {
    "number": 581,
    "title": "QueryBuilder Update seems to generate incorrect SQL statement for MSSQL",
    "created_at": "2017-06-26T20:51:16Z",
    "closed_at": "2017-06-29T16:29:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/581",
    "body": "QueryBuilder's update() seems to generate:\r\n\r\nUPDATE Table1 Alias SET Column1=\"Value1\" ...\r\n\r\nWhereas I think MSSQL only accepts:\r\n\r\nUPDATE Alias SET Column1=\"Value1\" FROM Table1 Alias ...\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/581/comments",
    "author": "tjme",
    "comments": [
      {
        "user": "tjme",
        "created_at": "2017-06-26T22:07:54Z",
        "body": "A work-around seems to be to add .from(\"Table1\",\"\")"
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-27T10:49:41Z",
        "body": "Since `0.1.0-alpha.20` proper way of doing that:\r\n\r\n```ts\r\n        await connection.createQueryBuilder()\r\n            .update(User)\r\n            .set({\r\n                name: \"Dima Zotov\"\r\n            })\r\n            .where(\"name = :name\", { name: \"Alex Messer\" })\r\n            .execute();\r\n```\r\n\r\nor\r\n\r\n```ts\r\nawait connection.getRepository(User)\r\n            .createQueryBuilder(\"user\")\r\n            .update()\r\n            .set({ name: \"Dima Zotov\" })\r\n            .where(\"user.name = :name\", { name: \"Alex Messer\" })\r\n            .execute();\r\n```"
      },
      {
        "user": "tjme",
        "created_at": "2017-06-29T16:29:11Z",
        "body": "Many thanks! I got the second option working, using alpha.22, but it does currently report type error:\r\n\"Supplied parameters do not match any signature of call target\"."
      }
    ]
  },
  {
    "number": 577,
    "title": "Impossible to execute the Quick Start",
    "created_at": "2017-06-24T17:40:20Z",
    "closed_at": "2017-06-27T20:00:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/577",
    "body": "Hi everybody,\r\n\r\nI would like to test typeorm with MySQL 2.13.0 on Visual code studio. The version used is 0.1.0-alpha.19. I have copied your following example \r\n\r\n```ts\r\nimport \"reflect-metadata\";\r\nimport {createConnection} from \"typeorm\";\r\nimport {Photo} from \"./entity/Photo\";\r\n\r\ncreateConnection({\r\n    driver: {\r\n        type: \"mysql\",\r\n        host: \"localhost\",\r\n        port: 3306,\r\n        username: \"root\",\r\n        password: \"admin\",\r\n        database: \"test\"\r\n    },\r\n    entities: [\r\n        Photo\r\n    ],\r\n    autoSchemaSync: true,\r\n}).then(connection => {\r\n    // here you can start to work with your entities\r\n}).catch(error => console.log(error));\r\n```\r\nand I have the following message error \r\n\r\nfile: 'file:///d%3A/sandbox/nest-test/src/tests/orm/app.ts'\r\nseverity: 'Erreur'\r\nmessage: 'Argument of type '{ driver: { type: \"mysql\"; host: string; port: number; username: string; password: string; databa...' is not assignable to parameter of type 'ConnectionOptions'.\r\n  Type '{ driver: { type: \"mysql\"; host: string; port: number; username: string; password: string; databa...' is not assignable to type '**MongoConnectionOptions**'.\r\n    Property 'type' is missing in type '{ driver: { type: \"mysql\"; host: string; port: number; username: string; password: string; databa...'.'\r\nat: '20,18'\r\nsource: 'ts'\r\n\r\nI have try to use connectionOptions \r\n\r\nimport \"reflect-metadata\";\r\nimport {createConnection} from \"typeorm\";\r\nimport {Photo} from \"./entity/Photo\";\r\nimport {MysqlConnectionOptions} from \"../../../node_modules/typeorm/driver/mysql/MysqlConnectionOptions.js\";\r\n\r\nconst connectionOptions: MysqlConnectionOptions = {\r\n    driver: {\r\n        type: \"mysql\",\r\n        host: \"localhost\",\r\n        port: 3306,\r\n        username: \"root\",\r\n        password: \"admin\",\r\n        database: \"test\"\r\n    },\r\n    entities: [Photo],\r\n    autoSchemaSync: true\r\n};\r\n\r\nand I have the following message\r\n\r\nfile: 'file:///d%3A/sandbox/nest-test/src/tests/orm/app.ts'\r\nseverity: 'Erreur'\r\nmessage: 'Type '{ driver: { type: \"mysql\"; host: string; port: number; username: string; password: string; databa...' **is not assignable to type 'MysqlConnectionOptions**'.\r\n  Property 'type' is missing in type '{ driver: { type: \"mysql\"; host: string; port: number; username: string; password: string; databa...'.'\r\nat: '7,7'\r\nsource: 'ts'\r\n\r\nI don't understand why it is checking connectionOptions from MongoDb and not MySQL. If there is somebody who can give me an indication, I will be happy.\r\n\r\nThanks in advance.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/577/comments",
    "author": "afontange",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-06-27T12:03:20Z",
        "body": "Can you please try to extract \"driver\" section into connection options this way:\r\n\r\n```ts\r\ncreateConnection({\r\n        type: \"mysql\",\r\n        host: \"localhost\",\r\n        port: 3306,\r\n        username: \"root\",\r\n        password: \"admin\",\r\n        database: \"test\",\r\n    entities: [\r\n        Photo\r\n    ],\r\n    autoSchemaSync: true,\r\n}).then(connection => {\r\n    // here you can start to work with your entities\r\n}).catch(error => console.log(error));\r\n```"
      },
      {
        "user": "afontange",
        "created_at": "2017-06-27T16:29:49Z",
        "body": "Thanks for your quick answer : without \"driver\" the error disappeared. I will continue to evaluate typeorm next week-end. I have another question : is there a way to define unique keys?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-27T20:00:15Z",
        "body": "yes you can create `@Index({ unique: true })`, you can put index to class and create composite indices, or you can put in on columns. Also you can mark column as unique: `@Column({ unqiue: true })`\n\n---\n\nI'll close it - let me know if you will still have issues with it."
      },
      {
        "user": "JoshGlazebrook",
        "created_at": "2017-07-25T04:00:08Z",
        "body": "Is this an issue of the docs being out of date? I also ran into this.\r\n\r\nEdit: Actually it appears the alpha versions are being published under the latest tag rather than a alpha/beta tag on npm, so these alpha versions are being installed by default for everyone.\r\n\r\nIs there a reason these aren't on a special tag?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-07-25T11:22:50Z",
        "body": "actually latest alpha versions overall are much more stable then 0.0.11 version, so I recommend to use it instead. Some of the docs are out of date unfortunately, I'll fix it once I get more free time (or anyone can help me ;))"
      }
    ]
  },
  {
    "number": 562,
    "title": "MySQL column type: Medium/Long Text",
    "created_at": "2017-06-21T04:57:44Z",
    "closed_at": "2017-06-21T10:01:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/562",
    "body": "Hi, does TypeORM support Medium/Long Text column data type for MySQL, Seem it only support Text when I add column with type 'text' or 'json'.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/562/comments",
    "author": "brookshi",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-06-21T07:44:17Z",
        "body": "what typeorm version are you using?"
      },
      {
        "user": "brookshi",
        "created_at": "2017-06-21T09:31:51Z",
        "body": "I'm using 0.0.9."
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-21T09:45:55Z",
        "body": "Medium/Long Text is supported only in latest 0.1.0-alpha versions."
      },
      {
        "user": "brookshi",
        "created_at": "2017-06-21T10:00:42Z",
        "body": "Great, Thanks. "
      }
    ]
  },
  {
    "number": 544,
    "title": "groupBy() and getCount() cannot be used at the same time",
    "created_at": "2017-06-15T02:26:52Z",
    "closed_at": "2017-06-20T11:56:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/544",
    "body": "During my development, I found there is literally no way to count the number of kinds of data in a query with Typeorm. The getCount wiil return the fist value of groupBy(). For example, if we have 9 fruits in the db, 4 apples, 3 bananas, and 2 cherries. The getCount after groupBy will return us 4 coz we have 4 apples. Any idea?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/544/comments",
    "author": "bobmayuze",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-06-20T09:47:16Z",
        "body": "`getCount` of `QueryBuilder` is for pagination purposes. For example if you have 1000 bananas, but your query to load bananas uses `skip`/`take` for pagination purposes which returns you only 20 bananas, you need to get know how many bananas do you have overall to create correct number of pages. Thats what `getCount` stays for. For your purposes you probably need to use regular SQL COUNT() in your queries and get raw results.\n\n---\n\nDid I answer your question?"
      },
      {
        "user": "bobmayuze",
        "created_at": "2017-06-20T10:00:54Z",
        "body": "Thanks for answering the question, but I wonder if I can do so with typeorm. "
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-20T11:56:37Z",
        "body": "> For your purposes you probably need to use regular SQL COUNT() in your queries and get raw results.\r\n\r\nyeah you simply do something like \r\n\r\n```ts\r\nconst results = await queryBuilder.select(\"COUNT(post.id) AS cnt\").getRawMany()\r\n```"
      },
      {
        "user": "bobmayuze",
        "created_at": "2017-06-21T00:51:01Z",
        "body": "Thanks for the help! Really appreciate for that"
      },
      {
        "user": "wodka",
        "created_at": "2020-02-18T19:24:45Z",
        "body": "I created a helper for myself to do the same thing:\r\n\r\n```typescript\r\nimport { SelectQueryBuilder } from 'typeorm'\r\n\r\nexport class CoreQbHelper {\r\n  public static async getRawManyAndCount<T>(qb: SelectQueryBuilder<any>, groupColumns: string[]): Promise<[number, T[]]> {\r\n    return Promise.all([\r\n      new Promise<number>((resolve, reject) => {\r\n        const cQb = qb.clone()\r\n        cQb.skip(0)\r\n        cQb.select(`COUNT(DISTINCT (${groupColumns.join(', ')})) as c`)\r\n        cQb.orderBy(null)\r\n        cQb.getRawOne()\r\n          .then(value => resolve(value.c ? Number(value.c) : 0))\r\n          .catch(e => reject(e))\r\n      }),\r\n      new Promise<T[]>((resolve, reject) => {\r\n        const vQb = qb.clone()\r\n        vQb.groupBy(groupColumns.join(', '))\r\n        vQb.getRawMany()\r\n          .then(values => resolve(values))\r\n          .catch(e => reject(e))\r\n      }),\r\n    ])\r\n  }\r\n}\r\n```\r\n\r\nAnd to use it pass the columns you are grouping to it as well like `CoreQbHelper.getRawManyAndCount(qb, ['b.type'])`"
      },
      {
        "user": "Logic-Bits",
        "created_at": "2021-02-18T07:54:16Z",
        "body": "> I created a helper for myself to do the same thing:\r\n> \r\n> ```ts\r\n> import { SelectQueryBuilder } from 'typeorm'\r\n> \r\n> export class CoreQbHelper {\r\n>   public static async getRawManyAndCount<T>(qb: SelectQueryBuilder<any>, groupColumns: string[]): Promise<[number, T[]]> {\r\n>     return Promise.all([\r\n>       new Promise<number>((resolve, reject) => {\r\n>         const cQb = qb.clone()\r\n>         cQb.skip(0)\r\n>         cQb.select(`COUNT(DISTINCT (${groupColumns.join(', ')})) as c`)\r\n>         cQb.orderBy(null)\r\n>         cQb.getRawOne()\r\n>           .then(value => resolve(value.c ? Number(value.c) : 0))\r\n>           .catch(e => reject(e))\r\n>       }),\r\n>       new Promise<T[]>((resolve, reject) => {\r\n>         const vQb = qb.clone()\r\n>         vQb.groupBy(groupColumns.join(', '))\r\n>         vQb.getRawMany()\r\n>           .then(values => resolve(values))\r\n>           .catch(e => reject(e))\r\n>       }),\r\n>     ])\r\n>   }\r\n> }\r\n> ```\r\n> \r\n> And to use it pass the columns you are grouping to it as well like `CoreQbHelper.getRawManyAndCount(qb, ['b.type'])`\r\n\r\nThanks!\r\n\r\nI just flipped number and T[] so its works just like the getManyAndCount()"
      },
      {
        "user": "choninoa",
        "created_at": "2022-03-21T03:16:59Z",
        "body": "count = await (await qb.getRawMany()).length"
      },
      {
        "user": "ernestdolog",
        "created_at": "2023-07-14T19:11:00Z",
        "body": "> count = await (await qb.getRawMany()).length\r\n\r\nunless You are paginating, and set a `first` and/or an `after`"
      }
    ]
  },
  {
    "number": 539,
    "title": "Allow manual rollback or commit of transaction",
    "created_at": "2017-06-14T01:51:23Z",
    "closed_at": "2017-06-15T18:29:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/539",
    "body": "",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/539/comments",
    "author": "yonilerner",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-06-14T12:23:36Z",
        "body": "Everything you wrap into transaction will be executed and in the end transaction will be commited. You can throw exception in your transaction function and rollback will be executed. Why do you need more then this? But yeah, you can do manual rollback and commit, but using more low-level api."
      },
      {
        "user": "yonilerner",
        "created_at": "2017-06-14T17:59:05Z",
        "body": "@pleerock How can I access this lower level API? I dont see any references in the documentation.\r\n\r\nThrowing exceptions of course works, but its often more cumbersome than really necessary if all I want to do is rollback a transaction based on a condition "
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-15T17:55:00Z",
        "body": "as of `0.1.0-alpha.9` its possible using this syntax:\r\n\r\n```ts\r\nconst queryRunner = connection.driver.createQueryRunner(); // queryRunner is a single real connection to the database obtained from a connection pool\r\nawait queryRunner.startTransaction();\r\n// execute sql queries using queryRunner\r\nawait queryRunner.commitTransaction(); // or .rollbackTransaction()\r\nawait queryRunner.release(); // don't forget to release connection, very important!\r\n```\r\n\r\nExecute any sql operations using queryRunner. USE ONLY this queryRunner to execute queries, don't use entity managers, repositories because they are running queries on their own query runners. In the case you want to use managers/repositories you need to create them using this api:\r\n\r\n```ts\r\nconst entityManager = connection.createIsolatedManager(yourQueryRunner);\r\n```\r\n\r\nor \r\n\r\n```ts\r\nconst entityRepository = connection.createIsolatedRepository(Entity, yourQueryRunner);\r\n```"
      },
      {
        "user": "yonilerner",
        "created_at": "2017-06-15T18:29:45Z",
        "body": "Great, thank you!"
      },
      {
        "user": "EVINK",
        "created_at": "2020-09-11T01:04:48Z",
        "body": "@pleerock\r\n\r\nHi, there! I am using UPDATE SQL in queryRunner.query API, and I do not commit it, but it has changed data to db later.\r\n\r\nHere is my code\r\n\r\n```ts\r\n// A request is coming, since I do not commit it , so the data in db not changes after responded\r\n// but it is changed while an another request arrived (this new request had calling \"startTransaction() \")\r\nconst queryRunner = getConnection().createQueryRunner()\r\ntry{\r\n    await queryRunner.startTransaction() \r\n    await queryRunner.connect()\r\n    await queryRunner.query('UPDATE ...')\r\n}catch(err){\r\n    return next(err)\r\n}finally{\r\n   queryRunner.release()\r\n}\r\n\r\n```\r\nHow I gonna do if I want to ensure the data not changed?\r\n\r\n"
      }
    ]
  },
  {
    "number": 506,
    "title": "Schema sync/drop in 0.1.0-alpha.3",
    "created_at": "2017-05-31T14:38:02Z",
    "closed_at": "2017-06-03T19:49:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/506",
    "body": "I've got some problems with typeorm@0.1.0-alpha.3:\r\n\r\n`typeorm schema:sync`\r\n\r\n`UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): TypeError: this.metadataArgsStorage.filterTables is not a function`\r\n\r\nThe same issue with `schema:drop` command.\r\nnodejs: v6.10.3\r\nenv: windows 10 x64\r\nserver: PostgreSQL 9.4.11 on x86_64-unknown-linux-gnu, compiled by gcc (Debian 4.9.2-10) 4.9.2, 64-bit\"\r\n\r\nBy the way: where can i find the information about debug way for typeorm cli commands?\r\nThanks.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/506/comments",
    "author": "rkylsyi",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-06-03T05:50:02Z",
        "body": "You have this issue because your `ormconfig.json` is not an array, ormconfig.json should contain an array of connection options, e.g.:\r\n\r\n```json\r\n[{\r\n  \"driver\": {\r\n    \"type\": \"mysql\",\r\n    \"host\": \"localhost\",\r\n    \"port\": 3306,\r\n    \"username\": \"test\",\r\n    \"password\": \"test\",\r\n    \"database\": \"test\",\r\n    \"usePool\": true,\r\n    \"extra\": {\r\n      \"timezone\": \"utc\"\r\n    }\r\n  },\r\n  \"autoSchemaSync\": true,\r\n  \"entities\": [\r\n    \"modules/**/entity/{*.ts,*.js}\"\r\n  ],\r\n  \"subscribers\": [\r\n    \"modules/**/subscriber/{*.ts,*.js}\"\r\n  ]\r\n}]\r\n```\r\n\r\n> where can i find the information about debug way for typeorm cli commands? \r\n\r\nyou debug it just the regular way you usually debug javascript"
      }
    ]
  },
  {
    "number": 461,
    "title": "Use ManyToMany decorator alongside with PrimaryGeneratedColumn",
    "created_at": "2017-05-09T12:59:05Z",
    "closed_at": "2017-05-10T13:53:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/461",
    "body": "Let's say I have 3 classes / tables : 'Artist', 'Artwork' and 'Tag'. \r\nArtist and Artwork both have a ManyToMany relation with Tag. What I'd like to do is the following : \r\n\r\n```\r\nclass Tag {\r\n    @PrimaryGeneratedColumn()\r\n    @ManyToMany(type => Artwork, artwork => artwork.tags)\r\n    @ManyToMany(type => Artist, artist => artist.tags)\r\n    id: number;\r\n} \r\n```\r\n\r\n```\r\nclass Artwork {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n   \r\n    @ManyToMany(type => Tag, tag => tag.id, {\r\n        cascadeInsert: true\r\n    })\r\n    @JoinTable()\r\n    public tags: Tag[];\r\n  \r\n}\r\n```\r\n\r\n```\r\nclass Artist {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n   \r\n    @ManyToMany(type => Tag, tag => tag.id, {\r\n        cascadeInsert: true\r\n    })\r\n    @JoinTable()\r\n    public tags: Tag[];\r\n    \r\n}\r\n```\r\n\r\nCurrently, it doesn't seem to work: tags are created but relationship between Tag and Artwork / Artist is not saved in 'join' table . How could I manage to setup such a mechanism without having to implement 2 specific Tag classes (one for each class) ? \r\n\r\nBy the way I'm using @next version of typeorm with mysql-driver.\r\n\r\nThank you and keep up the good work !\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/461/comments",
    "author": "cclaim",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-05-10T05:18:53Z",
        "body": "In second argument of relation you should provide `inverse relation`, not `id column` as you do right now:\r\n\r\n\r\n```ts\r\nclass Tag {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @ManyToMany(type => Artwork, artwork => artwork.tags)\r\n    artworks: Artwork[];\r\n\r\n    @ManyToMany(type => Artist, artist => artist.tags)\r\n    artists: Artist[];\r\n} \r\n```\r\n\r\n```ts\r\nclass Artwork {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n   \r\n    @ManyToMany(type => Tag, tag => tag.artworks, {\r\n        cascadeInsert: true\r\n    })\r\n    @JoinTable()\r\n    public tags: Tag[];\r\n  \r\n}\r\n```\r\n```ts\r\nclass Artist {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n   \r\n    @ManyToMany(type => Tag, tag => tag.artists, {\r\n        cascadeInsert: true\r\n    })\r\n    @JoinTable()\r\n    public tags: Tag[];\r\n    \r\n}\r\n```"
      },
      {
        "user": "cclaim",
        "created_at": "2017-05-10T10:28:33Z",
        "body": "Thank you !"
      }
    ]
  },
  {
    "number": 450,
    "title": "Saving a relationship",
    "created_at": "2017-05-02T22:14:30Z",
    "closed_at": "2017-05-04T18:37:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/450",
    "body": "I'm probably just doing this wrong. I'm trying to add related object to another object through a many2many relationship.\r\n\r\nHere's my scenario:\r\n\r\nUser->hasFriends [User] (many2many)\r\nUser->hasGroups [Group] (many2many)\r\n\r\nWhen i want to add a group to a user I\r\n1) fetch the respective user\r\n2) left join the groups\r\n3) fetch my respective group\r\n4) push my group, user.addGroup(group)\r\n5) persist my user object.\r\n\r\nThis works; but deletes all friend relationships. If I add a friend to my user; all group relationships get deleted.\r\n\r\nHere are my model definitions:\r\n\r\nUser:\r\n\r\n\trequire(\"reflect-metadata\");\r\n\timport {Entity, PrimaryColumn, Column, ManyToMany, JoinTable} from \"typeorm\";\r\n\timport Group from './Group';\r\n\t\r\n\t\r\n\t@Entity()\r\n\texport default class User {\r\n\t\r\n\t    @PrimaryColumn(\"int\", { generated: true })\r\n\t    id = undefined;\r\n\t\r\n\t    @Column(\"string\")\r\n\t    email = \"\";\r\n\t\r\n\t    @Column(\"string\")\r\n\t    firstname = \"\";\r\n\t\r\n\t    @Column(\"string\")\r\n\t    lastname = \"\";    \r\n\t    \r\n\t    @Column(\"string\")\r\n\t    middlename = \"\";\r\n\t    \r\n\t    @Column(\"string\")\r\n\t    password = \"\";\r\n\t    \r\n\t    @Column(\"string\")\r\n\t    salt = \"\";\r\n\t       \r\n\t    \r\n\t    setEmail(email) {\r\n\t\t    this.email = email;\r\n\t\t    return this;\r\n\t    }\r\n\t    \r\n\t    getEmail() {\r\n\t\t    return this.email;\t    \r\n\t    }\r\n\t    \r\n\t    setFirstname(firstname) {\r\n\t\t    this.firstname = firstname;\r\n\t\t    return this;\r\n\t    }\r\n\t    \r\n\t    getFirstname() {\r\n\t\t    return this.firstname;\r\n\t    }\r\n\t    \r\n\t    setLastname(lastname) {\r\n\t\t    this.lastname = lastname;\r\n\t\t    return this;\r\n\t    }\r\n\t    \r\n\t    getLastname() {\r\n\t\t    return this.lastname;\r\n\t    }\r\n\t    \r\n\t    setMiddlename(middlename) {\r\n\t\t    this.middlename = middlename;\r\n\t\t    return this;\r\n\t    }\r\n\t    \r\n\t    getMiddlename() {\r\n\t\t    return this.middlename;\r\n\t    }\r\n\t    \r\n\t    setPassword(password) {\r\n\t\t    this.password = password;\r\n\t\t    return this;\r\n\t    }\r\n\t    \r\n\t    getPassword() {\r\n\t\t    return this.password;\r\n\t    }\r\n\t    \r\n\t    setSalt(salt) {\r\n\t\t    this.salt = salt;\r\n\t\t    return this;\r\n\t    }\r\n\t    \r\n\t    getSalt() {\r\n\t\t    return this.salt;\r\n\t    }\r\n\t    \r\n\t    addFriend(friend) {\r\n\t\t    this.friends.push(friend);\r\n\t    }\r\n\t\r\n\t    getGroups() {\r\n\t\t    return this.groups;\r\n\t    }\r\n\t    \r\n\t    addGroup(group) {\r\n\t\t    this.groups.push(group);\r\n\t    }\r\n\t    \r\n\t    getFriends() {\r\n\t\t    return this.friends;\r\n\t    }\r\n\t    \r\n\t    getFriendsInverse() {\r\n\t\t    return this.friends;\r\n\t    }\r\n\t    \r\n\t\r\n\t\t@ManyToMany(type => User, user => user.friendsInverse, {\r\n\t\t\tcascadeInsert: false,\r\n\t\t\tcascadeUpdate: false,\r\n\t\t})\r\n\t\t@JoinTable()\r\n\t\tfriends = [];\r\n\t\r\n\t\t@ManyToMany(type => User, user => user.friends, {\r\n\t\t\tcascadeInsert: true,\r\n\t\t\tcascadeUpdate: true,\r\n\t\t\tcascadeRemove: false,\r\n\t\t})\r\n\t\tfriendsInverse = [];\r\n\t\t\r\n\t\t\r\n\t    @ManyToMany(type => Group, group => group.users, {\r\n\t        cascadeInsert: true,\r\n\t        cascadeUpdate: true,\r\n\t        cascadeRemove: false\r\n\t    })\r\n\t    groups = [];\r\n\t    \r\n\t    \r\n\t}\r\n\r\n\r\nGroup:\r\n\r\n\trequire(\"reflect-metadata\");\r\n\timport {Entity, PrimaryColumn, Column, ManyToMany, JoinTable} from \"typeorm\";\r\n\timport User from './User';\r\n\t\r\n\t@Entity()\r\n\texport default class Group {\r\n\t\r\n\t    @PrimaryColumn(\"int\", { generated: true })\r\n\t    id = undefined;\r\n\t\r\n\t    @Column(\"string\")\r\n\t    title = \"\";\r\n\t\r\n\t    @Column(\"string\")\r\n\t    description = \"\";\r\n\t\r\n\t    \r\n\t    setTitle(title) {\r\n\t\t    this.title = title;\r\n\t\t    return this;\r\n\t    }\r\n\t    \r\n\t    getTitle() {\r\n\t\t    return this.title;\t    \r\n\t    }\r\n\t    \r\n\t    setDescription(description) {\r\n\t\t    this.description = description;\r\n\t\t    return this;\r\n\t    }\r\n\t    \r\n\t    getDescription() {\r\n\t\t    return this.description;\r\n\t    }\r\n\t\r\n\t\t@ManyToMany(type => User, user => user.groups, {\r\n\t\t\tcascadeInsert: true,\r\n\t        cascadeUpdate: true,\r\n\t        cascadeRemove: true\r\n\t\t})\r\n\t\t@JoinTable()\r\n\t\tusers = [];\r\n\t    \r\n\t    \r\n\t}\r\n\r\n-------\r\n\r\nIs this the expected behaviour?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/450/comments",
    "author": "Matt007",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-05-03T04:40:44Z",
        "body": "Remove initializations from your model ` = []`. When you load object without friends and there is initialization orm thinks that you have remove all friends from your object and removes them. There is no way it can understand is it just initialized empty array or its empty because all entities were removed."
      },
      {
        "user": "Matt007",
        "created_at": "2017-05-04T16:09:19Z",
        "body": "Oh, makes sense! Thanks a lot for your help!\r\n\r\nMaybe it would help to point this out in the example. I'm sure a lot of people might run into the same issue when they copy&paste the example from the docs.\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2017-05-04T18:37:31Z",
        "body": "you are right, thanks."
      }
    ]
  },
  {
    "number": 449,
    "title": "Event subscribers not affecting abstract entities",
    "created_at": "2017-05-02T20:34:13Z",
    "closed_at": "2017-05-10T05:58:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/449",
    "body": "Tried to create a new abstract entity with created_at and updated_at to be automatically update on change, it's not working, only if I put the columns in the entity itself.\r\n\r\nbtw, is there any built in soft deletes?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/449/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-05-03T04:42:43Z",
        "body": "> btw, is there any built in soft deletes?\r\n\r\nno\r\n\r\n> Tried to create a new abstract entity with created_at and updated_at to be automatically update on change, it's not working, only if I put the columns in the entity itself.\r\n\r\nthey should work. Did you include your abstract entity in the `entities` of the configuration?"
      },
      {
        "user": "ghost",
        "created_at": "2017-05-05T18:47:32Z",
        "body": "Thanks! that was the issue,\r\nis there any why I can put global condition on each entity so I can add for example\r\n\"deleted_at\" is null?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-05-10T05:58:20Z",
        "body": "no there is no such way, put your queries always if you need this."
      }
    ]
  },
  {
    "number": 355,
    "title": "InnerjoinAndSelect returns undefined",
    "created_at": "2017-03-19T15:15:33Z",
    "closed_at": "2017-03-23T21:34:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/355",
    "body": "Hello,\r\n\r\nI have a many to one relation. Every photo has one photoCollectionId and photoCollection and every PhotoCollection has an array of Photo. Now I want to load a collection with its photos:\r\n```typescript\r\n let collection = await this.collectionRepository.findOneById(id\r\n        , {\r\n          alias: \"collection\",\r\n          innerJoinAndSelect: {\r\n            \"photos\": \"collection.photos\"\r\n          }\r\n        });\r\n```\r\nWhen there is no photo related to the collection this returns undefined. However, if there is a related photo, it works as expected. \r\n\r\nFor now I have worked around the issue like this:\r\n```typescript\r\n@Get(\"/:id/photos\")\r\n  async getOne( @Param(\"id\") id: number) {\r\n    let photo = await this.photoRepository.findOne({ photoCollectionId: id });\r\n    if (photo) {\r\n      let collection = await this.collectionRepository.findOneById(id\r\n        , {\r\n          alias: \"collection\",\r\n          innerJoinAndSelect: {\r\n            \"photos\": \"collection.photos\"\r\n          }\r\n        });\r\n      console.log(collection);\r\n      return collection;\r\n    }\r\n    else {\r\n      let collection = await this.collectionRepository.findOneById(id);\r\n      console.log(collection);\r\n      return collection;\r\n    }\r\n  }\r\n```\r\n\r\nHowever, this is probably not how it should be I suppose. Is there a better/easier way to do this?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/355/comments",
    "author": "Christian24",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-03-22T13:06:08Z",
        "body": "can you try `QueryBuilder` instead? Using \r\n\r\n```ts\r\n{\r\n          alias: \"collection\",\r\n          innerJoinAndSelect: {\r\n            \"photos\": \"collection.photos\"\r\n          }\r\n        }\r\n``` \r\n\r\nis deprecated and will be removed in next typeorm version. Use `QueryBuilder` instead:\r\n\r\n\r\n```ts\r\nrepository.createQueryBuilder(\"collection\")\r\n     .innerJoinAndSelect(\"collection.photos\", \"photos\")\r\n     .where(\"collection.id = :id\", { id })\r\n     .getOne();\r\n```"
      },
      {
        "user": "MichalLytek",
        "created_at": "2017-03-23T18:34:31Z",
        "body": "Could you paste here you entities classes?"
      },
      {
        "user": "Christian24",
        "created_at": "2017-03-23T21:34:03Z",
        "body": "@pleerock How do I know it is deprecated? Is there any way to know?\r\n\r\nUsing QueryBuilder works like a charm. Thanks a lot. \r\n\r\n\n\n---\n\n@19majkel94 \r\n\r\nPhotoCollection.ts:\r\n```typescript\r\n@Entity()\r\nexport class PhotoCollection extends BaseEntity {\r\n    @OneToMany(type => Photograph, photo => photo.photoCollection)\r\n    public photos:Array<Photograph> = new Array<Photograph>();\r\n     @Column(\"string\",{nullable:true})\r\n    public title:string;\r\n     @Column()\r\n    public showPhotoTitle:boolean = false;\r\n     @Column()\r\n    public showCollectionTitle:boolean = false;\r\n     @Column(\"string\",{nullable:true})\r\n\r\n    public titlePhotoUrl:string;\r\n     @Column()\r\n    public hidden:boolean = true;\r\n    @OneToMany(type => PhotoInfoSetting, infoSetting => infoSetting.photoCollection)\r\n    public infoSettings:Array<PhotoInfoSetting> = new Array<PhotoInfoSetting>();\r\n}\r\n```\r\nPhoto.ts:\r\n```typescript\r\n@Entity()\r\nexport class Photograph extends BaseEntity {\r\n     @Column(\"int\")\r\n   public photoCollectionId:number;\r\n   @ManyToOne(type => PhotoCollection, photoCollection => photoCollection.photos)\r\n   @JoinColumn({name:\"photoCollectionId\"})\r\n   public photoCollection:PhotoCollection;\r\n   @OneToMany(type => PhotoInfo, photoInfo => photoInfo.photo)\r\n   public photoInfos:Array<PhotoInfo> = new Array<PhotoInfo>();\r\n     @Column(\"string\",{nullable:true})\r\n   public title:string;\r\n     @Column(\"string\",{nullable:true})\r\n   public source:string;\r\n     @Column(\"string\",{nullable:true})\r\n   public preview:string;\r\n    @Column()\r\n   public hidden:boolean = false;\r\n}\r\n```\r\nThose are my entities. I will be offline for a week, so please expect a delay in response. "
      }
    ]
  },
  {
    "number": 351,
    "title": "execute migrations through code",
    "created_at": "2017-03-16T15:58:39Z",
    "closed_at": "2017-03-16T19:06:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/351",
    "body": "Is there a way to execute migrations through my code?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/351/comments",
    "author": "natanielkdias",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-03-16T18:10:55Z",
        "body": "you can do that using `connection.runMigrations()` method"
      },
      {
        "user": "natanielkdias",
        "created_at": "2017-03-16T18:32:24Z",
        "body": "Thank you! I'm developing  a solution on electron and sqlite. It will be so helpful to my application updates. "
      }
    ]
  },
  {
    "number": 303,
    "title": "Connection pooling doesn't really pool connections",
    "created_at": "2017-02-22T00:41:50Z",
    "closed_at": "2017-02-23T17:25:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/303",
    "body": "It looks like when you create a connection and have connection pooling on type orm creates a \"pool of 1 connection\", and then when you close the connection type orm ends the pool.  Ideally what we want to do is create a pool of 50 connections in our web api that type orm re-uses across requests.  I'm new to type orm.  Hopefully I'm just missing some way to configure this.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/303/comments",
    "author": "swilliams-a3digital",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-02-22T06:18:15Z",
        "body": "> when you close the connection type orm ends the pool\r\n\r\nyou should not close connection in the app lifecycle. You open connection once in application bootstrap and close only when application shut downs. Connection pools are handled in a single orm connection, and when you are closing connection - you are closing pool too. If you don't close connection - pool will work as you expect."
      },
      {
        "user": "swilliams-a3digital",
        "created_at": "2017-02-22T20:36:01Z",
        "body": "Thanks for the quick reply.  If I create the \"type orm connection\" in the app bootstrap, and I have a bunch of simultaneous requests that all use the one \"type orm connection\" will there be any issues?  \r\n\r\nMy concern is:\r\nrequest A comes in, type orm does a persist and while its waiting for the promise to resolve node handles request B that uses the same type orm connection and there is some problem because the connection is in use.\r\n\r\nI'm hoping the answer is the one \"type orm\" connection will open multiple my sql db connections if it needs to do multiple things at the same time\r\n\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2017-02-23T03:19:01Z",
        "body": "> If I create the \"type orm connection\" in the app bootstrap, and I have a bunch of simultaneous requests that all use the one \"type orm connection\" will there be any issues\r\n\r\nno, because its designed to work this way.\r\n\r\n> I'm hoping the answer is the one \"type orm\" connection will open multiple my sql db connections if it needs to do multiple things at the same time\r\n\r\nyes it is. Real database connection is used from pull per each `persist` / `remove`/ or any other `find` method call"
      },
      {
        "user": "swilliams-a3digital",
        "created_at": "2017-02-23T17:14:21Z",
        "body": "Thank you so much for the fast answer to my question.  You can close this issue.\r\n"
      },
      {
        "user": "zxr90",
        "created_at": "2017-04-22T06:48:05Z",
        "body": "> yes it is. Real database connection is used from pull per each persist / remove/ or any other find method call\r\n\r\nSorry to hijack this issue but i have a similar question while browsing the docs. Is there an option to control the max number of real database connection? If no, what is the default pool size?\r\n\r\nI'm coming off Activerecord and in Rails, they allow you to setup your own connection pool size when initializing the app."
      },
      {
        "user": "pleerock",
        "created_at": "2017-04-24T08:33:07Z",
        "body": "@zxr90 I have created separate issue for your issue. You can setup connection pool using \"extra\" option in connection driver options and pass there underlying driver options (for example if you are using mysql see mysql driver options on how to do this)"
      }
    ]
  },
  {
    "number": 294,
    "title": "Troubles with UglifyJS",
    "created_at": "2017-02-17T21:51:17Z",
    "closed_at": "2017-02-23T17:29:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/294",
    "body": "I use webpack and babel. I pass imported models to the connectionConfig. When I build the app for production with UglifyJsPlugin, an error occurs: `ER_NO_SUCH_TABLE: Table 'posts-app.e' doesn't exist`. How to avoid it without disabling the plugin? I found only one way: pass such options: ```  mangle: {\r\n    except: ['Post','User']\r\n  } ```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/294/comments",
    "author": "SPAHI4",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-02-23T17:29:23Z",
        "body": "You have such error because table names are generated from class names, e.g. `Post` and `User`, but when you minify your code uglifier made your names `p` and `e` now. You have several choices: set explicit names for your tables, e.g. `@Entity(\"post\")` and `@Entity(\"user\")` or enable `mangle` (no need to specify entities, just mangle them all) or simply don't use uglify because its really pointless to use it and webpack on the backend.\n\n---\n\nI guess I've answered your question and now this issue can be closed."
      }
    ]
  },
  {
    "number": 149,
    "title": "AbstractTable doesnt work in inherited classes",
    "created_at": "2016-12-25T16:21:16Z",
    "closed_at": "2016-12-25T18:59:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/149",
    "body": "Hi all!\r\nI have problem with AbstractTable decorator. Error:\r\n_MissingPrimaryColumnError: Entity \"Post\" does not have a primary column. Primary column is required to have in all your entities. Use @PrimaryColumn decorator to add a primary column to your entity._\r\nFiles:\r\n**BasePost.ts**:\r\n```\r\nimport {PrimaryGeneratedColumn, Column} from \"typeorm\";\r\nimport {AbstractTable} from \"typeorm\";\r\n\r\n@AbstractTable()\r\nexport class BasePost {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    title: string;\r\n}\r\n```\r\n**Post.ts**:\r\n```\r\nimport {Column, Table} from \"typeorm\";\r\nimport {BasePost} from \"./BasePost\";\r\n\r\n@Table(\"post\")\r\nexport class Post extends BasePost {\r\n    @Column()\r\n    text: string;\r\n}\r\n```\r\n**app.ts**:\r\n```\r\nimport \"reflect-metadata\";\r\nimport { createConnection } from \"typeorm\";\r\nimport { Post } from \"./entities/Post\";\r\n\r\ncreateConnection({\r\n  driver: {\r\n    type: \"postgres\",\r\n    host: \"host\",\r\n    port: 7755,\r\n    username: \"postgres\",\r\n    password: \"pass\",\r\n    database: \"testdatabase\"\r\n  },\r\n  entities: [\r\n    Post\r\n  ],\r\n  autoSchemaSync: true\r\n  }).then(connection => {\r\n    console.log('Good!');\r\n  })\r\n  .catch(reason => {\r\n    console.log(reason);\r\n});\r\n```\r\nWhat is wrong?\r\nNodeJS version: 7.3.0\r\nTypescript version: 2.1.4\r\nTypeORM version: 0.0.5",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/149/comments",
    "author": "CocaColaBear",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2016-12-25T18:46:34Z",
        "body": "Please include `BasePost` in a list of your `entities: [Post, BasePost]`"
      },
      {
        "user": "CocaColaBear",
        "created_at": "2016-12-25T18:59:23Z",
        "body": "@pleerock thanks a lot! :)"
      },
      {
        "user": "pleerock",
        "created_at": "2016-12-25T19:00:10Z",
        "body": "one star from you ;)"
      }
    ]
  },
  {
    "number": 142,
    "title": "innerJoinAndSelect with no matching rows results in rejected promise",
    "created_at": "2016-12-22T22:40:54Z",
    "closed_at": "2016-12-23T18:28:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/142",
    "body": "Hi,\r\n\r\nThere's a OneToMany relation between \"ent\" (one) and \"some_stuff\" (many).\r\n\r\nI'm doing something similar to this:\r\n\r\n```\r\nentRepository.createQueryBuilder('ent')\r\n\t.innerJoinAndSelect('ent.some_stuff', 'some_stuff')\r\n\t.getOne();\r\n```\r\n\r\nWhenever some_stuff has corresponding rows for ent, it works.\r\nWhenever there're no corresponding rows for ent, the promise is rejected.\r\n\r\nHow can I simply have some_stuff set to an empty array in ent whenever there're no corresponding rows instead of having the promise rejected?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/142/comments",
    "author": "royibernthal",
    "comments": [
      {
        "user": "eduardoweiland",
        "created_at": "2016-12-23T00:36:09Z",
        "body": "If you want to get the result for `ent` when it does not have any `some_stuff`, you should use a `LEFT JOIN`. When doing an `INNER JOIN`, the database will not return the `ent` row if it does not have corresponding rows in the joined table.\r\n\r\n@royibernthal can you try using `leftJoinAndSelect` and see if it works?\r\n\r\n```typescript\r\nentRepository.createQueryBuilder('ent')\r\n\t.leftJoinAndSelect('ent.some_stuff', 'some_stuff')\r\n\t.getOne();\r\n```"
      },
      {
        "user": "royibernthal",
        "created_at": "2016-12-23T09:15:05Z",
        "body": "True, works.\r\n\r\nIs that the only difference between innerJoinAndSelect and leftJoinAndSelect?\r\nIs there a reason not to always use leftJoinAndSelect?"
      },
      {
        "user": "pleerock",
        "created_at": "2016-12-23T13:01:38Z",
        "body": "yes. same applies for `INNER JOIN` vs `LEFT JOIN` in SQL."
      },
      {
        "user": "royibernthal",
        "created_at": "2016-12-24T00:48:41Z",
        "body": "Thanks"
      }
    ]
  }
]